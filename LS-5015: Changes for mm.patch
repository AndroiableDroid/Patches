From 42b4011736223c2ad4dac1a7af37a0963c2cf3a9 Mon Sep 17 00:00:00 2001
From: Mohd Faraz <mohd.faraz.abc@gmail.com>
Date: Fri, 22 Jun 2018 07:31:50 +0000
Subject: [PATCH] LS-5015: Added LS-5015 Changes

Signed-off-by: Mohd Faraz <mohd.faraz.abc@gmail.com>
---
 .../devicetree/bindings/input/misc/bma2x2.txt      |    3 -
 LICENSE                                            |  674 +++
 README.md                                          |    1 +
 arch/arm/boot/dts/qcom/Makefile                    |    5 +-
 arch/arm/boot/dts/qcom/msm8916.dtsi                |    2 +-
 arch/arm/boot/dts/qcom/msm8939-common.dtsi         |    2 +-
 arch/arm/boot/dts/qcom/msm8939-mdss.dtsi           |    4 +-
 arch/arm/boot/dts/qcom/msm8939-qrd-skuk.dts        |    6 +-
 arch/arm/boot/dts/qcom/msm8939-qrd.dtsi            |   21 -
 arch/arm/boot/dts/qcom/msm8939-v3.0-qrd-skuk.dts   |    2 +-
 .../arm/boot/dts/qcom/test01a-msm8939-qrd-skuk.dts |  142 +
 .../dsi-panel-ams497-720p-video.dtsi               |   80 +
 .../test01a-msm8939-camera-sensor-qrd.dtsi         |  588 ++
 .../test01a-msm8939-pinctrl.dtsi                   | 1585 +++++
 .../test01a-msm8939-qrd-skuk.dtsi                  |  335 ++
 .../test01a-msm8939-qrd.dtsi                       |  208 +
 .../test01a-msm8939-v3.0.dtsi                      |  686 +++
 .../test01a-msm8939-qrd-skuk/test01a-msm8939.dtsi  |  492 ++
 .../dts/qcom/test01a-msm8939-v3.0-qrd-skuk.dts     |  143 +
 arch/arm64/configs/msm_defconfig                   |   23 +-
 arch/arm64/configs/test01a_msm_defconfig           |  589 ++
 arch/arm64/configs/testplus_msm_defconfig          |  589 ++
 drivers/char/diag/diagchar.h                       |    1 +
 drivers/char/diag/diagfwd.c                        |    2 +-
 drivers/hwmon/lm80.c                               |    1 -
 drivers/input/misc/Kconfig                         |   98 +-
 drivers/input/misc/Makefile                        |   27 +-
 drivers/input/misc/lsm6ds3_core.c                  | 2534 ++++++++
 drivers/input/misc/lsm6ds3_core.h                  |  193 +
 drivers/input/misc/lsm6ds3_i2c.c                   |  175 +
 drivers/input/misc/ltr553_test.c                   | 6337 ++++++++++++++++++++
 drivers/input/misc/st480_test.c                    |  905 +++
 drivers/input/misc/st480_test_plus.c               |  904 +++
 drivers/input/touchscreen/Kconfig                  |    2 +
 drivers/input/touchscreen/Makefile                 |    3 +-
 drivers/input/touchscreen/gt9xx/goodix_tool.c      |    6 +-
 drivers/input/touchscreen/gt9xx/gt9xx.c            |  122 +-
 drivers/input/touchscreen/gt9xx/gt9xx.h            |   12 +-
 drivers/input/touchscreen/gt9xx/gt9xx_update.c     |    4 +-
 drivers/input/touchscreen/melfas_mip4_test/Kconfig |   42 +
 .../input/touchscreen/melfas_mip4_test/Makefile    |    6 +
 drivers/input/touchscreen/melfas_mip4_test/mip4.c  | 1460 +++++
 drivers/input/touchscreen/melfas_mip4_test/mip4.h  |  373 ++
 .../touchscreen/melfas_mip4_test/mip4_debug.c      | 1300 ++++
 .../touchscreen/melfas_mip4_test/mip4_fw_mms438.c  |  503 ++
 .../input/touchscreen/melfas_mip4_test/mip4_mod.c  |  612 ++
 .../input/touchscreen/melfas_mip4_test/mip4_reg.h  |  155 +
 .../input/touchscreen/melfas_mip4_testplus/Kconfig |   42 +
 .../touchscreen/melfas_mip4_testplus/Makefile      |    6 +
 .../input/touchscreen/melfas_mip4_testplus/mip4.c  | 1460 +++++
 .../input/touchscreen/melfas_mip4_testplus/mip4.h  |  373 ++
 .../touchscreen/melfas_mip4_testplus/mip4_debug.c  | 1300 ++++
 .../melfas_mip4_testplus/mip4_fw_mms438.c          |  503 ++
 .../touchscreen/melfas_mip4_testplus/mip4_mod.c    |  612 ++
 .../touchscreen/melfas_mip4_testplus/mip4_reg.h    |  155 +
 drivers/leds/Kconfig                               |    7 +
 drivers/leds/Makefile                              |    2 +-
 drivers/leds/aw2013_rgb.c                          |  888 +++
 drivers/leds/led-class.c                           |   32 +
 drivers/leds/leds-msm-gpio-flash.c                 |  225 +-
 drivers/leds/leds.h                                |   25 +-
 drivers/media/platform/msm/camera_v2/Kconfig       |   15 +
 .../media/platform/msm/camera_v2/ispif/msm_ispif.c |    4 +-
 .../media/platform/msm/camera_v2/sensor/Makefile   |    9 +-
 .../msm/camera_v2/sensor/actuator/Makefile         |    4 +
 .../camera_v2/sensor/actuator/lc898212axb_AfDef.h  |  328 +
 .../camera_v2/sensor/actuator/msm_actuator_altek.c | 1734 ++++++
 .../camera_v2/sensor/actuator/msm_actuator_altek.h |  133 +
 .../msm/camera_v2/sensor/eeprom/msm_eeprom.c       |   10 +
 .../msm/camera_v2/sensor/flash/msm_led_flash.h     |    1 +
 .../msm/camera_v2/sensor/flash/msm_led_trigger.c   |   10 +
 .../platform/msm/camera_v2/sensor/msm_sensor.c     |  139 +-
 .../msm/camera_v2/sensor/msm_sensor_driver.c       |   84 +
 .../media/platform/msm/camera_v2/sensor/ov2685.c   | 2171 +++++++
 drivers/mmc/core/mmc.c                             |    2 +
 drivers/net/wireless/wcnss/wcnss_wlan.c            |   25 +
 drivers/power/Kconfig                              |   44 +
 drivers/power/Makefile                             |    2 +
 drivers/power/reset/msm-poweroff.c                 |    2 +-
 drivers/power/smb1360-charger-fg-test.c            | 5502 +++++++++++++++++
 drivers/power/smb1360-charger-fg-testplus.c        | 5348 +++++++++++++++++
 drivers/power/smb1360-charger-fg.c                 |    3 +-
 drivers/usb/gadget/android.c                       |   19 +-
 drivers/usb/phy/phy-msm-usb.c                      |   38 +-
 drivers/video/msm/mdss/mdss_dsi.c                  |   40 +
 drivers/video/msm/mdss/mdss_dsi_panel.c            |    8 +
 firmware/Makefile                                  |    3 +
 firmware/melfas/test_melfas_mip4.bin.ihex          | 3079 ++++++++++
 firmware/melfas/testplus_melfas_mip4.bin.ihex      | 3079 ++++++++++
 fs/proc/base.c                                     |    4 +-
 include/linux/i2c/st480.h                          |  166 +
 include/linux/input/lsm6dx0.h                      |  182 +
 include/linux/leds.h                               |    1 +
 include/linux/platform_data/lsm6ds3.h              |   22 +
 include/linux/platform_data/melfas_mip4.h          |   53 +
 include/media/msm_cam_sensor.h                     |   17 +-
 include/media/msm_camsensor_sdk.h                  |    1 +
 include/soc/qcom/camera2.h                         |    7 +
 sound/soc/codecs/msm8x16-wcd.c                     |   80 +-
 sound/soc/codecs/wcd-mbhc-v2.c                     |   42 +-
 sound/soc/msm/msm8x16.c                            |   36 +-
 sound/soc/msm/qdsp6v2/msm-compr-q6-v2.c            | 1704 ++++++
 sound/soc/msm/qdsp6v2/msm-dts-eagle.c              | 1036 ++++
 sound/soc/msm/qdsp6v2/q6adm.c                      |    1 -
 sound/soc/msm/qdsp6v2/q6asm.c                      |    1 -
 sound/soc/msm/qdsp6v2/q6core.c                     |  110 +
 sound/soc/soc-jack.c                               |    5 +-
 107 files changed, 52691 insertions(+), 200 deletions(-)
 create mode 100644 LICENSE
 create mode 100644 README.md
 create mode 100755 arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk.dts
 create mode 100755 arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/dsi-panel-ams497-720p-video.dtsi
 create mode 100755 arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-camera-sensor-qrd.dtsi
 create mode 100755 arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-pinctrl.dtsi
 create mode 100755 arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-qrd-skuk.dtsi
 create mode 100755 arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-qrd.dtsi
 create mode 100755 arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-v3.0.dtsi
 create mode 100755 arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939.dtsi
 create mode 100755 arch/arm/boot/dts/qcom/test01a-msm8939-v3.0-qrd-skuk.dts
 create mode 100644 arch/arm64/configs/test01a_msm_defconfig
 create mode 100644 arch/arm64/configs/testplus_msm_defconfig
 create mode 100755 drivers/input/misc/lsm6ds3_core.c
 create mode 100755 drivers/input/misc/lsm6ds3_core.h
 create mode 100755 drivers/input/misc/lsm6ds3_i2c.c
 create mode 100644 drivers/input/misc/ltr553_test.c
 create mode 100755 drivers/input/misc/st480_test.c
 create mode 100755 drivers/input/misc/st480_test_plus.c
 create mode 100755 drivers/input/touchscreen/melfas_mip4_test/Kconfig
 create mode 100755 drivers/input/touchscreen/melfas_mip4_test/Makefile
 create mode 100755 drivers/input/touchscreen/melfas_mip4_test/mip4.c
 create mode 100755 drivers/input/touchscreen/melfas_mip4_test/mip4.h
 create mode 100755 drivers/input/touchscreen/melfas_mip4_test/mip4_debug.c
 create mode 100755 drivers/input/touchscreen/melfas_mip4_test/mip4_fw_mms438.c
 create mode 100755 drivers/input/touchscreen/melfas_mip4_test/mip4_mod.c
 create mode 100755 drivers/input/touchscreen/melfas_mip4_test/mip4_reg.h
 create mode 100755 drivers/input/touchscreen/melfas_mip4_testplus/Kconfig
 create mode 100755 drivers/input/touchscreen/melfas_mip4_testplus/Makefile
 create mode 100755 drivers/input/touchscreen/melfas_mip4_testplus/mip4.c
 create mode 100755 drivers/input/touchscreen/melfas_mip4_testplus/mip4.h
 create mode 100755 drivers/input/touchscreen/melfas_mip4_testplus/mip4_debug.c
 create mode 100755 drivers/input/touchscreen/melfas_mip4_testplus/mip4_fw_mms438.c
 create mode 100755 drivers/input/touchscreen/melfas_mip4_testplus/mip4_mod.c
 create mode 100755 drivers/input/touchscreen/melfas_mip4_testplus/mip4_reg.h
 create mode 100755 drivers/leds/aw2013_rgb.c
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/actuator/lc898212axb_AfDef.h
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator_altek.c
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator_altek.h
 create mode 100755 drivers/media/platform/msm/camera_v2/sensor/ov2685.c
 create mode 100755 drivers/power/smb1360-charger-fg-test.c
 create mode 100755 drivers/power/smb1360-charger-fg-testplus.c
 create mode 100755 firmware/melfas/test_melfas_mip4.bin.ihex
 create mode 100755 firmware/melfas/testplus_melfas_mip4.bin.ihex
 create mode 100755 include/linux/i2c/st480.h
 create mode 100755 include/linux/input/lsm6dx0.h
 create mode 100755 include/linux/platform_data/lsm6ds3.h
 create mode 100755 include/linux/platform_data/melfas_mip4.h
 create mode 100644 sound/soc/msm/qdsp6v2/msm-compr-q6-v2.c
 create mode 100644 sound/soc/msm/qdsp6v2/msm-dts-eagle.c

diff --git a/Documentation/devicetree/bindings/input/misc/bma2x2.txt b/Documentation/devicetree/bindings/input/misc/bma2x2.txt
index a3e52c85f62..40629abf8f9 100644
--- a/Documentation/devicetree/bindings/input/misc/bma2x2.txt
+++ b/Documentation/devicetree/bindings/input/misc/bma2x2.txt
@@ -37,13 +37,10 @@ Optional properties:
 				If this property is defined, data ready, fifo full and
 				other event will trigger level change on interrupt pin2
 				instead of interrupt pin1.
-<<<<<<< HEAD
-=======
  - bosch,use-smd	: enable signification motion detection(SMD). Enable this
 				will create a new sensor which triggers an event each time
 				significant motion is detected.
  - bosch,use-hrtimer	: Use hrtimer to report data. Hrtimer can report data more timely.
->>>>>>> d19f89f... input: sensors: add bma2x2 support schedule data poll on idle CPU
 
 Example:
 &i2c_0 { /* BLSP1 QUP2 */
diff --git a/LICENSE b/LICENSE
new file mode 100644
index 00000000000..347fada359a
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,674 @@
+GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    {one line to give the program's name and a brief idea of what it does.}
+    Copyright (C) 2017  {name of author}
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    android_kernel_lyf_mobee01a_msm8939_64  Copyright (C) 2017  Varun Pilankar
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
\ No newline at end of file
diff --git a/README.md b/README.md
new file mode 100644
index 00000000000..8dc523e03e3
--- /dev/null
+++ b/README.md
@@ -0,0 +1 @@
+# android_kernel_lyf_mobee01a_msm8939_64
diff --git a/arch/arm/boot/dts/qcom/Makefile b/arch/arm/boot/dts/qcom/Makefile
index 4d488acf20c..d5e9354e63b 100644
--- a/arch/arm/boot/dts/qcom/Makefile
+++ b/arch/arm/boot/dts/qcom/Makefile
@@ -124,7 +124,10 @@ dtb-$(CONFIG_ARCH_MSM8916) += msm8916-cdp.dtb \
 	msm8929-mtp-wcd9306-smb1360.dtb \
 	msm8929-qrd-skul.dtb \
 	msm8929-qrd-skulb.dtb \
-	msm8929-cdp-jdi.dtb
+	msm8929-cdp-jdi.dtb \
+	test01a-msm8939-qrd-skuk.dtb \
+	test01a-msm8939-v3.0-qrd-skuk.dtb \
+
 dtb-$(CONFIG_ARCH_MSM8226) += msm8226-sim.dtb \
 	msm8226-fluid.dtb \
 	msm8226-v1-cdp.dtb \
diff --git a/arch/arm/boot/dts/qcom/msm8916.dtsi b/arch/arm/boot/dts/qcom/msm8916.dtsi
index 6ae5f5b11f4..afc31ea01db 100644
--- a/arch/arm/boot/dts/qcom/msm8916.dtsi
+++ b/arch/arm/boot/dts/qcom/msm8916.dtsi
@@ -374,7 +374,7 @@
 
 	cpubw: qcom,cpubw {
 		compatible = "qcom,devbw";
-		governor = "cpufreq";
+		governor = "performance";
 		qcom,src-dst-ports = <1 512>;
 		qcom,active-only;
 		qcom,bw-tbl =
diff --git a/arch/arm/boot/dts/qcom/msm8939-common.dtsi b/arch/arm/boot/dts/qcom/msm8939-common.dtsi
index 54e42e4195a..30c85a31959 100644
--- a/arch/arm/boot/dts/qcom/msm8939-common.dtsi
+++ b/arch/arm/boot/dts/qcom/msm8939-common.dtsi
@@ -441,7 +441,7 @@
 		compatible = "qcom,iris_fm";
 	};
 
-	qcom,wcnss-wlan@0a000000 {
+	wcnss_wlan: qcom,wcnss-wlan@0a000000 {
 		compatible = "qcom,wcnss_wlan";
 		reg = <0x0a000000 0x280000>,
 			<0xb011008 0x04>,
diff --git a/arch/arm/boot/dts/qcom/msm8939-mdss.dtsi b/arch/arm/boot/dts/qcom/msm8939-mdss.dtsi
index 4e8e8ec1dd3..0cd49ed74d5 100644
--- a/arch/arm/boot/dts/qcom/msm8939-mdss.dtsi
+++ b/arch/arm/boot/dts/qcom/msm8939-mdss.dtsi
@@ -155,7 +155,7 @@
 		qcom,regulator-ldo-mode;
 		qcom,platform-strength-ctrl = [ff 06];
 		qcom,platform-bist-ctrl = [00 00 b1 ff 00 00];
-		qcom,platform-regulator-settings = [00 01 01 00 20 07 00];
+		qcom,platform-regulator-settings = [02 09 03 00 20 00 01];
 		qcom,platform-lane-config = [00 00 00 00 00 00 00 01 97
 			00 00 00 00 05 00 00 01 97
 			00 00 00 00 0a 00 00 01 97
@@ -241,7 +241,7 @@
 		qcom,platform-strength-ctrl = [ff 06];
 		qcom,platform-bist-ctrl = [00 00 b1 ff 00 00];
 		qcom,regulator-ldo-mode;
-		qcom,platform-regulator-settings = [00 01 01 00 20 07 00];
+		qcom,platform-regulator-settings = [02 09 03 00 20 00 01];
 		qcom,platform-lane-config = [00 00 00 00 00 00 00 01 97
 			00 00 00 00 05 00 00 01 97
 			00 00 00 00 0a 00 00 01 97
diff --git a/arch/arm/boot/dts/qcom/msm8939-qrd-skuk.dts b/arch/arm/boot/dts/qcom/msm8939-qrd-skuk.dts
index 9014a8e89b8..c5aac0c5156 100644
--- a/arch/arm/boot/dts/qcom/msm8939-qrd-skuk.dts
+++ b/arch/arm/boot/dts/qcom/msm8939-qrd-skuk.dts
@@ -19,7 +19,7 @@
 / {
 	model = "Qualcomm Technologies, Inc. MSM8939 QRD SKUK";
 	compatible = "qcom,msm8939-qrd-skuk", "qcom,msm8939-qrd", "qcom,msm8939", "qcom,qrd";
-	qcom,board-id = <0x1000b 5>, <0x2000b 5>;
+	qcom,board-id = <0x1000b 20>, <0x2000b 20>;
 };
 
 &tlmm_pinmux {
@@ -111,7 +111,7 @@
 	qcom,disable-bms;
 };
 
-&mdss_dsi0 {
+/*&mdss_dsi0 {
 	qcom,dsi-pref-prim-pan = <&dsi_nt35596_1080p_skuk_video>;
 
 	vsp-supply = <&tps65132_pos>;
@@ -150,7 +150,7 @@
 	qcom,mdss-dsi-pan-enable-dynamic-fps;
 	qcom,mdss-dsi-pan-fps-update = "dfps_immediate_porch_mode";
 };
-
+*/
 &usb_otg {
        qcom,hsusb-otg-mode = <3>;
        qcom,usbid-gpio = <&msm_gpio 110 0>;
diff --git a/arch/arm/boot/dts/qcom/msm8939-qrd.dtsi b/arch/arm/boot/dts/qcom/msm8939-qrd.dtsi
index 61dda4d6b62..873506b8b7b 100644
--- a/arch/arm/boot/dts/qcom/msm8939-qrd.dtsi
+++ b/arch/arm/boot/dts/qcom/msm8939-qrd.dtsi
@@ -22,27 +22,6 @@
 	pinctrl-0 = <&uart_console_sleep>;
 };
 
-&soc {
-	i2c@78ba000 { /* BLSP1 QUP6 */
-		nfc-nci@e {
-			compatible = "qcom,nfc-nci";
-			reg = <0x0e>;
-			qcom,irq-gpio = <&msm_gpio 21 0x00>;
-			qcom,dis-gpio = <&msm_gpio 20 0x00>;
-			qcom,clk-src = "BBCLK2";
-			qcom,clk-en-gpio = <&msm_gpio 0 0x00>;
-			interrupt-parent = <&msm_gpio>;
-			interrupts = <21 0>;
-			interrupt-names = "nfc_irq";
-			pinctrl-names = "nfc_active","nfc_suspend";
-			pinctrl-0 = <&nfc_int_active &nfc_disable_active>;
-			pinctrl-1 = <&nfc_int_suspend &nfc_disable_suspend>;
-			qcom,clk-gpio = <&pm8916_gpios 2 0>;
-			clocks = <&clock_rpm clk_bb_clk2_pin>;
-			clock-names = "ref_clk";
-		};
-	};
-};
 
 &spmi_bus {
 	qcom,pm8916@1 {
diff --git a/arch/arm/boot/dts/qcom/msm8939-v3.0-qrd-skuk.dts b/arch/arm/boot/dts/qcom/msm8939-v3.0-qrd-skuk.dts
index 4951aea0853..93cdf3a4f17 100644
--- a/arch/arm/boot/dts/qcom/msm8939-v3.0-qrd-skuk.dts
+++ b/arch/arm/boot/dts/qcom/msm8939-v3.0-qrd-skuk.dts
@@ -20,7 +20,7 @@
 / {
 	model = "Qualcomm Technologies, Inc. MSM8939v3.0 QRD SKUK";
 	compatible = "qcom,msm8939-qrd-skuk", "qcom,msm8939-qrd", "qcom,msm8939", "qcom,qrd";
-	qcom,board-id = <0x1000b 5>, <0x2000b 5>;
+	qcom,board-id = <0x1000b 20>, <0x2000b 20>;
 };
 
 &tlmm_pinmux {
diff --git a/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk.dts b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk.dts
new file mode 100755
index 00000000000..370909a13a9
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk.dts
@@ -0,0 +1,142 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "./test01a-msm8939-qrd-skuk/test01a-msm8939.dtsi"
+#include "./test01a-msm8939-qrd-skuk/test01a-msm8939-qrd-skuk.dtsi"
+
+/ {
+	model = "Qualcomm Technologies, Inc. MSM8939 QRD SKUK";
+	compatible = "qcom,msm8939-qrd-skuk", "qcom,msm8939-qrd", "qcom,msm8939", "qcom,qrd";
+	qcom,board-id = <0x1000b 12>, <0x2000b 12>;
+};
+
+&tlmm_pinmux {
+	tps65132-en-pin {
+		qcom,pins = <&gp 97>, <&gp 98>;
+		qcom,num-grp-pins = <2>;
+		label = "tps65132_en_pins";
+		qcom,pin-func = <0>;
+
+		tps65132_en_default: en-default {
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+};
+
+&i2c_0 { /* BLSP1 QUP2 */
+	tps65132@3e {
+		compatible = "ti,tps65132";
+		reg = <0x3e>;
+		i2c-pwr-supply = <&pm8916_l6>;
+		ti,en-gpio-lpm;
+		pinctrl-names = "default";
+		pinctrl-0 = <&tps65132_en_default>;
+
+		regulators {
+			tps65132_pos: pos-boost {
+				regulator-name = "tps65132-pos";
+				regulator-min-microvolt = <5800000>;
+				regulator-max-microvolt = <5800000>;
+				ti,discharge-enable;
+				ti,enable-time = <800>;
+				ti,current-limit = <200000>;
+				ti,en-gpio = <&msm_gpio 97 0>;
+			};
+
+			tps65132_neg: neg-boost {
+				regulator-name = "tps65132-neg";
+				regulator-min-microvolt = <5800000>;
+				regulator-max-microvolt = <5800000>;
+				ti,discharge-enable;
+				ti,enable-time = <800>;
+				ti,current-limit = <40000>;
+				ti,en-gpio = <&msm_gpio 98 0>;
+			};
+		};
+	};
+};
+
+&i2c_4 {
+	smb1360_otg_supply: smb1360-chg-fg@14 {
+		compatible = "qcom,smb1360-chg-fg";
+		reg = <0x14>;
+		interrupt-parent = <&msm_gpio>;
+		interrupts = <62 2>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&smb_int_default>;
+		qcom,stat-pulsed-irq;
+		qcom,chg-inhibit-disabled;
+		/*battery capacity*/
+		qcom,float-voltage-mv = <4350>;
+		qcom,fg-cc-to-cv-mv = <4340>;
+		qcom,fg-cutoff-voltage-mv = <3400>;
+		qcom,fg-voltage-min-mv = <3200>;
+		qcom,fg-voltage-empty-mv = <3200>;
+		qcom,fg-suspend-voltage-empty-mv = <3400>;
+		qcom,fg-ibatt-standby-ma = <200>;
+		qcom,fg-soc-max = <90>;
+		qcom,fg-soc-min = <15>;
+		qcom,fg-batt-capacity-mah = <2610>;
+		qcom,fg-cc-soc-coeff = <0x8247>;
+		qcom,thermistor-c1-coeff = <0x86C2>;
+		qcom,iterm-ma = <200>;
+		qcom,charging-timeout = <768>;
+		qcom,otg-batt-curr-limit = <1500>;
+		qcom,recharge-thresh-mv = <100>;
+		qcom,thermal-mitigation = <1500 1200 900 0>;
+	//	qcom,fg-auto-recharge-soc = <99>;
+                qcom,fg-delta-soc = <1>;
+	//	qcom,empty-soc-disabled;
+		regulator-name = "smb1360_otg_vreg";
+		qcom,rsense-10mhom;
+
+		/*battery-profile selection properties*/
+		qcom,batt-profile-select;
+		qcom,smb1360-vadc = <&pm8916_vadc>;
+		qcom,batt-id-vref-uv = <1800000>;
+		qcom,batt-id-rpullup-kohm = <100>;
+		qcom,profile-a-rid-kohm = <33>;
+		qcom,profile-b-rid-kohm = <91>;
+		qcom,shdn-after-pwroff;
+		qcom,config-hard-thresholds;
+		qcom,hot-bat-decidegc = <550>;
+		qcom,cold-bat-decidegc = <0>;
+		qcom,hot-bat-mv = <4100>;
+		qcom,fg-reset-at-pon;
+		qcom,fg-reset-thresold-mv = <250>;
+	};
+};
+
+&pm8916_chg {
+	status = "ok";
+	qcom,use-external-charger;
+};
+
+&pm8916_bms {
+	status = "ok";
+	qcom,disable-bms;
+};
+
+&usb_otg {
+       qcom,hsusb-otg-mode = <3>;
+       qcom,usbid-gpio = <&msm_gpio 110 0>;
+       pinctrl-names = "default";
+       pinctrl-0 = <&usbid_default>;
+       vbus_otg-supply = <&smb1360_otg_supply>;
+	   qcom,usbin-vadc = <&pm8916_vadc>;
+};
+&android_usb{
+        adb_diaplay_name = "MOBEE01A";
+};
diff --git a/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/dsi-panel-ams497-720p-video.dtsi b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/dsi-panel-ams497-720p-video.dtsi
new file mode 100755
index 00000000000..0f24f29ff52
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/dsi-panel-ams497-720p-video.dtsi
@@ -0,0 +1,80 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*---------------------------------------------------------------------------
+ * This file is autogenerated file using gcdb parser. Please do not edit it.
+ * Update input XML file to add a new entry or update variable in this file
+ * VERSION = "1.0"
+ *---------------------------------------------------------------------------*/
+&mdss_mdp {
+	dsi_ams497_720p_video: qcom,mdss_dsi_ams497_720p_video {
+		qcom,mdss-dsi-panel-name = "ams497_720p_video";
+		qcom,mdss-dsi-panel-controller = <&mdss_dsi0>;
+		qcom,mdss-dsi-panel-type = "dsi_video_mode";
+		qcom,mdss-dsi-panel-destination = "display_1";
+		qcom,mdss-dsi-panel-framerate = <62>;
+		qcom,mdss-dsi-virtual-channel-id = <0>;
+		qcom,mdss-dsi-stream = <0>;
+		qcom,mdss-dsi-panel-width = <720>;
+		qcom,mdss-dsi-panel-height = <1280>;
+		qcom,mdss-pan-physical-width-dimension = <62>;
+		qcom,mdss-pan-physical-height-dimension = <110>;
+		qcom,mdss-dsi-h-front-porch = <107>;
+		qcom,mdss-dsi-h-back-porch = <40>;
+		qcom,mdss-dsi-h-pulse-width = <30>;
+		qcom,mdss-dsi-h-sync-skew = <0>;
+		qcom,mdss-dsi-v-back-porch = <8>;
+		qcom,mdss-dsi-v-front-porch = <14>;
+		qcom,mdss-dsi-v-pulse-width = <2>;
+		qcom,mdss-dsi-h-left-border = <0>;
+		qcom,mdss-dsi-h-right-border = <0>;
+		qcom,mdss-dsi-v-top-border = <0>;
+		qcom,mdss-dsi-v-bottom-border = <0>;
+		qcom,mdss-dsi-bpp = <24>;
+		qcom,mdss-dsi-color-order = "rgb_swap_rgb";
+		qcom,mdss-dsi-underflow-color = <0xff>;
+		qcom,mdss-dsi-border-color = <0>;
+		qcom,mdss-dsi-on-command = [05 01 00 00 80 00 01 11
+				39 01 00 00 00 00 03 f0 5a 5a
+				39 01 00 00 00 00 03 fc 5a 5a
+				39 01 00 00 00 00 04 c0 d8 d8 20
+				39 01 00 00 00 00 05 fd 16 05 00 20
+				39 01 00 00 00 00 03 f0 a5 a5
+				39 01 00 00 00 00 03 fc a5 a5
+				15 01 00 00 00 00 02 53 20
+				15 01 00 00 00 00 02 51 0a
+				05 01 00 00 28 00 01 29];
+		qcom,mdss-dsi-off-command = [05 01 00 00 32 00 01 28
+				 05 01 00 00 78 00 01 10];
+		qcom,mdss-dsi-on-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-off-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-force-clock-lane-hs;
+		qcom,mdss-dsi-h-sync-pulse = <1>;
+		qcom,mdss-dsi-traffic-mode = "burst_mode";
+		qcom,mdss-dsi-lane-map = "lane_map_0123";
+		qcom,mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-bllp-power-mode;
+		qcom,mdss-dsi-lane-0-state;
+		qcom,mdss-dsi-lane-1-state;
+		qcom,mdss-dsi-lane-2-state;
+		qcom,mdss-dsi-lane-3-state;
+		qcom,mdss-dsi-panel-timings = [7b 1a 10 00 3e 42 16 1e 15 03 04 00];
+		qcom,mdss-dsi-t-clk-post = <0x1f>;
+		qcom,mdss-dsi-t-clk-pre = <0x2d>;
+		qcom,mdss-dsi-bl-min-level = <1>;
+		qcom,mdss-dsi-bl-max-level = <255>;
+		qcom,mdss-dsi-dma-trigger = "trigger_sw";
+		qcom,mdss-dsi-mdp-trigger = "none";
+		qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_dcs";
+		qcom,mdss-dsi-reset-sequence = <1 20>, <0 10>, <1 20>;
+	};
+};
diff --git a/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-camera-sensor-qrd.dtsi b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-camera-sensor-qrd.dtsi
new file mode 100755
index 00000000000..624b3cf3a89
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-camera-sensor-qrd.dtsi
@@ -0,0 +1,588 @@
+/*
+ * Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+&tlmm_pinmux {
+	SGM314_pins {
+		qcom,pins = <&gp 31>, <&gp 32>;
+		qcom,num-grp-pins = <2>;
+		qcom,pin-func = <0>;
+		label = "SGM314_pins";
+		SGM314_default: en_default {
+			  drive-strength = <2>;
+			  bias-pull-down;
+		};
+	};
+};
+
+&soc {
+	flash_SGM314:flashlight {
+		compatible = "qcom,leds-gpio-flash";
+		status = "okay";
+		pinctrl-names = "flash_default";
+		pinctrl-0 = <&SGM314_default>;
+		qcom,flash-en = <&msm_gpio 31 0>;
+		qcom,flash-now = <&msm_gpio 32 0>;
+		qcom,torch-en = <&msm_gpio 20 0>;//10 0>;
+		qcom,flash-front-enable = <&msm_gpio 16 0>;
+		qcom,flash-rear-enable = <&msm_gpio 17 0>;
+		qcom,op-seq = "flash_en", "flash_now", "torch_en", "enable_multi";
+		qcom,torch-seq-val = <1 0 0 1>;//liang.zhu//<1 0 1 1>;
+		qcom,pre-seq-val = <1 0 0 1>;
+		qcom,flash-seq-val = <1 1 0 1>;
+		linux,name = "flashlight";
+		linux,default-trigger = "flashlight-trigger";
+	};
+
+	led_flash0: qcom,camera-led-flash {
+		cell-index = <0>;
+		reg = <0x00>;
+		compatible = "qcom,camera-led-flash";
+		qcom,flash-type = <3>;
+		qcom,flash-source = <&flash_SGM314>;
+		qcom,torch-source = <&flash_SGM314>;
+	};
+};
+
+&cci {
+	actuator0: qcom,actuator@0 {
+		cell-index = <0>;
+		reg = <0x00>;
+		compatible = "qcom,actuator";
+		qcom,cci-master = <0>;
+	};
+
+	eeprom0: qcom,eeprom@6a{//6c{
+		cell-index = <0>;
+		reg = <0x6c>;
+		qcom,eeprom-name = "toshiba_st1382";
+		compatible = "qcom,eeprom";
+		qcom,slave-addr = <0x6c>;
+		qcom,cci-master = <0>;
+		qcom,num-blocks = <12>;  //12
+		//qcom,slave-id-addr = <0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000>;
+		//qcom,slave-id = <0x00>;
+
+		// page 0
+		qcom,page0 = <1 0x0101 2 0x03 1 1>;//0x3500 = 1 otp read_enable
+		qcom,poll0 = <0 0x0 2 0x0 1 1>;
+		qcom,mem0 = <0 0 2 0x0 1 0>;
+
+
+		qcom,page1 = <1 0x3502 2 0x0 1 1>;//0x3502 page select from 0x00->0x0f
+		qcom,poll1 = <0 0x0 2 0x0 1 1>;
+		qcom,mem1 = <0 0 2 0x0 1 0>;
+
+		qcom,page2 = <1 0x3500 2 0x81 1 1>;//select otp access 0x3500[7]=1
+		qcom,poll2 = <0 0x0 2 0x0 1 1>;
+		qcom,mem2 = <64 0x3504 2 0x0 1 0>;
+
+		// page 1
+		qcom,page3 = <1 0x3500 2 0x01 1 1>;
+		qcom,poll3 = <0 0x0 2 0x0 1 1>;
+		qcom,mem3 = <0 0 2 0x0 1 0>;
+
+		qcom,page4 = <1 0x3502 2 0x1 1 1>;
+		qcom,poll4 = <0 0x0 2 0x0 1 1>;
+		qcom,mem4 = <0 0 2 0x0 1 0>;
+
+                qcom,page5 = <1 0x3500 2 0x81 1 1>;
+                qcom,poll5 = <0 0x0 2 0x0 1 1>;
+                qcom,mem5 = <64 0x3504 2 0x0 1 0>;
+
+                // page 2
+                qcom,page6 = <1 0x3500 2 0x01 1 1>;
+                qcom,poll6 = <0 0x0 2 0x0 1 1>;
+                qcom,mem6 = <0 0 2 0x0 1 0>;
+
+                qcom,page7 = <1 0x3502 2 0x2 1 1>;
+                qcom,poll7 = <0 0x0 2 0x0 1 1>;
+                qcom,mem7 = <0 0 2 0x0 1 0>;
+
+                qcom,page8 = <1 0x3500 2 0x81 1 1>;
+                qcom,poll8 = <0 0x0 2 0x0 1 1>;
+                qcom,mem8 = <64 0x3504 2 0x0 1 0>;
+
+                // page 5
+                qcom,page9 = <1 0x3500 2 0x01 1 1>;
+                qcom,poll9 = <0 0x0 2 0x0 1 1>;
+                qcom,mem9 = <0 0 2 0x0 1 0>;
+
+                qcom,page10 = <1 0x3502 2 0xf 1 1>;
+                qcom,poll10 = <0 0x0 2 0x0 1 1>;
+                qcom,mem10 = <0 0 2 0x0 1 0>;
+
+		qcom,page11 = <1 0x3500 2 0x81 1 1>;
+		qcom,poll11 = <0 0x0 2 0x0 1 1>;
+		qcom,mem11 = <64 0x3504 2 0x0 1 0>;
+
+		cam_vdig-supply = <&pm8916_l2>;
+		cam_vana-supply = <&pm8916_l17>;
+		cam_vio-supply = <&pm8916_l6>;
+		cam_vaf-supply = <&pm8916_l10>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+			"cam_vaf";
+  		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000 100000>;
+		pinctrl-names = "cam_default", "cam_suspend";
+		pinctrl-0 = <&cam_sensor_mclk0_default &cam_sensor_rear_default>;
+		pinctrl-1 = <&cam_sensor_mclk0_sleep &cam_sensor_rear_sleep>;
+		gpios = <&msm_gpio 26 0>,
+			  <&msm_gpio 35 0>,
+			  <&msm_gpio 34 0>,
+			  <&msm_gpio 0 0>,
+			  <&msm_gpio 8 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-vana = <3>;
+        qcom,gpio-vdig = <4>;
+		qcom,gpio-req-tbl-num = <0 1 2 3 4>;
+		qcom,gpio-req-tbl-flags = <1 0 0 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+			"CAM_RESET1",
+			"CAM_STANDBY",
+			"MCAM_GPIO_AVDD",
+            "MCAM_GPIO_DVDD";
+		  qcom,cam-power-seq-type = "sensor_vreg",
+		   "sensor_gpio", "sensor_gpio",
+		   "sensor_gpio", "sensor_gpio",
+		   "sensor_clk";
+		  qcom,cam-power-seq-val = "cam_vio",
+		   "sensor_gpio_vana", "sensor_gpio_vdig",
+		   "sensor_gpio_reset",
+		   "sensor_gpio_standby",
+		   "sensor_cam_mclk" ;
+		  qcom,cam-power-seq-cfg-val = <1 1 1 1 1 24000000>;
+		  qcom,cam-power-seq-delay = <1 1 1 10 10 5>;
+
+		  clocks = <&clock_gcc clk_mclk0_clk_src>,
+			   <&clock_gcc clk_gcc_camss_mclk0_clk>;
+		clock-names = "cam_src_clk", "cam_clk";
+	};
+
+
+       eeprom1: qcom,eeprom@6b{
+               cell-index = <1>;
+               reg = <0x20>;
+               qcom,eeprom-name = "qtech_s5k3m2_F3M2YBN";
+               compatible = "qcom,eeprom";
+               qcom,slave-addr = <0xa0>;
+               qcom,cci-master = <0>;
+               qcom,num-blocks = <1>;
+			   //qcom,slave-id-addr = <0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000>;
+			   //qcom,slave-id = <0x00>;
+
+			   qcom,page0 = <0 0x0 0 0x00 0 0>;
+			   qcom,poll0 = <0 0x0 0 0x00 0 0>;
+			   qcom,mem0 = <0x0B0C 0x0 2 0 1 0>;
+			   qcom,saddr0 = <0xA0>;
+
+               cam_vdig-supply = <&pm8916_l2>;
+               cam_vana-supply = <&pm8916_l17>;
+               cam_vio-supply = <&pm8916_l6>;
+               cam_vaf-supply = <&pm8916_l10>;
+               qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+                       "cam_vaf";
+               qcom,cam-vreg-type = <0 1 0 0>;
+               qcom,cam-vreg-min-voltage = <1200000 0 2850000 2800000>;
+               qcom,cam-vreg-max-voltage = <1200000 0 2850000 2800000>;
+               qcom,cam-vreg-op-mode = <200000 0 80000 100000>;
+               pinctrl-names = "cam_default", "cam_suspend";
+               pinctrl-0 = <&cam_sensor_mclk0_default &cam_sensor_rear_default>;
+               pinctrl-1 = <&cam_sensor_mclk0_sleep &cam_sensor_rear_sleep>;
+               gpios = <&msm_gpio 26 0>,
+                         <&msm_gpio 35 0>,
+                         <&msm_gpio 34 0>,
+                         <&msm_gpio 0 0>,
+                         <&msm_gpio 8 0>;
+               qcom,gpio-reset = <1>;
+               qcom,gpio-standby = <2>;
+               qcom,gpio-vdig = <3>;
+              qcom,gpio-vana = <4>;
+               qcom,gpio-req-tbl-num = <0 1 2 3 4>;
+               qcom,gpio-req-tbl-flags = <1 0 0 0 0>;
+               qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+                       "CAM_RESET1",
+                       "CAM_STANDBY",
+                       "MCAM_GPIO_DVDD",
+                       "MCAM_GPIO_AVDD";
+                 qcom,cam-power-seq-type = "sensor_vreg",
+                  "sensor_gpio", "sensor_gpio",
+                  "sensor_gpio", "sensor_gpio",
+                  "sensor_clk";
+                 qcom,cam-power-seq-val = "cam_vio",
+                  "sensor_gpio_vana", "sensor_gpio_vdig",
+                  "sensor_gpio_reset",
+                  "sensor_gpio_standby",
+                  "sensor_cam_mclk" ;
+                 qcom,cam-power-seq-cfg-val = <1 1 1 1 1 24000000>;
+                 qcom,cam-power-seq-delay = <1  1 1 10 10 5>;
+
+                 clocks = <&clock_gcc clk_mclk0_clk_src>,
+                          <&clock_gcc clk_gcc_camss_mclk0_clk>;
+               clock-names = "cam_src_clk", "cam_clk";
+       };
+
+	eeprom2: qcom,eeprom@6c{
+		cell-index = <2>;
+		reg = <0x0>;
+		qcom,eeprom-name = "s5k5e2_SFS5C7597";
+		compatible = "qcom,eeprom";
+		qcom,slave-addr = <0x20>;
+		qcom,cci-master = <0>;
+		qcom,num-blocks = <17>;
+		qcom,mid-addr = <2 0x0A04 3 0x0A04 4 0x0A04 2 0x0A0C 2 0x0A14 2 0x0A1C 2 0x0A24 2 0x0A2C 2 0x0A34 2 0x0A3C>;//page and addr
+		qcom,mid = <0x10>;
+
+        //page 2, addr 0x0a04 ~ 0x0a0b
+        //Flag of group, Module ID, Lens ID, Current rgb avg and Golden rgb avg
+		qcom,page0 = <1 0x0A00 2 0x04 1 1>;//make initial state
+		qcom,pageen0 = <0 0x0 0 0x0 0 0>;
+		qcom,poll0 = <0 0x0 2 0 1 1>;
+		qcom,mem0 = <0 0x0 2 0 1 0>;
+
+		qcom,page1 = <1 0x0A02 2 0x02 1 1>;//set the PAGE 2 of OTP(0 <= the number of PAGE <= 15)
+		qcom,pageen1 = <0 0x0 0 0x0 0 0>;
+		qcom,poll1 = <0 0x0 2 0 1 1>;
+		qcom,mem1 = <0 0x0 2 0 1 0>;
+
+		qcom,page2 = <1 0x0A00 2 0x01 1 1>;//set read mode of NVM controller Interface1
+		qcom,pageen2 = <0 0x0 0 0x0 0 0>;
+		qcom,poll2 = <0 0x0 2 0 1 1>;
+		qcom,mem2 = <8 0x0A04 2 0 1 0>;//read otp data addr 0a04 ~ 0x0a0b
+
+
+        //page 3, addr 0x0a04 ~ 0x0a0b
+        //Flag of group, Module ID, Lens ID, Current rgb avg and Golden rgb avg
+		qcom,page3 = <1 0x0A00 2 0x04 1 1>;//make initial state
+		qcom,pageen3 = <0 0x0 0 0x0 0 0>;
+		qcom,poll3 = <0 0x0 2 0 1 1>;
+		qcom,mem3 = <0 0x0 2 0 1 0>;
+
+		qcom,page4 = <1 0x0A02 2 0x03 1 1>;//set the PAGE 3 of OTP(0 <= the number of PAGE <= 15)
+		qcom,pageen4 = <0 0x0 0 0x0 0 0>;
+		qcom,poll4 = <0 0x0 2 0 1 1>;
+		qcom,mem4 = <0 0x0 2 0 1 0>;
+
+		qcom,page5 = <1 0x0A00 2 0x01 1 1>;//set read mode of NVM controller Interface1
+		qcom,pageen5 = <0 0x0 0 0x0 0 0>;
+		qcom,poll5 = <0 0x0 2 0 1 1>;
+		qcom,mem5 = <8 0x0A04 2 0 1 0>;//read otp data addr 0a04 ~ 0x0a0b
+
+
+        //page 4, addr 0x0a04 ~ 0x0a0b
+        //Flag of group, Module ID, Lens ID, Current rgb avg and Golden rgb avg
+		qcom,page6 = <1 0x0A00 2 0x04 1 1>;//make initial state
+		qcom,pageen6 = <0 0x0 0 0x0 0 0>;
+		qcom,poll6 = <0 0x0 2 0 1 1>;
+		qcom,mem6 = <0 0x0 2 0 1 0>;
+
+		qcom,page7 = <1 0x0A02 2 0x04 1 1>;//set the PAGE 4 of OTP(0 <= the number of PAGE <= 15)
+		qcom,pageen7 = <0 0x0 0 0x0 0 0>;
+		qcom,poll7 = <0 0x0 2 0 1 1>;
+		qcom,mem7 = <0 0x0 2 0 1 0>;
+
+		qcom,page8 = <1 0x0A00 2 0x01 1 1>;//set read mode of NVM controller Interface1
+		qcom,pageen8 = <0 0x0 0 0x0 0 0>;
+		qcom,poll8 = <0 0x0 2 0 1 1>;
+		qcom,mem8 = <8 0x0A04 2 0 1 0>;//read otp data addr 0a04 ~ 0x0a0b
+
+
+        //compatible with old otp rule
+        //page 2, addr 0x0a0c ~ 0x0a43
+        //Flag of group, Module ID, Lens ID, Current rgb avg and Golden rgb avg
+		qcom,page9 = <1 0x0A00 2 0x04 1 1>;//make initial state
+		qcom,pageen9 = <0 0x0 0 0x0 0 0>;
+		qcom,poll9 = <0 0x0 2 0 1 1>;
+		qcom,mem9 = <0 0x0 2 0 1 0>;
+
+		qcom,page10 = <1 0x0A02 2 0x02 1 1>;//set the PAGE 2 of OTP(0 <= the number of PAGE <= 15)
+		qcom,pageen10 = <0 0x0 0 0x0 0 0>;
+		qcom,poll10 = <0 0x0 2 0 1 1>;
+		qcom,mem10 = <0 0x0 2 0 1 0>;
+
+		qcom,page11 = <1 0x0A00 2 0x01 1 1>;//set read mode of NVM controller Interface1
+		qcom,pageen11 = <0 0x0 0 0x0 0 0>;
+		qcom,poll11 = <0 0x0 2 0 1 1>;
+		qcom,mem11 = <56 0x0A0C 2 0 1 0>;//read otp data addr 0x0a0c ~ 0a43
+
+
+        //page 5, addr 0x0a43
+        //LSC OTP disable bit
+		qcom,page12 = <1 0x0A00 2 0x04 1 1>;//make initial state
+		qcom,pageen12 = <0 0x0 0 0x0 0 0>;
+		qcom,poll12 = <0 0x0 2 0 1 1>;
+		qcom,mem12 = <0 0x0 2 0 1 0>;
+
+		qcom,page13 = <1 0x0A02 2 0x05 1 1>;//set the PAGE 5 of OTP(0 <= the number of PAGE <= 15)
+		qcom,pageen13 = <0 0x0 0 0x0 0 0>;
+		qcom,poll13 = <0 0x0 2 0 1 1>;
+		qcom,mem13 = <0 0x0 2 0 1 0>;
+
+		qcom,page14 = <1 0x0A00 2 0x01 1 1>;//set read mode of NVM controller Interface1
+		qcom,pageen14 = <0 0x0 0 0x0 0 0>;
+		qcom,poll14 = <0 0x0 2 0 1 1>;
+		qcom,mem14 = <1 0x0A43 2 0 1 0>;//read otp data addr 0a43
+
+
+        //end of read OTP
+		qcom,page15 = <1 0x0A00 2 0x04 1 1>;//make initial state
+		qcom,pageen15 = <0 0x0 0 0x0 0 0>;
+		qcom,poll15 = <0 0x0 2 0 1 1>;
+		qcom,mem15 = <0 0x0 2 0 1 0>;
+
+        qcom,page16 = <1 0x0A00 2 0x00 1 1>;//disable NVM controller
+        qcom,pageen16 = <0 0x0 0 0x0 0 0>;
+        qcom,poll16 = <0 0x0 2 0 1 1>;
+        qcom,mem16 = <0 0x0 2 0 1 0>;
+
+        qcom,cmm-data-support;
+        qcom,cmm-data-compressed;
+        qcom,cmm-data-offset = <0>;
+        qcom,cmm-data-size = <0>;
+
+        cam_vdig-supply = <&pm8916_l2>;
+		cam_vana-supply = <&pm8916_l17>;
+		cam_vio-supply = <&pm8916_l6>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000>;
+		pinctrl-names = "cam_default", "cam_suspend";
+		pinctrl-0 = <&cam_sensor_mclk1_default &cam_sensor_front_default>;
+		pinctrl-1 = <&cam_sensor_mclk1_sleep &cam_sensor_front_sleep>;
+		gpios = <&msm_gpio 27 0>,
+			<&msm_gpio 28 0>,
+			<&msm_gpio 33 0>,
+			<&msm_gpio 1 0>,
+            <&msm_gpio 21 0>;//9 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+	    qcom,gpio-vdig = <3>;
+		qcom,gpio-vana = <4>;
+		qcom,gpio-req-tbl-num = <0 1 2 3 4>;
+		qcom,gpio-req-tbl-flags = <1 0 0 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK1",
+    		"SCAM_RESET",
+    		"SCAM_STANDBY",
+    		"SCAM_GPIO_DVDD",
+    		"SCAM_GPIO_AVDD";
+
+        qcom,cam-power-seq-type = "sensor_vreg",
+            "sensor_gpio",
+            "sensor_gpio",
+            "sensor_gpio",
+            "sensor_gpio",
+            "sensor_clk";
+		qcom,cam-power-seq-val = "cam_vio",
+            "sensor_gpio_vana",
+            "sensor_gpio_vdig",
+            "sensor_gpio_reset",
+            "sensor_gpio_standby",
+            "sensor_cam_mclk" ;
+		qcom,cam-power-seq-cfg-val = <1 1 1 1 1 24000000>;
+		qcom,cam-power-seq-delay = <1 1 1 10 5 10>;
+
+		clocks = <&clock_gcc clk_mclk1_clk_src>,
+			   <&clock_gcc clk_gcc_camss_mclk1_clk>;
+		clock-names = "cam_src_clk", "cam_clk";
+	};
+
+	eeprom3: qcom,eeprom@6d{
+		cell-index = <3>;
+		reg = <0x01>;
+		qcom,eeprom-name = "s5k5e2_F5E2YAU";
+		compatible = "qcom,eeprom";
+		qcom,slave-addr = <0x20>;
+		qcom,cci-master = <0>;
+		qcom,num-blocks = <5>;
+		qcom,mid-addr = <5 0x0A0B 5 0x0A1B 5 0x0A2B>;
+		qcom,mid = <0x06>;
+
+        //page 5
+        //AWB flag, MID, Year, Month, Day, LensID, VCMID, DriverICID
+        //R_avg_H, R_avg_L, G_avg_H ,G_avg_L ,B_avg_H ,B_avg_L
+		qcom,page0 = <1 0x0A00 2 0x04 1 1>;//make initial state
+		qcom,pageen0 = <0 0x0 0 0x0 0 0>;
+		qcom,poll0 = <0 0x0 2 0 1 1>;
+		qcom,mem0 = <0 0x0 2 0 1 0>;
+
+		qcom,page1 = <1 0x0A02 2 0x05 1 1>;//set the PAGE of OTP(0 <= the number of PAGE <= 15)
+		qcom,pageen1 = <0 0x0 0 0x0 0 0>;
+		qcom,poll1 = <0 0x0 2 0 1 1>;
+		qcom,mem1 = <0 0x0 2 0 1 0>;
+
+		qcom,page2 = <1 0x0A00 2 0x01 1 1>;//set read mode of NVM controller Interface1
+		qcom,pageen2 = <0 0x0 0 0x0 0 0>;
+		qcom,poll2 = <0 0x0 2 0 1 1>;
+		qcom,mem2 = <64 0x0A04 2 0 1 0>;//read otp data addr 0a04 ~ 0a43
+
+        //end of read OTP
+		qcom,page3 = <1 0x0A00 2 0x04 1 1>;//make initial state
+		qcom,pageen3 = <0 0x0 0 0x0 0 0>;
+		qcom,poll3 = <0 0x0 2 0 1 1>;
+		qcom,mem3 = <0 0x0 2 0 1 0>;
+
+        qcom,page4 = <1 0x0A00 2 0x00 1 1>;//disable NVM controller
+        qcom,pageen4 = <0 0x0 0 0x0 0 0>;
+        qcom,poll4 = <0 0x0 2 0 1 1>;
+        qcom,mem4 = <0 0x0 2 0 1 0>;
+
+        qcom,cmm-data-support;
+        qcom,cmm-data-compressed;
+        qcom,cmm-data-offset = <0>;
+        qcom,cmm-data-size = <0>;
+
+        cam_vdig-supply = <&pm8916_l2>;
+		cam_vana-supply = <&pm8916_l17>;
+		cam_vio-supply = <&pm8916_l6>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000>;
+		pinctrl-names = "cam_default", "cam_suspend";
+		pinctrl-0 = <&cam_sensor_mclk1_default &cam_sensor_front_default>;
+		pinctrl-1 = <&cam_sensor_mclk1_sleep &cam_sensor_front_sleep>;
+		gpios = <&msm_gpio 27 0>,
+			<&msm_gpio 28 0>,
+			<&msm_gpio 33 0>,
+			<&msm_gpio 1 0>,
+            <&msm_gpio 21 0>;//9 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+	    qcom,gpio-vdig = <3>;
+		qcom,gpio-vana = <4>;
+		qcom,gpio-req-tbl-num = <0 1 2 3 4>;
+		qcom,gpio-req-tbl-flags = <1 0 0 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK1",
+    		"SCAM_RESET",
+    		"SCAM_STANDBY",
+    		"SCAM_GPIO_DVDD",
+    		"SCAM_GPIO_AVDD";
+
+        qcom,cam-power-seq-type = "sensor_vreg",
+            "sensor_gpio",
+            "sensor_gpio",
+            "sensor_gpio",
+            "sensor_gpio",
+            "sensor_clk";
+		qcom,cam-power-seq-val = "cam_vio",
+            "sensor_gpio_vana",
+            "sensor_gpio_vdig",
+            "sensor_gpio_reset",
+            "sensor_gpio_standby",
+            "sensor_cam_mclk" ;
+		qcom,cam-power-seq-cfg-val = <1 1 1 1 1 24000000>;
+		qcom,cam-power-seq-delay = <1 1 1 10 5 10>;
+
+		clocks = <&clock_gcc clk_mclk1_clk_src>,
+			   <&clock_gcc clk_gcc_camss_mclk1_clk>;
+		clock-names = "cam_src_clk", "cam_clk";
+	};
+
+	qcom,camera@0 {
+		cell-index = <0>;
+		compatible = "qcom,camera";
+		reg = <0x0>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,mount-angle = <90>;
+		qcom,eeprom-src = <&eeprom0 &eeprom1>;
+		qcom,actuator-src = <&actuator0>;
+		qcom,led-flash-src = <&led_flash0>;
+		cam_vdig-supply = <&pm8916_l2>;
+		cam_vana-supply = <&pm8916_l17>;
+		cam_vio-supply = <&pm8916_l6>;
+		cam_vaf-supply = <&pm8916_l10>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+							"cam_vaf";
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000 100000>;
+		pinctrl-names = "cam_default", "cam_suspend";
+		pinctrl-0 = <&cam_sensor_mclk0_default &cam_sensor_rear_default>;
+		pinctrl-1 = <&cam_sensor_mclk0_sleep &cam_sensor_rear_sleep>;
+		gpios = <&msm_gpio 26 0>,
+			<&msm_gpio 35 0>,
+			<&msm_gpio 34 0>,
+			<&msm_gpio 120 0>,
+                        <&msm_gpio 0 0>,
+			<&msm_gpio 8 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-af-pwdm = <3>;
+                qcom,gpio-vana = <4>;
+                qcom,gpio-vdig = <5>;
+		qcom,gpio-req-tbl-num = <0 1 2 3 4 5>;
+		qcom,gpio-req-tbl-flags = <1 0 0 0 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK0",
+			"MCAM_RESET",
+			"MCAM_STANDBY",
+			"MCAM_AF_PWDM",
+                        "MCAM_GPIO_AVDD",
+                        "MCAM_GPIO_DVDD";
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <0>;
+		qcom,cci-master = <0>;
+		status = "ok";
+		clocks = <&clock_gcc clk_mclk0_clk_src>,
+				<&clock_gcc clk_gcc_camss_mclk0_clk>;
+		clock-names = "cam_src_clk", "cam_clk";
+	};
+
+	qcom,camera@1 {
+		cell-index = <1>;
+		compatible = "qcom,camera";
+		reg = <0x1>;
+		qcom,csiphy-sd-index = <1>;
+		qcom,csid-sd-index = <1>;
+		qcom,mount-angle = <270>;//90>;
+		qcom,led-flash-src = <&led_flash0>;
+		qcom,eeprom-src = <&eeprom2 &eeprom3>;
+		cam_vdig-supply = <&pm8916_l2>;
+		cam_vana-supply = <&pm8916_l17>;
+		cam_vio-supply = <&pm8916_l6>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000>;
+		pinctrl-names = "cam_default", "cam_suspend";
+		pinctrl-0 = <&cam_sensor_mclk1_default &cam_sensor_front_default &cam_sensor_front_avdd_default>;
+		pinctrl-1 = <&cam_sensor_mclk1_sleep &cam_sensor_front_sleep &cam_sensor_front_avdd_sleep>;
+		gpios = <&msm_gpio 27 0>,
+			<&msm_gpio 28 0>,
+			<&msm_gpio 33 0>,
+                        <&msm_gpio 1 0>,
+                        <&msm_gpio 21 0>;//9 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+                       qcom,gpio-vana = <3>;
+                       qcom,gpio-vdig = <4>;
+		qcom,gpio-req-tbl-num = <0 1 2 3 4>;
+		qcom,gpio-req-tbl-flags = <1 0 0 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK1",
+			"SCAM_RESET",
+			"SCAM_STANDBY",
+                        "SCAM_GPIO_AVDD",
+                        "SCAM_GPIO_DVDD";
+		qcom,sensor-position = <1>;
+		qcom,sensor-mode = <0>;
+		qcom,cci-master = <0>;
+		status = "ok";
+		clocks = <&clock_gcc clk_mclk1_clk_src>,
+				<&clock_gcc clk_gcc_camss_mclk1_clk>;
+		clock-names = "cam_src_clk", "cam_clk";
+	};
+};
diff --git a/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-pinctrl.dtsi b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-pinctrl.dtsi
new file mode 100755
index 00000000000..c39c79918d7
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-pinctrl.dtsi
@@ -0,0 +1,1585 @@
+/* Copyright (c) 2014-2015, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&soc {
+	tlmm_pinmux: pinctrl@1000000 {
+		compatible = "qcom,msm-tlmm-8939", "qcom,msm-tlmm-8916";
+		reg = <0x1000000 0x300000>;
+		interrupts = <0 208 0>;
+
+		/*General purpose pins*/
+		gp: gp {
+			qcom,num-pins = <122>;
+			#qcom,pin-cells = <1>;
+			msm_gpio: msm_gpio {
+				compatible = "qcom,msm-tlmm-gp";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				num_irqs = <122>;
+			};
+		};
+
+		cdc-ext-spk-pa {
+			qcom,pins = <&gp 0>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <0>;
+			label = "cdc-ext-spk-pa";
+			cdc_ext_spk_pa_act: ext_spk_pa_on {
+				drive-strength = <8>;
+				output-low;
+				bias-pull-none;
+			};
+			cdc_ext_spk_pa_sus: ext_spk_pa_off {
+				drive-strength = <2>;
+				bias-disable;
+			};
+		};
+
+		pmx-uartconsole {
+			qcom,pins = <&gp 4>, <&gp 5>;
+			qcom,num-grp-pins = <2>;
+			qcom,pin-func = <2>;
+			label = "uart-console";
+			uart_console_sleep: uart-console {
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+		};
+
+		pmx_i2c_6 {
+			/* CLK, DATA */
+			qcom,pins = <&gp 22>, <&gp 23>;
+			qcom,num-grp-pins = <2>;
+			qcom,pin-func = <2>;
+			label = "pmx_i2c_6";
+			/* active state */
+			i2c_6_active: i2c_6_active{
+				drive-strength = <2>; /* 2 MA */
+				bias-disable; /* No PULL */
+			};
+			/* suspended state */
+			i2c_6_sleep: i2c_6_sleep {
+				drive-strength = <2>; /* 2 MA */
+				bias-disable; /* No PULL */
+			};
+		};
+
+		pmx_rd_nfc_int{
+			qcom,pins = <&gp 21>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "pmx_nfc_int";
+
+			nfc_int_active: active {
+				drive-strength = <6>;
+				bias-pull-up;
+			};
+
+			nfc_int_suspend: suspend {
+				drive-strength = <6>;
+				bias-pull-up;
+			};
+		};
+
+		pmx_nfc_reset{
+			qcom,pins = <&gp 20>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "pmx_nfc_disable";
+
+			nfc_disable_active: active {
+				drive-strength = <6>;
+				bias-pull-up;
+			};
+
+			nfc_disable_suspend: suspend {
+				drive-strength = <6>;
+				bias-disable;
+			};
+		};
+
+//Jelly remove   <&gp 1>
+		blsp1_uart1_active {
+			qcom,pins = <&gp 0>, <&gp 2>, <&gp 3>;
+			qcom,num-grp-pins = <3>;
+			qcom,pin-func = <2>;
+			label = "blsp1_uart1_active";
+
+			hsuart_active: default {
+			        drive-strength = <16>;
+			        bias-disable;
+			};
+		};
+
+//Jelly remove   <&gp 1>
+		blsp1_uart1_sleep {
+			qcom,pins = <&gp 0>, <&gp 2>, <&gp 3>;
+			qcom,num-grp-pins = <3>;
+			qcom,pin-func = <0>;
+			label = "blsp1_uart1_sleep";
+
+			hsuart_sleep: sleep {
+			        drive-strength = <2>;
+			        bias-disable;
+			};
+		};
+
+		sdhc2_cd_pin {
+			qcom,pins = <&gp 108>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <0>;
+			label = "cd-gpio";
+			sdc2_cd_on: cd_on {
+				drive-strength = <2>;
+				bias-pull-up;
+			};
+			sdc2_cd_off: cd_off {
+				drive-strength = <2>;
+				bias-pull-up;
+                                //bias-disable;
+			};
+		};
+
+		/* SDC pin type */
+		sdc: sdc {
+			/* 0-2 for sdc1 4-6 for sdc2 */
+			qcom,num-pins = <7>;
+			/* Order of pins */
+			/* SDC1: CLK -> 0, CMD -> 1, DATA -> 2 */
+			/* SDC2: CLK -> 4, CMD -> 5, DATA -> 6 */
+			#qcom,pin-cells = <1>;
+		};
+
+		pmx_sdc1_clk {
+			qcom,pins = <&sdc 0>;
+			qcom,num-grp-pins = <1>;
+			label = "sdc1-clk";
+			sdc1_clk_on: clk_on {
+				bias-disable; /* NO pull */
+				drive-strength = <16>; /* 16 MA */
+			};
+			sdc1_clk_off: clk_off {
+				bias-disable; /* NO pull */
+				drive-strength = <2>; /* 2 MA */
+			};
+		};
+
+		pmx_sdc1_cmd {
+			qcom,pins = <&sdc 1>;
+			qcom,num-grp-pins = <1>;
+			label = "sdc1-cmd";
+			sdc1_cmd_on: cmd_on {
+				bias-pull-up; /* pull up */
+				drive-strength = <10>; /* 10 MA */
+			};
+			sdc1_cmd_off: cmd_off {
+				bias-pull-up; /* pull up */
+				drive-strength = <2>; /* 2 MA */
+			};
+		};
+
+		pmx_sdc1_data {
+			qcom,pins = <&sdc 2>;
+			qcom,num-grp-pins = <1>;
+			label = "sdc1-data";
+			sdc1_data_on: data_on {
+				bias-pull-up; /* pull up */
+				drive-strength = <10>; /* 10 MA */
+			};
+			sdc1_data_off: data_off {
+				bias-pull-up; /* pull up */
+				drive-strength = <2>; /* 2 MA */
+			};
+		};
+
+		pmx_sdc2_clk {
+			qcom,pins = <&sdc 4>;
+			qcom,num-grp-pins = <1>;
+			label = "sdc2-clk";
+			sdc2_clk_on: clk_on {
+				bias-disable; /* NO pull */
+				drive-strength = <16>; /* 16 MA */
+			};
+			sdc2_clk_off: clk_off {
+				bias-disable; /* NO pull */
+				drive-strength = <2>; /* 2 MA */
+			};
+		};
+
+		pmx_sdc2_cmd {
+			qcom,pins = <&sdc 5>;
+			qcom,num-grp-pins = <1>;
+			label = "sdc2-cmd";
+			sdc2_cmd_on: cmd_on {
+				bias-pull-up; /* pull up */
+				drive-strength = <10>; /* 10 MA */
+			};
+			sdc2_cmd_off: cmd_off {
+				bias-pull-up; /* pull up */
+				drive-strength = <2>; /* 2 MA */
+			};
+		};
+
+		pmx_sdc2_data {
+			qcom,pins = <&sdc 6>;
+			qcom,num-grp-pins = <1>;
+			label = "sdc2-data";
+			sdc2_data_on: data_on {
+				bias-pull-up; /* pull up */
+				drive-strength = <10>; /* 10 MA */
+			};
+			sdc2_data_off: data_off {
+				bias-pull-up; /* pull up */
+				drive-strength = <2>; /* 2 MA */
+			};
+		};
+		pmx_i2c_0 {
+			/* CLK, DATA */
+			qcom,pins = <&gp 7>, <&gp 6>;
+			qcom,num-grp-pins = <2>;
+			qcom,pin-func = <3>;
+			label = "pmx_i2c_0";
+
+			i2c_0_active: i2c_0_active {
+				drive-strength = <2>; /* 2 MA */
+				bias-disable;         /* No PULL */
+			};
+
+			i2c_0_sleep: i2c_0_sleep {
+				drive-strength = <2>; /* 2 MA */
+				bias-disable;	      /* No PULL */
+			};
+		};
+
+		pmx_i2c_4 {
+			qcom,pins = <&gp 14>, <&gp 15>; /* SDA, SCL */
+			qcom,num-grp-pins = <2>;
+			qcom,pin-func = <2>;
+			label = "pmx_i2c_4";
+
+			i2c_4_active: i2c_4_active {
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			i2c_4_sleep: i2c_4_sleep {
+				drive-strength = <2>;
+				bias-disable;
+			};
+		};
+
+		pmx_i2c_5 {
+			qcom,pins = <&gp 18>, <&gp 19>; /* SDA, SCL */
+			qcom,num-grp-pins = <2>;
+			qcom,pin-func = <2>;
+			label = "pmx_i2c_5";
+
+			i2c_5_active: i2c_5_active {
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			i2c_5_sleep: i2c_5_sleep {
+				drive-strength = <2>;
+				bias-disable;
+			};
+		};
+
+		smb_int_pin {
+			qcom,pins = <&gp 62>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <0>;
+			label = "smb1360_int_gpio";
+			smb_int_default: smb_int_default {
+				drive-strength = <2>;	/* 2 MA */
+				bias-pull-up;		/* PULL UP*/
+			};
+		};
+
+		usb-id-pin {
+			qcom,pins = <&gp 110>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <0>;
+			label = "usb-id-pin";
+			usbid_default: default {
+				drive-strength = <8>;
+				bias-pull-up;
+			};
+		};
+
+		 spi0_active {
+                        /* MOSI, MISO, CLK */
+                        qcom,pins = <&gp 8>, <&gp 9>, <&gp 11>;
+                        qcom,num-grp-pins = <3>;
+                        qcom,pin-func = <1>;
+                        label = "spi0-active";
+                        /* active state */
+                        spi0_default: spi0_default {
+                                drive-strength = <12>; /* 12 MA */
+                                bias-disable = <0>; /* No PULL */
+                        };
+                };
+
+                spi0_suspend {
+                        /* MOSI, MISO, CLK */
+                        qcom,pins = <&gp 8>, <&gp 9>, <&gp 11>;
+                        qcom,num-grp-pins = <3>;
+                        qcom,pin-func = <0>;
+                        label = "spi0-suspend";
+                        /* suspended state */
+                        spi0_sleep: spi0_sleep {
+                                drive-strength = <2>; /* 2 MA */
+			        bias-pull-down; /* PULL Down */
+                        };
+                };
+
+                spi0_cs0_active {
+                        /* CS */
+                        qcom,pins = <&gp 10>;
+                        qcom,num-grp-pins = <1>;
+                        qcom,pin-func = <1>;
+                        label = "spi0-cs0-active";
+                        spi0_cs0_active: cs0_active {
+                                drive-strength = <2>;
+                                bias-disable = <0>;
+                        };
+                };
+
+                spi0_cs0_suspend {
+                        /* CS */
+                        qcom,pins = <&gp 10>;
+                        qcom,num-grp-pins = <1>;
+                        qcom,pin-func = <0>;
+                        label = "spi0-cs0-suspend";
+                        spi0_cs0_sleep: cs0_sleep {
+                                drive-strength = <2>;
+                                bias-disable = <0>;
+                        };
+                };
+
+		wcnss_pmux_5wire: wcnss_pmux_5wire {
+			/* Uses general purpose pins */
+			qcom,pins = <&gp 40>, <&gp 41>,
+				    <&gp 42>, <&gp 43>,
+				    <&gp 44>;
+			qcom,num-grp-pins = <5>;
+			qcom,pin-func = <1>;
+			label = "wcnss_5wire_pins";
+			/* Active configuration of bus pins */
+			wcnss_default: wcnss_default {
+			        drive-strength = <6>; /* 6 MA */
+			        bias-pull-up; /* PULL UP */
+			};
+			wcnss_sleep: wcnss_sleep {
+			        drive-strength = <2>; /* 2 MA */
+			        bias-pull-down; /* PULL Down */
+			};
+		};
+
+		spi5_active {
+                        /* MOSI, MISO, CLK */
+                        qcom,pins = <&gp 16>, <&gp 17>, <&gp 19>;
+                        qcom,num-grp-pins = <3>;
+                        qcom,pin-func = <1>;
+                        label = "spi5-active";
+                        /* active state */
+                        spi5_default: spi5_default {
+                                drive-strength = <16>; /* 16 MA */
+                                bias-disable = <0>; /* No PULL */
+                        };
+                };
+
+                spi5_suspend {
+                        /* MOSI, MISO, CLK */
+                        qcom,pins = <&gp 16>, <&gp 17>, <&gp 19>;
+                        qcom,num-grp-pins = <3>;
+                        qcom,pin-func = <0>;
+                        label = "spi5-suspend";
+                        /* suspended state */
+                        spi5_sleep: spi5_sleep {
+                                drive-strength = <2>; /* 2 MA */
+                                bias-disable = <0>; /* No PULL */
+                        };
+                };
+
+                spi5_cs0_active {
+                        /* CS */
+                        qcom,pins = <&gp 18>;
+                        qcom,num-grp-pins = <1>;
+                        qcom,pin-func = <1>;
+                        label = "spi5-cs0-active";
+                        spi5_cs0_active: cs0_active {
+                                drive-strength = <2>;
+                                bias-disable = <0>;
+                        };
+                };
+
+                spi5_cs0_suspend {
+                        /* CS */
+                        qcom,pins = <&gp 18>;
+                        qcom,num-grp-pins = <1>;
+                        qcom,pin-func = <0>;
+                        label = "spi5-cs0-suspend";
+                        spi5_cs0_sleep: cs0_sleep {
+                                drive-strength = <2>;
+                                bias-disable = <0>;
+                        };
+                };
+
+		wcnss_pmux_gpio: wcnss_pmux_gpio {
+			/* Uses general purpose pins */
+			qcom,pins = <&gp 40>, <&gp 41>,
+				    <&gp 42>, <&gp 43>,
+				    <&gp 44>;
+			qcom,num-grp-pins = <5>;
+			qcom,pin-func = <0>;
+			label = "wcnss_5gpio_pins";
+			/* Active configuration of bus pins */
+			wcnss_gpio_default: wcnss_gpio_default {
+			        drive-strength = <6>; /* 6 MA */
+			        bias-pull-up; /* PULL UP */
+			};
+		};
+
+		tlmm_gpio_key {
+			qcom,pins = <&gp 107>, <&gp 109>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <2>;
+			label = "tlmm_gpio_key";
+			gpio_key_active: gpio_key_active {
+				drive-strength = <2>;
+				bias-pull-up;
+			};
+			gpio_key_suspend: gpio_key_suspend {
+				drive-strength = <2>;
+				bias-pull-up;
+			};
+		};
+
+		/* add pingrp for touchscreen */
+		pmx_ts_int_active {
+			qcom,pins = <&gp 13>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "pmx_ts_int_active";
+
+			ts_int_active: ts_int_active {
+				drive-strength = <16>;
+				bias-pull-up;
+			};
+		};
+
+		pmx_ts_int_suspend {
+			qcom,pins = <&gp 13>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "pmx_ts_int_suspend";
+
+			ts_int_suspend: ts_int_suspend {
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+		};
+
+		pmx_ts_reset_active {
+			qcom,pins = <&gp 12>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "pmx_ts_reset_active";
+
+			ts_reset_active: ts_reset_active {
+				drive-strength = <16>;
+				bias-pull-up;
+			};
+		};
+
+		pmx_ts_reset_suspend {
+			qcom,pins = <&gp 12>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "pmx_ts_reset_suspend";
+
+			ts_reset_suspend: ts_reset_suspend {
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+		};
+
+		afe_pwr_active {
+			qcom,pins = <&gp 75>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "afe_active";
+
+			afe_pwr_active: afe_pwr_active {
+				drive-strength = <16>;
+				output-high;
+			};
+		};
+
+		afe_pwr_suspend {
+			qcom,pins = <&gp 75>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "afe_suspend";
+
+			afe_pwr_suspend: afe_pwr_suspend {
+				drive-strength = <2>;
+				output-low;
+			};
+		};
+
+		mod_en_active {
+			qcom,pins = <&gp 97>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "mod_en_active";
+
+			mod_en_active: mod_en_active {
+				drive-strength = <16>;
+				output-high;
+			};
+		};
+
+		mod_en_suspend {
+			qcom,pins = <&gp 97>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "mod_en_suspend";
+
+			mod_en_suspend: mod_en_suspend {
+				drive-strength = <2>;
+				output-low;
+			};
+		};
+
+		disp_vsn_active {
+			qcom,pins = <&gp 77>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "disp_vsn_active";
+
+			disp_vsn_active: disp_vsn_active {
+				drive-strength = <16>;
+				output-high;
+			};
+		};
+
+		disp_vsn_suspend {
+			qcom,pins = <&gp 77>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "disp_vsn_suspend";
+
+			disp_vsn_suspend: disp_vsn_suspend {
+				drive-strength = <2>;
+				output-low;
+			};
+		};
+
+		ddic_rst_active {
+			qcom,pins = <&gp 25>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "ddic_rst_active";
+
+			ddic_rst_active: ddic_rst_active {
+				drive-strength = <16>;
+				output-high;
+			};
+		};
+
+		ddic_rst_suspend {
+			qcom,pins = <&gp 25>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "ddic_rst_suspend";
+
+			ddic_rst_suspend: ddic_rst_suspend {
+				drive-strength = <2>;
+				output-low;
+			};
+		};
+
+		pmx_ts_release {
+			qcom,pins = <&gp 13>, <&gp 12>;
+			qcom,num-grp-pins = <2>;
+			label = "pmx_ts_release";
+
+			ts_release: ts_release {
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+		};
+
+		apds99xx_int_pin {
+			/* Ambient light and proximity sensor apds9930 and apds9900 */
+			qcom,pins = <&gp 113>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "apds99xx-irq";
+			apds99xx_default: apds99xx_default {
+				drive-strength = <6>;
+				bias-pull-up;
+			};
+			apds99xx_sleep: apds99xx_sleep {
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+		};
+
+		mpu6050_int_pin {
+			/* Gyroscope and accelerometer sensor combo */
+			qcom,pins = <&gp 115>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "mpu6050-irq";
+			mpu6050_default: mpu6050_default {
+				drive-strength = <6>;
+				bias-pull-up;
+			};
+			mpu6050_sleep: mpu6050_sleep {
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+		};
+
+		ak8963_int_pin {
+			qcom,pins = <&gp 69>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "ak8963-irq";
+			ak8963_default: ak8963_default {
+				drive-strength = <6>;
+				bias-pull-up;
+			};
+			ak8963_sleep: ak8963_sleep {
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+		};
+
+		ext_buck_vsel {
+			qcom,pins = <&gp 111>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <0>;
+			label = "ext-buck-vsel";
+
+			ext_buck_vsel_default: vsel0 {
+				drive-strength = <2>;
+			};
+		};
+
+		ext-cdc-tlmm-lines {
+			qcom,pins = <&gp 116>, <&gp 112>, <&gp 117>,
+					<&gp 118>, <&gp 119>;
+			qcom,num-grp-pins = <5>;
+			qcom,pin-func = <1>;
+			label = "ext-cdc-tlmm-lines";
+			ext_cdc_tlmm_lines_act: tlmm_lines_on {
+				drive-strength = <8>;
+			};
+			ext_cdc_tlmm_lines_sus: tlmm_lines_off {
+				drive-strength = <2>;
+				bias-disable;
+			};
+		};
+
+		cdc_slim_lines {
+			qcom,pins = <&gp 63>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <2>;
+			label = "cdc_slim_lines";
+			cdc_slim_lines_act: slim_lines_on {
+				drive-strength = <8>;
+				bias-pull-none;
+				output-high;
+			};
+			cdc_slim_lines_sus: slim_lines_off {
+				drive-strength = <2>;
+				bias-disable;
+			};
+		};
+
+		cdc-pdm-lines {
+			qcom,pins = <&gp 63>, <&gp 64>, <&gp 65>,
+					<&gp 66>, <&gp 67>, <&gp 68>;
+			qcom,num-grp-pins = <6>;
+			qcom,pin-func = <1>;
+			label = "cdc-pdm-lines";
+			cdc_pdm_lines_act: pdm_lines_on {
+				drive-strength = <8>;
+				bias-pull-none;
+			};
+			cdc_pdm_lines_sus: pdm_lines_off {
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+		};
+
+		cdc-pdm-lines38 {
+                       qcom,pins = <&gp 11>;
+                       qcom,num-grp-pins = <1>;
+                       qcom,pin-func = <0>;
+                       label = "cdc-pdm-lines38";
+                       cdc_pdm_lines_act38: pdm_lines_on38 {
+                               drive-strength = <8>;
+                               output-low;
+                               bias-pull-none;
+                       };
+                       cdc_pdm_lines_sus38: pdm_lines_off38 {
+                               drive-strength = <2>;
+                               output-low;
+                               bias-disable;
+                       };
+               };
+
+
+		cross-conn-det {
+			qcom,pins = <&gp 120>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <0>;
+			label = "cross-conn-det-sw";
+			cross_conn_det_act: lines_on {
+				drive-strength = <8>;
+				output-low;
+				bias-pull-down;
+			};
+			cross_conn_det_sus: lines_off {
+				drive-strength = <2>;
+				bias-disable;
+			};
+		};
+
+		melfas_int_pin {
+			qcom,pins = <&gp 13>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "melfas-irq";
+
+			melfas_int_default: melfas_int_default {
+				drive-strength = <6>;
+				bias-pull-up;
+			};
+		};
+
+		pmx_mdss: pmx_mdss {
+			label = "mdss-pins";
+			qcom,pin-func = <0>;
+
+			mdss_dsi_active: active {
+				drive-strength = <8>; /* 8 mA */
+				bias-disable = <0>; /* no pull */
+			};
+			mdss_dsi_suspend: suspend {
+				drive-strength = <2>; /* 2 mA */
+				bias-pull-down; /* pull down */
+			};
+		};
+
+		pmx_mdss_te: pmx_mdss_te {
+			label = "mdss-te-pin";
+			qcom,pin-func = <1>;
+			mdss_te_active: active {
+				drive-strength = <2>; /* 2 mA */
+				bias-pull-down; /* pull down */
+				input-debounce = <0>;
+			};
+			mdss_te_suspend: suspend {
+				drive-strength = <2>; /* 2 mA */
+				bias-pull-down; /* pull down */
+				input-debounce = <0>;
+			};
+		};
+
+		/* QDSD pin type */
+		qdsd: qdsd {
+			qcom,pin-type-qdsd;
+			/* 0-> clk, 1 -> cmd, 2->data0, 3->data1, 4->data2, 5->data3 */
+			qcom,num-pins = <6>;
+
+			#qcom,pin-cells = <1>;
+		};
+
+		pmx_qdsd_clk {
+			qcom,pins = <&qdsd 0>;
+			qcom,num-grp-pins = <1>;
+			label = "qdsd-clk";
+			qdsd_clk_sdcard: clk_sdcard {
+				bias-disable; /* NO pull */
+				drive-strength = <7>; /* 7 MA */
+			};
+			qdsd_clk_trace: clk_trace {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_clk_swdtrc: clk_swdtrc {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_clk_spmi: clk_spmi {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+		};
+
+		pmx_qdsd_cmd {
+			qcom,pins = <&qdsd 1>;
+			qcom,num-grp-pins = <1>;
+			label = "qdsd-cmd";
+			qdsd_cmd_sdcard: cmd_sdcard {
+				bias-pull-down; /* pull down */
+				drive-strength = <3>; /* 3 MA */
+			};
+			qdsd_cmd_trace: cmd_trace {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_cmd_swduart: cmd_uart {
+				bias-pull-up; /* pull up */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_cmd_swdtrc: cmd_swdtrc {
+				bias-pull-up; /* pull up */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_cmd_jtag: cmd_jtag {
+				bias-disable; /* NO pull */
+				drive-strength = <3>; /* 3 MA */
+			};
+			qdsd_cmd_spmi: cmd_spmi {
+				bias-pull-down; /* pull down */
+				drive-strength = <4>; /* 4 MA */
+			};
+		};
+
+		pmx_qdsd_data0 {
+			qcom,pins = <&qdsd 2>;
+			qcom,num-grp-pins = <1>;
+			label = "qdsd-data0";
+			qdsd_data0_sdcard: data0_sdcard {
+				bias-pull-down; /* pull down */
+				drive-strength = <3>; /* 3 MA */
+			};
+			qdsd_data0_trace: data0_trace {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_data0_swduart: data0_uart {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_data0_swdtrc: data0_swdtrc {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_data0_jtag: data0_jtag {
+				bias-pull-up; /* pull up */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_data0_spmi: data0_spmi {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+		};
+
+		pmx_qdsd_data1 {
+			qcom,pins = <&qdsd 3>;
+			qcom,num-grp-pins = <1>;
+			label = "qdsd-data1";
+			qdsd_data1_sdcard: data1_sdcard {
+				bias-pull-down; /* pull down */
+				drive-strength = <3>; /* 3 MA */
+			};
+			qdsd_data1_trace: data1_trace {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_data1_swduart: data1_uart {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_data1_swdtrc: data1_swdtrc {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_data1_jtag: data1_jtag {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+		};
+
+		pmx_qdsd_data2 {
+			qcom,pins = <&qdsd 4>;
+			qcom,num-grp-pins = <1>;
+			label = "qdsd-data2";
+			qdsd_data2_sdcard: data2_sdcard {
+				bias-pull-down; /* pull down */
+				drive-strength = <3>; /* 3 MA */
+			};
+			qdsd_data2_trace: data2_trace {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_data2_swduart: data2_uart {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_data2_swdtrc: data2_swdtrc {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_data2_jtag: data2_jtag {
+				bias-pull-up; /* pull up */
+				drive-strength = <3>; /* 3 MA */
+			};
+		};
+
+		pmx_qdsd_data3 {
+			qcom,pins = <&qdsd 5>;
+			qcom,num-grp-pins = <1>;
+			label = "qdsd-data3";
+			qdsd_data3_sdcard: data3_sdcard {
+				bias-pull-down; /* pull down */
+				drive-strength = <3>; /* 3 MA */
+			};
+			qdsd_data3_trace: data3_trace {
+				bias-pull-down; /* pull down */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_data3_swduart: data3_uart {
+				bias-pull-up; /* pull up */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_data3_swdtrc: data3_swdtrc {
+				bias-pull-up; /* pull up */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_data3_jtag: data3_jtag {
+				bias-pull-up; /* pull up */
+				drive-strength = <0>; /* 0 MA */
+			};
+			qdsd_data3_spmi: data3_spmi {
+				bias-pull-down; /* pull down */
+				drive-strength = <3>; /* 3 MA */
+			};
+		};
+
+		cci0_pinmux {
+			/* CLK, DATA */
+			qcom,pins = <&gp 29>, <&gp 30>;
+			qcom,num-grp-pins = <2>;
+			qcom,pin-func = <1>;
+			label = "cci0";
+			/* active state */
+			cci0_default: default {
+				drive-strength = <2>; /* 2 MA */
+				bias-disable = <0>; /* No PULL */
+			};
+			/*suspended state */
+			cci0_sleep: sleep {
+				drive-strength = <2>; /* 2 MA */
+				bias-disable = <0>; /* No PULL */
+			};
+		};
+
+		cam_sensor_mclk0 {
+			/* MCLK */
+			qcom,pins = <&gp 26>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <1>;
+			label = "cam-sensor-mclk0";
+			/* active state */
+			cam_sensor_mclk0_default: default {
+				drive-strength = <2>; /* 2 MA */
+				bias-disable = <0>; /* No PULL */
+			};
+                };
+
+		cam_sensor_mclk0_sleep {
+			/* MCLK */
+			qcom,pins = <&gp 26>;
+			qcom,num-grp-pins = <1>;
+			label = "cam-sensor-mclk0-sleep";
+			/*suspend state */
+			cam_sensor_mclk0_sleep: sleep {
+				drive-strength = <2>; /* 2 MA */
+				bias-pull-down; /* PULL DOWN */
+			};
+		};
+		cam_sensor_mclk1 {
+			/* MCLK */
+			qcom,pins = <&gp 27>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <1>;
+			label = "cam-sensor-mclk1";
+			/* active state */
+			cam_sensor_mclk1_default: default {
+				drive-strength = <2>; /* 2 MA */
+				bias-disable = <0>; /* No PULL */
+			};
+                };
+
+		cam_sensor_mclk1_sleep {
+			/* MCLK */
+			qcom,pins = <&gp 27>;
+			qcom,num-grp-pins = <1>;
+			label = "cam-sensor-mclk1-sleep";
+			/*suspend state */
+			cam_sensor_mclk1_sleep: sleep {
+				drive-strength = <2>; /* 2 MA */
+				bias-pull-down; /* PULL DOWN */
+			};
+		};
+
+		cam_sensor_rear {
+			/* RESET, STANDBY */
+			qcom,pins =  <&gp 35>, <&gp 34>;
+			qcom,num-grp-pins = <2>;
+			qcom,pin-func = <0>;
+			label = "cam-sensor-rear";
+			/* active state */
+			cam_sensor_rear_default: default {
+				drive-strength = <2>; /* 2 MA */
+				bias-disable = <0>; /* No PULL */
+			};
+		};
+
+		cam_sensor_rear_sleep {
+			/* RESET, STANDBY */
+			qcom,pins =  <&gp 35>, <&gp 34>;
+			qcom,num-grp-pins = <2>;
+			qcom,pin-func = <0>;
+			label = "cam-sensor-rear-sleep";
+			/*suspend state */
+			cam_sensor_rear_sleep: sleep {
+				drive-strength = <2>; /* 2 MA */
+				bias-pull-down; /* PULL DOWN */
+			};
+		};
+
+		cam_sensor_front {
+			/* RESET, STANDBY */
+			qcom,pins = <&gp 28>, <&gp 33>;
+			qcom,num-grp-pins = <2>;
+			qcom,pin-func = <0>;
+			label = "cam_sensor_front";
+			/* active state */
+			cam_sensor_front_default: default {
+				drive-strength = <2>; /* 2 MA */
+				bias-disable = <0>; /* No PULL */
+			};
+		};
+
+		cam_sensor_front_sleep {
+			/* RESET, STANDBY */
+			qcom,pins = <&gp 28>, <&gp 33>;
+			qcom,num-grp-pins = <2>;
+			qcom,pin-func = <0>;
+			label = "cam_sensor_front_sleep";
+			/*suspend state */
+			cam_sensor_front_sleep: sleep {
+				drive-strength = <2>; /* 2 MA */
+				bias-pull-down = <0>; /* PULL DOWN */
+			};
+		};
+//Jelly add front camera avdd control
+	cam_sensor_front_avdd{
+			/*front avdd*/
+			qcom,pins = <&gp 1>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <0>;
+			label = "cam_sensor_front_avdd";
+			/* active state */
+			cam_sensor_front_avdd_default: default {
+				drive-strength = <6>;
+				bias-pull-up;
+			};
+			cam_sensor_front_avdd_sleep: sleep {
+				drive-strength = <6>;
+				bias-pull-up;
+			};
+		};
+
+		cam_sensor_flash {
+			/* FLSH_RESET,FLASH_EN,FLASH_NOW */
+			qcom,pins = <&gp 36>, <&gp 31>,<&gp 32> ;
+			qcom,num-grp-pins = <3>;
+			qcom,pin-func = <0>;
+			label = "cam_sensor_flash";
+			/* active state */
+			cam_sensor_flash_default: default {
+				drive-strength = <2>; /* 2 MA */
+				bias-disable = <0>; /* No PULL */
+			};
+			/*suspended state */
+			cam_sensor_flash_sleep: sleep {
+				drive-strength = <2>; /* 2 MA */
+				bias-pull-down = <0>; /* PULL DOWN */
+			};
+		};
+
+		/* CoreSight */
+		tpiu_seta_1 {
+			qcom,pins = <&gp 8>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <3>;
+			label = "tpiu-seta-1";
+			seta_1: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_2 {
+			qcom,pins = <&gp 9>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <2>;
+			label = "tpiu-seta-2";
+			seta_2: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+		red_led_gpio10{
+			qcom,pins = <&gp 10>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "red_led_gpio";
+	
+			redled_gpio10_active: redled_gpio10_active {
+				drive-strength = <6>;
+				bias-pull-up;
+				};
+		
+			redled_gpio10_suspend: suspend {
+				drive-strength = <6>;
+				bias-pull-up;
+   		   };
+		};
+		tpiu_seta_3 {
+			qcom,pins = <&gp 10>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <3>;
+			label = "tpiu-seta-3";
+			seta_3: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_4 {
+			qcom,pins = <&gp 39>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <2>;
+			label = "tpiu-seta-4";
+			seta_4: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_5 {
+			qcom,pins = <&gp 40>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <2>;
+			label = "tpiu-seta-5";
+			seta_5: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_6 {
+			qcom,pins = <&gp 41>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <2>;
+			label = "tpiu-seta-6";
+			seta_6: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_7 {
+			qcom,pins = <&gp 42>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <2>;
+			label = "tpiu-seta-7";
+			seta_7: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_8 {
+			qcom,pins = <&gp 43>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <3>;
+			label = "tpiu-seta-8";
+			seta_8: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_9 {
+			qcom,pins = <&gp 45>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <3>;
+			label = "tpiu-seta-9";
+			seta_9: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_10 {
+			qcom,pins = <&gp 46>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <2>;
+			label = "tpiu-seta-10";
+			seta_10: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_11 {
+			qcom,pins = <&gp 47>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <3>;
+			label = "tpiu-seta-11";
+			seta_11: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_12 {
+			qcom,pins = <&gp 48>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <2>;
+			label = "tpiu-seta-12";
+			seta_12: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_13 {
+			qcom,pins = <&gp 62>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <1>;
+			label = "tpiu-seta-13";
+			seta_13: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_14 {
+			qcom,pins = <&gp 69>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <2>;
+			label = "tpiu-seta-14";
+			seta_14: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_15 {
+			qcom,pins = <&gp 112>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <6>;
+			label = "tpiu-seta-15";
+			seta_15: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_16 {
+			qcom,pins = <&gp 113>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <9>;
+			label = "tpiu-seta-16";
+			seta_16: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_17 {
+			qcom,pins = <&gp 114>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <8>;
+			label = "tpiu-seta-17";
+			seta_17: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_seta_18 {
+			qcom,pins = <&gp 115>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <8>;
+			label = "tpiu-seta-18";
+			seta_18: seta {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_1 {
+			qcom,pins = <&gp 4>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <5>;
+			label = "tpiu-setb-1";
+			setb_1: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_2 {
+			qcom,pins = <&gp 5>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <5>;
+			label = "tpiu-setb-2";
+			setb_2: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_3 {
+			qcom,pins = <&gp 26>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <7>;
+			label = "tpiu-setb-3";
+			setb_3: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_4 {
+			qcom,pins = <&gp 27>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <10>;
+			label = "tpiu-setb-4";
+			setb_4: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_5 {
+			qcom,pins = <&gp 28>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <7>;
+			label = "tpiu-setb-5";
+			setb_5: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_6 {
+			qcom,pins = <&gp 29>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <7>;
+			label = "tpiu-setb-6";
+			setb_6: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_7 {
+			qcom,pins = <&gp 30>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <9>;
+			label = "tpiu-setb-7";
+			setb_7: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_8 {
+			qcom,pins = <&gp 31>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <10>;
+			label = "tpiu-setb-8";
+			setb_8: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_9 {
+			qcom,pins = <&gp 32>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <10>;
+			label = "tpiu-setb-9";
+			setb_9: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_10 {
+			qcom,pins = <&gp 33>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <9>;
+			label = "tpiu-setb-10";
+			setb_10: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_11 {
+			qcom,pins = <&gp 34>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <9>;
+			label = "tpiu-setb-11";
+			setb_11: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_12 {
+			qcom,pins = <&gp 35>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <9>;
+			label = "tpiu-setb-12";
+			setb_12: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_13 {
+			qcom,pins = <&gp 36>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <8>;
+			label = "tpiu-setb-13";
+			setb_13: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_14 {
+			qcom,pins = <&gp 37>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <7>;
+			label = "tpiu-setb-14";
+			setb_14: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_15 {
+			qcom,pins = <&gp 110>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <4>;
+			label = "tpiu-setb-15";
+			setb_15: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_16 {
+			qcom,pins = <&gp 111>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <1>;
+			label = "tpiu-setb-16";
+			setb_16: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_17 {
+			qcom,pins = <&gp 120>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <10>;
+			label = "tpiu-setb-17";
+			setb_17: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		tpiu_setb_18 {
+			qcom,pins = <&gp 121>;
+			qcom,num-grp-pins = <1>;
+			qcom,pin-func = <11>;
+			label = "tpiu-setb-18";
+			setb_18: setb {
+				drive-strength = <16>;
+				bias-disable;
+			};
+		};
+
+		uicc-active {
+			qcom,pins = <&gp 53>, <&gp 54>;
+			qcom,num-grp-pins = <2>;
+			qcom,pin-func = <2>;
+			label = "uicc-active-pins";
+
+			uicc_active: active {
+				drive-strength = <8>;
+				bias-disable;
+			};
+		};
+
+		uicc-sleep {
+			qcom,pins = <&gp 53>, <&gp 54>;
+			qcom,num-grp-pins = <2>;
+			qcom,pin-func = <0>;
+			label = "uicc-sleep-pins";
+
+			uicc_sleep: sleep {
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+		};
+
+		ltr553_int_pin {
+			qcom,pins = <&gp 113>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "ltr553-irq";
+
+			ltr553_default: ltr553_default {
+				drive-strength = <6>;
+				bias-pull-up;
+			};
+			ltr553_sleep: ltr553_sleep {
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-qrd-skuk.dtsi b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-qrd-skuk.dtsi
new file mode 100755
index 00000000000..042dadde0ab
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-qrd-skuk.dtsi
@@ -0,0 +1,335 @@
+/* Copyright (c) 2014-2015, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "test01a-msm8939-qrd.dtsi"
+#include "test01a-msm8939-camera-sensor-qrd.dtsi"
+#include "dsi-panel-ams497-720p-video.dtsi"
+
+&soc {
+        i2c@78b6000 { /* BLSP1 QUP2 */
+		awrgb@45 {
+			compatible = "aw,aw2013-rgb-leds";
+			reg = <0x45>;
+			pinctrl-names = "redled_gpio";
+			pinctrl-0 =  <&redled_gpio10_active>;
+			aw2013,red_gpio20 = <&msm_gpio 10 0>;
+			aw2013,maxbrightness = <160>;
+			aw2013,Imax = <1>;
+		};
+		st480@0c {
+			compatible = "senodia,st480";
+			reg = <0x0c>;
+			vdd-supply = <&pm8916_l17>;
+			vio-supply = <&pm8916_l6>;
+			senodia,axis-map-x = <1>;
+			senodia,axis-map-y = <0>;
+			senodia,axis-map-z = <2>;
+			senodia,negate-x;
+		};
+
+                iteon@23 {
+		        compatible = "liteon,ltr553";
+		        reg = <0x23>;
+		        pinctrl-names = "default","sleep";
+		        pinctrl-0 = <&ltr553_default>;
+		        pinctrl-1 = <&ltr553_sleep>;
+		        interrupt-parent = <&msm_gpio>;
+		        interrupts = <113 0x2>;
+		        vdd-supply = <&pm8916_l17>;
+		        vio-supply = <&pm8916_l6>;
+		        liteon,intr = <&msm_gpio 113 0x2>;
+		        liteon,highthr = <250>;
+		        liteon,lowthr = <150>;
+		        liteon_project = "test01a";
+	        };
+	};
+
+	i2c@78b9000 { /* BLSP1 QUP5 */
+	    lsm6ds0@6b {
+			compatible = "st,lsm6ds3";
+			reg = <0x6b>;
+			rot-matrix = /bits/ 16 <(0) (1) (0)
+				(-1) (0) (0)
+				(0) (0) (1)>;
+			g-poll-interval = <100>;
+			g-min-interval = <2>;
+			g-fs-range = <0>;
+			x-poll-interval = <100>;
+			x-min-interval = <1>;
+			x-fs-range = <0>;
+			aa-filter-bw = <0>;
+		};
+
+		focaltech@38 {
+			compatible = "focaltech,5x06";
+			reg = <0x38>;
+			interrupt-parent = <&msm_gpio>;
+			interrupts = <13 0x2008>;
+			vdd-supply = <&pm8916_l17>;
+			vcc_i2c-supply = <&pm8916_l6>;
+			/* pins used by touchscreen */
+			pinctrl-names = "pmx_ts_active","pmx_ts_suspend","pmx_ts_release";
+			pinctrl-0 = <&ts_int_active &ts_reset_active>;
+			pinctrl-1 = <&ts_int_suspend &ts_reset_suspend>;
+			pinctrl-2 = <&ts_release>;
+			focaltech,name = "ft5336";
+			focaltech,family-id = <0x14>;
+			focaltech,reset-gpio = <&msm_gpio 12 0x0>;
+			focaltech,irq-gpio = <&msm_gpio 13 0x2008>;
+			focaltech,display-coords = <0 0 1080 1920>;
+			focaltech,panel-coords = <0 0 1080 2098>;
+			focaltech,button-map= <139 102 158>;
+			focaltech,no-force-update;
+			focaltech,i2c-pull-up;
+			focaltech,group-id = <1>;
+			focaltech,hard-reset-delay-ms = <20>;
+			focaltech,soft-reset-delay-ms = <200>;
+			focaltech,num-max-touches = <5>;
+			focaltech,fw-delay-aa-ms = <30>;
+			focaltech,fw-delay-55-ms = <30>;
+			focaltech,fw-upgrade-id1 = <0x11>;
+			focaltech,fw-upgrade-id2 = <0x11>;
+			focaltech,fw-delay-readid-ms = <10>;
+			focaltech,fw-delay-era-flsh-ms = <2000>;
+			focaltech,fw-auto-cal;
+			focaltech,ignore-id-check;
+		};
+	};
+
+	i2c@78ba000 { /* BLSP1 QUP6 */
+			melfas_mip4@48 {
+			compatible = "melfas,mip4_ts";
+			reg = <0x48>;
+			interrupt-parent = <&msm_gpio>;
+			interrupts = <13 0x2>;
+			mip4_ts,fw_name = "melfas/test_melfas_mip4.bin";
+			pinctrl-names = "default";
+			pinctrl-0 = <&melfas_int_default>;
+			mip4_ts,irq-gpio = <&msm_gpio 13 0x00>;
+			mip4_ts,reset-gpio = <&msm_gpio 12 0x00>;
+			mip4_ts,vdd-supply = <&msm_gpio 24 0x00>;
+			mip4_ts,i2c-pull-up = <1>;
+			mip4_ts,max_x = <720>;
+			mip4_ts,max_y = <1080>;
+		};
+	};
+
+	gen-vkeys {
+		compatible = "qcom,gen-vkeys";
+		label = "ft5x06_ts";
+		qcom,disp-maxx = <1080>;
+		qcom,disp-maxy = <1920>;
+		qcom,panel-maxx = <1080>;
+		qcom,panel-maxy = <2098>;
+		qcom,key-codes = <139 172 158>;
+		qcom,y-offset = <0>;
+	};
+
+	sound {
+		compatible = "qcom,msm8x16-audio-codec";
+		qcom,model = "msm8939-snd-card-skuk";
+		qcom,msm-snd-card-id = <0>;
+		qcom,msm-codec-type = "internal";
+		qcom,msm-ext-pa = "primary";
+		qcom,msm-mbhc-hphl-swh = <1>;
+		qcom,msm-mbhc-gnd-swh = <0>;
+		qcom,msm-micbias1-ext-cap;
+		qcom,msm-hs-micbias-type = "internal";
+		qcom,msm-spk-ext-pa = <&msm_gpio 11 0>;
+		qcom,audio-routing =
+			"RX_BIAS", "MCLK",
+			"SPK_RX_BIAS", "MCLK",
+			"INT_LDO_H", "MCLK",
+			"MIC BIAS External", "Handset Mic",
+			"MIC BIAS Internal2", "Headset Mic",
+			"MIC BIAS External", "Secondary Mic",
+			"AMIC1", "MIC BIAS External",
+			"AMIC2", "MIC BIAS Internal2",
+			"AMIC3", "MIC BIAS External";
+		pinctrl-names = "cdc_lines_act",
+				"cdc_lines_sus";
+		pinctrl-0 = <&cdc_pdm_lines_act &cdc_pdm_lines_act38>;
+		pinctrl-1 = <&cdc_pdm_lines_sus &cdc_pdm_lines_sus38>;
+
+		asoc-platform = <&pcm0>, <&pcm1>, <&voip>, <&voice>,
+				<&loopback>, <&compress>, <&hostless>,
+				<&afe>, <&lsm>, <&routing>, <&lpa>;
+		asoc-platform-names = "msm-pcm-dsp.0", "msm-pcm-dsp.1",
+				"msm-voip-dsp", "msm-pcm-voice", "msm-pcm-loopback",
+				"msm-compress-dsp", "msm-pcm-hostless", "msm-pcm-afe",
+				"msm-lsm-client", "msm-pcm-routing", "msm-pcm-lpa";
+		asoc-cpu = <&dai_pri_auxpcm>, <&dai_hdmi>, <&dai_mi2s0>, <&dai_mi2s1>,
+				<&dai_mi2s2>, <&dai_mi2s3>, <&sb_0_rx>, <&sb_0_tx>,
+				<&sb_1_rx>, <&sb_1_tx>, <&sb_3_rx>, <&sb_3_tx>,
+				<&sb_4_rx>, <&sb_4_tx>, <&sb_5_tx>, <&bt_sco_rx>,
+				<&bt_sco_tx>, <&bt_a2dp_rx>,
+				<&int_fm_rx>, <&int_fm_tx>, <&afe_pcm_rx>,
+				<&afe_pcm_tx>, <&afe_proxy_rx>, <&afe_proxy_tx>,
+				<&incall_record_rx>, <&incall_record_tx>, <&incall_music_rx>,
+				<&incall_music_2_rx>;
+		asoc-cpu-names = "msm-dai-q6-auxpcm.1", "msm-dai-q6-hdmi.8", "msm-dai-q6-mi2s.0",
+				"msm-dai-q6-mi2s.1", "msm-dai-q6-mi2s.2",
+				"msm-dai-q6-mi2s.3", "msm-dai-q6-dev.16384",
+				"msm-dai-q6-dev.16385", "msm-dai-q6-dev.16386",
+				"msm-dai-q6-dev.16387", "msm-dai-q6-dev.16390",
+				"msm-dai-q6-dev.16391", "msm-dai-q6-dev.16392",
+				"msm-dai-q6-dev.16393", "msm-dai-q6-dev.16395",
+				"msm-dai-q6-dev.12288", "msm-dai-q6-dev.12289",
+				"msm-dai-q6-dev.12290", "msm-dai-q6-dev.12292",
+				"msm-dai-q6-dev.12293",	"msm-dai-q6-dev.224",
+				"msm-dai-q6-dev.225", "msm-dai-q6-dev.241",
+				"msm-dai-q6-dev.240", "msm-dai-q6-dev.32771",
+				"msm-dai-q6-dev.32772", "msm-dai-q6-dev.32773",
+				"msm-dai-q6-dev.32770";
+		asoc-codec = <&stub_codec>, <&pm8916_tombak_dig>;
+		asoc-codec-names = "msm-stub-codec.1", "tombak_codec";
+	};
+};
+
+
+&tlmm_pinmux {
+	bma2x2_int1_pin {
+		qcom,pins = <&gp 112>;
+		qcom,num-grp-pins = <1>;
+		label = "bma2x2_int1_pin";
+		bma2x2_int1_default: int1_default {
+			  drive-strength = <6>;
+			  bias-pull-up;
+		};
+		bma2x2_int1_sleep: int1_sleep {
+			  drive-strength = <2>;
+			  bias-pull-down;
+		};
+	};
+
+	bma2x2_int2_pin {
+		qcom,pins = <&gp 114>;
+		qcom,num-grp-pins = <1>;
+		label = "bma2x2_int2_pin";
+		bma2x2_int2_default: int2_default {
+			  drive-strength = <6>;
+			  bias-pull-up;
+		};
+		bma2x2_int2_sleep: int2_sleep {
+			  drive-strength = <2>;
+			  bias-pull-down;
+		};
+	};
+};
+
+&i2c_0 { /* BLSP1 QUP2 */
+	avago@39 { /* Ambient light and proximity sensor */
+		compatible = "avago,apds9930";
+		reg = <0x39>;
+		pinctrl-names = "default","sleep";
+		pinctrl-0 = <&apds99xx_default>;
+		pinctrl-1 = <&apds99xx_sleep>;
+		interrupt-parent = <&msm_gpio>;
+		interrupts = <113 0x2002>;
+		vdd-supply = <&pm8916_l17>;
+		vio-supply = <&pm8916_l6>;
+		avago,irq-gpio = <&msm_gpio 113 0x2002>;
+		avago,ps-threshold = <600>;
+		avago,ps-hysteresis-threshold = <500>;
+		avago,ps-pulse = <8>;
+		avago,ps-pgain = <0>;
+		avago,als-B = <186>;
+		avago,als-C = <75>;
+		avago,als-D = <129>;
+		avago,ga-value = <560>;
+	};
+
+	bosch@18 { /* Accelerometer sensor */
+		compatible = "bosch,bma2x2";
+		reg = <0x18>;
+		pinctrl-names = "bma_default","bma_sleep";
+		pinctrl-0 = <&bma2x2_int1_default &bma2x2_int2_default>;
+		pinctrl-1 = <&bma2x2_int1_sleep &bma2x2_int2_sleep>;
+		interrupt-parent = <&msm_gpio>;
+		interrupts = <112 0x2002>;
+		vdd-supply = <&pm8916_l17>;
+		vio-supply = <&pm8916_l6>;
+		bosch,init-interval = <200>;
+		bosch,place = <2>;
+		bosch,gpio-int1 = <&msm_gpio 112 0x2002>;
+		bosch,gpio-int2 = <&msm_gpio 114 0x2002>;
+	};
+
+	memsic@30 { /* Magnetic field sensor */
+		compatible = "memsic,mmc3416x";
+		reg = <0x30>;
+		vdd-supply = <&pm8916_l17>;
+		vio-supply = <&pm8916_l6>;
+		memsic,dir = "obverse-x-axis-forward";
+		memsic,auto-report;
+	};
+
+	mpu6050@68 { /* Gyroscope and accelerometer sensor combo */
+		compatible = "invn,mpu6050";
+		reg = <0x68>;
+		pinctrl-names = "mpu_default","mpu_sleep";
+		pinctrl-0 = <&mpu6050_default>;
+		pinctrl-1 = <&mpu6050_sleep>;
+		interrupt-parent = <&msm_gpio>;
+		interrupts = <115 0x2002>;
+		vdd-supply = <&pm8916_l17>;
+		vlogic-supply = <&pm8916_l16>;
+		vi2c-supply = <&pm8916_l6>;
+		invn,gpio-int = <&msm_gpio 115 0x2002>;
+		invn,place = "Portrait Down Back Side";
+	};
+};
+
+/*wubo mask it
+&sdc2_cd_on {
+	/delete-property/ bias-pull-up;
+	bias-pull-down;
+};
+
+&sdc2_cd_off {
+	/delete-property/ bias-disable;
+	bias-pull-down;
+};*/
+/*wubo mask it
+&sdhc_2 {
+	qcom,nonhotplug;
+	interrupts = <0 1>;
+	interrupt-map = <0 &intc 0 125 0
+		1 &intc 0 221 0>;
+	interrupt-names = "hc_irq", "pwr_irq";
+	/delete-property/ cd-gpios;
+};*/
+
+&mdss_mdp {
+	qcom,mdss-pref-prim-intf = "dsi";
+};
+
+//Jelly Remove  <&gp 1>, <&gp 36>, <&gp 76>;
+&pmx_mdss {
+	qcom,num-grp-pins = <1>;
+	qcom,pins = <&gp 25>;
+};
+
+&mdss_dsi0 {
+	qcom,dsi-pref-prim-pan = <&dsi_ams497_720p_video>;
+	pinctrl-names = "mdss_default", "mdss_sleep";
+	pinctrl-0 = <&mdss_dsi_active>;
+	pinctrl-1 = <&mdss_dsi_suspend>;
+
+	qcom,platform-reset-gpio = <&msm_gpio 25 0>;
+	//qcom,platform-enable-gpio = <&msm_gpio 36 0>;
+	//qcom,platform-bklight-en-gpio = <&msm_gpio 76 0>;
+};
+
+&dsi_ams497_720p_video {
+	qcom,cont-splash-enabled;
+};
diff --git a/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-qrd.dtsi b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-qrd.dtsi
new file mode 100755
index 00000000000..82a12d987d2
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-qrd.dtsi
@@ -0,0 +1,208 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "test01a-msm8939-pinctrl.dtsi"
+
+&blsp1_uart1 {
+	status = "disabled";
+};
+
+&blsp1_uart2 {
+	status = "ok";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart_console_sleep>;
+};
+
+&soc {
+	i2c@78ba000 { /* BLSP1 QUP6 */
+		nfc-nci@e {
+			compatible = "qcom,nfc-nci";
+			reg = <0x0e>;
+			qcom,irq-gpio = <&msm_gpio 21 0x00>;
+			qcom,dis-gpio = <&msm_gpio 20 0x00>;
+			qcom,clk-src = "BBCLK2";
+			qcom,clk-en-gpio = <&msm_gpio 0 0x00>;
+			interrupt-parent = <&msm_gpio>;
+			interrupts = <21 0>;
+			interrupt-names = "nfc_irq";
+			pinctrl-names = "nfc_active","nfc_suspend";
+			pinctrl-0 = <&nfc_int_active &nfc_disable_active>;
+			pinctrl-1 = <&nfc_int_suspend &nfc_disable_suspend>;
+			qcom,clk-gpio = <&pm8916_gpios 2 0>;
+			clocks = <&clock_rpm clk_bb_clk2_pin>;
+			clock-names = "ref_clk";
+		};
+	};
+};
+
+&spmi_bus {
+	qcom,pm8916@1 {
+		qcom,vibrator@c000 {
+			status = "okay";
+			qcom,vib-timeout-ms = <15000>;
+			qcom,vib-vtg-level-mV = <3100>;
+		};
+	};
+
+	qcom,pm8916@0 {
+		qcom,leds@a100 {
+			status = "okay";
+			qcom,led_mpp_2 {
+				label = "mpp";
+				linux,name = "button-backlight";
+				linux,default-trigger = "none";
+				qcom,default-state = "off";
+				qcom,max-current = <40>;
+				qcom,current-setting = <5>;
+				qcom,id = <6>;
+				qcom,mode = "manual";
+				qcom,source-sel = <1>;
+				qcom,mode-ctrl = <0x60>;
+			};
+		};
+	};
+};
+
+/* CoreSight */
+&tpiu {
+	pinctrl-names = "sdcard", "trace", "swduart",
+			"swdtrc", "jtag", "spmi";
+	/* NIDnT */
+	pinctrl-0 = <&qdsd_clk_sdcard &qdsd_cmd_sdcard
+		     &qdsd_data0_sdcard &qdsd_data1_sdcard
+		     &qdsd_data2_sdcard &qdsd_data3_sdcard>;
+	pinctrl-1 = <&qdsd_clk_trace &qdsd_cmd_trace
+		     &qdsd_data0_trace &qdsd_data1_trace
+		     &qdsd_data2_trace &qdsd_data3_trace>;
+	pinctrl-2 = <&qdsd_cmd_swduart &qdsd_data0_swduart
+		     &qdsd_data1_swduart &qdsd_data2_swduart
+		     &qdsd_data3_swduart>;
+	pinctrl-3 = <&qdsd_clk_swdtrc &qdsd_cmd_swdtrc
+		     &qdsd_data0_swdtrc &qdsd_data1_swdtrc
+		     &qdsd_data2_swdtrc &qdsd_data3_swdtrc>;
+	pinctrl-4 = <&qdsd_cmd_jtag &qdsd_data0_jtag
+		     &qdsd_data1_jtag &qdsd_data2_jtag
+		     &qdsd_data3_jtag>;
+	pinctrl-5 = <&qdsd_clk_spmi &qdsd_cmd_spmi
+		     &qdsd_data0_spmi &qdsd_data3_spmi>;
+};
+
+&soc {
+	gpio_keys {
+		compatible = "gpio-keys";
+		input-name = "gpio-keys";
+		pinctrl-names = "tlmm_gpio_key_active","tlmm_gpio_key_suspend";
+		pinctrl-0 = <&gpio_key_active>;
+		pinctrl-1 = <&gpio_key_suspend>;
+
+		vol_up {
+			label = "volume_up";
+			gpios = <&msm_gpio 107 0x1>;
+			linux,input-type = <1>;
+			linux,code = <115>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+
+		switch_lid {
+			label = "switch_lid";
+			gpios = <&msm_gpio 9 0x1>;
+			linux,input-type = <5>; /* EV_SW */
+			linux,code = <0>; /* SW_LID */
+			debounce-interval = <1>;
+			gpio-key,wakeup;
+		};
+	};
+};
+
+&sdhc_1 {
+	vdd-supply = <&pm8916_l8>;
+	qcom,vdd-voltage-level = <2900000 2900000>;
+	qcom,vdd-current-level = <200 400000>;
+
+	vdd-io-supply = <&pm8916_l5>;
+	qcom,vdd-io-always-on;
+	qcom,vdd-io-lpm-sup;
+	qcom,vdd-io-voltage-level = <1800000 1800000>;
+	qcom,vdd-io-current-level = <200 60000>;
+
+	pinctrl-names = "active", "sleep";
+	pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+	pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+
+	qcom,nonremovable;
+
+	status = "ok";
+};
+
+&sdhc_2 {
+	vdd-supply = <&pm8916_l11>;
+	qcom,vdd-voltage-level = <2800000 2950000>;
+	qcom,vdd-current-level = <15000 400000>;
+
+	vdd-io-supply = <&pm8916_l12>;
+	qcom,vdd-io-voltage-level = <1800000 2950000>;
+	qcom,vdd-io-current-level = <200 50000>;
+
+	pinctrl-names = "active", "sleep";
+	pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on &sdc2_cd_on>;
+	pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off &sdc2_cd_off>;
+
+	#address-cells = <0>;
+	interrupt-parent = <&sdhc_2>;
+	interrupts = <0 1 2>;
+	#interrupt-cells = <1>;
+	interrupt-map-mask = <0xffffffff>;
+	interrupt-map = <0 &intc 0 125 0
+			1 &intc 0 221 0
+			2 &msm_gpio 108 0>;
+	interrupt-names = "hc_irq", "pwr_irq", "status_irq";
+	cd-gpios = <&msm_gpio 108 0x0>;
+
+	status = "ok";
+};
+
+&qcom_tzlog {
+	status = "okay";
+};
+
+&qcom_rng {
+	status = "okay";
+};
+
+&qcom_crypto {
+	status = "okay";
+};
+
+&qcom_cedev {
+	status = "okay";
+};
+
+&qcom_seecom {
+	status = "okay";
+};
+
+&android_usb {
+	qcom,android-usb-cdrom;
+};
+
+&apc_vreg_corner {
+	vdd-apc-supply = <&fan53555>;
+	qcom,cpr-step-quotient = <26>;
+	qcom,cpr-apc-volt-step = <12500>;
+	qcom,cpr-up-threshold = <2>;
+};
+//enable 5G
+&wcnss_wlan {
+	qcom,has-48mhz-xo;
+	qcom,chip_name = "wcn3660B";
+};
diff --git a/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-v3.0.dtsi b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-v3.0.dtsi
new file mode 100755
index 00000000000..c13c2ff15d6
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939-v3.0.dtsi
@@ -0,0 +1,686 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "./../skeleton64.dtsi"
+#include <dt-bindings/clock/msm-clocks-8936.h>
+#include <dt-bindings/clock/msm-cpu-clocks-8939.h>
+#include "./../msm8939-common.dtsi"
+#include "./../msm8939-coresight.dtsi"
+#include "./../msm8939-cpu.dtsi"
+#include "./../msm8939-v3.0-pm.dtsi"
+#include "./../msm8939-smem.dtsi"
+#include "./../msm8939-smp2p.dtsi"
+#include "./../msm8939-v3.0-gpu.dtsi"
+#include "test01a-msm8939-pinctrl.dtsi"
+
+/ {
+	model = "Qualcomm Technologies, Inc. MSM8939v3.0";
+	compatible = "qcom,msm8939";
+	qcom,msm-id = <239 0x30000>, <241 0x30000>, <263 0x30000>;
+
+	chosen {
+		bootargs = "boot_cpus=0,4,5,6,7 sched_enable_hmp=1";
+	};
+};
+
+&soc {
+	timer {
+		compatible = "arm,armv7-timer";
+		interrupts = <1 2 0xff08>,
+			     <1 3 0xff08>,
+			     <1 4 0xff08>,
+			     <1 1 0xff08>;
+		clock-frequency = <19200000>;
+	};
+
+	clock_cpu: qcom,cpu-clock-8939@b111050 {
+		compatible = "qcom,cpu-clock-8939";
+		reg =   <0xb111050 0x8>,
+			<0xb011050 0x8>,
+			<0xb1d1050 0x8>,
+			<0x5800c   0x8>,
+			<0x58000   0x8>,
+			<0x58004   0x8>;
+		reg-names = "apcs-c0-rcg-base", "apcs-c1-rcg-base",
+				"apcs-cci-rcg-base", "efuse", "efuse1",
+				"efuse2";
+		vdd-c0-supply = <&apc_vreg_corner>;
+		vdd-c1-supply = <&apc_vreg_corner>;
+		vdd-cci-supply = <&apc_vreg_corner>;
+		clocks = <&clock_gcc clk_gpll0_ao>,
+			 <&clock_gcc clk_a53ss_c0_pll>,
+			 <&clock_gcc clk_gpll0_ao>,
+			 <&clock_gcc clk_a53ss_c1_pll>,
+			 <&clock_gcc clk_gpll0_ao>,
+			 <&clock_gcc clk_a53ss_cci_pll>;
+		clock-names = "clk-c0-4", "clk-c0-5",
+				"clk-c1-4", "clk-c1-5",
+				"clk-cci-4", "clk-cci-5";
+		qcom,speed0-bin-v0-c0 =
+			<          0 0>,
+			<  400000000 3>,
+			<  500000000 9>,
+			<  800000000 12>,
+			<  998400000 17>,
+			< 1113600000 20>,
+			< 1209600000 21>;
+
+		qcom,speed0-bin-v0-c1 =
+			<          0 0>,
+			<  400000000 3>,
+			<  800000000 9>,
+			<  960000000 12>,
+			< 1113600000 14>,
+			< 1344000000 17>;
+
+		qcom,speed0-bin-v0-cci =
+			<          0 0>,
+			<  200000000 3>,
+			<  300000000 9>,
+			<  400000000 15>,
+			<  600000000 17>;
+
+		qcom,speed2-bin-v0-c0 =
+			<          0 0>,
+			<  400000000 3>,
+			<  500000000 9>,
+			<  800000000 12>,
+			<  998400000 17>,
+			< 1113600000 20>,
+			< 1209600000 22>;
+
+		qcom,speed2-bin-v0-c1 =
+			<          0 0>,
+			<  400000000 3>,
+			<  800000000 9>,
+			<  960000000 12>,
+			< 1113600000 14>,
+			< 1344000000 17>,
+			< 1459200000 20>,
+			< 1497600000 21>;
+
+		qcom,speed2-bin-v0-cci =
+			<          0 0>,
+			<  200000000 3>,
+			<  300000000 9>,
+			<  400000000 15>,
+			<  600000000 17>;
+
+		qcom,speed2-bin-v2-c0 =
+			<          0 0>,
+			<  400000000 3>,
+			<  500000000 9>,
+			<  800000000 12>,
+			<  998400000 17>,
+			< 1113600000 20>,
+			< 1209600000 22>;
+
+		qcom,speed2-bin-v2-c1 =
+			<          0 0>,
+			<  400000000 3>,
+			<  800000000 9>,
+			<  960000000 12>,
+			< 1113600000 14>,
+			< 1344000000 17>,
+			< 1459200000 20>;
+
+		qcom,speed2-bin-v2-cci =
+			<          0 0>,
+			<  200000000 3>,
+			<  300000000 9>,
+			<  400000000 15>,
+			<  600000000 17>;
+
+		qcom,speed4-bin-v0-c0 =
+			<          0 0>,
+			<  400000000 3>,
+			<  500000000 9>,
+			<  800000000 12>,
+			<  998400000 17>,
+			< 1113600000 20>,
+			< 1209600000 26>;
+
+		qcom,speed4-bin-v0-c1 =
+			<          0 0>,
+			<  400000000 3>,
+			<  800000000 9>,
+			<  960000000 12>,
+			< 1113600000 14>,
+			< 1344000000 17>,
+			< 1459200000 20>,
+			< 1497600000 21>,
+			< 1651200000 26>;
+
+		qcom,speed4-bin-v0-cci =
+			<          0 0>,
+			<  200000000 3>,
+			<  300000000 9>,
+			<  400000000 15>,
+			<  600000000 17>;
+
+		qcom,speed5-bin-v0-c0 =
+			<          0 0>,
+			<  400000000 3>,
+			<  500000000 9>,
+			<  800000000 12>,
+			<  998400000 17>,
+			< 1113600000 20>,
+			< 1209600000 23>;
+
+		qcom,speed5-bin-v0-c1 =
+			<          0 0>,
+			<  400000000 3>,
+			<  800000000 9>,
+			<  960000000 12>,
+			< 1113600000 14>,
+			< 1344000000 17>,
+			< 1459200000 18>,
+			< 1497600000 21>,
+			< 1651200000 26>;
+
+		qcom,speed5-bin-v0-cci =
+			<          0 0>,
+			<  200000000 3>,
+			<  300000000 9>,
+			<  400000000 15>,
+			<  600000000 17>;
+
+		qcom,speed5-bin-v6-c0 =
+			<          0 0>,
+			<  400000000 3>,
+			<  500000000 9>,
+			<  800000000 12>,
+			<  998400000 17>,
+			< 1113600000 20>,
+			< 1209600000 23>;
+
+		qcom,speed5-bin-v6-c1 =
+			<          0 0>,
+			<  400000000 3>,
+			<  800000000 9>,
+			<  960000000 12>,
+			< 1113600000 14>,
+			< 1344000000 17>,
+			< 1459200000 18>,
+			< 1497600000 21>,
+			< 1651200000 26>;
+
+		qcom,speed5-bin-v6-cci =
+			<          0 0>,
+			<  200000000 3>,
+			<  300000000 9>,
+			<  400000000 15>,
+			<  600000000 17>;
+
+		#clock-cells = <1>;
+	};
+
+	cci_cache: qcom,cci {
+		compatible = "devfreq-simple-dev";
+		clock-names = "devfreq_clk";
+		clocks = <&clock_cpu clk_a53ssmux_cci>;
+		governor = "cpufreq";
+		freq-tbl-khz =
+			<  200000 >,
+			<  297600 >,
+			<  400000 >,
+			<  595200 >;
+	};
+
+	cpubw: qcom,cpubw {
+		compatible = "qcom,devbw";
+		governor = "cpufreq";
+		qcom,src-dst-ports = <1 512>;
+		qcom,active-only;
+		qcom,bw-tbl =
+			<  1525 /*  100   MHz */ >,
+			<  2636 /*  172.8 MHz */ >,
+			<  3955 /*  259.2 MHz */ >,
+			<  5346 /*  350.4 MHz */ >,
+			<  5712 /*  374.4 MHz */ >,
+			<  6079 /*  398.4 MHz */ >;
+	};
+
+	mincpubw: qcom,mincpubw {
+		compatible = "qcom,devbw";
+		governor = "powersave";
+		qcom,src-dst-ports = <1 512>;
+		qcom,active-only;
+		qcom,bw-tbl =
+			<  1525 /*  100   MHz */ >,
+			<  2636 /*  172.8 MHz */ >,
+			<  3955 /*  259.2 MHz */ >,
+			<  5346 /*  350.4 MHz */ >,
+			<  5712 /*  374.4 MHz */ >,
+			<  6079 /*  398.4 MHz */ >;
+	};
+
+	devfreq-cpufreq {
+		cpubw-cpufreq {
+		target-dev = <&cpubw>;
+		cpu-to-dev-map-0 =
+			<  200000  1525 >,
+			<  800000  2636 >,
+			< 1113600  5346 >,
+			< 1651200  6079 >;
+		cpu-to-dev-map-4 =
+			<  200000  1525 >,
+			<  499200  2636 >,
+			<  800000  5346 >,
+			< 1209600  6079 >;
+		};
+
+		mincpubw-cpufreq {
+		target-dev = <&mincpubw>;
+		cpu-to-dev-map-0 =
+			< 1113600 2636 >,
+			< 1651200 5346 >;
+		cpu-to-dev-map-4 =
+			<  998400 2636 >,
+			< 1209600 5346 >;
+		};
+
+		cci-cpufreq {
+		target-dev = <&cci_cache>;
+		cpu-to-dev-map-0 =
+			<  200000  200000 >,
+			<  400000  200000 >,
+			< 1113600  297000 >,
+			< 1651200  595200 >;
+		cpu-to-dev-map-4 =
+			<  200000 200000 >,
+			<  400000 200000 >,
+			<  800000 297600 >,
+			< 1209600 595200 >;
+		};
+	};
+
+	qcom,msm-cpufreq {
+		compatible = "qcom,msm-cpufreq";
+		clock-names = "l2_clk", "cpu0_clk", "cpu1_clk", "cpu2_clk",
+				"cpu3_clk", "cpu4_clk", "cpu5_clk",
+				"cpu6_clk", "cpu7_clk";
+		clocks = <&clock_cpu clk_a53ssmux_cci>,
+			 <&clock_cpu clk_a53ssmux_bc>,
+			 <&clock_cpu clk_a53ssmux_bc>,
+			 <&clock_cpu clk_a53ssmux_bc>,
+			 <&clock_cpu clk_a53ssmux_bc>,
+			 <&clock_cpu clk_a53ssmux_lc>,
+			 <&clock_cpu clk_a53ssmux_lc>,
+			 <&clock_cpu clk_a53ssmux_lc>,
+			 <&clock_cpu clk_a53ssmux_lc>;
+
+		qcom,governor-per-policy;
+
+		qcom,cpufreq-table-0 =
+			 <  200000 >,
+			 <  345600 >,
+			 <  400000 >,
+			 <  533330 >,
+			 <  800000 >,
+                         <  960000 >,
+			 < 1113600 >,
+			 < 1344000 >,
+			 < 1459200 >,
+			 < 1497600 >,
+			 < 1651200 >;
+
+		qcom,cpufreq-table-4 =
+			 <  200000 >,
+			 <  249600 >,
+			 <  400000 >,
+			 <  499200 >,
+			 <  800000 >,
+			 <  998400 >,
+			 < 1113600 >,
+			 < 1209600 >;
+	};
+
+	cpu-pmu {
+		compatible = "arm,armv8-pmuv3";
+		qcom,irq-is-percpu;
+		interrupts = <1 7 0xff00>;
+	};
+
+	jtag_fuse: jtagfuse@5e01c {
+		compatible = "qcom,jtag-fuse-v2";
+		reg = <0x5e01c 0x8>;
+		reg-names = "fuse-base";
+	};
+
+	jtag_mm0: jtagmm@8fc000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8fc000 0x1000>,
+		      <0x8f0000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU0>;
+	};
+
+	jtag_mm1: jtagmm@8fd000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8fd000 0x1000>,
+		      <0x8f2000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU1>;
+	};
+
+	jtag_mm2: jtagmm@8fe000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8fe000 0x1000>,
+		      <0x8f4000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU2>;
+	};
+
+	jtag_mm3: jtagmm@8ff000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8ff000 0x1000>,
+		      <0x8f6000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU3>;
+	};
+
+	jtag_mm4: jtagmm@8dc000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8dc000 0x1000>,
+		      <0x8d0000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU4>;
+	};
+
+	jtag_mm5: jtagmm@8dd000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8dd000 0x1000>,
+		      <0x8d2000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU5>;
+	};
+
+	jtag_mm6: jtagmm@8de000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8de000 0x1000>,
+		      <0x8d4000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU6>;
+	};
+
+	jtag_mm7: jtagmm@8df000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8df000 0x1000>,
+		      <0x8d6000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU7>;
+	};
+
+	qcom,msm-thermal {
+		qcom,core-control-mask = <0xFF>;
+		qcom,freq-mitigation-control-mask = <0xFF>;
+	};
+
+	/delete-node/ regulator@b018000;
+	/delete-node/ regulator@1942130;
+
+	mem_acc_vreg_corner: regulator@1942130 {
+		compatible = "qcom,mem-acc-regulator";
+		reg = <0x1942130 0x4>, <0x58000 0x1000>;
+		reg-names = "acc-sel-l1", "efuse_addr";
+		regulator-name = "mem_acc_corner";
+		regulator-min-microvolt = <1>;
+		regulator-max-microvolt = <3>;
+
+		qcom,acc-sel-l1-bit-pos = <0>;
+		qcom,corner-acc-map = <0 0 1>;
+
+		qcom,override-acc-fuse-sel = <0 30 1 1 0>;
+		qcom,override-corner-acc-map = <0 1 1>;
+	};
+
+	apc_vreg_corner: regulator@b018000 {
+		compatible = "qcom,cpr-regulator";
+		reg = <0xb018000 0x1000>, <0xb011064 4>, <0x58000 0x1000>;
+		reg-names = "rbcpr", "rbcpr_clk", "efuse_addr";
+		interrupts = <0 15 0>;
+		regulator-name = "apc_corner";
+		regulator-min-microvolt = <1>;
+		regulator-max-microvolt = <28>;
+
+		qcom,cpr-fuse-corners = <3>;
+		qcom,cpr-voltage-ceiling = <1050000 1150000 1350000>;
+		qcom,cpr-voltage-floor = <1050000 1050000 1100000>;
+		vdd-apc-supply = <&ncp6335d>;
+
+		qcom,vdd-mx-corner-map = <4 5 7>;
+		qcom,vdd-mx-vmin-method = <4>;
+		vdd-mx-supply = <&pm8916_l3_corner_ao>;
+		qcom,vdd-mx-vmax = <7>;
+
+		mem-acc-supply = <&mem_acc_vreg_corner>;
+
+		qcom,cpr-ref-clk = <19200>;
+		qcom,cpr-timer-delay = <5000>;
+		qcom,cpr-timer-cons-up = <0>;
+		qcom,cpr-timer-cons-down = <2>;
+		qcom,cpr-irq-line = <0>;
+		qcom,cpr-step-quotient = <13>;
+		qcom,cpr-up-threshold = <0>;
+		qcom,cpr-down-threshold = <8>;
+		qcom,cpr-idle-clocks = <15>;
+		qcom,cpr-gcnt-time = <1>;
+		qcom,vdd-apc-step-up-limit = <1>;
+		qcom,vdd-apc-step-down-limit = <1>;
+		qcom,cpr-apc-volt-step = <6250>;
+
+		qcom,cpr-fuse-row = <27 0>;
+		qcom,cpr-fuse-target-quot = <42 24 6>;
+		qcom,cpr-fuse-ro-sel = <54 54 54>;
+		qcom,cpr-quot-min-diff = <0>;
+		qcom,cpr-init-voltage-ref = <1050000 1150000 1350000>;
+		qcom,cpr-fuse-init-voltage =
+					<27 36 6 0>,
+					<27 18 6 0>,
+					<27 0 6 0>;
+		qcom,cpr-init-voltage-step = <10000>;
+		qcom,cpr-scaled-init-voltage-as-ceiling;
+		qcom,cpr-corner-map = <1 1 1 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3
+					3 3 3 3 3 3 3 3>;
+		qcom,cpr-corner-frequency-map =
+					<1 200000000>,
+					<2 345600000>,
+					<3 400000000>,
+					<4 422400000>,
+					<5 499200000>,
+					<6 533330000>,
+					<7 652800000>,
+					<8 729600000>,
+					<9 800000000>,
+					<10 806400000>,
+					<11 883200000>,
+					<12 960000000>,
+					<13 1036800000>,
+					<14 1113600000>,
+					<15 1190400000>,
+					<16 1267200000>,
+					<17 1344000000>,
+					<18 1363200000>,
+					<19 1420800000>,
+					<20 1459200000>,
+					<21 1497600000>,
+					<22 1536000000>,
+					<23 1574400000>,
+					<24 1612800000>,
+					<25 1632000000>,
+					<26 1651200000>,
+					<27 1689600000>,
+					<28 1708800000>;
+		qcom,speed-bin-fuse-sel = <1 34 3 0>;
+		qcom,fuse-remap-base-row = <1000>;
+		qcom,fuse-remap-source =
+					<0 29 1 0>, /* speed bit[0]	*/
+					<0 50 2 0>, /* speed bit[2:1]	*/
+					<0 30 1 0>; /* ACC Override Bit	*/
+		qcom,pvs-version-fuse-sel = <1000 0 3 0>;
+		qcom,cpr-fuse-revision = <1000 3 1 0>;
+		qcom,cpr-speed-bin-max-corners =
+					<0 0 3 14 17>,
+					<2 0 3 14 21>,
+					<2 2 3 14 20>,
+					<5 0 3 14 26>,
+					<5 6 3 14 26>;
+		qcom,cpr-quot-adjust-scaling-factor-max = <1400>;
+		qcom,cpr-fuse-version-map =
+		/* <Speed_bits PVS_version   CPR_Rev - - -> */
+			<2      2  0 (-1) (-1) (-1)>,
+			<2      2  1 (-1) (-1) (-1)>,
+			<2      0  0 (-1) (-1) (-1)>,
+			<2      0  1 (-1) (-1) (-1)>,
+			<5    (-1) 0 (-1) (-1) (-1)>,
+			<5    (-1) 1 (-1) (-1) (-1)>,
+			<(-1) (-1) 0 (-1) (-1) (-1)>,
+			<(-1) (-1) 1 (-1) (-1) (-1)>;
+		qcom,cpr-init-voltage-adjustment =
+					<0   20000  0>,
+					<0   45000  0>,
+					<0   20000  0>,
+					<0   45000  0>,
+					<0   20000  0>,
+					<0   45000  0>,
+					<0   20000  0>,
+					<0   45000  0>;
+		qcom,cpr-quotient-adjustment =
+			<0   41   (-124)>, /*NOM + 20mv, TURBO - 60mv	*/
+			<0   93   (-124)>, /*NOM + 45mv, TURBO - 60mv	*/
+			<0   41   (-41)>, /* NOM + 20mv, TURBO - 20mv	*/
+			<0   93   (-41)>, /* NOM + 45mv, TURBO - 20mv	*/
+			<0   41   (-41)>, /* NOM + 20mv, TURBO - 20mv	*/
+			<0   93   (-41)>, /* NOM + 45mv, TURBO - 20mv	*/
+			<0   41   (-41)>, /* NOM + 20mv, TURBO - 20mv	*/
+			<0   93   (-41)>; /* NOM + 45mv, TURBO - 20mv	*/
+		qcom,cpr-fuse-min-quot-diff = <0 0 40>;
+		qcom,cpr-min-quot-diff-adjustment =
+					<0 0 40>,
+					<0 0 40>,
+					<0 0 40>,
+					<0 0 40>,
+					<0 0 40>,
+					<0 0 40>,
+					<0 0 40>,
+					<0 0 40>;
+		qcom,cpr-virtual-corner-quotient-adjustment =
+			<0 0 0 (-104) (-104) (-104) (-104) (-104) (-104) (-104)
+			 (-104) (-41) (-41) (41) 0 0 (-52) 0 0 0 0 (124)
+			 0 0 0 0 0 0>,
+			<0 0 0 (-104) (-104) (-104) (-104) (-104) (-104) (-104)
+			 (-104) (-41) (-41) (41) 0 0 (-52) 0 0 0 0 (124)
+			 0 0 0 0 0 0>,
+			<0 0 0 (-104) (-104) (-104) (-104) (-104) (-104) (-104)
+			 (-104) (-41) (-41) (41) 0 0 (-52) 0 0 0 0 (42)
+			 0 0 0 0 0 0>,
+			<0 0 0 (-104) (-104) (-104) (-104) (-104) (-104) (-104)
+			 (-104) (-41) (-41) (41) 0 0 (-52) 0 0 0 0 (42)
+			 0 0 0 0 0 0>,
+			<0 0 0 (-104) (-104) (-104) (-104) (-104) (-104) (-104)
+			 (-104) (-41) (-41) (41) 0 0 (-52) 0 0 0  (-52)
+			 0 0 0 0 0 0 0>,
+			<0 0 0 (-104) (-104) (-104) (-104) (-104) (-104) (-104)
+			 (-104) (-41) (-41) (41) 0 0 (-52) 0 0 0  (-52)
+			 0 0 0 0 0 0 0>,
+			<0 0 0 (-104) (-104) (-104) (-104) (-104) (-104) (-104)
+			 (-104) (-41) (-41) 0 0 0 0 0 0 0   0 0 0 0 0 0 0 0>,
+			<0 0 0 (-104) (-104) (-104) (-104) (-104) (-104) (-104)
+			 (-104) (-41) (-41) 0 0 0 0 0 0 0   0 0 0 0 0 0 0 0>;
+		qcom,cpr-virtual-corner-init-voltage-adjustment =
+			<0 0 0 0 0 0 0 0 0 0 0 0 0 (20000) 0 0 0 0 0 0 0 (20000)
+			 0 0 0 0 0 0>,
+			<0 0 0 0 0 0 0 0 0 0 0 0 0 (20000) 0 0 0 0 0 0 0 (20000)
+			 0 0 0 0 0 0>,
+			<0 0 0 0 0 0 0 0 0 0 0 0 0 (20000) 0 0 0 0 0 0 0 (20000)
+			 0 0 0 0 0 0>,
+			<0 0 0 0 0 0 0 0 0 0 0 0 0 (20000) 0 0 0 0 0 0 0 (20000)
+			 0 0 0 0 0 0>,
+			<0 0 0 0 0 0 0 0 0 0 0 0 0 (20000) 0 0 0 0 0 0 0 0 0 0 0
+			 0 0 0>,
+			<0 0 0 0 0 0 0 0 0 0 0 0 0 (20000) 0 0 0 0 0 0 0 0 0 0 0
+			 0 0 0>,
+			<0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
+			 0>,
+			<0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
+			 0>;
+		qcom,cpr-voltage-floor-override =
+			<0xffffffff 0xffffffff 1050000 1050000 1050000 1050000
+			1050000 1050000 1050000 1050000 1050000 1050000 1050000
+			1050000 1050000 1100000 1100000 1100000 1100000 1100000
+			1100000 1100000 1100000 1100000 1100000 1100000 1100000
+			1100000 1100000 1100000>;
+		qcom,cpr-enable;
+	};
+};
+
+&tsens {
+	qcom,sensors = <10>;
+	qcom,slope = <2911 2789 2906 2763 2922 2867 2833 2838 2840 2852>;
+	qcom,sensor-id = <0 1 2 3 5 6 7 8 9 10>;
+};
+
+&bam_dmux {
+	qcom,no-cpu-affinity;
+};
+
+/*&mdss_dsi0 {
+	qcom,platform-regulator-settings = [03 08 07 00 20 07 01];
+	/delete-property/ qcom,regulator-ldo-mode;
+};
+
+&mdss_dsi1 {
+	qcom,platform-regulator-settings = [03 08 07 00 20 07 01];
+	/delete-property/ qcom,regulator-ldo-mode;
+};*/
diff --git a/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939.dtsi b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939.dtsi
new file mode 100755
index 00000000000..0fd56dcd31e
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/test01a-msm8939-qrd-skuk/test01a-msm8939.dtsi
@@ -0,0 +1,492 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "./../skeleton64.dtsi"
+#include <dt-bindings/clock/msm-clocks-8936.h>
+#include <dt-bindings/clock/msm-cpu-clocks-8939.h>
+#include "./../msm8939-common.dtsi"
+#include "./../msm8939-coresight.dtsi"
+#include "./../msm8939-cpu.dtsi"
+#include "./../msm8939-pm.dtsi"
+#include "./../msm8939-smem.dtsi"
+#include "./../msm8939-smp2p.dtsi"
+#include "./../msm8939-gpu.dtsi"
+
+/ {
+	model = "Qualcomm Technologies, Inc. MSM8939";
+	compatible = "qcom,msm8939";
+	qcom,msm-id = <239 0>, <241 0>, <263 0>;
+
+	chosen {
+		bootargs = "boot_cpus=0,4,5,6,7 sched_enable_hmp=1";
+	};
+};
+
+&soc {
+	timer {
+		compatible = "arm,armv7-timer";
+		interrupts = <1 2 0xff08>,
+			     <1 3 0xff08>,
+			     <1 4 0xff08>,
+			     <1 1 0xff08>;
+		clock-frequency = <19200000>;
+	};
+
+	clock_cpu: qcom,cpu-clock-8939@b111050 {
+		compatible = "qcom,cpu-clock-8939";
+		reg = <0x0b111050 0x8>,
+			<0xb011050 0x8>,
+			<0xb1d1050 0x8>,
+			<0x5800c 0x8>,
+			<0x58000 0x8>,
+			<0x58004 0x8>;
+		reg-names = "apcs-c0-rcg-base", "apcs-c1-rcg-base",
+				"apcs-cci-rcg-base", "efuse", "efuse1",
+				"efuse2";
+		vdd-c0-supply = <&apc_vreg_corner>;
+		vdd-c1-supply = <&apc_vreg_corner>;
+		vdd-cci-supply = <&apc_vreg_corner>;
+		clocks = <&clock_gcc clk_gpll0_ao>,
+			 <&clock_gcc clk_a53ss_c0_pll>,
+			 <&clock_gcc clk_gpll0_ao>,
+			 <&clock_gcc clk_a53ss_c1_pll>,
+			 <&clock_gcc clk_gpll0_ao>,
+			 <&clock_gcc clk_a53ss_cci_pll>;
+		clock-names = "clk-c0-4", "clk-c0-5",
+				"clk-c1-4", "clk-c1-5",
+				"clk-cci-4", "clk-cci-5";
+		qcom,speed0-bin-v0-c0 =
+			<          0 0>,
+			<  250000000 3>,
+			<  500000000 9>,
+			<  800000000 12>,
+			<  998400000 17>,
+			< 1113600000 24>;
+
+		qcom,speed0-bin-v0-c1 =
+			<          0 0>,
+			<  400000000 3>,
+			<  800000000 9>,
+			<  960000000 12>,
+			< 1113600000 14>,
+			< 1344000000 17>,
+			< 1459200000 20>,
+			< 1497600000 21>;
+
+		qcom,speed0-bin-v0-cci =
+			<          0 0>,
+			<  200000000 3>,
+			<  300000000 11>,
+			<  400000000 14>,
+			<  600000000 17>;
+
+		qcom,speed2-bin-v0-c0 =
+			<          0 0>,
+			<  250000000 3>,
+			<  500000000 9>,
+			<  800000000 12>,
+			<  998400000 17>,
+			< 1113600000 24>;
+
+		qcom,speed2-bin-v0-c1 =
+			<          0 0>,
+			<  400000000 3>,
+			<  800000000 9>,
+			<  960000000 12>,
+			< 1113600000 14>,
+			< 1344000000 17>,
+			< 1459200000 20>,
+			< 1497600000 21>;
+
+		qcom,speed2-bin-v0-cci =
+			<          0 0>,
+			<  200000000 3>,
+			<  300000000 11>,
+			<  400000000 15>,
+			<  600000000 17>;
+
+		qcom,speed2-bin-v2-c0 =
+			<          0 0>,
+			<  250000000 3>,
+			<  500000000 9>,
+			<  800000000 12>,
+			<  998400000 17>,
+			< 1113600000 24>;
+
+		qcom,speed2-bin-v2-c1 =
+			<          0 0>,
+			<  400000000 3>,
+			<  800000000 9>,
+			<  960000000 12>,
+			< 1113600000 14>,
+			< 1344000000 17>,
+			< 1459200000 20>;
+
+		qcom,speed2-bin-v2-cci =
+			<          0 0>,
+			<  200000000 3>,
+			<  300000000 11>,
+			<  400000000 15>,
+			<  600000000 17>;
+
+		qcom,speed4-bin-v0-c0 =
+			<          0 0>,
+			<  250000000 3>,
+			<  500000000 9>,
+			<  800000000 12>,
+			<  998400000 17>,
+			< 1113600000 24>;
+
+		qcom,speed4-bin-v0-c1 =
+			<          0 0>,
+			<  400000000 3>,
+			<  800000000 9>,
+			<  960000000 12>,
+			< 1113600000 14>,
+			< 1344000000 17>,
+			< 1459200000 20>,
+			< 1497600000 21>,
+			< 1651200000 26>;
+
+		qcom,speed4-bin-v0-cci =
+			<          0 0>,
+			<  200000000 3>,
+			<  300000000 11>,
+			<  400000000 15>,
+			<  600000000 17>;
+
+		qcom,speed5-bin-v0-c0 =
+			<          0 0>,
+			<  250000000 3>,
+			<  500000000 9>,
+			<  800000000 12>,
+			<  998400000 17>,
+			< 1113600000 24>;
+
+		qcom,speed5-bin-v0-c1 =
+			<          0 0>,
+			<  400000000 3>,
+			<  800000000 9>,
+			<  960000000 12>,
+			< 1113600000 14>,
+			< 1344000000 17>,
+			< 1459200000 20>,
+			< 1497600000 21>,
+			< 1651200000 26>;
+
+		qcom,speed5-bin-v0-cci =
+			<          0 0>,
+			<  200000000 3>,
+			<  300000000 11>,
+			<  400000000 15>,
+			<  600000000 17>;
+
+		qcom,speed5-bin-v6-c0 =
+			<          0 0>,
+			<  250000000 3>,
+			<  500000000 9>,
+			<  800000000 12>,
+			<  998400000 17>,
+			< 1113600000 24>;
+
+		qcom,speed5-bin-v6-c1 =
+			<          0 0>,
+			<  400000000 3>,
+			<  800000000 9>,
+			<  960000000 12>,
+			< 1113600000 14>,
+			< 1344000000 17>,
+			< 1459200000 20>,
+			< 1497600000 21>,
+			< 1651200000 26>;
+
+		qcom,speed5-bin-v6-cci =
+			<          0 0>,
+			<  200000000 3>,
+			<  300000000 11>,
+			<  400000000 15>,
+			<  600000000 17>;
+		#clock-cells = <1>;
+	};
+
+	cci_cache: qcom,cci {
+		compatible = "devfreq-simple-dev";
+		clock-names = "devfreq_clk";
+		clocks = <&clock_cpu clk_a53ssmux_cci>;
+		governor = "cpufreq";
+		freq-tbl-khz =
+			<  200000 >,
+			<  297600 >,
+			<  400000 >,
+			<  595200 >;
+	};
+
+	cpubw: qcom,cpubw {
+		compatible = "qcom,devbw";
+		governor = "cpufreq";
+		qcom,src-dst-ports = <1 512>;
+		qcom,active-only;
+		qcom,bw-tbl =
+			<  1525 /*  100   MHz */ >,
+			<  2636 /*  172.8 MHz */ >,
+			<  3955 /*  259.2 MHz */ >,
+			<  5346 /*  350.4 MHz */ >,
+			<  5712 /*  374.4 MHz */ >,
+			<  6079 /*  398.4 MHz */ >;
+	};
+
+	mincpubw: qcom,mincpubw {
+		compatible = "qcom,devbw";
+		governor = "powersave";
+		qcom,src-dst-ports = <1 512>;
+		qcom,active-only;
+		qcom,bw-tbl =
+			<  1525 /*  100   MHz */ >,
+			<  2636 /*  172.8 MHz */ >,
+			<  3955 /*  259.2 MHz */ >,
+			<  5346 /*  350.4 MHz */ >,
+			<  5712 /*  374.4 MHz */ >,
+			<  6079 /*  398.4 MHz */ >;
+	};
+
+	devfreq-cpufreq {
+		cpubw-cpufreq {
+		target-dev = <&cpubw>;
+		cpu-to-dev-map-0 =
+			<  200000  1525 >,
+			<  345600  2636 >,
+			<  400000  2636 >,
+			<  800000  2636 >,
+			<  960000  2636 >,
+			<  1113600 5346 >,
+			<  1344000 6079 >,
+			<  1459200 6079 >,
+			<  1497600 6079 >,
+			<  1651200 6079 >;
+		cpu-to-dev-map-4 =
+			<  200000 1525 >,
+			<  249600 2636 >,
+			<  499200 2636 >,
+			<  800000 5346 >,
+			<  998400 6079 >,
+			< 1113600 6079 >;
+		};
+
+		mincpubw-cpufreq {
+		target-dev = <&mincpubw>;
+		cpu-to-dev-map-0 =
+			<  200000  2636 >,
+			<  345600  2636 >,
+			<  400000  2636 >,
+			<  800000  2636 >,
+			<  960000  2636 >,
+			<  1113600 2636 >,
+			<  1344000 5346 >,
+			<  1497600 5346 >,
+			<  1612800 5346 >,
+			<  1651200 5346 >;
+		cpu-to-dev-map-4 =
+			<  200000 2636 >,
+			<  249600 2636 >,
+			<  499200 2636 >,
+			<  800000 2636 >,
+			<  998400 5346 >,
+			< 1113600 5346 >;
+		};
+
+		cci-cpufreq {
+		target-dev = <&cci_cache>;
+		cpu-to-dev-map-0 =
+			<  200000  200000 >,
+			<  345600  200000 >,
+			<  400000  200000 >,
+			<  533330  297600 >,
+			<  800000  297600 >,
+			<  960000  297600 >,
+			< 1113600  297000 >,
+			< 1344000  595200 >,
+			< 1459200  595200 >,
+			< 1497600  595200 >,
+			< 1651200  595200 >;
+		cpu-to-dev-map-4 =
+			<  200000 200000 >,
+			<  249600 200000 >,
+			<  499200 297600 >,
+			<  800000 297600 >,
+			<  998400 595200 >,
+			< 1113600 595200 >;
+		};
+	};
+
+	qcom,msm-cpufreq {
+		compatible = "qcom,msm-cpufreq";
+		clock-names = "l2_clk", "cpu0_clk", "cpu1_clk", "cpu2_clk",
+				"cpu3_clk", "cpu4_clk", "cpu5_clk",
+				"cpu6_clk", "cpu7_clk";
+		clocks = <&clock_cpu clk_a53ssmux_cci>,
+			 <&clock_cpu clk_a53ssmux_bc>,
+			 <&clock_cpu clk_a53ssmux_bc>,
+			 <&clock_cpu clk_a53ssmux_bc>,
+			 <&clock_cpu clk_a53ssmux_bc>,
+			 <&clock_cpu clk_a53ssmux_lc>,
+			 <&clock_cpu clk_a53ssmux_lc>,
+			 <&clock_cpu clk_a53ssmux_lc>,
+			 <&clock_cpu clk_a53ssmux_lc>;
+
+		qcom,governor-per-policy;
+
+		qcom,cpufreq-table-0 =
+			 <  200000 >,
+			 <  345600 >,
+			 <  400000 >,
+			 <  533330 >,
+			 <  800000 >,
+                         <  960000 >,
+			 < 1113600 >,
+			 < 1344000 >,
+			 < 1459200 >,
+			 < 1497600 >,
+			 < 1651200 >;
+		qcom,cpufreq-table-4 =
+			 <  200000 >,
+			 <  249600 >,
+			 <  499200 >,
+			 <  800000 >,
+			 <  998400 >,
+			 < 1113600 >;
+	};
+
+	cpu-pmu {
+		compatible = "arm,armv8-pmuv3";
+		qcom,irq-is-percpu;
+		interrupts = <1 7 0xff00>;
+	};
+
+	qcom,msm-thermal {
+		qcom,core-control-mask = <0xFF>;
+		qcom,freq-mitigation-control-mask = <0xFF>;
+	};
+
+	jtag_fuse: jtagfuse@5e01c {
+		compatible = "qcom,jtag-fuse";
+		reg = <0x5e01c 0x8>;
+		reg-names = "fuse-base";
+	};
+
+	jtag_mm0: jtagmm@8fc000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8fc000 0x1000>,
+		      <0x8f0000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU0>;
+	};
+
+	jtag_mm1: jtagmm@8fd000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8fd000 0x1000>,
+		      <0x8f2000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU1>;
+	};
+
+	jtag_mm2: jtagmm@8fe000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8fe000 0x1000>,
+		      <0x8f4000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU2>;
+	};
+
+	jtag_mm3: jtagmm@8ff000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8ff000 0x1000>,
+		      <0x8f6000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU3>;
+	};
+
+	jtag_mm4: jtagmm@8dc000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8dc000 0x1000>,
+		      <0x8d0000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU4>;
+	};
+
+	jtag_mm5: jtagmm@8dd000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8dd000 0x1000>,
+		      <0x8d2000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU5>;
+	};
+
+	jtag_mm6: jtagmm@8de000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8de000 0x1000>,
+		      <0x8d4000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU6>;
+	};
+
+	jtag_mm7: jtagmm@8df000 {
+		compatible = "qcom,jtagv8-mm";
+		reg = <0x8df000 0x1000>,
+		      <0x8d6000 0x1000>;
+		reg-names = "etm-base", "debug-base";
+
+		clocks = <&clock_rpm clk_qdss_clk>,
+		         <&clock_rpm clk_qdss_a_clk>;
+		clock-names = "core_clk", "core_a_clk";
+
+		qcom,coresight-jtagmm-cpu = <&CPU7>;
+	};
+};
+
+&bam_dmux {
+	qcom,no-cpu-affinity;
+};
diff --git a/arch/arm/boot/dts/qcom/test01a-msm8939-v3.0-qrd-skuk.dts b/arch/arm/boot/dts/qcom/test01a-msm8939-v3.0-qrd-skuk.dts
new file mode 100755
index 00000000000..45d3a747939
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/test01a-msm8939-v3.0-qrd-skuk.dts
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "./test01a-msm8939-qrd-skuk/test01a-msm8939-v3.0.dtsi"
+#include "./test01a-msm8939-qrd-skuk/test01a-msm8939-qrd-skuk.dtsi"
+
+/ {
+	model = "Qualcomm Technologies, Inc. MSM8939v3.0 QRD SKUK";
+	compatible = "qcom,msm8939-qrd-skuk", "qcom,msm8939-qrd", "qcom,msm8939", "qcom,qrd";
+	qcom,board-id = <0x1000b 12>, <0x2000b 12>;
+};
+
+&tlmm_pinmux {
+	tps65132-en-pin {
+		qcom,pins = <&gp 97>, <&gp 98>;
+		qcom,num-grp-pins = <2>;
+		label = "tps65132_en_pins";
+		qcom,pin-func = <0>;
+
+		tps65132_en_default: en-default {
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+};
+
+&i2c_0 { /* BLSP1 QUP2 */
+	tps65132@3e {
+		compatible = "ti,tps65132";
+		reg = <0x3e>;
+		i2c-pwr-supply = <&pm8916_l6>;
+		ti,en-gpio-lpm;
+		pinctrl-names = "default";
+		pinctrl-0 = <&tps65132_en_default>;
+
+		regulators {
+			tps65132_pos: pos-boost {
+				regulator-name = "tps65132-pos";
+				regulator-min-microvolt = <5800000>;
+				regulator-max-microvolt = <5800000>;
+				ti,discharge-enable;
+				ti,enable-time = <800>;
+				ti,current-limit = <200000>;
+				ti,en-gpio = <&msm_gpio 97 0>;
+			};
+
+			tps65132_neg: neg-boost {
+				regulator-name = "tps65132-neg";
+				regulator-min-microvolt = <5800000>;
+				regulator-max-microvolt = <5800000>;
+				ti,discharge-enable;
+				ti,enable-time = <800>;
+				ti,current-limit = <40000>;
+				ti,en-gpio = <&msm_gpio 98 0>;
+			};
+		};
+	};
+};
+
+&i2c_4 {
+	smb1360_otg_supply: smb1360-chg-fg@14 {
+		compatible = "qcom,smb1360-chg-fg";
+		reg = <0x14>;
+		interrupt-parent = <&msm_gpio>;
+		interrupts = <62 2>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&smb_int_default>;
+		qcom,stat-pulsed-irq;
+		qcom,chg-inhibit-disabled;
+		/*battery capacity*/
+		qcom,float-voltage-mv = <4350>;
+		qcom,fg-cc-to-cv-mv = <4340>;
+		qcom,fg-cutoff-voltage-mv = <3400>;
+		qcom,fg-voltage-min-mv = <3200>;
+		qcom,fg-voltage-empty-mv = <3200>;
+		qcom,fg-suspend-voltage-empty-mv = <3400>;
+		qcom,fg-ibatt-standby-ma = <200>;
+		qcom,fg-soc-max = <90>;
+		qcom,fg-soc-min = <15>;
+		qcom,fg-batt-capacity-mah = <2610>;
+		qcom,fg-cc-soc-coeff = <0x8247>;
+		qcom,thermistor-c1-coeff = <0x86C2>;
+		qcom,iterm-ma = <200>;
+		qcom,charging-timeout = <768>;
+		qcom,otg-batt-curr-limit = <1500>;
+		qcom,recharge-thresh-mv = <100>;
+		qcom,thermal-mitigation = <1500 1200 900 0>;
+	//	qcom,fg-auto-recharge-soc = <99>;
+                qcom,fg-delta-soc = <1>;
+	//	qcom,empty-soc-disabled;
+		regulator-name = "smb1360_otg_vreg";
+		qcom,rsense-10mhom;
+
+		/*battery-profile selection properties*/
+		qcom,batt-profile-select;
+		qcom,smb1360-vadc = <&pm8916_vadc>;
+		qcom,batt-id-vref-uv = <1800000>;
+		qcom,batt-id-rpullup-kohm = <100>;
+		qcom,profile-a-rid-kohm = <33>;
+		qcom,profile-b-rid-kohm = <91>;
+		qcom,shdn-after-pwroff;
+		qcom,config-hard-thresholds;
+		qcom,hot-bat-decidegc = <550>;
+		qcom,cold-bat-decidegc = <0>;
+		qcom,hot-bat-mv = <4100>;
+		qcom,fg-reset-at-pon;
+		qcom,fg-reset-thresold-mv = <250>;
+	};
+};
+
+&pm8916_chg {
+	status = "ok";
+	qcom,use-external-charger;
+};
+
+&pm8916_bms {
+	status = "ok";
+	qcom,disable-bms;
+};
+
+&usb_otg {
+       qcom,hsusb-otg-mode = <3>;
+       qcom,usbid-gpio = <&msm_gpio 110 0>;
+       pinctrl-names = "default";
+       pinctrl-0 = <&usbid_default>;
+       vbus_otg-supply = <&smb1360_otg_supply>;
+	   qcom,usbin-vadc = <&pm8916_vadc>;
+};
+&android_usb{
+        adb_diaplay_name = "MOBEE01A";
+};
diff --git a/arch/arm64/configs/msm_defconfig b/arch/arm64/configs/msm_defconfig
index a6b1028d7e5..7532b08cb40 100644
--- a/arch/arm64/configs/msm_defconfig
+++ b/arch/arm64/configs/msm_defconfig
@@ -260,17 +260,18 @@ CONFIG_INPUT_EVBUG=m
 CONFIG_KEYBOARD_GPIO=y
 # CONFIG_INPUT_MOUSE is not set
 CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_CORE_v21=y
-CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV_v21=y
-CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE_v21=y
-CONFIG_TOUCHSCREEN_ATMEL_MXT=y
-CONFIG_TOUCHSCREEN_FT5X06=y
-CONFIG_TOUCHSCREEN_MSTAR21XX=y
-CONFIG_TOUCHSCREEN_GEN_VKEYS=y
-CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4=y
-CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI4_DEV=y
-CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE=y
-CONFIG_TOUCHSCREEN_BU21150=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_CORE_v21=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV_v21=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE_v21=y
+#CONFIG_TOUCHSCREEN_ATMEL_MXT=y
+#CONFIG_TOUCHSCREEN_FT5X06=y
+#CONFIG_TOUCHSCREEN_MSTAR21XX=y
+#CONFIG_TOUCHSCREEN_GEN_VKEYS=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI4_DEV=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE=y
+#CONFIG_TOUCHSCREEN_BU21150=y
+CONFIG_TOUCHSCREEN_MELFAS_MMS449=y
 CONFIG_INPUT_MT_WRAPPER=y
 CONFIG_INPUT_MISC=y
 CONFIG_INPUT_HBTP_INPUT=y
diff --git a/arch/arm64/configs/test01a_msm_defconfig b/arch/arm64/configs/test01a_msm_defconfig
new file mode 100644
index 00000000000..f230b319fa1
--- /dev/null
+++ b/arch/arm64/configs/test01a_msm_defconfig
@@ -0,0 +1,589 @@
+# CONFIG_SYSVIPC is not set
+CONFIG_AUDIT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_RCU_FAST_NO_HZ=y
+CONFIG_IKCONFIG=y
+# CONFIG_IKCONFIG_PROC is not set
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_SCHED_HMP=y
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_DEVMEM is not set
+# CONFIG_DEVKMEM is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_PANIC_TIMEOUT=5
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_EMBEDDED=y
+CONFIG_PROFILING=y
+CONFIG_CC_STACKPROTECTOR_REGULAR=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SIG=y
+CONFIG_MODULE_SIG_FORCE=y
+CONFIG_MODULE_SIG_SHA512=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_ARCH_MSM=y
+CONFIG_ARCH_MSM8916=y
+CONFIG_SMP=y
+CONFIG_SCHED_MC=y
+CONFIG_PREEMPT=y
+CONFIG_ARMV7_COMPAT=y
+CONFIG_SECCOMP=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE=y
+CONFIG_BALANCE_ANON_FILE_RECLAIM=y
+CONFIG_PROCESS_RECLAIM=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_COMPAT=y
+CONFIG_PM_AUTOSLEEP=y
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_WAKELOCKS_LIMIT=0
+CONFIG_PM_RUNTIME=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_CPU_FREQ=y
+CONFIG_SCHED_FREQ_INPUT=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_INET=y
+CONFIG_INET_IPCOMP=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+CONFIG_NETFILTER_XT_TARGET_HARDIDLETIMER=y
+CONFIG_NETFILTER_XT_TARGET_LOG=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_TARGET_TEE=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_NF_NAT_IPV4=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_SECURITY=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_BRIDGE_NF_EBTABLES=y
+CONFIG_BRIDGE_EBT_BROUTE=y
+CONFIG_L2TP=y
+CONFIG_L2TP_DEBUGFS=y
+CONFIG_L2TP_V3=y
+CONFIG_L2TP_IP=y
+CONFIG_L2TP_ETH=y
+CONFIG_BRIDGE=y
+CONFIG_NET_KEY=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_PRIO=y
+CONFIG_NET_CLS_FW=y
+CONFIG_NET_CLS_U32=y
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_FLOW=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_CMP=y
+CONFIG_NET_EMATCH_NBYTE=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_EMATCH_META=y
+CONFIG_NET_EMATCH_TEXT=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_RMNET_DATA=y
+CONFIG_RMNET_DATA_FC=y
+# CONFIG_RMNET_DATA_DEBUG_PKT is not set
+CONFIG_SOCKEV_NLMCAST=y
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+CONFIG_MSM_BT_POWER=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_INTERNAL_REGDB=y
+CONFIG_RFKILL=y
+CONFIG_NFC_QNCI=y
+# CONFIG_NFC_NQ=y
+CONFIG_IPC_ROUTER=y
+CONFIG_IPC_ROUTER_SECURITY=y
+CONFIG_CMA=y
+CONFIG_CMA_SIZE_MBYTES=64
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_APDS9930=y
+CONFIG_QSEECOM=y
+CONFIG_SCSI=y
+CONFIG_SCSI_TGT=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_REQ_CRYPT=y
+CONFIG_DM_VERITY=y
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=y
+CONFIG_MII=y
+CONFIG_TUN=y
+CONFIG_MSM_RMNET_BAM=y
+CONFIG_PHYLIB=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPPOL2TP=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_WCNSS_CORE=y
+CONFIG_WCNSS_CORE_PRONTO=y
+CONFIG_WCNSS_MEM_PRE_ALLOC=y
+CONFIG_WCNSS_REGISTER_DUMP_ON_BITE=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_CORE_v21=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV_v21=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE_v21=y
+#CONFIG_TOUCHSCREEN_ATMEL_MXT=y
+#CONFIG_TOUCHSCREEN_FT5X06=y
+#CONFIG_TOUCHSCREEN_MSTAR21XX=y
+#CONFIG_TOUCHSCREEN_GEN_VKEYS=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI4_DEV=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE=y
+#CONFIG_TOUCHSCREEN_BU21150=y
+CONFIG_TOUCHSCREEN_MELFAS_MMS449=y
+CONFIG_INPUT_MT_WRAPPER=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_HBTP_INPUT=y
+CONFIG_SENSORS_MPU6050=y
+CONFIG_SENSORS_LIS3DH=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=m
+CONFIG_SENSORS_MMC3416X=y
+CONFIG_SENSORS_AKM09911=y
+CONFIG_SENSORS_AKM8963=y
+CONFIG_SENSORS_BMA2X2=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_MSM_HS=y
+CONFIG_SERIAL_MSM_HSL=y
+CONFIG_SERIAL_MSM_HSL_CONSOLE=y
+CONFIG_SERIAL_MSM_SMD=y
+CONFIG_DIAG_CHAR=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_MSM=y
+CONFIG_MSM_SMD_PKT=y
+CONFIG_MSM_ADSPRPC=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MSM_V2=y
+CONFIG_SLIMBUS_MSM_NGD=y
+CONFIG_SOUNDWIRE=y
+CONFIG_SPI=y
+CONFIG_SPI_QUP=y
+CONFIG_SPI_SPIDEV=m
+CONFIG_SPMI=y
+CONFIG_SPMI_MSM_PMIC_ARB=y
+CONFIG_MSM_QPNP_INT=y
+CONFIG_USE_PINCTRL_IRQ=y
+CONFIG_PINCTRL_MSM_TLMM=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_QPNP_PIN=y
+CONFIG_SMB135X_CHARGER=n
+CONFIG_SMB1360_CHARGER_FG=n
+CONFIG_SMB1360_CHARGER_FG_TEST=y
+CONFIG_BATTERY_BCL=n
+CONFIG_QPNP_VM_BMS=n
+CONFIG_QPNP_LINEAR_CHARGER=n
+CONFIG_POWER_RESET_MSM=y
+CONFIG_MSM_DLOAD_MODE=y
+CONFIG_MSM_PM=y
+CONFIG_SENSORS_QPNP_ADC_VOLTAGE=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_TSENS8974=y
+CONFIG_THERMAL_MONITOR=y
+CONFIG_THERMAL_QPNP=y
+CONFIG_THERMAL_QPNP_ADC_TM=y
+CONFIG_REGULATOR=y
+CONFIG_WCD9335_CODEC=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_PROXY_CONSUMER=y
+CONFIG_REGULATOR_FAN53555=y
+CONFIG_REGULATOR_MEM_ACC=y
+CONFIG_REGULATOR_ONSEMI_NCP6335D=y
+CONFIG_REGULATOR_TPS65132=y
+CONFIG_REGULATOR_STUB=y
+CONFIG_REGULATOR_RPM_SMD=y
+CONFIG_REGULATOR_QPNP=y
+CONFIG_REGULATOR_SPM=y
+CONFIG_REGULATOR_CPR=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_RADIO_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_VIDEOBUF2_MSM_MEM=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_MSMB_CAMERA=y
+CONFIG_MSM_CAMERA_SENSOR=y
+CONFIG_MSM_CPP=y
+CONFIG_MSM_CCI=y
+CONFIG_MSM_CSI30_HEADER=y
+CONFIG_MSM_CSIPHY=y
+CONFIG_MSM_CSID=y
+CONFIG_MSM_EEPROM=y
+CONFIG_MSM_ISPIF=y
+CONFIG_HI256=y
+CONFIG_MT9M114=y
+CONFIG_OV5645=y
+CONFIG_MSM_V4L2_VIDEO_OVERLAY_DEVICE=y
+CONFIG_MSMB_JPEG=y
+CONFIG_MSM_VIDC_V4L2=y
+CONFIG_RADIO_IRIS=y
+CONFIG_RADIO_IRIS_TRANSPORT=y
+CONFIG_MSM_KGSL=y
+CONFIG_KGSL_PER_PROCESS_PAGE_TABLE=y
+CONFIG_FB=y
+CONFIG_FB_MSM=y
+CONFIG_FB_MSM_MDSS=y
+CONFIG_FB_MSM_MDSS_WRITEBACK=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_MSM8X16=y
+CONFIG_UHID=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_MON=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_EHSET=y
+CONFIG_USB_EHCI_MSM=y
+CONFIG_USB_EHCI_MSM_UICC=y
+CONFIG_USB_ICE40_HCD=y
+CONFIG_USB_ACM=y
+CONFIG_USB_CCID_BRIDGE=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_CSVT=y
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+CONFIG_USB_PHY=y
+CONFIG_USB_MSM_SSPHY_QMP=y
+CONFIG_MSM_QUSB_PHY=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_USB_GADGET_DEBUG_FS=y
+CONFIG_USB_CI13XXX_MSM=y
+CONFIG_USB_DWC3_MSM=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_MMC=y
+CONFIG_MMC_PERF_PROFILING=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_CLKGATE=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_TEST=m
+CONFIG_MMC_BLOCK_TEST=m
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_MSM=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_QPNP=y
+CONFIG_LEDS_MSM_GPIO_FLASH=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_aw2013rgb=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_QPNP=y
+CONFIG_DMADEVICES=y
+CONFIG_QCOM_SPS_DMA=y
+CONFIG_UIO=y
+CONFIG_UIO_MSM_SHAREDMEM=y
+CONFIG_STAGING=y
+CONFIG_ZSMALLOC=y
+CONFIG_ZRAM=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_ANDROID_INTF_ALARM_DEV=y
+CONFIG_ONESHOT_SYNC=y
+CONFIG_ION=y
+CONFIG_ION_MSM=y
+CONFIG_SPS=y
+CONFIG_USB_BAM=y
+CONFIG_SPS_SUPPORT_NDP_BAM=y
+CONFIG_QPNP_POWER_ON=y
+CONFIG_QPNP_VIBRATOR=y
+CONFIG_QPNP_REVID=y
+CONFIG_QPNP_COINCELL=y
+CONFIG_MSM_AVTIMER=y
+CONFIG_PFT=y
+CONFIG_MSM_BUS_SCALING=y
+CONFIG_BUS_TOPOLOGY_ADHOC=y
+CONFIG_MSM_MDSS_PLL=y
+CONFIG_REMOTE_SPINLOCK_MSM=y
+CONFIG_MSM_IOMMU_V1=y
+CONFIG_PWM=y
+CONFIG_PWM_QPNP=y
+CONFIG_MOBICORE_SUPPORT=m
+CONFIG_MOBICORE_API=m
+# CONFIG_CORESIGHT is not set
+# CONFIG_CORESIGHT_EVENT is not set
+# CONFIG_CORESIGHT_FUSE is not set
+# CONFIG_CORESIGHT_CTI is not set
+# CONFIG_CORESIGHT_TMC is not set
+# CONFIG_CORESIGHT_TPIU is not set
+# CONFIG_CORESIGHT_FUNNEL is not set
+# CONFIG_CORESIGHT_REPLICATOR is not set
+# CONFIG_CORESIGHT_STM is not set
+# CONFIG_CORESIGHT_HWEVENT is not set
+# CONFIG_CORESIGHT_ETMV4 is not set
+# CONFIG_CORESIGHT_MODEM_ETM is not set
+# CONFIG_CORESIGHT_WCN_ETM is not set
+# CONFIG_CORESIGHT_RPM_ETM is not set
+CONFIG_SENSORS=y
+CONFIG_SENSORS_SSC=y
+# CONFIG_CP_ACCESS64 is not set
+CONFIG_MSM_BAM_DMUX=y
+CONFIG_MSM_IPC_ROUTER_SMD_XPRT=y
+CONFIG_MSM_QMI_INTERFACE=y
+CONFIG_MSM_SMD=y
+# CONFIG_MSM_SMD_DEBUG is not set
+CONFIG_MSM_RPM_SMD=y
+CONFIG_MSM_RPM_LOG=y
+CONFIG_MSM_RPM_STATS_LOG=y
+CONFIG_MSM_RUN_QUEUE_STATS=y
+CONFIG_MSM_SMEM=y
+CONFIG_MSM_SMEM_LOGGING=y
+CONFIG_MSM_SMP2P=y
+CONFIG_MSM_SMP2P_TEST=y
+CONFIG_MSM_SPM=y
+CONFIG_MSM_L2_SPM=y
+CONFIG_MSM_ADSP_LOADER=y
+CONFIG_MSM_MEMORY_DUMP_V2=y
+# CONFIG_MSM_DEBUG_LAR_UNLOCK is not set
+CONFIG_MSM_COMMON_LOG=y
+CONFIG_MSM_WATCHDOG_V2=y
+# CONFIG_MSM_FORCE_WDOG_BITE_ON_PANIC is not set
+CONFIG_MSM_SUBSYSTEM_RESTART=y
+CONFIG_MSM_SYSMON_COMM=y
+CONFIG_MSM_PIL=y
+CONFIG_MSM_PIL_SSR_GENERIC=y
+CONFIG_MSM_PIL_MSS_QDSP6V5=y
+CONFIG_MSM_OCMEM=y
+CONFIG_MSM_OCMEM_LOCAL_POWER_CTRL=y
+# CONFIG_MSM_OCMEM_DEBUG is not set
+# CONFIG_MSM_OCMEM_NONSECURE is not set
+CONFIG_MSM_SCM=y
+CONFIG_MSM_CORE_CTL_HELPER=y
+CONFIG_MSM_PERFORMANCE=y
+CONFIG_MEM_SHARE_QMI_SERVICE=y
+# CONFIG_MSM_TZ_LOG is not set
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_FUSE_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_LOCKUP_DETECTOR is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+CONFIG_PANIC_ON_RECURSIVE_FAULT=y
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE=4000
+# CONFIG_DEBUG_TASK_STACK_SCAN_OFF is not set
+# CONFIG_DEBUG_MODULE_SCAN_OFF is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_FAIL_PAGE_ALLOC is not set
+# CONFIG_FAULT_INJECTION_DEBUG_FS is not set
+# CONFIG_FAULT_INJECTION_STACKTRACE_FILTER is not set
+# CONFIG_MSM_RTB is not set
+CONFIG_MSM_RTB_SEPARATE_CPUS=y
+CONFIG_IPC_LOGGING=y
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_PANIC_ON_DATA_CORRUPTION is not set
+CONFIG_SECURITY=y
+CONFIG_SECURITY_NETWORK=y
+CONFIG_LSM_MMAP_MIN_ADDR=4096
+CONFIG_SECURITY_SELINUX=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_XCBC=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_DEV_QCRYPTO=y
+CONFIG_CRYPTO_DEV_QCE=y
+CONFIG_CRYPTO_DEV_QCEDEV=y
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
+CONFIG_QMI_ENCDEC=y
+# CONFIG_STRICT_MEMORY_RWX is not set
+CONFIG_UID_CPUTIME=y
+CONFIG_TEST_ONLY=y
+CONFIG_INPUT_LSM6DS3=y
+CONFIG_SENSORS_ST480_TEST=y
+CONFIG_SENSORS_LTR553_TEST=y
diff --git a/arch/arm64/configs/testplus_msm_defconfig b/arch/arm64/configs/testplus_msm_defconfig
new file mode 100644
index 00000000000..779d18489dc
--- /dev/null
+++ b/arch/arm64/configs/testplus_msm_defconfig
@@ -0,0 +1,589 @@
+CONFIG_SYSVIPC=y
+CONFIG_AUDIT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_RCU_FAST_NO_HZ=y
+CONFIG_IKCONFIG=y
+# CONFIG_IKCONFIG_PROC is not set
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_SCHED_HMP=y
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_DEVMEM is not set
+# CONFIG_DEVKMEM is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_PANIC_TIMEOUT=5
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_EMBEDDED=y
+CONFIG_PROFILING=y
+CONFIG_CC_STACKPROTECTOR_REGULAR=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SIG=y
+CONFIG_MODULE_SIG_FORCE=y
+CONFIG_MODULE_SIG_SHA512=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_ARCH_MSM=y
+CONFIG_ARCH_MSM8916=y
+CONFIG_SMP=y
+CONFIG_SCHED_MC=y
+CONFIG_PREEMPT=y
+CONFIG_ARMV7_COMPAT=y
+CONFIG_SECCOMP=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE=y
+CONFIG_BALANCE_ANON_FILE_RECLAIM=y
+CONFIG_PROCESS_RECLAIM=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_COMPAT=y
+CONFIG_PM_AUTOSLEEP=y
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_WAKELOCKS_LIMIT=0
+CONFIG_PM_RUNTIME=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_CPU_FREQ=y
+CONFIG_SCHED_FREQ_INPUT=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_INET=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+CONFIG_NETFILTER_XT_TARGET_HARDIDLETIMER=y
+CONFIG_NETFILTER_XT_TARGET_LOG=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_TARGET_TEE=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_NF_NAT_IPV4=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_SECURITY=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_BRIDGE_NF_EBTABLES=y
+CONFIG_BRIDGE_EBT_BROUTE=y
+CONFIG_L2TP=y
+CONFIG_L2TP_DEBUGFS=y
+CONFIG_L2TP_V3=y
+CONFIG_L2TP_IP=y
+CONFIG_L2TP_ETH=y
+CONFIG_BRIDGE=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_PRIO=y
+CONFIG_NET_CLS_FW=y
+CONFIG_NET_CLS_U32=y
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_FLOW=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_CMP=y
+CONFIG_NET_EMATCH_NBYTE=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_EMATCH_META=y
+CONFIG_NET_EMATCH_TEXT=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_RMNET_DATA=y
+CONFIG_RMNET_DATA_FC=y
+# CONFIG_RMNET_DATA_DEBUG_PKT is not set
+CONFIG_SOCKEV_NLMCAST=y
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+CONFIG_MSM_BT_POWER=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_INTERNAL_REGDB=y
+CONFIG_RFKILL=y
+CONFIG_NFC_QNCI=y
+# CONFIG_NFC_NQ=y
+CONFIG_IPC_ROUTER=y
+CONFIG_IPC_ROUTER_SECURITY=y
+CONFIG_CMA=y
+CONFIG_CMA_SIZE_MBYTES=64
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_APDS9930=y
+CONFIG_QSEECOM=y
+CONFIG_SCSI=y
+CONFIG_SCSI_TGT=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_REQ_CRYPT=y
+CONFIG_DM_VERITY=y
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=y
+CONFIG_MII=y
+CONFIG_TUN=y
+CONFIG_MSM_RMNET_BAM=y
+CONFIG_PHYLIB=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPPOL2TP=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_WCNSS_CORE=y
+CONFIG_WCNSS_CORE_PRONTO=y
+CONFIG_WCNSS_MEM_PRE_ALLOC=y
+CONFIG_WCNSS_REGISTER_DUMP_ON_BITE=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_CORE_v21=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV_v21=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE_v21=y
+#CONFIG_TOUCHSCREEN_ATMEL_MXT=y
+#CONFIG_TOUCHSCREEN_FT5X06=y
+#CONFIG_TOUCHSCREEN_MSTAR21XX=y
+#CONFIG_TOUCHSCREEN_GEN_VKEYS=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI4_DEV=y
+#CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE=y
+#CONFIG_TOUCHSCREEN_BU21150=y
+CONFIG_TOUCHSCREEN_MELFAS_MMS449=y
+CONFIG_INPUT_MT_WRAPPER=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_HBTP_INPUT=y
+CONFIG_SENSORS_MPU6050=y
+CONFIG_SENSORS_LIS3DH=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=m
+CONFIG_SENSORS_MMC3416X=y
+CONFIG_SENSORS_AKM09911=y
+CONFIG_SENSORS_AKM8963=y
+CONFIG_SENSORS_BMA2X2=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_MSM_HS=y
+CONFIG_SERIAL_MSM_HSL=y
+CONFIG_SERIAL_MSM_HSL_CONSOLE=y
+CONFIG_SERIAL_MSM_SMD=y
+CONFIG_DIAG_CHAR=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_MSM=y
+CONFIG_MSM_SMD_PKT=y
+CONFIG_MSM_ADSPRPC=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MSM_V2=y
+CONFIG_SLIMBUS_MSM_NGD=y
+CONFIG_SOUNDWIRE=y
+CONFIG_SPI=y
+CONFIG_SPI_QUP=y
+CONFIG_SPI_SPIDEV=m
+CONFIG_SPMI=y
+CONFIG_SPMI_MSM_PMIC_ARB=y
+CONFIG_MSM_QPNP_INT=y
+CONFIG_USE_PINCTRL_IRQ=y
+CONFIG_PINCTRL_MSM_TLMM=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_QPNP_PIN=y
+CONFIG_SMB135X_CHARGER=y
+CONFIG_SMB1360_CHARGER_FG=n
+CONFIG_SMB1360_CHARGER_FG_TESTPLUS=y
+CONFIG_BATTERY_BCL=n
+CONFIG_QPNP_VM_BMS=n
+CONFIG_QPNP_LINEAR_CHARGER=y
+CONFIG_POWER_RESET_MSM=y
+CONFIG_MSM_DLOAD_MODE=y
+CONFIG_MSM_PM=y
+CONFIG_SENSORS_QPNP_ADC_VOLTAGE=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_TSENS8974=y
+CONFIG_THERMAL_MONITOR=y
+CONFIG_THERMAL_QPNP=y
+CONFIG_THERMAL_QPNP_ADC_TM=y
+CONFIG_REGULATOR=y
+CONFIG_WCD9335_CODEC=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_PROXY_CONSUMER=y
+CONFIG_REGULATOR_FAN53555=y
+CONFIG_REGULATOR_MEM_ACC=y
+CONFIG_REGULATOR_ONSEMI_NCP6335D=y
+CONFIG_REGULATOR_TPS65132=y
+CONFIG_REGULATOR_STUB=y
+CONFIG_REGULATOR_RPM_SMD=y
+CONFIG_REGULATOR_QPNP=y
+CONFIG_REGULATOR_SPM=y
+CONFIG_REGULATOR_CPR=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_RADIO_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_VIDEOBUF2_MSM_MEM=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_MSMB_CAMERA=y
+CONFIG_MSM_CAMERA_SENSOR=y
+CONFIG_MSM_CPP=y
+CONFIG_MSM_CCI=y
+CONFIG_MSM_CSI30_HEADER=y
+CONFIG_MSM_CSIPHY=y
+CONFIG_MSM_CSID=y
+CONFIG_MSM_EEPROM=y
+CONFIG_MSM_ISPIF=y
+CONFIG_HI256=y
+CONFIG_MT9M114=y
+CONFIG_OV5645=y
+CONFIG_ALTEK_AF=y
+CONFIG_MSM_V4L2_VIDEO_OVERLAY_DEVICE=y
+CONFIG_MSMB_JPEG=y
+CONFIG_MSM_VIDC_V4L2=y
+CONFIG_RADIO_IRIS=y
+CONFIG_RADIO_IRIS_TRANSPORT=y
+CONFIG_MSM_KGSL=y
+CONFIG_KGSL_PER_PROCESS_PAGE_TABLE=y
+CONFIG_FB=y
+CONFIG_FB_MSM=y
+CONFIG_FB_MSM_MDSS=y
+CONFIG_FB_MSM_MDSS_WRITEBACK=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_MSM8X16=y
+CONFIG_UHID=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_MON=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_EHSET=y
+CONFIG_USB_EHCI_MSM=y
+CONFIG_USB_EHCI_MSM_UICC=y
+CONFIG_USB_ICE40_HCD=y
+CONFIG_USB_ACM=y
+CONFIG_USB_CCID_BRIDGE=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_CSVT=y
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+CONFIG_USB_PHY=y
+CONFIG_USB_MSM_SSPHY_QMP=y
+CONFIG_MSM_QUSB_PHY=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_USB_GADGET_DEBUG_FS=y
+CONFIG_USB_CI13XXX_MSM=y
+CONFIG_USB_DWC3_MSM=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_MMC=y
+CONFIG_MMC_PERF_PROFILING=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_CLKGATE=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_TEST=m
+CONFIG_MMC_BLOCK_TEST=m
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_MSM=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_QPNP=y
+CONFIG_LEDS_MSM_GPIO_FLASH=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_aw2013rgb=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_QPNP=y
+CONFIG_DMADEVICES=y
+CONFIG_QCOM_SPS_DMA=y
+CONFIG_UIO=y
+CONFIG_UIO_MSM_SHAREDMEM=y
+CONFIG_STAGING=y
+CONFIG_ZSMALLOC=y
+CONFIG_ZRAM=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_ANDROID_INTF_ALARM_DEV=y
+CONFIG_ONESHOT_SYNC=y
+CONFIG_ION=y
+CONFIG_ION_MSM=y
+CONFIG_SPS=y
+CONFIG_USB_BAM=y
+CONFIG_SPS_SUPPORT_NDP_BAM=y
+CONFIG_QPNP_POWER_ON=y
+CONFIG_QPNP_VIBRATOR=y
+CONFIG_QPNP_REVID=y
+CONFIG_QPNP_COINCELL=y
+CONFIG_MSM_AVTIMER=y
+CONFIG_PFT=y
+CONFIG_MSM_BUS_SCALING=y
+CONFIG_BUS_TOPOLOGY_ADHOC=y
+CONFIG_MSM_MDSS_PLL=y
+CONFIG_REMOTE_SPINLOCK_MSM=y
+CONFIG_MSM_IOMMU_V1=y
+CONFIG_PWM=y
+CONFIG_PWM_QPNP=y
+CONFIG_MOBICORE_SUPPORT=m
+CONFIG_MOBICORE_API=m
+# CONFIG_CORESIGHT is not set
+# CONFIG_CORESIGHT_EVENT is not set
+# CONFIG_CORESIGHT_FUSE is not set
+# CONFIG_CORESIGHT_CTI is not set
+# CONFIG_CORESIGHT_TMC is not set
+# CONFIG_CORESIGHT_TPIU is not set
+# CONFIG_CORESIGHT_FUNNEL is not set
+# CONFIG_CORESIGHT_REPLICATOR is not set
+# CONFIG_CORESIGHT_STM is not set
+# CONFIG_CORESIGHT_HWEVENT is not set
+# CONFIG_CORESIGHT_ETMV4 is not set
+# CONFIG_CORESIGHT_MODEM_ETM is not set
+# CONFIG_CORESIGHT_WCN_ETM is not set
+# CONFIG_CORESIGHT_RPM_ETM is not set
+CONFIG_SENSORS=y
+CONFIG_SENSORS_SSC=y
+# CONFIG_CP_ACCESS64 is not set
+CONFIG_MSM_BAM_DMUX=y
+CONFIG_MSM_IPC_ROUTER_SMD_XPRT=y
+CONFIG_MSM_QMI_INTERFACE=y
+CONFIG_MSM_SMD=y
+# CONFIG_MSM_SMD_DEBUG is not set
+CONFIG_MSM_RPM_SMD=y
+CONFIG_MSM_RPM_LOG=y
+CONFIG_MSM_RPM_STATS_LOG=y
+CONFIG_MSM_RUN_QUEUE_STATS=y
+CONFIG_MSM_SMEM=y
+CONFIG_MSM_SMEM_LOGGING=y
+CONFIG_MSM_SMP2P=y
+CONFIG_MSM_SMP2P_TEST=y
+CONFIG_MSM_SPM=y
+CONFIG_MSM_L2_SPM=y
+CONFIG_MSM_ADSP_LOADER=y
+CONFIG_MSM_MEMORY_DUMP_V2=y
+# CONFIG_MSM_DEBUG_LAR_UNLOCK is not set
+CONFIG_MSM_COMMON_LOG=y
+CONFIG_MSM_WATCHDOG_V2=y
+# CONFIG_MSM_FORCE_WDOG_BITE_ON_PANIC is not set
+CONFIG_MSM_SUBSYSTEM_RESTART=y
+CONFIG_MSM_SYSMON_COMM=y
+CONFIG_MSM_PIL=y
+CONFIG_MSM_PIL_SSR_GENERIC=y
+CONFIG_MSM_PIL_MSS_QDSP6V5=y
+CONFIG_MSM_OCMEM=y
+CONFIG_MSM_OCMEM_LOCAL_POWER_CTRL=y
+# CONFIG_MSM_OCMEM_DEBUG is not set
+# CONFIG_MSM_OCMEM_NONSECURE is not set
+CONFIG_MSM_SCM=y
+CONFIG_MSM_CORE_CTL_HELPER=y
+CONFIG_MSM_PERFORMANCE=y
+CONFIG_MEM_SHARE_QMI_SERVICE=y
+# CONFIG_MSM_TZ_LOG is not set
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_FUSE_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_LOCKUP_DETECTOR is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+CONFIG_PANIC_ON_RECURSIVE_FAULT=y
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE=4000
+# CONFIG_DEBUG_TASK_STACK_SCAN_OFF is not set
+# CONFIG_DEBUG_MODULE_SCAN_OFF is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_FAIL_PAGE_ALLOC is not set
+# CONFIG_FAULT_INJECTION_DEBUG_FS is not set
+# CONFIG_FAULT_INJECTION_STACKTRACE_FILTER is not set
+# CONFIG_MSM_RTB is not set
+CONFIG_MSM_RTB_SEPARATE_CPUS=y
+CONFIG_IPC_LOGGING=y
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_PANIC_ON_DATA_CORRUPTION is not set
+CONFIG_SECURITY=y
+CONFIG_SECURITY_NETWORK=y
+CONFIG_LSM_MMAP_MIN_ADDR=4096
+CONFIG_SECURITY_SELINUX=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_XCBC=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_DEV_QCRYPTO=y
+CONFIG_CRYPTO_DEV_QCE=y
+CONFIG_CRYPTO_DEV_QCEDEV=y
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
+CONFIG_QMI_ENCDEC=y
+# CONFIG_STRICT_MEMORY_RWX is not set
+CONFIG_UID_CPUTIME=y
+CONFIG_TESTPLUS_ONLY=y
+CONFIG_INPUT_LSM6DS3=y
+CONFIG_SENSORS_ST480_TEST_PLUS=y
+CONFIG_SENSORS_LTR553_TEST_PLUS=y
+CONFIG_OV2685=y
diff --git a/drivers/char/diag/diagchar.h b/drivers/char/diag/diagchar.h
index a6839d52ca5..b2d22fde68f 100644
--- a/drivers/char/diag/diagchar.h
+++ b/drivers/char/diag/diagchar.h
@@ -107,6 +107,7 @@
 
 #define MODE_CMD	41
 #define RESET_ID	2
+#define POWER_OFF_ID    6
 
 #define FEATURE_MASK_LEN	2
 
diff --git a/drivers/char/diag/diagfwd.c b/drivers/char/diag/diagfwd.c
index 19e38d4800a..d2d641911f6 100644
--- a/drivers/char/diag/diagfwd.c
+++ b/drivers/char/diag/diagfwd.c
@@ -1096,7 +1096,7 @@ int diag_process_apps_pkt(unsigned char *buf, int len)
 	data_type = APPS_DATA;
 	/* Dont send any command other than mode reset */
 	if (chk_apps_master() && cmd_code == MODE_CMD) {
-		if (subsys_id != RESET_ID)
+		if (!(subsys_id == RESET_ID || subsys_id == POWER_OFF_ID))
 			data_type = MODEM_DATA;
 	}
 
diff --git a/drivers/hwmon/lm80.c b/drivers/hwmon/lm80.c
index eba89aac3ec..980b1948d51 100644
--- a/drivers/hwmon/lm80.c
+++ b/drivers/hwmon/lm80.c
@@ -4,7 +4,6 @@
  * Copyright (C) 1998, 1999  Frodo Looijaard <frodol@dds.nl>
  *			     and Philip Edelbrock <phil@netroedge.com>
  *
- * Ported to Linux 2.6 by Tiago Sousa <mirage@kaotik.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 9f8ce15c1b0..565f8b18713 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -745,7 +745,8 @@ config SENSORS_AP3426
 	  To compile this driver as a module, choose M here: the
 	  module will be called ap3426.
 
-config SENSORS_LTR553
+
+config SENSORS_LTR553_TEST
 	tristate "LTR553 light and proximity device driver"
 	depends on I2C
 	help
@@ -753,27 +754,43 @@ config SENSORS_LTR553
 	  proximity sensor driver.
 
 	  To compile this driver as a module, choose M here: the
-	  module will be called ltr553.
+	  module will be called ltr553 for test.
 
-config SENSORS_MMC3416X
-	tristate "MMC3416xPJ 3-axis magnetic sensor driver"
+config SENSORS_LTR553_TEST_PLUS
+	tristate "LTR553 light and proximity device driver"
 	depends on I2C
 	help
-	  Say Y here if you want to enable the MMC3416xPJ magnetic sensor
-	  driver.
+	  Say Y here if you want to enable the LTR553 light and
+	  proximity sensor driver.
 
 	  To compile this driver as a module, choose M here: the
-	  module will be called mmc3416x.
+	  module will be called ltr553 for test_plus.
 
-config SENSORS_MMC3X30
-	tristate "MMC3X30KJ 3-axis magnetic sensor driver"
+config SENSORS_MMC3416X
+	tristate "MMC3416xPJ 3-axis magnetic sensor driver"
 	depends on I2C
 	help
-	  Say Y here if you want to enable the MMC3X30KJ magnetic sensor
+	  Say Y here if you want to enable the MMC3416xPJ magnetic sensor
 	  driver.
 
 	  To compile this driver as a module, choose M here: the
-	  module will be called mmc3X30.
+	  module will be called mmc3416x.
+
+config SENSORS_ST480_TEST_PLUS
+	tristate "Senodia ST480 magnetic sensor support"
+	depends on I2C=y
+    default n
+    help
+		If you say yes here you get support for Senodia
+		magnetic sensors ST480 for test_plus.
+
+config SENSORS_ST480_TEST
+        tristate "Senodia ST480 magnetic sensor support"
+        depends on I2C=y
+    default n
+    help
+                If you say yes here you get support for Senodia
+                magnetic sensors ST480 for test.
 
 config SENSORS_AKM09911
 	tristate "AKM09911 3-axis electronic compass sensor driver"
@@ -860,38 +877,39 @@ config SENSORS_BMI058
 	 If you say yes here, you get support for Bosch Sensortec's
 	 sensor driver of BMI058.
 
-config SENSORS_BMI160
-	tristate "BMI160 Sensor Support"
-	depends on I2C || SPI_MASTER
-	help
-	 If you say yes here, you get support for Bosch Sensortec's
-         sensor driver of BMI160.
+config INPUT_LSM6DS3
+     tristate "STMicroelectronics LSM6DS3"
+     depends on INPUT
+     depends on I2C
+     help
+         Say Y here to enable STMicroelectronics LSM6DS3.
 
-config SENSORS_BMI160_I2C
-	tristate "support I2C bus communication"
-	depends on SENSORS_BMI160 && I2C
-	help
-	 If you say yes here, you get support Bosch Sensortec's BMI160 sensor hooked to an I2C bus.
+         To compile this driver as a module, choose M here: the
+         module will be called lsm6ds3.
 
-config BMI160_MAG_INTERFACE_SUPPORT
-	tristate "BMI160 Sensor mag interface support"
-	depends on SENSORS_BMI160
-	help
-	 If you say yes here, you get support for Bosch Sensortec's
-	 sensor driver of BMI160 with mag sensor support.
+if INPUT_LSM6DS3
+choice
+	prompt "LSM6DS3 bus selection"
+	default INPUT_LSM6DS3_I2C
 
-config SENSORS_BMI160_ENABLE_INT1
-	tristate "BMI160 sensor interrupt INT1 support"
-	depends on SENSORS_BMI160
-	help
-	 If you say yes here, you get INT1 support for Bosch Sensortec
-	 sensors BMI160.
+config INPUT_LSM6DS3_I2C
+	bool "I2C"
 
-config SENSORS_BMI160_ENABLE_INT2
-	tristate "BMI160 sensor interrupt INT2 support"
-	depends on SENSORS_BMI160
-	help
-	 If you say yes here, you get INT2 support for Bosch Sensortec
-	 sensors BMI160.
+config INPUT_LSM6DS3_SPI
+	bool "SPI"
+endchoice
+
+choice
+	prompt "LSM6DS3 mode selection"
+	default LSM6DS3_POLLING_MODE
+
+config LSM6DS3_POLLING_MODE
+	bool "Polling"
+
+config LSM6DS3_FIFO_MODE
+	bool "FIFO trigger"
+endchoice
+
+endif
 endif
 
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 8ce1a977576..18efb1a2ab6 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -66,7 +66,8 @@ obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
 obj-$(CONFIG_BMP18X)			+= bmp18x-core.o
 obj-$(CONFIG_BMP18X_I2C)		+= bmp18x-i2c.o
 obj-$(CONFIG_SENSORS_MMC3416X)		+= mmc3416x.o
-obj-$(CONFIG_SENSORS_MMC3X30)		+= mmc3x30.o
+obj-$(CONFIG_SENSORS_ST480_TEST_PLUS)     += st480_test_plus.o
+obj-$(CONFIG_SENSORS_ST480_TEST)     += st480_test.o
 obj-$(CONFIG_SENSORS_MMA8X5X)	  	+= mma8x5x.o
 obj-$(CONFIG_SENSORS_STK3X1X)		+= stk3x1x.o
 obj-$(CONFIG_SENSORS_CAPELLA_CM36283)	+= cm36283.o
@@ -76,10 +77,9 @@ obj-$(CONFIG_SENSORS_AKM09911)		+= akm09911.o
 obj-$(CONFIG_SENSORS_LIS3DH)		+= lis3dh_acc.o
 obj-$(CONFIG_SENSORS_AP3426)		+= ap3426.o
 obj-$(CONFIG_SENSORS_BMA2X2)	+= bstclass.o
-
 obj-$(CONFIG_SENSORS_BMA2X2)	+= bma2x2.o
-obj-$(CONFIG_SENSORS_LTR553)	+= ltr553.o
-
+obj-$(CONFIG_SENSORS_LTR553_TEST_PLUS)	+= ltr553_test_plus.o
+obj-$(CONFIG_SENSORS_LTR553_TEST)	+= ltr553_test.o
 ifeq ($(CONFIG_SENSORS_BMA2X2_ENABLE_INT1),y)
 	EXTRA_CFLAGS += -DBMA2X2_ENABLE_INT1
 endif
@@ -88,19 +88,6 @@ ifeq ($(CONFIG_BOSCH_BMA2X2_ENABLE_INT2),y)
 	EXTRA_CFLAGS += -DBMA2X2_ENABLE_INT2
 endif
 
-obj-$(CONFIG_SENSORS_BMI160) += bmi160_driver.o bmi160.o
-ifeq ($(CONFIG_BMI160_MAG_INTERFACE_SUPPORT),y)
-	EXTRA_CFLAGS += -DBMI160_MAG_INTERFACE_SUPPORT
-endif
-ifeq ($(CONFIG_SENSORS_BMI160_ENABLE_INT1),y)
-	EXTRA_CFLAGS += -DBMI160_ENABLE_INT1
-endif
-
-ifeq ($(CONFIG_SENSORS_BMI160_ENABLE_INT2),y)
-	EXTRA_CFLAGS += -DBMI160_ENABLE_INT2
-endif
-
-obj-$(CONFIG_SENSORS_BMI160_I2C) += bmi160_i2c.o
-ifeq ($(CONFIG_SENSORS_BMI160_I2C),y)
-	EXTRA_CFLAGS += -DBMI_USE_BASIC_I2C_FUNC
-endif
+obj-$(CONFIG_INPUT_LSM6DS3) += lsm6ds3.o
+lsm6ds3-y := lsm6ds3_core.o
+obj-$(CONFIG_INPUT_LSM6DS3_I2C) += lsm6ds3_i2c.o
diff --git a/drivers/input/misc/lsm6ds3_core.c b/drivers/input/misc/lsm6ds3_core.c
new file mode 100755
index 00000000000..01b875c8ff6
--- /dev/null
+++ b/drivers/input/misc/lsm6ds3_core.c
@@ -0,0 +1,2534 @@
+/*
+ * STMicroelectronics lsm6ds3 driver
+ *
+ * Copyright 2014 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * v 1.1.0
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/input.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include	<linux/platform_data/lsm6ds3.h>
+#include	"lsm6ds3_core.h"
+
+#if defined (CONFIG_LSM6DS3_POLLING_MODE)
+#include <linux/workqueue.h>
+#include <linux/hrtimer.h>
+#endif
+/* COMMON VALUES FOR ACCEL-GYRO SENSORS */
+#define LSM6DS3_WHO_AM_I			0x0f
+#define LSM6DS3_WHO_AM_I_DEF			0x69
+#define LSM6DS3_AXIS_EN_MASK			0x38
+#define LSM6DS3_INT1_CTRL_ADDR			0x0d
+#define LSM6DS3_INT2_CTRL_ADDR			0x0e
+#define LSM6DS3_INT1_FULL			0x20
+#define LSM6DS3_INT1_FTH			0x08
+#define LSM6DS3_MD1_ADDR			0x5e
+#define LSM6DS3_ODR_LIST_NUM			7
+#define LSM6DS3_ODR_POWER_OFF_VAL		0x00
+#define LSM6DS3_ODR_13HZ_VAL            0x01
+#define LSM6DS3_ODR_26HZ_VAL			0x02
+#define LSM6DS3_ODR_52HZ_VAL			0x03
+#define LSM6DS3_ODR_104HZ_VAL			0x04
+#define LSM6DS3_ODR_208HZ_VAL			0x05
+#define LSM6DS3_ODR_416HZ_VAL			0x06
+#define LSM6DS3_ODR_833HZ_VAL           0x07
+#define LSM6DS3_ODR_1660HZ_VAL          0x08
+#define LSM6DS3_FS_LIST_NUM			4
+#define LSM6DS3_BDU_ADDR			0x12
+#define LSM6DS3_BDU_MASK			0x40
+#define LSM6DS3_EN_BIT				0x01
+#define LSM6DS3_DIS_BIT				0x00
+#define LSM6DS3_FUNC_EN_ADDR			0x19
+#define LSM6DS3_FUNC_EN_MASK			0x04
+#define LSM6DS3_FUNC_CFG_ACCESS_ADDR		0x01
+#define LSM6DS3_FUNC_CFG_ACCESS_MASK		0x01
+#define LSM6DS3_FUNC_CFG_ACCESS_MASK2		0x04
+#define LSM6DS3_FUNC_CFG_REG2_MASK		0x80
+#define LSM6DS3_FUNC_CFG_START1_ADDR		0x62
+#define LSM6DS3_FUNC_CFG_START2_ADDR		0x63
+#define LSM6DS3_SELFTEST_ADDR			0x14
+#define LSM6DS3_SELFTEST_ACCEL_MASK		0x03
+#define LSM6DS3_SELFTEST_GYRO_MASK		0x0c
+#define LSM6DS3_SELF_TEST_DISABLED_VAL		0x00
+#define LSM6DS3_SELF_TEST_POS_SIGN_VAL		0x01
+#define LSM6DS3_SELF_TEST_NEG_ACCEL_SIGN_VAL	0x02
+#define LSM6DS3_SELF_TEST_NEG_GYRO_SIGN_VAL	0x03
+#define LSM6DS3_LIR_ADDR			0x58
+#define LSM6DS3_LIR_MASK			0x01
+#define LSM6DS3_TIMER_EN_ADDR			0x58
+#define LSM6DS3_TIMER_EN_MASK			0x80
+#define LSM6DS3_PEDOMETER_EN_ADDR		0x58
+#define LSM6DS3_PEDOMETER_EN_MASK		0x40
+#define LSM6DS3_INT2_ON_INT1_ADDR		0x13
+#define LSM6DS3_INT2_ON_INT1_MASK		0x20
+#define LSM6DS3_MIN_DURATION_MS			1638
+#define LSM6DS3_ROUNDING_ADDR			0x16
+#define LSM6DS3_ROUNDING_MASK			0x04
+#define LSM6DS3_FIFO_MODE_ADDR			0x0a
+#define LSM6DS3_FIFO_MODE_MASK			0x07
+#define LSM6DS3_FIFO_MODE_BYPASS		0x00
+#define LSM6DS3_FIFO_MODE_CONTINUOS		0x06
+#define LSM6DS3_FIFO_THRESHOLD_IRQ_MASK		0x08
+#define LSM6DS3_FIFO_ODR_ADDR			0x0a
+#define LSM6DS3_FIFO_ODR_MASK			0x78
+#define LSM6DS3_FIFO_ODR_MAX			0x07
+#define LSM6DS3_FIFO_ODR_MAX_HZ			800
+#define LSM6DS3_FIFO_ODR_OFF			0x00
+#define LSM6DS3_FIFO_CTRL3_ADDR			0x08
+#define LSM6DS3_FIFO_ACCEL_DECIMATOR_MASK	0x07
+#define LSM6DS3_FIFO_GYRO_DECIMATOR_MASK	0x38
+#define LSM6DS3_FIFO_CTRL4_ADDR			0x09
+#define LSM6DS3_FIFO_STEP_C_DECIMATOR_MASK	0x38
+#define LSM6DS3_FIFO_THR_L_ADDR			0x06
+#define LSM6DS3_FIFO_THR_H_ADDR			0x07
+#define LSM6DS3_FIFO_THR_H_MASK			0x0f
+#define LSM6DS3_FIFO_THR_IRQ_MASK		0x08
+#define LSM6DS3_FIFO_PEDO_E_ADDR		0x07
+#define LSM6DS3_FIFO_PEDO_E_MASK		0x80
+#define LSM6DS3_FIFO_STEP_C_FREQ		25
+
+/* CUSTOM VALUES FOR ACCEL SENSOR */
+#define LSM6DS3_ACCEL_ODR_ADDR			0x10
+#define LSM6DS3_ACCEL_ODR_MASK			0xf0
+#define LSM6DS3_ACCEL_FS_ADDR			0x10
+#define LSM6DS3_ACCEL_FS_MASK			0x0c
+#define LSM6DS3_ACCEL_FS_2G_VAL			0x00
+#define LSM6DS3_ACCEL_FS_4G_VAL			0x02
+#define LSM6DS3_ACCEL_FS_8G_VAL			0x03
+#define LSM6DS3_ACCEL_FS_16G_VAL		0x01
+#define LSM6DS3_ACCEL_FS_2G_GAIN		610
+#define LSM6DS3_ACCEL_FS_4G_GAIN		1220
+#define LSM6DS3_ACCEL_FS_8G_GAIN		2440
+#define LSM6DS3_ACCEL_FS_16G_GAIN		4880
+#define LSM6DS3_ACCEL_OUT_X_L_ADDR		0x28
+#define LSM6DS3_ACCEL_OUT_Y_L_ADDR		0x2a
+#define LSM6DS3_ACCEL_OUT_Z_L_ADDR		0x2c
+#define LSM6DS3_ACCEL_AXIS_EN_ADDR		0x18
+#define LSM6DS3_ACCEL_DRDY_IRQ_MASK		0x01
+#define LSM6DS3_ACCEL_STD			1
+#define LSM6DS3_ACCEL_STD_FROM_PD		2
+
+/* CUSTOM VALUES FOR GYRO SENSOR */
+#define LSM6DS3_GYRO_ODR_ADDR			0x11
+#define LSM6DS3_GYRO_ODR_MASK			0xf0
+#define LSM6DS3_GYRO_FS_ADDR			0x11
+#define LSM6DS3_GYRO_FS_MASK			0x0c
+#define LSM6DS3_GYRO_FS_245_VAL			0x00
+#define LSM6DS3_GYRO_FS_500_VAL			0x01
+#define LSM6DS3_GYRO_FS_1000_VAL		0x02
+#define LSM6DS3_GYRO_FS_2000_VAL		0x03
+#define LSM6DS3_GYRO_FS_245_GAIN		8750
+#define LSM6DS3_GYRO_FS_500_GAIN		17500
+#define LSM6DS3_GYRO_FS_1000_GAIN		35000
+#define LSM6DS3_GYRO_FS_2000_GAIN		70000
+#define LSM6DS3_GYRO_OUT_X_L_ADDR		0x22
+#define LSM6DS3_GYRO_OUT_Y_L_ADDR		0x24
+#define LSM6DS3_GYRO_OUT_Z_L_ADDR		0x26
+#define LSM6DS3_GYRO_AXIS_EN_ADDR		0x19
+#define LSM6DS3_GYRO_DRDY_IRQ_MASK		0x02
+#define LSM6DS3_GYRO_STD			6
+#define LSM6DS3_GYRO_STD_FROM_PD		2
+
+#define LSM6DS3_OUT_XYZ_SIZE			8
+
+/* CUSTOM VALUES FOR SIGNIFICANT MOTION SENSOR */
+#define LSM6DS3_SIGN_MOTION_EN_ADDR		0x19
+#define LSM6DS3_SIGN_MOTION_EN_MASK		0x01
+#define LSM6DS3_SIGN_MOTION_DRDY_IRQ_MASK	0x40
+
+/* CUSTOM VALUES FOR STEP DETECTOR SENSOR */
+#define LSM6DS3_STEP_DETECTOR_DRDY_IRQ_MASK	0x80
+
+/* CUSTOM VALUES FOR STEP COUNTER SENSOR */
+#define LSM6DS3_STEP_COUNTER_DRDY_IRQ_MASK	0x80
+#define LSM6DS3_STEP_COUNTER_OUT_L_ADDR		0x4b
+#define LSM6DS3_STEP_COUNTER_OUT_SIZE		2
+#define LSM6DS3_STEP_COUNTER_RES_ADDR		0x19
+#define LSM6DS3_STEP_COUNTER_RES_MASK		0x06
+#define LSM6DS3_STEP_COUNTER_RES_ALL_EN		0x03
+#define LSM6DS3_STEP_COUNTER_RES_FUNC_EN	0x02
+#define LSM6DS3_STEP_COUNTER_DURATION_ADDR	0x15
+
+/* CUSTOM VALUES FOR TILT SENSOR */
+#define LSM6DS3_TILT_EN_ADDR			0x58
+#define LSM6DS3_TILT_EN_MASK			0x20
+#define LSM6DS3_TILT_DRDY_IRQ_MASK		0x02
+
+#define LSM6DS3_ENABLE_AXIS			0x07
+#define LSM6DS3_FIFO_DIFF_L			0x3a
+#define LSM6DS3_FIFO_DIFF_MASK			0x0fff
+#define LSM6DS3_FIFO_DATA_OUT_L			0x3e
+#define LSM6DS3_FIFO_ELEMENT_LEN_BYTE		6
+#define LSM6DS3_FIFO_BYTE_FOR_CHANNEL		2
+#define LSM6DS3_FIFO_DATA_OVR_2REGS		0x4000
+#define LSM6DS3_FIFO_DATA_OVR			0x40
+
+#define LSM6DS3_SRC_FUNC_ADDR			0x53
+#define LSM6DS3_FIFO_DATA_AVL_ADDR		0x3b
+
+#define LSM6DS3_SRC_SIGN_MOTION_DATA_AVL	0x40
+#define LSM6DS3_SRC_STEP_DETECTOR_DATA_AVL	0x10
+#define LSM6DS3_SRC_TILT_DATA_AVL		0x20
+#define LSM6DS3_SRC_STEP_COUNTER_DATA_AVL	0x80
+#define LSM6DS3_FIFO_DATA_AVL			0x80
+#define LSM6DS3_RESET_ADDR			0x12
+#define LSM6DS3_RESET_MASK			0x01
+#define LSM6DS3_MAX_FIFO_SIZE			(8 * 1024)
+#define LSM6DS3_MAX_FIFO_LENGHT			(LSM6DS3_MAX_FIFO_SIZE / \
+						LSM6DS3_FIFO_ELEMENT_LEN_BYTE)
+#define ACC_GYRO_MAX_POS			(1495040)/** max positive value acc [ug] */
+#define ACC_GYRO_MAX_NEG			(1495770)/** max negative value acc [ug] */
+#define FUZZ				(0)
+#define FLAT				(0)
+#define CAL_REPT (30)
+#define GRAVITY_HAL_UNIT    (9800000)
+#define ABS(x)		((x) < 0 ? (-x) : (x))
+#define CTS_OPTIMISE_MS   (5)
+
+#ifndef MAX
+#define MAX(a, b)				(((a) > (b)) ? (a) : (b))
+#endif
+
+#ifndef MIN
+#define MIN(a, b)				(((a) < (b)) ? (a) : (b))
+#endif
+
+static struct sensors_classdev lsm6ds3_acc_classdev = {
+    .name = "lsm6ds3_accelerometer",
+	.vendor = "st",
+	.version = 1,
+	.handle = SENSORS_ACCELERATION_HANDLE,
+	.type = SENSOR_TYPE_ACCELEROMETER,
+	.max_range = "19.6",
+	.resolution = "0.00061",
+	.sensor_power = "4",
+	.min_delay = 10000,//us
+	.max_delay = 1000,//ms
+	.fifo_reserved_event_count = 0,
+	.fifo_max_event_count = 0,
+	.enabled = 0,
+	.delay_msec = 200,
+	.sensors_enable = NULL,
+	.sensors_poll_delay = NULL,
+};
+
+static struct sensors_classdev lsm6ds3_gyr_classdev = {
+    .name = "lsm6ds3_gyroscope",
+	.vendor = "st",
+	.version = 1,
+	.handle = SENSORS_GYROSCOPE_HANDLE,
+	.type = SENSOR_TYPE_GYROSCOPE,
+	.max_range = "34.906586",
+	.resolution = "0.0012217305",
+	.sensor_power = "4",
+	.min_delay = 10000,//us
+	.max_delay = 1000,//ms
+	.fifo_reserved_event_count = 0,
+	.fifo_max_event_count = 0,
+	.enabled = 0,
+	.delay_msec = 200,
+	.sensors_enable = NULL,
+	.sensors_poll_delay = NULL,
+};
+/*************************************************************
+static struct sensors_classdev lsm6ds3_step_counter_classdev = {
+    .name = "lsm6ds3_step_counter",
+	.vendor = "st",
+	.version = 1,
+	.handle = SENSOR_STEP_COUNTER_HANDLE,
+	.type = SENSOR_TYPE_STEP_COUNTER,
+	.max_range = "65535",
+	.resolution = "1",
+	.sensor_power = "4",
+	.min_delay = 2000,//us
+	.max_delay = 1000,//ms
+	.fifo_reserved_event_count = 0,
+	.fifo_max_event_count = 0,
+	.enabled = 0,
+	.delay_msec = 200,
+	.sensors_enable = NULL,
+	.sensors_poll_delay = NULL,
+};
+
+static struct sensors_classdev lsm6ds3_step_detector_classdev = {
+    .name = "lsm6ds3_step_detector",
+	.vendor = "st",
+	.version = 1,
+	.handle = SENSOR_STEP_DETECTOR_HANDLE,
+	.type = SENSOR_TYPE_STEP_DETECTOR,
+	.max_range = "1",
+	.resolution = "1",
+	.sensor_power = "4",
+	.min_delay = 2000,//us
+	.max_delay = 1000,//ms
+	.fifo_reserved_event_count = 0,
+	.fifo_max_event_count = 0,
+	.enabled = 0,
+	.delay_msec = 200,
+	.sensors_enable = NULL,
+	.sensors_poll_delay = NULL,
+};
+***********************************************************/
+
+static const struct lsm6ds3_sensor_name {
+	const char *name;
+	const char *description;
+} lsm6ds3_sensor_name[LSM6DS3_SENSORS_NUMB] = {
+	[LSM6DS3_ACCEL] = {
+			.name = "accelerometer",
+			.description = "accelerometer",
+	},
+	[LSM6DS3_GYRO] = {
+			.name = "gyroscope",
+			.description = "gyroscope",
+	},
+	[LSM6DS3_SIGN_MOTION] = {
+			.name = "significant_motion",
+			.description = "significant_motion",
+	},
+	[LSM6DS3_STEP_COUNTER] = {
+			.name = "step_counter",
+			.description = "step_counter",
+	},
+	[LSM6DS3_STEP_DETECTOR] = {
+			.name = "step_detector",
+			.description = "step_detector",
+	},
+	[LSM6DS3_TILT] = {
+			.name = "tilt",
+			.description = "tilt",
+	},
+};
+
+struct lsm6ds3_odr_reg {
+	u32 hz;
+	u8 value;
+};
+
+static const struct lsm6ds3_odr_table {
+	u8 addr[2];
+	u8 mask[2];
+	struct lsm6ds3_odr_reg odr_avl[8];
+} lsm6ds3_odr_table = {
+	.addr[LSM6DS3_ACCEL] = LSM6DS3_ACC_ODR_ADDR,
+	.mask[LSM6DS3_ACCEL] = LSM6DS3_ACC_ODR_MASK,
+	.addr[LSM6DS3_GYRO] = LSM6DS3_GYR_ODR_ADDR,
+	.mask[LSM6DS3_GYRO] = LSM6DS3_GYR_ODR_MASK,
+	.odr_avl[0] = { .hz = 26, .value = LSM6DS3_ODR_26HZ_VAL },
+	.odr_avl[1] = { .hz = 52, .value = LSM6DS3_ODR_52HZ_VAL },
+	.odr_avl[2] = { .hz = 104, .value = LSM6DS3_ODR_104HZ_VAL },
+	.odr_avl[3] = { .hz = 208, .value = LSM6DS3_ODR_208HZ_VAL },
+	.odr_avl[4] = { .hz = 416, .value = LSM6DS3_ODR_416HZ_VAL },
+	.odr_avl[5] = { .hz = 833, .value = LSM6DS3_ODR_833HZ_VAL },
+	.odr_avl[6] = { .hz = 1660, .value = LSM6DS3_ODR_1660HZ_VAL },
+};
+
+struct lsm6ds3_fs_reg {
+	unsigned int gain;
+	u8 value;
+	int urv;
+};
+
+static struct lsm6ds3_fs_table {
+	u8 addr;
+	u8 mask;
+	struct lsm6ds3_fs_reg fs_avl[LSM6DS3_FS_LIST_NUM];
+} lsm6ds3_fs_table[LSM6DS3_SENSORS_NUMB] = {
+	[LSM6DS3_ACCEL] = {
+		.addr = LSM6DS3_ACCEL_FS_ADDR,
+		.mask = LSM6DS3_ACCEL_FS_MASK,
+		.fs_avl[0] = { .gain = LSM6DS3_ACCEL_FS_2G_GAIN,
+					.value = LSM6DS3_ACCEL_FS_2G_VAL,
+					.urv = 2, },
+		.fs_avl[1] = { .gain = LSM6DS3_ACCEL_FS_4G_GAIN,
+					.value = LSM6DS3_ACCEL_FS_4G_VAL,
+					.urv = 4, },
+		.fs_avl[2] = { .gain = LSM6DS3_ACCEL_FS_8G_GAIN,
+					.value = LSM6DS3_ACCEL_FS_8G_VAL,
+					.urv = 8, },
+		.fs_avl[3] = { .gain = LSM6DS3_ACCEL_FS_16G_GAIN,
+					.value = LSM6DS3_ACCEL_FS_16G_VAL,
+					.urv = 16, },
+	},
+	[LSM6DS3_GYRO] = {
+		.addr = LSM6DS3_GYRO_FS_ADDR,
+		.mask = LSM6DS3_GYRO_FS_MASK,
+		.fs_avl[0] = { .gain = LSM6DS3_GYRO_FS_245_GAIN,
+					.value = LSM6DS3_GYRO_FS_245_VAL,
+					.urv = 245, },
+		.fs_avl[1] = { .gain = LSM6DS3_GYRO_FS_500_GAIN,
+					.value = LSM6DS3_GYRO_FS_500_VAL,
+					.urv = 500, },
+		.fs_avl[2] = { .gain = LSM6DS3_GYRO_FS_1000_GAIN,
+					.value = LSM6DS3_GYRO_FS_1000_VAL,
+					.urv = 1000, },
+		.fs_avl[3] = { .gain = LSM6DS3_GYRO_FS_2000_GAIN,
+					.value = LSM6DS3_GYRO_FS_2000_VAL,
+					.urv = 2000, },
+	}
+};
+
+static struct workqueue_struct *lsm6ds3_workqueue = 0;
+
+static inline void lsm6ds3_flush_works(void)
+{
+	flush_workqueue(lsm6ds3_workqueue);
+}
+
+static inline s64 lsm6ds3_get_time_ns(void)
+{
+	struct timespec ts;
+	/*
+	 * calls getnstimeofday.
+	 * If hrtimers then up to ns accurate, if not microsecond.
+	 */
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+#if 0
+static void lsm6ds3_swap(int* x, int* y){
+	int tmp;
+	tmp = *x;
+	*x = *y;
+	*y = tmp;
+}
+#endif
+
+static void lsm6ds3_change_diretion(int *z){
+	*z = -*z;
+}
+
+static int lsm6ds3_write_data_with_mask(struct lsm6ds3_data *cdata,
+				u8 reg_addr, u8 mask, u8 data, bool b_lock)
+{
+	int err;
+	u8 new_data = 0x00, old_data = 0x00;
+
+	err = cdata->tf->read(cdata, reg_addr, 1, &old_data, b_lock);
+	if (err < 0)
+		return err;
+
+	new_data = ((old_data & (~mask)) | ((data << __ffs(mask)) & mask));
+
+	if (new_data == old_data)
+		return 1;
+
+	return cdata->tf->write(cdata, reg_addr, 1, &new_data, b_lock);
+}
+
+static int lsm6ds3_input_init(struct lsm6ds3_sensor_data *sdata, u16 bustype,
+							const char *description)
+{
+	int err = 0;
+
+	sdata->input_dev = input_allocate_device();
+	if (!sdata->input_dev) {
+		dev_err(sdata->cdata->dev, "failed to allocate input device");
+		return -ENOMEM;
+	}
+
+	sdata->input_dev->name = lsm6ds3_sensor_name[sdata->sindex].description;
+
+	sdata->input_dev->id.bustype = bustype;
+	sdata->input_dev->dev.parent = sdata->cdata->dev;
+	sdata->input_dev->name = description;
+	input_set_drvdata(sdata->input_dev, sdata);
+
+	set_bit(EV_ABS, sdata->input_dev->evbit);
+
+	if ((sdata->sindex == LSM6DS3_ACCEL) || (sdata->sindex == LSM6DS3_GYRO)) {
+		input_set_abs_params(sdata->input_dev, ABS_X, -ACC_GYRO_MAX_NEG,
+						ACC_GYRO_MAX_POS, FUZZ, FLAT);
+		input_set_abs_params(sdata->input_dev, ABS_Y, -ACC_GYRO_MAX_NEG,
+						ACC_GYRO_MAX_POS, FUZZ, FLAT);
+		input_set_abs_params(sdata->input_dev, ABS_Z,-ACC_GYRO_MAX_NEG,
+						ACC_GYRO_MAX_POS, FUZZ, FLAT);
+	}
+
+	if ((sdata->sindex == LSM6DS3_STEP_COUNTER) ||
+		(sdata->sindex ==LSM6DS3_STEP_DETECTOR)) {
+		input_set_abs_params(sdata->input_dev, ABS_MISC, -ACC_GYRO_MAX_NEG,
+						ACC_GYRO_MAX_POS, FUZZ, FLAT);
+	}
+
+	err = input_register_device(sdata->input_dev);
+	if (err) {
+		dev_err(sdata->cdata->dev, "unable to register sensor %s\n",
+								sdata->name);
+		input_free_device(sdata->input_dev);
+	}
+
+	return err;
+}
+
+static void lsm6ds3_input_cleanup(struct lsm6ds3_sensor_data *sdata)
+{
+	input_unregister_device(sdata->input_dev);
+	input_free_device(sdata->input_dev);
+}
+
+static void lsm6ds3_report_3axes_event(struct lsm6ds3_sensor_data *sdata, s32 *xyz){
+	ktime_t timestamp;
+	struct input_dev  * input  	= sdata->input_dev;
+
+	if (!sdata->enabled)
+		return;
+	
+	input_report_abs(input, ABS_X, xyz[0]);
+	input_report_abs(input, ABS_Y, xyz[1]);
+	input_report_abs(input, ABS_Z, xyz[2]);
+
+	timestamp = ktime_get_boottime();
+	input_event(input, EV_SYN, SYN_TIME_SEC, ktime_to_timespec(timestamp).tv_sec);
+	input_event(input, EV_SYN, SYN_TIME_NSEC, ktime_to_timespec(timestamp).tv_nsec);
+	input_sync(input);
+}
+
+static void lsm6ds3_report_single_event(struct lsm6ds3_sensor_data *sdata, s32 data){
+	ktime_t timestamp;
+	struct input_dev  * input  	= sdata->input_dev;
+
+	if (!sdata->enabled)
+		return;
+
+	input_report_abs(input, ABS_MISC, data);
+	timestamp = ktime_get_boottime();
+	input_event(input, EV_SYN, SYN_TIME_SEC, ktime_to_timespec(timestamp).tv_sec);
+	input_event(input, EV_SYN, SYN_TIME_NSEC, ktime_to_timespec(timestamp).tv_nsec);
+	input_sync(input);
+}
+
+#if !defined (CONFIG_LSM6DS3_POLLING_MODE)
+static void lsm6ds3_push_data_with_timestamp(struct lsm6ds3_sensor_data *sdata,
+							u16 offset)
+{
+	s32 data[3];
+
+	data[0] = (s32)((s16)(sdata->cdata->fifo_data_buffer[offset] |
+			(sdata->cdata->fifo_data_buffer[offset + 1] << 8)));
+	data[1] = (s32)((s16)(sdata->cdata->fifo_data_buffer[offset + 2] |
+			(sdata->cdata->fifo_data_buffer[offset + 3] << 8)));
+	data[2] = (s32)((s16)(sdata->cdata->fifo_data_buffer[offset + 4] |
+			(sdata->cdata->fifo_data_buffer[offset + 5] << 8)));
+
+	data[0] *= sdata->c_gain;
+	data[1] *= sdata->c_gain;
+	data[2] *= sdata->c_gain;
+	lsm6ds3_swap(&data[0], &data[1]);
+	data[0] += sdata->cali_data[0];
+	data[1] += sdata->cali_data[1];
+	data[2] += sdata->cali_data[2];
+	lsm6ds3_report_3axes_event(sdata, data);
+}
+#else
+enum hrtimer_restart lsm6ds3_poll_function_read(struct hrtimer *timer)
+{
+	struct lsm6ds3_sensor_data *sdata;
+
+	sdata = container_of((struct hrtimer *)timer, struct lsm6ds3_sensor_data,
+							hr_timer);
+
+	queue_work(lsm6ds3_workqueue, &sdata->input_work);
+	
+//	sdata->timestamp += MS_TO_NS(sdata->poll_interval);
+//	hrtimer_start(&sdata->hr_timer, sdata->ktime, HRTIMER_MODE_REL);
+	hrtimer_forward_now(&sdata->hr_timer, sdata->ktime);
+
+	return HRTIMER_RESTART;
+}
+
+static int lsm6ds3_get_step_c_data(struct lsm6ds3_sensor_data *sdata, u16 *steps)
+{
+	u8 data[2];
+	int err = 0;
+	err = sdata->cdata->tf->read(sdata->cdata,
+					LSM6DS3_STEP_COUNTER_OUT_L_ADDR,
+					LSM6DS3_STEP_COUNTER_OUT_SIZE,
+					data, true);
+	if (err < 0)
+		return err;
+
+	*steps = data[0] | (data[1] << 8);
+
+	return 0;
+}
+
+static int lsm6ds3_get_poll_data(struct lsm6ds3_sensor_data *sdata, u8 *data)
+{
+	int err = 0;
+	u8 reg_addr;
+
+	switch(sdata->sindex) {
+	case LSM6DS3_ACCEL:
+		reg_addr = LSM6DS3_ACCEL_OUT_X_L_ADDR;
+
+		break;
+	case LSM6DS3_GYRO:
+		reg_addr = LSM6DS3_GYRO_OUT_X_L_ADDR;
+
+		break;
+	default:
+		dev_err(sdata->cdata->dev, "invalid polling mode for sensor %s\n",
+								sdata->name);
+		return -1;
+	}
+
+	err = sdata->cdata->tf->read(sdata->cdata, reg_addr, LSM6DS3_OUT_XYZ_SIZE,
+								data, true);
+
+	return err;
+}
+ 
+static int lsm6ds3_cal_poll_data(struct lsm6ds3_sensor_data* sdata, int* output){
+	int err;
+	u8 data[6];
+	int old_xyz[3] = {0,0,0};
+	int count = 0;
+
+again:
+	err = lsm6ds3_get_poll_data(sdata, data);
+	if (err < 0) {
+		dev_err(sdata->cdata->dev, "get %s data failed %d\n",
+								sdata->name, err);
+		return -1;
+	} else {
+		output[0] = (s32)((s16)(data[0] | (data[1] << 8)));
+		output[1] = (s32)((s16)(data[2] | (data[3] << 8)));
+		output[2] = (s32)((s16)(data[4] | (data[5] << 8)));
+
+		if((old_xyz[0]==output[0]) && (old_xyz[1]==output[1]) && (old_xyz[2]==output[2])){
+			if(count++ <2)
+				goto again;
+		}
+		old_xyz[0] = output[0];
+		old_xyz[1] = output[1];
+		old_xyz[2] = output[2];
+		output[0] *= sdata->c_gain;
+		output[1] *= sdata->c_gain;
+		output[2] *= sdata->c_gain;
+		//lsm6ds3_swap(&output[0], &output[1]);//swap x and y
+		lsm6ds3_change_diretion(&output[2]);
+	}
+
+	return 0;
+	
+}
+ 
+static void poll_function_work(struct work_struct *input_work)
+{
+	struct lsm6ds3_sensor_data *sdata;
+	int xyz[3] = { 0 };
+	int err;
+
+	sdata = container_of((struct work_struct *)input_work,
+			struct lsm6ds3_sensor_data, input_work);
+	err = lsm6ds3_cal_poll_data(sdata, xyz);
+	if (err < 0) 
+		return ;
+	xyz[0] += sdata->cali_data[0];
+	xyz[1] += sdata->cali_data[1];
+	xyz[2] += sdata->cali_data[2];
+
+	#ifdef CONFIG_TESTPLUS_ONLY
+	xyz[0] = -xyz[0];
+	xyz[2] = -xyz[2];
+	#endif
+	#ifdef CONFIG_TEST_ONLY
+	xyz[0] = xyz[0];
+	xyz[2] = xyz[2];
+	#endif
+	lsm6ds3_report_3axes_event(sdata, xyz);
+}
+#endif
+
+#if !defined (CONFIG_LSM6DS3_POLLING_MODE)
+static void lsm6ds3_parse_fifo_data(struct lsm6ds3_data *cdata, u16 read_len)
+{
+	u16 fifo_offset = 0, steps_c = 0;
+	u8 gyro_sip, accel_sip, step_c_sip;
+
+	while (fifo_offset < read_len) {
+		gyro_sip = cdata->sensors[LSM6DS3_GYRO].sample_in_pattern;
+		accel_sip = cdata->sensors[LSM6DS3_ACCEL].sample_in_pattern;
+		step_c_sip =
+			cdata->sensors[LSM6DS3_STEP_COUNTER].sample_in_pattern;
+
+		do {
+			if (gyro_sip > 0) {
+				if (cdata->sensors[LSM6DS3_GYRO].sample_to_discard > 0)
+					cdata->sensors[LSM6DS3_GYRO].sample_to_discard--;
+				else
+					lsm6ds3_push_data_with_timestamp(
+						&cdata->sensors[LSM6DS3_GYRO],
+						fifo_offset);
+
+				cdata->sensors[LSM6DS3_GYRO].timestamp +=
+					cdata->sensors[LSM6DS3_GYRO].deltatime;
+				fifo_offset += LSM6DS3_FIFO_ELEMENT_LEN_BYTE;
+				gyro_sip--;
+			}
+
+			if (accel_sip > 0) {
+				if (cdata->sensors[LSM6DS3_ACCEL].sample_to_discard > 0)
+					cdata->sensors[LSM6DS3_ACCEL].sample_to_discard--;
+				else
+					lsm6ds3_push_data_with_timestamp(
+						&cdata->sensors[LSM6DS3_ACCEL],
+						fifo_offset);
+
+				cdata->sensors[LSM6DS3_ACCEL].timestamp +=
+					cdata->sensors[LSM6DS3_ACCEL].deltatime;
+				fifo_offset += LSM6DS3_FIFO_ELEMENT_LEN_BYTE;
+				accel_sip--;
+			}
+
+			if (step_c_sip > 0) {
+				steps_c = cdata->fifo_data_buffer[fifo_offset + 4] |
+					(cdata->fifo_data_buffer[fifo_offset + 5] << 8);
+				if (cdata->steps_c != steps_c) {
+					lsm6ds3_report_single_event(
+						&cdata->sensors[LSM6DS3_STEP_COUNTER],
+						steps_c);
+					cdata->steps_c = steps_c;
+				}
+				cdata->sensors[LSM6DS3_STEP_COUNTER].timestamp +=
+						cdata->sensors[LSM6DS3_STEP_COUNTER].deltatime;
+				fifo_offset += LSM6DS3_FIFO_ELEMENT_LEN_BYTE;
+				step_c_sip--;
+			}
+		} while ((accel_sip > 0) || (gyro_sip > 0) || (step_c_sip > 0));
+	}
+
+	return;
+}
+
+void lsm6ds3_read_fifo(struct lsm6ds3_data *cdata, bool check_fifo_len)
+{
+	int err;
+	u16 read_len = cdata->fifo_threshold;
+
+	if (!cdata->fifo_data_buffer)
+		return;
+
+	if (check_fifo_len) {
+		err = cdata->tf->read(cdata, LSM6DS3_FIFO_DIFF_L, 2, (u8 *)&read_len,
+									true);
+		if (err < 0)
+			return;
+
+		if (read_len & LSM6DS3_FIFO_DATA_OVR_2REGS) {
+			dev_err(cdata->dev,
+				"data fifo overrun, failed to read it.\n");
+
+			return;
+		}
+
+		read_len &= LSM6DS3_FIFO_DIFF_MASK;
+		read_len *= LSM6DS3_FIFO_BYTE_FOR_CHANNEL;
+
+		if (read_len > cdata->fifo_threshold)
+			read_len = cdata->fifo_threshold;
+	}
+
+	if (read_len == 0)
+		return;
+
+	err = cdata->tf->read(cdata, LSM6DS3_FIFO_DATA_OUT_L, read_len,
+						cdata->fifo_data_buffer, true);
+	if (err < 0)
+		return;
+
+	lsm6ds3_parse_fifo_data(cdata, read_len);
+}
+
+static int lsm6ds3_set_fifo_enable(struct lsm6ds3_data *cdata, bool status)
+{
+	int err;
+	u8 reg_value;
+
+	if (status)
+		reg_value = LSM6DS3_FIFO_ODR_MAX;
+	else
+		reg_value = LSM6DS3_FIFO_ODR_OFF;
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+					LSM6DS3_FIFO_ODR_ADDR,
+					LSM6DS3_FIFO_ODR_MASK,
+					reg_value, true);
+	if (err < 0)
+		return err;
+
+	cdata->sensors[LSM6DS3_ACCEL].timestamp = lsm6ds3_get_time_ns();
+	cdata->sensors[LSM6DS3_GYRO].timestamp =
+					cdata->sensors[LSM6DS3_ACCEL].timestamp;
+	cdata->sensors[LSM6DS3_STEP_COUNTER].timestamp =
+					cdata->sensors[LSM6DS3_ACCEL].timestamp;
+
+	return 0;
+}
+
+int lsm6ds3_set_fifo_mode(struct lsm6ds3_data *cdata, enum fifo_mode fm)
+{
+	int err;
+	u8 reg_value;
+	bool enable_fifo;
+
+	switch (fm) {
+	case BYPASS:
+		reg_value = LSM6DS3_FIFO_MODE_BYPASS;
+		enable_fifo = false;
+		break;
+	case CONTINUOS:
+		reg_value = LSM6DS3_FIFO_MODE_CONTINUOS;
+		enable_fifo = true;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = lsm6ds3_set_fifo_enable(cdata, enable_fifo);
+	if (err < 0)
+		return err;
+
+	return lsm6ds3_write_data_with_mask(cdata, LSM6DS3_FIFO_MODE_ADDR,
+				LSM6DS3_FIFO_MODE_MASK, reg_value, true);
+}
+
+int lsm6ds3_set_fifo_decimators_and_threshold(struct lsm6ds3_data *cdata)
+{
+	int err;
+	unsigned int min_odr = 416, max_odr = 0;
+	u8 decimator = 0;
+	struct lsm6ds3_sensor_data *sdata_accel, *sdata_gyro, *sdata_step_c;
+	u16 fifo_len = 0, fifo_threshold;
+	u16 min_num_pattern, num_pattern;
+
+	min_num_pattern = LSM6DS3_MAX_FIFO_SIZE / LSM6DS3_FIFO_ELEMENT_LEN_BYTE;
+	sdata_accel = &cdata->sensors[LSM6DS3_ACCEL];
+	if (sdata_accel->enabled) {
+		min_odr = MIN(min_odr, sdata_accel->c_odr);
+		max_odr = MAX(max_odr, sdata_accel->c_odr);
+	}
+
+	sdata_gyro = &cdata->sensors[LSM6DS3_GYRO];
+	if (sdata_gyro->enabled) {
+		min_odr = MIN(min_odr, sdata_gyro->c_odr);
+		max_odr = MAX(max_odr, sdata_gyro->c_odr);
+	}
+
+	sdata_step_c = &cdata->sensors[LSM6DS3_STEP_COUNTER];
+	if (sdata_step_c->enabled) {
+		min_odr = MIN(min_odr, sdata_step_c->c_odr);
+	}
+
+	if (sdata_accel->enabled) {
+		sdata_accel->sample_in_pattern = (sdata_accel->c_odr / min_odr);
+		fifo_len += sdata_accel->sample_in_pattern;
+		num_pattern = MAX(sdata_accel->fifo_length /
+					sdata_accel->sample_in_pattern, 1);
+		min_num_pattern = MIN(min_num_pattern, num_pattern);
+		sdata_accel->deltatime = (1000000000ULL / sdata_accel->c_odr);
+		decimator = max_odr / sdata_accel->c_odr;
+	} else {
+		sdata_accel->sample_in_pattern = 0;
+		decimator = 0;
+	}
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+					LSM6DS3_FIFO_CTRL3_ADDR,
+					LSM6DS3_FIFO_ACCEL_DECIMATOR_MASK,
+					decimator, true);
+	if (err < 0)
+		return err;
+
+	if (sdata_gyro->enabled) {
+		sdata_gyro->sample_in_pattern = (sdata_gyro->c_odr / min_odr);
+		fifo_len += sdata_gyro->sample_in_pattern;
+		num_pattern = MAX(sdata_gyro->fifo_length /
+					sdata_gyro->sample_in_pattern, 1);
+		min_num_pattern = MIN(min_num_pattern, num_pattern);
+		sdata_gyro->deltatime = (1000000000ULL / sdata_gyro->c_odr);
+		decimator = max_odr / sdata_gyro->c_odr;
+	} else {
+		sdata_gyro->sample_in_pattern = 0;
+		decimator = 0;
+	}
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+					LSM6DS3_FIFO_CTRL3_ADDR,
+					LSM6DS3_FIFO_GYRO_DECIMATOR_MASK,
+					decimator, true);
+	if (err < 0)
+		return err;
+
+	if (sdata_step_c->enabled) {
+		sdata_step_c->sample_in_pattern = (sdata_step_c->c_odr / min_odr);
+		fifo_len += sdata_step_c->sample_in_pattern;
+		num_pattern = MAX(sdata_step_c->fifo_length /
+					sdata_step_c->sample_in_pattern, 1);
+		min_num_pattern = MIN(min_num_pattern, num_pattern);
+		sdata_step_c->deltatime = (1000000000ULL / sdata_step_c->c_odr);
+		decimator = MAX(max_odr / sdata_step_c->c_odr, 1);
+	} else {
+		sdata_step_c->sample_in_pattern = 0;
+		decimator = 0;
+	}
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+					LSM6DS3_FIFO_CTRL4_ADDR,
+					LSM6DS3_FIFO_STEP_C_DECIMATOR_MASK,
+					decimator, true);
+	if (err < 0)
+		return err;
+
+	fifo_len *= (min_num_pattern * LSM6DS3_FIFO_ELEMENT_LEN_BYTE);
+
+	if (fifo_len > 0) {
+		fifo_threshold = fifo_len;
+
+		err = cdata->tf->write(cdata,
+					LSM6DS3_FIFO_THR_L_ADDR,
+					1,
+					(u8 *)&fifo_threshold, true);
+		if (err < 0)
+			return err;
+
+		err = lsm6ds3_write_data_with_mask(cdata,
+					LSM6DS3_FIFO_THR_H_ADDR,
+					LSM6DS3_FIFO_THR_H_MASK,
+					*(((u8 *)&fifo_threshold) + 1), true);
+		if (err < 0)
+			return err;
+
+		cdata->fifo_threshold = fifo_len;
+	}
+	if (cdata->fifo_data_buffer) {
+		kfree(cdata->fifo_data_buffer);
+		cdata->fifo_data_buffer = 0;
+	}
+
+	if (fifo_len > 0) {
+		cdata->fifo_data_buffer = kmalloc(cdata->fifo_threshold, GFP_KERNEL);
+		if (!cdata->fifo_data_buffer)
+			return -ENOMEM;
+	}
+
+	return fifo_len;
+}
+
+int lsm6ds3_reconfigure_fifo(struct lsm6ds3_data *cdata,
+						bool disable_irq_and_flush)
+{
+	int err, fifo_len;
+
+	if (disable_irq_and_flush) {
+		disable_irq(cdata->irq);
+		lsm6ds3_flush_works();
+	}
+
+	mutex_lock(&cdata->fifo_lock);
+
+	lsm6ds3_read_fifo(cdata, true);
+
+	err = lsm6ds3_set_fifo_mode(cdata, BYPASS);
+	if (err < 0)
+		goto reconfigure_fifo_irq_restore;
+
+	fifo_len = lsm6ds3_set_fifo_decimators_and_threshold(cdata);
+	if (fifo_len < 0) {
+		err = fifo_len;
+		goto reconfigure_fifo_irq_restore;
+	}
+
+	if (fifo_len > 0) {
+		err = lsm6ds3_set_fifo_mode(cdata, CONTINUOS);
+		if (err < 0)
+			goto reconfigure_fifo_irq_restore;
+	}
+
+reconfigure_fifo_irq_restore:
+	mutex_unlock(&cdata->fifo_lock);
+
+	if (disable_irq_and_flush)
+		enable_irq(cdata->irq);
+
+	return err;
+}
+#endif
+
+int lsm6ds3_set_drdy_irq(struct lsm6ds3_sensor_data *sdata, bool state)
+{
+	u8 reg_addr, mask, value;
+
+	if (state)
+		value = LSM6DS3_EN_BIT;
+	else
+		value = LSM6DS3_DIS_BIT;
+
+	switch (sdata->sindex) {
+	case LSM6DS3_ACCEL:
+	case LSM6DS3_GYRO:
+#if defined (CONFIG_LSM6DS3_POLLING_MODE)
+		return 0;
+#else
+		if ((sdata->cdata->sensors[LSM6DS3_GYRO].enabled) ||
+				(sdata->cdata->sensors[LSM6DS3_ACCEL].enabled))
+			return 0;
+
+		reg_addr = LSM6DS3_INT1_CTRL_ADDR;
+		mask = LSM6DS3_FIFO_THR_IRQ_MASK;
+		break;
+#endif
+	case LSM6DS3_STEP_COUNTER:
+	case LSM6DS3_STEP_DETECTOR:
+		if ((sdata->cdata->sensors[LSM6DS3_STEP_DETECTOR].enabled) &&
+				(sdata->cdata->sensors[LSM6DS3_STEP_COUNTER].enabled))
+			return 0;
+
+		reg_addr = LSM6DS3_INT1_CTRL_ADDR;
+		mask = LSM6DS3_STEP_DETECTOR_DRDY_IRQ_MASK;
+		break;
+	case LSM6DS3_SIGN_MOTION:
+		reg_addr = LSM6DS3_INT1_CTRL_ADDR;
+		mask = LSM6DS3_SIGN_MOTION_DRDY_IRQ_MASK;
+		break;
+	case LSM6DS3_TILT:
+		reg_addr = LSM6DS3_MD1_ADDR;
+		mask = LSM6DS3_TILT_DRDY_IRQ_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return lsm6ds3_write_data_with_mask(sdata->cdata, reg_addr, mask, value,
+									true);
+}
+
+static int lsm6ds3_set_fs(struct lsm6ds3_sensor_data *sdata, u32 gain)
+{
+	int err, i;
+
+	for (i = 0; i < LSM6DS3_FS_LIST_NUM; i++) {
+		if (lsm6ds3_fs_table[sdata->sindex].fs_avl[i].gain == gain)
+			break;
+	}
+
+	if (i == LSM6DS3_FS_LIST_NUM)
+		return -EINVAL;
+
+	err = lsm6ds3_write_data_with_mask(sdata->cdata,
+				lsm6ds3_fs_table[sdata->sindex].addr,
+				lsm6ds3_fs_table[sdata->sindex].mask,
+				lsm6ds3_fs_table[sdata->sindex].fs_avl[i].value,
+				true);
+	if (err < 0)
+		return err;
+
+	sdata->c_gain = gain;
+
+	return 0;
+}
+
+irqreturn_t lsm6ds3_save_timestamp(int irq, void *private)
+{
+	struct lsm6ds3_data *cdata = private;
+
+	cdata->timestamp = lsm6ds3_get_time_ns();
+	queue_work(lsm6ds3_workqueue, &cdata->input_work);
+
+	disable_irq_nosync(irq);
+
+	return IRQ_HANDLED;
+}
+
+static int lsm6ds3_disable_sensors(struct lsm6ds3_sensor_data *sdata);
+
+static void lsm6ds3_irq_management(struct work_struct *input_work)
+{
+	struct lsm6ds3_data *cdata;
+	u8 src_value = 0x00, src_fifo = 0x00;
+	struct lsm6ds3_sensor_data *sdata;
+	u16 steps_c;
+	int err;
+
+	cdata = container_of((struct work_struct *)input_work,
+						struct lsm6ds3_data, input_work);
+
+	cdata->tf->read(cdata, LSM6DS3_SRC_FUNC_ADDR, 1, &src_value, true);
+	cdata->tf->read(cdata, LSM6DS3_FIFO_DATA_AVL_ADDR, 1, &src_fifo, true);
+
+#if !defined(CONFIG_LSM6DS3_POLLING_MODE)
+#erro !!!!!!!!!!!!!!!!!!!!
+	if (src_fifo & LSM6DS3_FIFO_DATA_AVL) {
+		if (src_fifo & LSM6DS3_FIFO_DATA_OVR) {
+			lsm6ds3_set_fifo_mode(cdata, BYPASS);
+			lsm6ds3_set_fifo_mode(cdata, CONTINUOS);
+			dev_err(cdata->dev,
+				"data fifo overrun, reduce fifo size.\n");
+		} else
+			lsm6ds3_read_fifo(cdata, false);
+	}
+#else
+	if (src_value & LSM6DS3_SRC_STEP_COUNTER_DATA_AVL) {
+		sdata = &cdata->sensors[LSM6DS3_STEP_COUNTER];
+		sdata->timestamp = cdata->timestamp;
+		err = lsm6ds3_get_step_c_data(sdata, &steps_c);
+		if (err < 0) {
+			dev_err(cdata->dev,
+				"error while reading step counter data\n");
+			enable_irq(cdata->irq);
+
+			return;
+		}
+
+		lsm6ds3_report_single_event(&cdata->sensors[LSM6DS3_STEP_COUNTER], steps_c);
+		cdata->steps_c = steps_c;
+	}
+#endif
+
+	if (src_value & LSM6DS3_SRC_STEP_DETECTOR_DATA_AVL) {
+		sdata = &cdata->sensors[LSM6DS3_STEP_DETECTOR];
+		sdata->timestamp = cdata->timestamp;
+		lsm6ds3_report_single_event(sdata, 1);
+
+		if (cdata->sign_motion_event_ready) {
+			sdata = &cdata->sensors[LSM6DS3_SIGN_MOTION];
+			sdata->timestamp = cdata->timestamp;
+			lsm6ds3_report_single_event(sdata, 1);
+			cdata->sign_motion_event_ready = false;
+			lsm6ds3_disable_sensors(sdata);
+		}
+	}
+
+	if (src_value & LSM6DS3_SRC_TILT_DATA_AVL) {
+		sdata = &cdata->sensors[LSM6DS3_TILT];
+		sdata->timestamp = cdata->timestamp;
+		lsm6ds3_report_single_event(sdata, 1);
+	}
+
+	enable_irq(cdata->irq);
+	return;
+}
+
+int lsm6ds3_interrupt_init(struct lsm6ds3_data *cdata)
+{
+	int err;
+
+	INIT_WORK(&cdata->input_work, lsm6ds3_irq_management);
+
+	err = request_threaded_irq(cdata->irq, lsm6ds3_save_timestamp, NULL,
+			IRQF_TRIGGER_HIGH | IRQF_ONESHOT, cdata->name, cdata);
+	if (err)
+		return err;
+	return 0;
+}
+
+static int lsm6ds3_set_extra_dependency(struct lsm6ds3_sensor_data *sdata,
+								bool enable)
+{
+	int err;
+
+	if (!(sdata->cdata->sensors[LSM6DS3_SIGN_MOTION].enabled |
+				sdata->cdata->sensors[LSM6DS3_STEP_COUNTER].enabled |
+				sdata->cdata->sensors[LSM6DS3_STEP_DETECTOR].enabled |
+				sdata->cdata->sensors[LSM6DS3_TILT].enabled)) {
+		if (enable) {
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+						LSM6DS3_FUNC_EN_ADDR,
+						LSM6DS3_FUNC_EN_MASK,
+						LSM6DS3_EN_BIT, true);
+			if (err < 0)
+				return err;
+		} else {
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+						LSM6DS3_FUNC_EN_ADDR,
+						LSM6DS3_FUNC_EN_MASK,
+						LSM6DS3_DIS_BIT, true);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	if (!sdata->cdata->sensors[LSM6DS3_ACCEL].enabled) {
+		if (sdata->cdata->sensors[LSM6DS3_STEP_COUNTER].enabled && 
+			sdata->cdata->sensors[LSM6DS3_STEP_DETECTOR].enabled) {
+			return 0;
+		}
+		
+		if (enable) {
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+						lsm6ds3_odr_table.addr[LSM6DS3_ACCEL],
+						lsm6ds3_odr_table.mask[LSM6DS3_ACCEL],
+						lsm6ds3_odr_table.odr_avl[0].value, true);
+			if (err < 0)
+				return err;
+		} else {
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+						lsm6ds3_odr_table.addr[LSM6DS3_ACCEL],
+						lsm6ds3_odr_table.mask[LSM6DS3_ACCEL],
+						LSM6DS3_ODR_POWER_OFF_VAL, true);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	return 0;
+}
+
+static int lsm6ds3_reset_steps(struct lsm6ds3_data *cdata)
+{
+	int err;
+	u8 reg_value = 0x00;
+
+	err = cdata->tf->read(cdata,
+			LSM6DS3_STEP_COUNTER_RES_ADDR, 1, &reg_value, true);
+	if (err < 0)
+		return err;
+
+	if (reg_value & LSM6DS3_FUNC_EN_MASK)
+		reg_value = LSM6DS3_STEP_COUNTER_RES_FUNC_EN;
+	else
+		reg_value = LSM6DS3_DIS_BIT;
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+				LSM6DS3_STEP_COUNTER_RES_ADDR,
+				LSM6DS3_STEP_COUNTER_RES_MASK,
+				LSM6DS3_STEP_COUNTER_RES_ALL_EN, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+				LSM6DS3_STEP_COUNTER_RES_ADDR,
+				LSM6DS3_STEP_COUNTER_RES_MASK,
+				reg_value, true);
+	if (err < 0)
+		return err;
+
+	cdata->reset_steps = true;
+
+	return 0;
+}
+
+
+static int lsm6ds3_enable_pedometer(struct lsm6ds3_sensor_data *sdata,
+								bool enable)
+{
+	int err = 0;
+	u8 value = LSM6DS3_DIS_BIT;
+
+	if ((sdata->sindex == LSM6DS3_STEP_COUNTER) && !enable){
+		err = lsm6ds3_reset_steps(sdata->cdata);
+		if (err < 0)
+			return err;
+	}
+	
+	if (sdata->cdata->sensors[LSM6DS3_STEP_COUNTER].enabled &&
+			sdata->cdata->sensors[LSM6DS3_STEP_DETECTOR].enabled)
+		return 0;
+
+	if (enable)
+		value = LSM6DS3_EN_BIT;
+
+	err = lsm6ds3_write_data_with_mask(sdata->cdata,
+						LSM6DS3_FIFO_PEDO_E_ADDR,
+						LSM6DS3_FIFO_PEDO_E_MASK,
+						value, true);
+	if (err < 0)
+		return err;
+
+	return lsm6ds3_write_data_with_mask(sdata->cdata,
+						LSM6DS3_PEDOMETER_EN_ADDR,
+						LSM6DS3_PEDOMETER_EN_MASK,
+						value, true);
+}
+
+static int lsm6ds3_enable_sensors(struct lsm6ds3_sensor_data *sdata)
+{
+	int err, i;
+
+	if (sdata->enabled)
+		return 0;
+
+	switch (sdata->sindex) {
+	case LSM6DS3_ACCEL:
+	case LSM6DS3_GYRO:
+		for (i = 0; i < LSM6DS3_ODR_LIST_NUM; i++) {
+			if (lsm6ds3_odr_table.odr_avl[i].hz == sdata->c_odr)
+				break;
+		}
+		if (i == LSM6DS3_ODR_LIST_NUM)
+			return -EINVAL;
+
+		if (sdata->sindex == LSM6DS3_ACCEL)
+			sdata->sample_to_discard = LSM6DS3_ACCEL_STD +
+							LSM6DS3_ACCEL_STD_FROM_PD;
+
+		sdata->cdata->sensors[LSM6DS3_GYRO].sample_to_discard =
+							LSM6DS3_GYRO_STD +
+							LSM6DS3_GYRO_STD_FROM_PD;
+
+		err = lsm6ds3_write_data_with_mask(sdata->cdata,
+				lsm6ds3_odr_table.addr[sdata->sindex],
+				lsm6ds3_odr_table.mask[sdata->sindex],
+				lsm6ds3_odr_table.odr_avl[i].value, true);
+		if (err < 0)
+			return err;
+
+#if defined (CONFIG_LSM6DS3_POLLING_MODE)
+		hrtimer_start(&sdata->hr_timer, sdata->ktime, HRTIMER_MODE_REL);
+		sdata->timestamp = lsm6ds3_get_time_ns();
+#endif
+
+		sdata->c_odr = lsm6ds3_odr_table.odr_avl[i].hz;
+
+		break;
+	case LSM6DS3_SIGN_MOTION:
+		err = lsm6ds3_write_data_with_mask(sdata->cdata,
+						LSM6DS3_SIGN_MOTION_EN_ADDR,
+						LSM6DS3_SIGN_MOTION_EN_MASK,
+						LSM6DS3_EN_BIT, true);
+		if (err < 0)
+			return err;
+
+		if ((sdata->cdata->sensors[LSM6DS3_STEP_COUNTER].enabled) ||
+				(sdata->cdata->sensors[LSM6DS3_STEP_DETECTOR].enabled)) {
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+						LSM6DS3_PEDOMETER_EN_ADDR,
+						LSM6DS3_PEDOMETER_EN_MASK,
+						LSM6DS3_DIS_BIT, true);
+			if (err < 0)
+				return err;
+
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+						LSM6DS3_PEDOMETER_EN_ADDR,
+						LSM6DS3_PEDOMETER_EN_MASK,
+						LSM6DS3_EN_BIT, true);
+			if (err < 0)
+				return err;
+		} else {
+			err = lsm6ds3_enable_pedometer(sdata, true);
+			if (err < 0)
+				return err;
+		}
+
+		sdata->cdata->sign_motion_event_ready = true;
+
+		break;
+	case LSM6DS3_STEP_COUNTER:
+	case LSM6DS3_STEP_DETECTOR:
+		err = lsm6ds3_enable_pedometer(sdata, true);
+		if (err < 0)
+			return err;
+
+		break;
+	case LSM6DS3_TILT:
+		err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					LSM6DS3_TILT_EN_ADDR,
+					LSM6DS3_TILT_EN_MASK,
+					LSM6DS3_EN_BIT, true);
+		if (err < 0)
+			return err;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = lsm6ds3_set_extra_dependency(sdata, true);
+	if (err < 0)
+		return err;
+
+
+	err = lsm6ds3_set_drdy_irq(sdata, true);
+	if (err < 0)
+		return err;
+
+	sdata->enabled = true;
+
+#if !defined (CONFIG_LSM6DS3_POLLING_MODE)
+	err = lsm6ds3_reconfigure_fifo(sdata->cdata, true);
+	if (err < 0)
+		return err;
+#endif
+
+	return 0;
+}
+
+static int lsm6ds3_disable_sensors(struct lsm6ds3_sensor_data *sdata)
+{
+	int err;
+
+	if (!sdata->enabled)
+		return 0;
+
+	switch (sdata->sindex) {
+	case LSM6DS3_ACCEL:
+		if (sdata->cdata->sensors[LSM6DS3_SIGN_MOTION].enabled |
+			sdata->cdata->sensors[LSM6DS3_STEP_COUNTER].enabled |
+			sdata->cdata->sensors[LSM6DS3_STEP_DETECTOR].enabled |
+			sdata->cdata->sensors[LSM6DS3_TILT].enabled) {
+
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					lsm6ds3_odr_table.addr[LSM6DS3_ACCEL],
+					lsm6ds3_odr_table.mask[LSM6DS3_ACCEL],
+					lsm6ds3_odr_table.odr_avl[0].value, true);
+		} else {
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					lsm6ds3_odr_table.addr[LSM6DS3_ACCEL],
+					lsm6ds3_odr_table.mask[LSM6DS3_ACCEL],
+					LSM6DS3_ODR_POWER_OFF_VAL, true);
+		}
+		if (err < 0)
+			return err;
+
+#if defined (CONFIG_LSM6DS3_POLLING_MODE)
+		cancel_work_sync(&sdata->input_work);
+		hrtimer_cancel(&sdata->hr_timer);
+#endif
+
+		break;
+	case LSM6DS3_GYRO:
+		err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					lsm6ds3_odr_table.addr[LSM6DS3_GYRO],
+					lsm6ds3_odr_table.mask[LSM6DS3_GYRO],
+					LSM6DS3_ODR_POWER_OFF_VAL, true);
+		if (err < 0)
+			return err;
+
+#if defined (CONFIG_LSM6DS3_POLLING_MODE)
+		cancel_work_sync(&sdata->input_work);
+		hrtimer_cancel(&sdata->hr_timer);
+#endif
+
+		break;
+	case LSM6DS3_SIGN_MOTION:
+		err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					LSM6DS3_SIGN_MOTION_EN_ADDR,
+					LSM6DS3_SIGN_MOTION_EN_MASK,
+					LSM6DS3_DIS_BIT, true);
+		if (err < 0)
+			return err;
+
+		err = lsm6ds3_enable_pedometer(sdata, false);
+		if (err < 0)
+			return err;
+
+		sdata->cdata->sign_motion_event_ready = false;
+
+		break;
+	case LSM6DS3_STEP_COUNTER:
+	case LSM6DS3_STEP_DETECTOR:
+		err = lsm6ds3_enable_pedometer(sdata, false);
+		if (err < 0)
+			return err;
+
+		break;
+	case LSM6DS3_TILT:
+		err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					LSM6DS3_TILT_EN_ADDR,
+					LSM6DS3_TILT_EN_MASK,
+					LSM6DS3_DIS_BIT, true);
+		if (err < 0)
+			return err;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = lsm6ds3_set_extra_dependency(sdata, false);
+	if (err < 0)
+		return err;
+
+	err = lsm6ds3_set_drdy_irq(sdata, false);
+	if (err < 0)
+		return err;
+
+	sdata->enabled = false;
+
+#if !defined (CONFIG_LSM6DS3_POLLING_MODE)
+	err = lsm6ds3_reconfigure_fifo(sdata->cdata, true);
+	if (err < 0)
+		return err;
+#endif
+
+	return 0;
+}
+
+static int lsm6ds3_init_sensors(struct lsm6ds3_data *cdata)
+{
+	int err, i;
+	u8 default_reg_value = 0;
+	struct lsm6ds3_sensor_data *sdata;
+
+	mutex_init(&cdata->tb.buf_lock);
+
+	for (i = 0; i < LSM6DS3_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+
+		err = lsm6ds3_disable_sensors(sdata);
+		if (err < 0)
+			return err;
+
+		if ((sdata->sindex == LSM6DS3_ACCEL) ||
+				(sdata->sindex == LSM6DS3_GYRO)) {
+			err = lsm6ds3_set_fs(sdata, sdata->c_gain);
+			if (err < 0)
+				return err;
+		}
+	}
+
+#if defined (CONFIG_LSM6DS3_POLLING_MODE)
+	hrtimer_init(&cdata->sensors[LSM6DS3_ACCEL].hr_timer, CLOCK_MONOTONIC,
+						HRTIMER_MODE_REL);
+	hrtimer_init(&cdata->sensors[LSM6DS3_GYRO].hr_timer, CLOCK_MONOTONIC,
+						HRTIMER_MODE_REL);
+	cdata->sensors[LSM6DS3_ACCEL].hr_timer.function =
+						&lsm6ds3_poll_function_read;
+	cdata->sensors[LSM6DS3_GYRO].hr_timer.function =
+						&lsm6ds3_poll_function_read;
+#endif
+
+	cdata->gyro_selftest_status = 0;
+	cdata->accel_selftest_status = 0;
+	cdata->steps_c = 0;
+	cdata->reset_steps = false;
+
+	err = lsm6ds3_write_data_with_mask(cdata, LSM6DS3_RESET_ADDR,
+				LSM6DS3_RESET_MASK, LSM6DS3_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+					LSM6DS3_LIR_ADDR,
+					LSM6DS3_LIR_MASK,
+					LSM6DS3_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+					LSM6DS3_TIMER_EN_ADDR,
+					LSM6DS3_TIMER_EN_MASK,
+					LSM6DS3_EN_BIT, true);
+		if (err < 0)
+			return err;
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+					LSM6DS3_BDU_ADDR,
+					LSM6DS3_BDU_MASK,
+					LSM6DS3_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+#if !defined (CONFIG_LSM6DS3_POLLING_MODE)
+	err = lsm6ds3_set_fifo_enable(sdata->cdata, false);
+	if (err < 0)
+		return err;
+#endif
+	err = lsm6ds3_write_data_with_mask(cdata,
+					LSM6DS3_ROUNDING_ADDR,
+					LSM6DS3_ROUNDING_MASK,
+					LSM6DS3_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+					LSM6DS3_INT2_ON_INT1_ADDR,
+					LSM6DS3_INT2_ON_INT1_MASK,
+					LSM6DS3_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6ds3_reset_steps(sdata->cdata);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&cdata->bank_registers_lock);
+	err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					LSM6DS3_FUNC_CFG_ACCESS_ADDR,
+					LSM6DS3_FUNC_CFG_REG2_MASK,
+					LSM6DS3_EN_BIT, false);
+	if (err < 0)
+		goto lsm6ds3_init_sensor_mutex_unlock;
+
+	err = sdata->cdata->tf->write(sdata->cdata,
+					LSM6DS3_STEP_COUNTER_DURATION_ADDR,
+					1,
+					&default_reg_value, false);
+	if (err < 0)
+		goto lsm6ds3_init_sensor_mutex_unlock;
+
+	err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					LSM6DS3_FUNC_CFG_ACCESS_ADDR,
+					LSM6DS3_FUNC_CFG_REG2_MASK,
+					LSM6DS3_DIS_BIT, false);
+	if (err < 0)
+		goto lsm6ds3_init_sensor_mutex_unlock;
+	mutex_unlock(&cdata->bank_registers_lock);
+
+#if defined (CONFIG_LSM6DS3_POLLING_MODE)
+	cdata->sensors[LSM6DS3_ACCEL].ktime = ktime_set(0,
+			MS_TO_NS(cdata->sensors[LSM6DS3_ACCEL].poll_interval));
+	cdata->sensors[LSM6DS3_GYRO].ktime = ktime_set(0,
+			MS_TO_NS(cdata->sensors[LSM6DS3_GYRO].poll_interval));
+	INIT_WORK(&cdata->sensors[LSM6DS3_ACCEL].input_work, poll_function_work);
+	INIT_WORK(&cdata->sensors[LSM6DS3_GYRO].input_work, poll_function_work);
+#else
+	err = lsm6ds3_reconfigure_fifo(cdata, false);
+	if (err < 0)
+		return err;
+#endif
+
+	return 0;
+
+lsm6ds3_init_sensor_mutex_unlock:
+	mutex_unlock(&cdata->bank_registers_lock);
+	return err;
+}
+
+static int lsm6ds3_set_odr(struct lsm6ds3_sensor_data *sdata, u32 odr)
+{
+	int err = 0, i;
+
+	for (i = 0; i < LSM6DS3_ODR_LIST_NUM; i++) {
+		if (lsm6ds3_odr_table.odr_avl[i].hz >= odr)
+			break;
+	}
+	if (i == LSM6DS3_ODR_LIST_NUM)
+		return -EINVAL;
+
+	if (sdata->c_odr == lsm6ds3_odr_table.odr_avl[i].hz)
+		return 0;
+
+	if (sdata->enabled) {
+		disable_irq(sdata->cdata->irq);
+		lsm6ds3_flush_works();
+
+		if (sdata->sindex == LSM6DS3_ACCEL)
+			sdata->cdata->sensors[LSM6DS3_ACCEL].sample_to_discard +=
+							LSM6DS3_ACCEL_STD;
+
+		if (sdata->cdata->sensors[LSM6DS3_GYRO].enabled)
+			sdata->cdata->sensors[LSM6DS3_GYRO].sample_to_discard +=
+							LSM6DS3_GYRO_STD;
+
+		err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					lsm6ds3_odr_table.addr[sdata->sindex],
+					lsm6ds3_odr_table.mask[sdata->sindex],
+					lsm6ds3_odr_table.odr_avl[i].value, true);
+		if (err < 0) {
+			enable_irq(sdata->cdata->irq);
+
+			return err;
+		}
+
+		sdata->c_odr = lsm6ds3_odr_table.odr_avl[i].hz;
+#if !defined (CONFIG_LSM6DS3_POLLING_MODE)
+		err = lsm6ds3_reconfigure_fifo(sdata->cdata, false);
+		if (err < 0)
+			return err;
+#endif
+		enable_irq(sdata->cdata->irq);
+	} else
+		sdata->c_odr = lsm6ds3_odr_table.odr_avl[i].hz;
+
+	return err;
+}
+
+static ssize_t get_enable(struct device *dev, struct device_attribute *attr,
+								char *buf)
+{
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->enabled);
+}
+
+static ssize_t set_enable(struct device *dev, struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	int err;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+	unsigned long enable;
+
+	if (strict_strtoul(buf, 10, &enable))
+		return -EINVAL;
+
+	if (enable)
+		err = lsm6ds3_enable_sensors(sdata);
+	else
+		err = lsm6ds3_disable_sensors(sdata);
+
+	return count;
+}
+
+#if defined (CONFIG_LSM6DS3_POLLING_MODE)
+static ssize_t get_polling_rate(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->poll_interval);
+}
+
+static ssize_t set_polling_rate(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	int err;
+	unsigned int polling_rate;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &polling_rate);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->input_dev->mutex);
+	/*
+	 * Polling interval is in msec, then we have to convert it in Hz to
+	 * configure ODR through lsm6ds3_set_odr
+	 */
+
+	if (polling_rate < CTS_OPTIMISE_MS) {
+		polling_rate += CTS_OPTIMISE_MS;
+	}
+
+	polling_rate -= CTS_OPTIMISE_MS;
+	err = lsm6ds3_set_odr(sdata, 1000 / polling_rate);
+	if (!(err < 0)) {
+		sdata->poll_interval = polling_rate;
+		sdata->ktime = ktime_set(0, MS_TO_NS(polling_rate));
+	}
+	mutex_unlock(&sdata->input_dev->mutex);
+
+	return (err < 0 ? err : count);
+}
+#endif
+
+static ssize_t get_sampling_freq(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->c_odr);
+}
+
+static ssize_t set_sampling_freq(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	int err;
+	unsigned int odr;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &odr);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->input_dev->mutex);
+	err = lsm6ds3_set_odr(sdata, odr);
+	mutex_unlock(&sdata->input_dev->mutex);
+
+	return (err < 0 ? err : count);
+}
+
+#if !defined (CONFIG_LSM6DS3_POLLING_MODE)
+static ssize_t get_fifo_length(struct device *dev,
+					struct device_attribute *attr, char *buf)
+{
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->fifo_length);
+}
+
+static ssize_t set_fifo_length(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	int err;
+	unsigned int fifo_length;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &fifo_length);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->input_dev->mutex);
+	sdata->fifo_length = fifo_length;
+	mutex_unlock(&sdata->input_dev->mutex);
+
+	lsm6ds3_reconfigure_fifo(sdata->cdata, true);
+
+	return count;
+}
+
+static ssize_t get_hw_fifo_lenght(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", LSM6DS3_MAX_FIFO_LENGHT);
+}
+
+static ssize_t flush_fifo(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t size)
+{
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	disable_irq(sdata->cdata->irq);
+	lsm6ds3_flush_works();
+
+	mutex_lock(&sdata->cdata->fifo_lock);
+	lsm6ds3_read_fifo(sdata->cdata, true);
+	mutex_unlock(&sdata->cdata->fifo_lock);
+
+	enable_irq(sdata->cdata->irq);
+
+	return size;
+}
+#endif
+
+static ssize_t reset_steps(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	int err;
+	unsigned int reset;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &reset);
+	if (err < 0)
+		return err;
+
+	lsm6ds3_reset_steps(sdata->cdata);
+
+	return count;
+}
+
+static ssize_t set_max_delivery_rate(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	u8 duration;
+	int err, err2;
+	unsigned int max_delivery_rate;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtouint(buf, 10, &max_delivery_rate);
+	if (err < 0)
+		return -EINVAL;
+
+	if (max_delivery_rate == sdata->c_odr)
+		return size;
+
+	duration = max_delivery_rate / LSM6DS3_MIN_DURATION_MS;
+
+	mutex_lock(&sdata->cdata->bank_registers_lock);
+
+	err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					LSM6DS3_FUNC_CFG_ACCESS_ADDR,
+					LSM6DS3_FUNC_CFG_REG2_MASK,
+					LSM6DS3_EN_BIT, false);
+	if (err < 0)
+		goto lsm6ds3_set_max_delivery_rate_mutex_unlock;
+
+	err = sdata->cdata->tf->write(sdata->cdata,
+					LSM6DS3_STEP_COUNTER_DURATION_ADDR,
+					1, &duration, false);
+	if (err < 0)
+		goto lsm6ds3_set_max_delivery_rate_restore_bank;
+
+	err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					LSM6DS3_FUNC_CFG_ACCESS_ADDR,
+					LSM6DS3_FUNC_CFG_REG2_MASK,
+					LSM6DS3_DIS_BIT, false);
+	if (err < 0)
+		goto lsm6ds3_set_max_delivery_rate_restore_bank;
+
+	mutex_unlock(&sdata->cdata->bank_registers_lock);
+
+	sdata->c_odr = max_delivery_rate;
+
+	return size;
+
+lsm6ds3_set_max_delivery_rate_restore_bank:
+	do {
+		err2 = lsm6ds3_write_data_with_mask(sdata->cdata,
+					LSM6DS3_FUNC_CFG_ACCESS_ADDR,
+					LSM6DS3_FUNC_CFG_REG2_MASK,
+					LSM6DS3_DIS_BIT, false);
+
+		msleep(500);
+	} while (err2 < 0);
+
+lsm6ds3_set_max_delivery_rate_mutex_unlock:
+	mutex_unlock(&sdata->cdata->bank_registers_lock);
+	return err;
+}
+
+static ssize_t get_max_delivery_rate(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", sdata->c_odr);
+}
+
+static ssize_t get_sampling_frequency_avail(struct device *dev,
+					struct device_attribute *attr, char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < LSM6DS3_ODR_LIST_NUM; i++) {
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+					lsm6ds3_odr_table.odr_avl[i].hz);
+	}
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t get_scale_avail(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int i, len = 0;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	for (i = 0; i < LSM6DS3_FS_LIST_NUM; i++)
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+			lsm6ds3_fs_table[sdata->sindex].fs_avl[i].urv);
+
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t get_cur_scale(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int i;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	for (i = 0; i < LSM6DS3_FS_LIST_NUM; i++)
+		if (sdata->c_gain == lsm6ds3_fs_table[sdata->sindex].fs_avl[i].gain)
+			break;
+
+	return sprintf(buf, "%d\n",
+			lsm6ds3_fs_table[sdata->sindex].fs_avl[i].urv);
+}
+
+static ssize_t set_cur_scale(struct device *dev, struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	int i, urv, err;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &urv);
+	if (err < 0)
+		return err;
+
+	for (i = 0; i < LSM6DS3_FS_LIST_NUM; i++)
+		if (urv == lsm6ds3_fs_table[sdata->sindex].fs_avl[i].urv)
+			break;
+
+	if (i == LSM6DS3_FS_LIST_NUM)
+		return -EINVAL;
+
+	err = lsm6ds3_set_fs(sdata,
+				lsm6ds3_fs_table[sdata->sindex].fs_avl[i].gain);
+	if (err < 0)
+		return err;
+
+	return count;
+}
+
+
+static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO, get_enable, set_enable);
+static DEVICE_ATTR(sampling_freq, S_IWUSR | S_IRUGO, get_sampling_freq,
+							set_sampling_freq);
+#if !defined (CONFIG_LSM6DS3_POLLING_MODE)
+static DEVICE_ATTR(fifo_length, S_IWUSR | S_IRUGO, get_fifo_length,
+							set_fifo_length);
+static DEVICE_ATTR(get_hw_fifo_lenght, S_IRUGO, get_hw_fifo_lenght, NULL);
+static DEVICE_ATTR(flush_fifo, S_IWUSR, NULL, flush_fifo);
+#else
+static DEVICE_ATTR(polling_rate, S_IWUSR | S_IRUGO, get_polling_rate,
+							set_polling_rate);
+#endif
+static DEVICE_ATTR(reset_steps, S_IWUSR, NULL, reset_steps);
+static DEVICE_ATTR(max_delivery_rate, S_IWUSR | S_IRUGO, get_max_delivery_rate,
+							set_max_delivery_rate);
+static DEVICE_ATTR(sampling_freq_avail, S_IRUGO, get_sampling_frequency_avail, NULL);
+static DEVICE_ATTR(scale_avail, S_IRUGO, get_scale_avail, NULL);
+static DEVICE_ATTR(scale, S_IWUSR | S_IRUGO, get_cur_scale, set_cur_scale);
+
+static struct attribute *lsm6ds3_accel_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_sampling_freq.attr,
+#if defined (CONFIG_LSM6DS3_POLLING_MODE)
+	&dev_attr_polling_rate.attr,
+#else
+	&dev_attr_fifo_length.attr,
+	&dev_attr_get_hw_fifo_lenght.attr,
+	&dev_attr_flush_fifo.attr,
+#endif
+	&dev_attr_sampling_freq_avail.attr,
+	&dev_attr_scale_avail.attr,
+	&dev_attr_scale.attr,
+	NULL,
+};
+
+static struct attribute *lsm6ds3_gyro_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_sampling_freq.attr,
+#if defined (CONFIG_LSM6DS3_POLLING_MODE)
+	&dev_attr_polling_rate.attr,
+#else
+	&dev_attr_fifo_length.attr,
+	&dev_attr_get_hw_fifo_lenght.attr,
+	&dev_attr_flush_fifo.attr,
+#endif
+	&dev_attr_sampling_freq_avail.attr,
+	&dev_attr_scale_avail.attr,
+	&dev_attr_scale.attr,
+	NULL,
+};
+
+static struct attribute *lsm6ds3_sign_m_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm6ds3_step_c_attribute[] = {
+	&dev_attr_enable.attr,
+#if !defined (CONFIG_LSM6DS3_POLLING_MODE)
+	&dev_attr_fifo_length.attr,
+	&dev_attr_get_hw_fifo_lenght.attr,
+	&dev_attr_flush_fifo.attr,
+#endif
+	&dev_attr_reset_steps.attr,
+	&dev_attr_max_delivery_rate.attr,
+	NULL,
+};
+
+static struct attribute *lsm6ds3_step_d_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm6ds3_tilt_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static const struct attribute_group lsm6ds3_attribute_groups[] = {
+	[LSM6DS3_ACCEL] = {
+		.attrs = lsm6ds3_accel_attribute,
+		.name = "accel",
+	},
+	[LSM6DS3_GYRO] = {
+		.attrs = lsm6ds3_gyro_attribute,
+		.name = "gyro",
+	},
+	[LSM6DS3_SIGN_MOTION] = {
+		.attrs = lsm6ds3_sign_m_attribute,
+		.name = "sign_m",
+	},
+	[LSM6DS3_STEP_COUNTER] = {
+		.attrs = lsm6ds3_step_c_attribute,
+		.name = "step_c",
+	},
+	[LSM6DS3_STEP_DETECTOR] = {
+		.attrs = lsm6ds3_step_d_attribute,
+		.name = "step_d",
+	},
+	[LSM6DS3_TILT] = {
+		.attrs = lsm6ds3_tilt_attribute,
+		.name = "tilt",
+	},
+};
+
+static int	lsm6ds3_devenable(struct sensors_classdev *sensors_cdev,
+					unsigned int enabled){
+	struct lsm6ds3_sensor_data *sdata = container_of(sensors_cdev,
+			                struct lsm6ds3_sensor_data, class_dev);
+
+	if (enabled)
+		return lsm6ds3_enable_sensors(sdata);
+	else
+		return lsm6ds3_disable_sensors(sdata);
+}
+
+static int	lsm6ds3_devdelay(struct sensors_classdev *sensors_cdev,
+					unsigned int delay_msec){
+	int err;
+	
+	struct lsm6ds3_sensor_data *sdata = container_of(sensors_cdev,
+			                struct lsm6ds3_sensor_data, class_dev);
+
+	mutex_lock(&sdata->input_dev->mutex);
+	/*
+	 * Polling interval is in msec, then we have to convert it in Hz to
+	 * configure ODR through lsm6ds3_set_odr
+	 */
+
+	if (delay_msec < CTS_OPTIMISE_MS) {
+		delay_msec += CTS_OPTIMISE_MS;
+	}
+
+	delay_msec -= CTS_OPTIMISE_MS;
+
+    printk("lsm6ds3_devdelay--delay_msec:%d\n", delay_msec);
+	err = lsm6ds3_set_odr(sdata, 1000 / delay_msec);
+	if (!(err < 0)) {
+		sdata->poll_interval = delay_msec;
+		sensors_cdev->delay_msec = delay_msec;
+		sdata->ktime = ktime_set(0, MS_TO_NS(delay_msec));
+	}
+	mutex_unlock(&sdata->input_dev->mutex);
+
+	return (err < 0 ? err : sizeof(delay_msec));
+}
+
+static int lsm6ds3_calibrate(struct sensors_classdev *sensors_cdev,
+		int axis, int apply_now){
+	int32_t ret,data[3] = {0, 0, 0};
+	long int sum_x = 0, sum_y = 0, sum_z = 0;
+	int32_t i = 0;
+	int rept = CAL_REPT;
+	int32_t max_data[3] = {0, 0, 0};
+	int32_t min_data[3] = {0, 0, 0};
+	//unsigned int cali_delay = 10;//make the test fastest
+	//unsigned int old_delay;
+	unsigned int cali_enable = 1;
+
+	struct lsm6ds3_sensor_data *sdata = container_of(sensors_cdev,
+		                struct lsm6ds3_sensor_data, class_dev);
+
+    /* forbid it,1.it'll shake,2.it'll be more and more faster when clicking calibration continuity after modify CTS. */
+	//old_delay = sensors_cdev->delay_msec;
+	//lsm6ds3_devdelay(sensors_cdev, cali_delay);
+	printk("lsm6ds3_calibrate start\n");
+	if (!sensors_cdev->enabled)
+	   lsm6ds3_devenable(sensors_cdev, cali_enable);
+
+	for (i = 0; i < rept; i++)
+	{
+	   msleep(sdata->poll_interval);
+	   ret = lsm6ds3_cal_poll_data(sdata, data);
+	   if (ret < 0){
+		  dev_err(sdata->cdata->dev, "get %s data error!\n", sdata->name);
+		  return ret;
+	   }
+
+	   if (i == 0){
+		   max_data[0] = data[0];
+		   max_data[1] = data[1];
+		   max_data[2] = data[2];
+		   
+		   min_data[0] = data[0];
+		   min_data[1] = data[1];
+		   min_data[2] = data[2];
+	   }
+
+	   if (max_data[0] < data[0])
+			   max_data[0] = data[0];
+	   if (max_data[1] < data[1])
+			   max_data[1] = data[1];
+	   if (max_data[2] < data[2])
+			   max_data[2] = data[2];
+
+	   if (min_data[0] > data[0])
+			   min_data[0] = data[0];
+	   if (min_data[1] > data[1])
+			   min_data[1] = data[1];
+	   if (min_data[2] > data[2])
+			   min_data[2] = data[2];
+
+	   sum_x += data[0];
+	   sum_y += data[1];
+	   sum_z += data[2];
+		   
+	}
+
+	sum_x -= (max_data[0] + min_data[0]);
+	sum_y -= (max_data[1] + min_data[1]);
+	sum_z -= (max_data[2] + min_data[2]);
+
+	data[0] = sum_x / (rept - 2);
+	data[1] = sum_y / (rept - 2);
+	data[2] = sum_z / (rept - 2);
+
+	sdata->cali_data[0] = -data[0];
+	sdata->cali_data[1] = -data[1];
+	if (sdata->sindex == LSM6DS3_ACCEL) {
+		#ifdef CONFIG_TESTPLUS_ONLY
+		sdata->cali_data[2] = GRAVITY_HAL_UNIT - ABS(data[2]);
+		#endif
+		#ifdef CONFIG_TEST_ONLY
+		sdata->cali_data[2] = ABS(data[2]) - GRAVITY_HAL_UNIT;
+		#endif
+	} else if (sdata->sindex == LSM6DS3_GYRO) {
+		sdata->cali_data[2] = -data[2];
+	}
+
+	if (sensors_cdev->params == NULL) {
+	  sensors_cdev->params = devm_kzalloc(sdata->cdata->dev, 128, GFP_KERNEL);
+	  if (sensors_cdev->params == NULL) {
+			  dev_err(sdata->cdata->dev, "sensor_cdev allocate memory error!\n");
+			  return -EBUSY;
+	  }
+	}
+	snprintf(sensors_cdev->params, 64, "%d,%d,%d", 
+						sdata->cali_data[0],
+						sdata->cali_data[1], 
+						sdata->cali_data[2]);
+	dev_dbg(sdata->cdata->dev, "sensor calibration offset:%s\n",sensors_cdev->params);
+
+	//lsm6ds3_devdelay(sensors_cdev, old_delay);
+	if (!sensors_cdev->enabled)
+	   lsm6ds3_devenable(sensors_cdev, !cali_enable);
+
+    printk("lsm6ds3_calibrate end\n");
+
+	return 0;
+}
+
+static int	lsm6ds3_write_cali_params(struct sensors_classdev
+		*sensors_cdev, struct cal_result_t *cal_result){
+	
+	struct lsm6ds3_sensor_data *sdata = container_of(sensors_cdev,
+							struct lsm6ds3_sensor_data, class_dev); 
+	
+	if (sensors_cdev->params == NULL) {
+	   sensors_cdev->params = devm_kzalloc(sdata->cdata->dev, 128, GFP_KERNEL);
+	   if (sensors_cdev->params == NULL) {
+	           dev_err(sdata->cdata->dev, "sensor_cdev allocate memory error!\n");
+	           return -EBUSY;
+	   }
+	}
+	sdata->cali_data[0] = cal_result->offset[0];
+	sdata->cali_data[1] = cal_result->offset[1];
+	sdata->cali_data[2] = cal_result->offset[2];
+
+	snprintf(sensors_cdev->params, 64, "%d,%d,%d", 
+				sdata->cali_data[0],
+				sdata->cali_data[1],
+				sdata->cali_data[2]);
+	
+	return 0;
+}
+
+static int	lsm6ds3_flush(struct sensors_classdev *sensors_cdev){
+	struct timespec ts;
+	struct lsm6ds3_sensor_data *sdata = container_of(sensors_cdev,
+							struct lsm6ds3_sensor_data, class_dev); 
+
+	struct input_dev  * input  	= sdata->input_dev;
+
+	get_monotonic_boottime(&ts);
+	input_event(input, EV_SYN, SYN_TIME_SEC, ts.tv_sec);
+	input_event(input, EV_SYN, SYN_TIME_NSEC, ts.tv_nsec);
+	input_sync(input);
+	return 0;
+}
+
+static int lsm6ds3_sysclass_register(struct device *dev, 
+                          struct lsm6ds3_sensor_data *sdata){
+	int ret;
+	
+	switch (sdata->sindex){
+	case LSM6DS3_ACCEL:
+		sdata->class_dev = lsm6ds3_acc_classdev;
+		break;
+	case LSM6DS3_GYRO:
+		sdata->class_dev = lsm6ds3_gyr_classdev;
+		break;
+/**************************************************
+	case LSM6DS3_STEP_COUNTER:
+		sdata->class_dev = lsm6ds3_step_counter_classdev;
+		break;
+	case LSM6DS3_STEP_DETECTOR:
+		sdata->class_dev = lsm6ds3_step_detector_classdev;
+		break;
+**************************************************/
+	default:
+		return -1;
+	}
+	
+	sdata->class_dev.sensors_enable= lsm6ds3_devenable;
+	sdata->class_dev.sensors_flush = lsm6ds3_flush;
+
+	if ((sdata->sindex == LSM6DS3_ACCEL) || (sdata->sindex == LSM6DS3_GYRO)){
+		sdata->class_dev.sensors_poll_delay = lsm6ds3_devdelay;
+		sdata->class_dev.sensors_calibrate = lsm6ds3_calibrate;
+		sdata->class_dev.sensors_write_cal_params= lsm6ds3_write_cali_params;
+	}
+	
+	ret = sensors_classdev_register(dev, &sdata->class_dev);
+	if (ret)
+		return -1;
+	return 0;
+}
+#if 0
+static int lsm6ds3_pinctrl_init(struct lsm6ds3_data *cdata){
+
+	cdata->pinctrl = devm_pinctrl_get(cdata->dev);
+	if (IS_ERR_OR_NULL(cdata->pinctrl)) {
+		dev_err(cdata->dev, "Failed to get pinctrl\n");
+		return PTR_ERR(cdata->pinctrl);
+	}
+
+	cdata->pin_default = pinctrl_lookup_state(cdata->pinctrl, "default");
+	if (IS_ERR_OR_NULL(cdata->pin_default)) {
+		dev_err(cdata->dev, "Failed to look up default state\n");
+		return PTR_ERR(cdata->pin_default);
+	}
+
+	cdata->pin_sleep = pinctrl_lookup_state(cdata->pinctrl, "sleep");
+	if (IS_ERR_OR_NULL(cdata->pin_sleep)) {
+		dev_err(cdata->dev, "Failed to look up sleep state\n");
+		return PTR_ERR(cdata->pin_sleep);
+	}
+
+	return 0;
+}
+#endif
+//end add 
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm6ds3_dt_id[] = {
+	{.compatible = "st,lsm6ds3",},
+	{},
+};
+MODULE_DEVICE_TABLE(of, lsm6ds3_dt_id);
+
+static u32 lsm6ds3_parse_dt(struct lsm6ds3_data *cdata)
+{
+	u32 val;
+	struct device_node *np;
+
+	np = cdata->dev->of_node;
+	if (!np)
+		return -EINVAL;
+
+	if (!of_property_read_u32(np, "st,drdy-int-pin", &val) &&
+							(val <= 2) && (val > 0))
+		cdata->drdy_int_pin = (u8)val;
+	else
+		cdata->drdy_int_pin = 1;
+
+	val = of_get_named_gpio_flags(np, "st,intr1", 0, NULL);
+	if (val < 0) {
+		dev_err(cdata->dev, "Unable to read intr\n");
+		return val;
+	}
+	cdata->gpio_irq1 = val;
+
+	if (gpio_request_one(cdata->gpio_irq1, GPIOF_DIR_IN, "lsm6ds3_gpio_intr1")){
+		dev_err(cdata->dev,	"%s: GPIO %d Request Fail\n", __func__, cdata->gpio_irq1);
+		return -1;
+	}
+	return 0;
+}
+
+#else
+#endif
+
+int lsm6ds3_common_probe(struct lsm6ds3_data *cdata, int irq, u16 bustype)
+{
+	/* TODO: add errors management */
+	int32_t err, i;
+	u8 wai =0x00;
+	struct lsm6ds3_sensor_data *sdata;
+
+	mutex_init(&cdata->bank_registers_lock);
+	mutex_init(&cdata->fifo_lock);
+	cdata->fifo_data_buffer = 0;
+
+	err = cdata->tf->read(cdata, LSM6DS3_WHO_AM_I, 1, &wai, true);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to read Who-Am-I register.\n");
+		return err;
+	}
+	if (wai != LSM6DS3_WHO_AM_I_DEF) {
+		dev_err(cdata->dev, "Who-Am-I value not valid.\n");
+		return -ENODEV;
+	}
+
+	mutex_init(&cdata->lock);
+
+	if (irq > 0) {
+#ifdef CONFIG_OF
+		err = lsm6ds3_parse_dt(cdata);
+		if (err < 0)
+			return err;
+#else /* CONFIG_OF */
+		if (cdata->dev->platform_data) {
+			cdata->drdy_int_pin = ((struct lsm6ds3_platform_data *)
+					cdata->dev->platform_data)->drdy_int_pin;
+
+			if ((cdata->drdy_int_pin > 2) || (cdata->drdy_int_pin < 1))
+				cdata->drdy_int_pin = 1;
+		} else
+			cdata->drdy_int_pin = 1;
+#endif /* CONFIG_OF */
+
+		dev_info(cdata->dev, "driver use DRDY int pin %d\n",
+							cdata->drdy_int_pin);
+	}
+#if 0
+	/* initialize pinctrl */
+	if (!lsm6ds3_pinctrl_init(cdata)) {
+		err = pinctrl_select_state(cdata->pinctrl, cdata->pin_default);
+		if (err) {
+			dev_err(cdata->dev, "Can't select pinctrl state\n");
+			return err;
+		}
+	}
+#endif
+	for (i = 0; i < LSM6DS3_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+		sdata->enabled = false;
+		sdata->cdata = cdata;
+		sdata->sindex = i;
+		sdata->name = lsm6ds3_sensor_name[i].name;
+		sdata->fifo_length = 1;
+		if ((i == LSM6DS3_ACCEL) || (i == LSM6DS3_GYRO)) {
+			sdata->c_odr = lsm6ds3_odr_table.odr_avl[0].hz;
+			sdata->c_gain = lsm6ds3_fs_table[i].fs_avl[0].gain;
+#if defined (CONFIG_LSM6DS3_POLLING_MODE)
+			sdata->poll_interval = 1000 / sdata->c_odr;
+#endif
+		}
+		if (i == LSM6DS3_STEP_COUNTER) {
+			sdata->c_odr = LSM6DS3_MIN_DURATION_MS;
+		}
+
+		lsm6ds3_input_init(sdata, bustype, lsm6ds3_sensor_name[i].description);
+
+		if (sysfs_create_group(&sdata->input_dev->dev.kobj,
+						&lsm6ds3_attribute_groups[i])) {
+			dev_err(cdata->dev, "failed to create sysfs group for sensor %s",
+								sdata->name);
+			input_unregister_device(sdata->input_dev);
+			sdata->input_dev = NULL;
+		}
+		err = lsm6ds3_sysclass_register(cdata->dev, sdata);
+		if (err < 0) {
+			dev_err(cdata->dev, "failed to create sensor class for sensor %s", sdata->name);
+			input_unregister_device(sdata->input_dev);
+			sdata->input_dev = NULL;
+		}
+		
+	}
+
+	if(lsm6ds3_workqueue == 0)
+		lsm6ds3_workqueue = alloc_workqueue("lsm6ds3_workqueue",
+				WQ_UNBOUND | WQ_MEM_RECLAIM | WQ_HIGHPRI, 1);
+	//		create_workqueue("lsm6ds3_workqueue");
+
+	err = lsm6ds3_init_sensors(cdata);
+	if (err < 0)
+		return err;
+	if (irq > 0)
+		cdata->irq = irq;
+
+	if (irq > 0) {
+		err = lsm6ds3_interrupt_init(cdata);
+		if (err < 0)
+			return err;
+	}
+
+	cdata->fifo_data_buffer = kmalloc(LSM6DS3_MAX_FIFO_SIZE, GFP_KERNEL);
+	if (!cdata->fifo_data_buffer)
+		return -ENOMEM;
+
+	cdata->fifo_data_size = LSM6DS3_MAX_FIFO_SIZE;
+
+	dev_info(cdata->dev, "%s: probed\n", LSM6DS3_ACC_GYR_DEV_NAME);
+	return 0;
+}
+EXPORT_SYMBOL(lsm6ds3_common_probe);
+
+void lsm6ds3_common_remove(struct lsm6ds3_data *cdata, int irq)
+{
+	u8 i;
+
+	for (i = 0; i < LSM6DS3_SENSORS_NUMB; i++) {
+		lsm6ds3_disable_sensors(&cdata->sensors[i]);
+		lsm6ds3_input_cleanup(&cdata->sensors[i]);
+		sensors_classdev_unregister(&cdata->sensors[i].class_dev);
+	}
+
+	//remove_sysfs_interfaces(cdata->dev);
+
+	if(!lsm6ds3_workqueue) {
+		flush_workqueue(lsm6ds3_workqueue);
+		destroy_workqueue(lsm6ds3_workqueue);
+	}
+
+	kfree(cdata->fifo_data_buffer);
+}
+EXPORT_SYMBOL(lsm6ds3_common_remove);
+
+#ifdef CONFIG_PM
+int lsm6ds3_common_suspend(struct lsm6ds3_data *cdata)
+{
+	int i, ret;
+	struct lsm6ds3_sensor_data *sdata;  
+	for (i = 0; i < LSM6DS3_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+		if (sdata->enabled) {
+			printk("lsm6ds3 suspend:%d\n", i);
+			ret = lsm6ds3_disable_sensors(sdata);
+			if (ret) {
+			dev_err(cdata->dev, "%s failed\n", __FUNCTION__);
+			return ret;
+			}
+		}
+	}
+	dev_info(cdata->dev, "%s\n", __FUNCTION__); 
+	return 0;
+
+}
+EXPORT_SYMBOL(lsm6ds3_common_suspend);
+
+int lsm6ds3_common_resume(struct lsm6ds3_data *cdata)
+{
+	int i, ret;
+	struct lsm6ds3_sensor_data *sdata;  
+	for (i = 0; i < LSM6DS3_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+		if (sdata->class_dev.enabled) {
+			printk("lsm6ds3 resume:%d\n", i);
+			ret = lsm6ds3_enable_sensors(sdata);
+			if (ret) {
+			dev_err(cdata->dev, "%s failed\n", __FUNCTION__);
+			return ret;
+			}
+		}
+	}
+	dev_info(cdata->dev, "%s\n", __FUNCTION__); 
+	return 0;
+}
+EXPORT_SYMBOL(lsm6ds3_common_resume);
+#endif /* CONFIG_PM */
+
diff --git a/drivers/input/misc/lsm6ds3_core.h b/drivers/input/misc/lsm6ds3_core.h
new file mode 100755
index 00000000000..315debc1e91
--- /dev/null
+++ b/drivers/input/misc/lsm6ds3_core.h
@@ -0,0 +1,193 @@
+/*
+ * STMicroelectronics lsm6ds3 driver
+ *
+ * Copyright 2014 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * v 1.1.0
+ * Licensed under the GPL-2.
+ */
+
+#ifndef DRIVERS_INPUT_MISC_LSM6DS3_CORE_H_
+#define DRIVERS_INPUT_MISC_LSM6DS3_CORE_H_
+
+#include <linux/sensors.h>
+
+#define HZ_TO_PERIOD_NSEC(hz)		(1000 * 1000 * 1000 / ((u32)(hz)))
+#define MS_TO_US(x)			({ typeof(x) _x = (x); ((_x) * \
+							((typeof(x)) 1000));})
+#define US_TO_NS(x)			(MS_TO_US(x))
+#define MS_TO_NS(x)			(US_TO_NS(MS_TO_US(x)))
+#define US_TO_MS(x)			({ typeof(x) _x = (x); ((_x) / \
+							((typeof(x)) 1000));})
+#define NS_TO_US(x)			(US_TO_MS(x))
+#define NS_TO_MS(x)			(US_TO_MS(NS_TO_US(x)))
+
+
+enum {
+	LSM6DS3_ACCEL = 0,
+	LSM6DS3_GYRO,
+	LSM6DS3_SIGN_MOTION,
+	LSM6DS3_STEP_COUNTER,
+	LSM6DS3_STEP_DETECTOR,
+	LSM6DS3_TILT,
+	LSM6DS3_SENSORS_NUMB,
+};
+
+enum fifo_mode {
+	BYPASS = 0,
+	CONTINUOS,
+};
+
+#define DEF_ZERO			(0x00)
+
+#define LSM6DS3_ACC_OUT_X_L_ADDR	(0x28)
+#define LSM6DS3_GYR_OUT_X_L_ADDR	(0x22)
+
+#define LSM6DS3_ACC_ODR_ADDR		CTRL1_ADDR
+#define LSM6DS3_ACC_ODR_MASK		(0xf0)
+#define LSM6DS3_GYR_ODR_ADDR		CTRL2_ADDR
+#define LSM6DS3_GYR_ODR_MASK		(0xf0)
+
+#define LSM6DS3_ACC_FS_ADDR		CTRL1_ADDR
+#define LSM6DS3_GYR_FS_ADDR		CTRL2_ADDR
+
+#define LSM6DS3_IF_INC_MASK		(0x04)
+
+#define LSM6DS3_HPERF_GYR_ADDR		CTRL7_ADDR
+#define LSM6DS3_HPERF_GYR_MASK		(0x80)
+
+#define LSM6DS3_HPERF_ACC_ADDR		CTRL6_ADDR
+#define LSM6DS3_HPERF_ACC_MASK		(0x10)
+#define LSM6DS3_HPERF_ACC_ENABLE	(0x00)
+
+#define CTRL1_ADDR			(0x10)
+#define CTRL2_ADDR			(0x11)
+#define CTRL3_ADDR			(0x12)
+#define CTRL6_ADDR			(0x15)
+#define CTRL7_ADDR			(0x16)
+
+
+/* Sensitivity Acc */
+#define SENSITIVITY_ACC_2G		(61)	/** ug/LSB */
+#define SENSITIVITY_ACC_4G		(122)	/** ug/LSB */
+#define SENSITIVITY_ACC_8G		(244)	/** ug/LSB */
+#define SENSITIVITY_ACC_16G		(488)	/** ug/LSB */
+/* Sensitivity Gyr */
+#define SENSITIVITY_GYR_125		(437)	/** 10udps/LSB */
+#define SENSITIVITY_GYR_245		(875)	/** 10udps/LSB */
+#define SENSITIVITY_GYR_500		(1750)	/** 10udps/LSB */
+#define SENSITIVITY_GYR_1000		(3500)	/** 10udps/LSB */
+#define SENSITIVITY_GYR_2000		(7000)	/** 10udps/LSB */
+
+#define FUZZ				(0)
+#define FLAT				(0)
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+#define LSM6DS3_RX_MAX_LENGTH		(500)
+#define LSM6DS3_TX_MAX_LENGTH		(500)
+
+#define to_dev(obj) container_of(obj, struct device, kobj)
+
+struct reg_rw {
+	u8 const address;
+	u8 const init_val;
+	u8 resume_val;
+};
+
+struct reg_r {
+	const u8 address;
+	const u8 init_val;
+};
+
+struct lsm6ds3_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[LSM6DS3_RX_MAX_LENGTH];
+	u8 tx_buf[LSM6DS3_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct lsm6ds3_data;
+
+struct lsm6ds3_transfer_function {
+	int (*write) (struct lsm6ds3_data *cdata, u8 reg_addr, int len, u8 *data,
+								bool b_lock);
+	int (*read) (struct lsm6ds3_data *cdata, u8 reg_addr, int len, u8 *data,
+								bool b_lock);
+};
+
+struct lsm6ds3_sensor_data {
+	struct lsm6ds3_data *cdata;
+	const char* name;
+	s64 timestamp;
+	u8 enabled;
+	u32 c_odr;
+	u32 c_gain;
+	u8 sindex;
+	u8 sample_to_discard;
+
+	u16 fifo_length;
+	u8 sample_in_pattern;
+	s64 deltatime;
+	s32 cali_data[3];
+
+	struct input_dev *input_dev;
+	struct sensors_classdev class_dev;
+#if defined (CONFIG_LSM6DS3_POLLING_MODE)
+	unsigned int poll_interval;
+	struct hrtimer hr_timer;
+	struct work_struct input_work;
+	ktime_t ktime;
+#endif
+};
+
+struct lsm6ds3_data {
+	const char *name;
+
+	bool reset_steps;
+	bool sign_motion_event_ready;
+	u16 steps_c;
+
+	u8 drdy_int_pin;
+	u8 gyro_selftest_status;
+	u8 accel_selftest_status;
+	struct pinctrl		*pinctrl;
+	struct pinctrl_state	*pin_default;
+	struct pinctrl_state	*pin_sleep;
+
+	struct mutex lock;
+	int irq;
+	int gpio_irq1;
+
+	s64 timestamp;
+	struct work_struct input_work;
+	struct device *dev;
+	struct lsm6ds3_sensor_data sensors[LSM6DS3_SENSORS_NUMB];
+
+	struct mutex bank_registers_lock;
+	struct mutex fifo_lock;
+	u16 fifo_data_size;
+	u8 *fifo_data_buffer;
+	u16 fifo_threshold;
+
+	const struct lsm6ds3_transfer_function *tf;
+	struct lsm6ds3_transfer_buffer tb;
+};
+
+
+int lsm6ds3_common_probe(struct lsm6ds3_data *cdata, int irq, u16 bustype);
+void lsm6ds3_common_remove(struct lsm6ds3_data *cdata, int irq);
+int lsm6ds3_common_resume(struct lsm6ds3_data *cdata);
+int lsm6ds3_common_suspend(struct lsm6ds3_data *cdata);
+
+#ifdef CONFIG_PM
+int lsm6ds3_common_suspend(struct lsm6ds3_data *cdata);
+int lsm6ds3_common_resume(struct lsm6ds3_data *cdata);
+#endif /* CONFIG_PM */
+
+#endif /* DRIVERS_INPUT_MISC_LSM6DS3_CORE_H_ */
diff --git a/drivers/input/misc/lsm6ds3_i2c.c b/drivers/input/misc/lsm6ds3_i2c.c
new file mode 100755
index 00000000000..ba965b87f25
--- /dev/null
+++ b/drivers/input/misc/lsm6ds3_i2c.c
@@ -0,0 +1,175 @@
+/*
+ * STMicroelectronics lsm6ds3 i2c driver
+ *
+ * Copyright 2014 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * v 1.1.0
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#include	<linux/platform_data/lsm6ds3.h>
+#include	"lsm6ds3_core.h"
+
+static int lsm6ds3_i2c_read(struct lsm6ds3_data *cdata, u8 reg_addr, int len,
+							u8 *data, bool b_lock)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, msg, 2);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else
+		err = i2c_transfer(client->adapter, msg, 2);
+
+	return err;
+}
+
+static int lsm6ds3_i2c_write(struct lsm6ds3_data *cdata, u8 reg_addr, int len,
+							u8 *data, bool b_lock)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, &msg, 1);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else
+		err = i2c_transfer(client->adapter, &msg, 1);
+
+	return err;
+}
+
+
+static const struct lsm6ds3_transfer_function lsm6ds3_tf_i2c = {
+	.write = lsm6ds3_i2c_write,
+	.read = lsm6ds3_i2c_read,
+};
+
+static int lsm6ds3_i2c_probe(struct i2c_client *client,
+						const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm6ds3_data *cdata;
+
+	cdata = kzalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->tf = &lsm6ds3_tf_i2c;
+	i2c_set_clientdata(client, cdata);
+
+	err = lsm6ds3_common_probe(cdata, client->irq, BUS_I2C);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+	return err;
+}
+
+static int lsm6ds3_i2c_remove(struct i2c_client *client)
+{
+	/* TODO: check the function */
+	struct lsm6ds3_data *cdata = i2c_get_clientdata(client);
+
+	lsm6ds3_common_remove(cdata, client->irq);
+	dev_info(cdata->dev, "%s: removed\n", LSM6DS3_ACC_GYR_DEV_NAME);
+	kfree(cdata);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lsm6ds3_suspend(struct device *dev)
+{
+	struct lsm6ds3_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lsm6ds3_common_suspend(cdata);
+}
+
+static int lsm6ds3_resume(struct device *dev)
+{
+	struct lsm6ds3_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lsm6ds3_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lsm6ds3_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm6ds3_suspend, lsm6ds3_resume)
+};
+
+#define LSM6DS3_PM_OPS		(&lsm6ds3_pm_ops)
+#else /* CONFIG_PM */
+#define LSM6DS3_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+
+static const struct i2c_device_id lsm6ds3_ids[] = {
+	{"lsm6ds3", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lsm6ds3_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm6ds3_id_table[] = {
+	{.compatible = "st,lsm6ds3", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm6ds3_id_table);
+#endif
+
+static struct i2c_driver lsm6ds3_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LSM6DS3_ACC_GYR_DEV_NAME,
+		.pm = LSM6DS3_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = lsm6ds3_id_table,
+#endif
+	},
+	.probe    = lsm6ds3_i2c_probe,
+	.remove   = lsm6ds3_i2c_remove,
+	.id_table = lsm6ds3_ids,
+};
+
+module_i2c_driver(lsm6ds3_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lsm6ds3 i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/misc/ltr553_test.c b/drivers/input/misc/ltr553_test.c
new file mode 100644
index 00000000000..cc79179ae2c
--- /dev/null
+++ b/drivers/input/misc/ltr553_test.c
@@ -0,0 +1,6337 @@
+/* Lite-On LTR-553ALS Android / Linux Driver
+ *
+ * Copyright (C) 2013-2014 Lite-On Technology Corp (Singapore)
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ */
+//#define DEBUG 1
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/gfp.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/wakelock.h>
+#include <linux/workqueue.h>
+#include <linux/uaccess.h>
+//#include <asm/mach-types.h>
+#include <asm/setup.h>
+#include <linux/version.h>
+#include <linux/sensors.h>
+#include <linux/of_gpio.h>
+#include <linux/regulator/consumer.h>
+
+/* LTR-553 Registers */
+#define LTR553_ALS_CONTR	0x80
+#define LTR553_PS_CONTR		0x81
+#define LTR553_PS_LED		0x82
+#define LTR553_PS_N_PULSES	0x83
+#define LTR553_PS_MEAS_RATE	0x84
+#define LTR553_ALS_MEAS_RATE	0x85
+#define LTR553_PART_ID		0x86
+#define LTR553_MANUFACTURER_ID	0x87
+#define LTR553_ALS_DATA_CH1_0	0x88
+#define LTR553_ALS_DATA_CH1_1	0x89
+#define LTR553_ALS_DATA_CH0_0	0x8A
+#define LTR553_ALS_DATA_CH0_1	0x8B
+#define LTR553_ALS_PS_STATUS	0x8C
+#define LTR553_PS_DATA_0	0x8D
+#define LTR553_PS_DATA_1	0x8E
+#define LTR553_INTERRUPT	0x8F
+#define LTR553_PS_THRES_UP_0	0x90
+#define LTR553_PS_THRES_UP_1	0x91
+#define LTR553_PS_THRES_LOW_0	0x92
+#define LTR553_PS_THRES_LOW_1	0x93
+#define LTR553_PS_OFFSET_1	0x94
+#define LTR553_PS_OFFSET_0	0x95
+#define LTR553_ALS_THRES_UP_0	0x97
+#define LTR553_ALS_THRES_UP_1	0x98
+#define LTR553_ALS_THRES_LOW_0	0x99
+#define LTR553_ALS_THRES_LOW_1	0x9A
+#define LTR553_INTERRUPT_PRST	0x9E
+/* LTR-553 Registers */
+
+
+#define SET_BIT 1
+#define CLR_BIT 0
+
+#define ALS 0
+#define PS 1
+#define ALSPS 2
+/*#define PS_W_SATURATION_BIT	3*/
+
+/* address 0x80 */
+#define ALS_MODE_ACTIVE	(1 << 0)
+#define ALS_MODE_STDBY		(0 << 0)
+#define ALS_SW_RESET		(1 << 1)
+#define ALS_SW_NRESET		(0 << 1)
+#define ALS_GAIN_1x		(0 << 2)
+#define ALS_GAIN_2x		(1 << 2)
+#define ALS_GAIN_4x		(2 << 2)
+#define ALS_GAIN_8x		(3 << 2)
+#define ALS_GAIN_48x	(6 << 2)
+#define ALS_GAIN_96x	(7 << 2)
+#define ALS_MODE_RDBCK			0
+#define ALS_SWRT_RDBCK			1
+#define ALS_GAIN_RDBCK			2
+#define ALS_CONTR_RDBCK		3
+
+/* address 0x81 */
+#define PS_MODE_ACTIVE		(3 << 0)
+#define PS_MODE_STDBY		(0 << 0)
+#define PS_GAIN_16x			(0 << 2)
+#define PS_GAIN_32x			(2 << 2)
+#define PS_GAIN_64x			(3 << 2)
+#define PS_SATUR_INDIC_EN	(1 << 5)
+#define PS_SATU_INDIC_DIS	(0 << 5)
+#define PS_MODE_RDBCK		0
+#define PS_GAIN_RDBCK		1
+#define PS_SATUR_RDBCK		2
+#define PS_CONTR_RDBCK		3
+
+/* address 0x82 */
+#define LED_CURR_5MA		(0 << 0)
+#define LED_CURR_10MA		(1 << 0)
+#define LED_CURR_20MA		(2 << 0)
+#define LED_CURR_50MA		(3 << 0)
+#define LED_CURR_100MA		(4 << 0)
+#define LED_CURR_DUTY_25PC		(0 << 3)
+#define LED_CURR_DUTY_50PC		(1 << 3)
+#define LED_CURR_DUTY_75PC		(2 << 3)
+#define LED_CURR_DUTY_100PC	(3 << 3)
+#define LED_PUL_FREQ_30KHZ		(0 << 5)
+#define LED_PUL_FREQ_40KHZ		(1 << 5)
+#define LED_PUL_FREQ_50KHZ		(2 << 5)
+#define LED_PUL_FREQ_60KHZ		(3 << 5)
+#define LED_PUL_FREQ_70KHZ		(4 << 5)
+#define LED_PUL_FREQ_80KHZ		(5 << 5)
+#define LED_PUL_FREQ_90KHZ		(6 << 5)
+#define LED_PUL_FREQ_100KHZ	(7 << 5)
+#define LED_CURR_RDBCK			0
+#define LED_CURR_DUTY_RDBCK	1
+#define LED_PUL_FREQ_RDBCK		2
+#define PS_LED_RDBCK			3
+
+/* address 0x84 */
+#define PS_MEAS_RPT_RATE_50MS		(0 << 0)
+#define PS_MEAS_RPT_RATE_70MS		(1 << 0)
+#define PS_MEAS_RPT_RATE_100MS	(2 << 0)
+#define PS_MEAS_RPT_RATE_200MS	(3 << 0)
+#define PS_MEAS_RPT_RATE_500MS	(4 << 0)
+#define PS_MEAS_RPT_RATE_1000MS	(5 << 0)
+#define PS_MEAS_RPT_RATE_2000MS	(6 << 0)
+#define PS_MEAS_RPT_RATE_10MS		(8 << 0)
+
+/* address 0x85 */
+#define ALS_MEAS_RPT_RATE_50MS	(0 << 0)
+#define ALS_MEAS_RPT_RATE_100MS	(1 << 0)
+#define ALS_MEAS_RPT_RATE_200MS	(2 << 0)
+#define ALS_MEAS_RPT_RATE_500MS	(3 << 0)
+#define ALS_MEAS_RPT_RATE_1000MS	(4 << 0)
+#define ALS_MEAS_RPT_RATE_2000MS	(5 << 0)
+#define ALS_INTEG_TM_100MS		(0 << 3)
+#define ALS_INTEG_TM_50MS			(1 << 3)
+#define ALS_INTEG_TM_200MS		(2 << 3)
+#define ALS_INTEG_TM_400MS		(3 << 3)
+#define ALS_INTEG_TM_150MS		(4 << 3)
+#define ALS_INTEG_TM_250MS		(5 << 3)
+#define ALS_INTEG_TM_300MS		(6 << 3)
+#define ALS_INTEG_TM_350MS		(7 << 3)
+#define ALS_MEAS_RPT_RATE_RDBCK	0
+#define ALS_INTEG_TM_RDBCK			1
+#define ALS_MEAS_RATE_RDBCK		2
+
+/* address 0x86 */
+#define PART_NUM_ID_RDBCK		0
+#define REVISION_ID_RDBCK		1
+#define PART_ID_REG_RDBCK		2
+
+/* address 0x8C */
+#define PS_DATA_STATUS_RDBCK		0
+#define PS_INTERR_STATUS_RDBCK	1
+#define ALS_DATA_STATUS_RDBCK		2
+#define ALS_INTERR_STATUS_RDBCK	3
+#define ALS_GAIN_STATUS_RDBCK		4
+#define ALS_VALID_STATUS_RDBCK	5
+#define ALS_PS_STATUS_RDBCK		6
+
+/* address 0x8F */
+#define INT_MODE_00					(0 << 0)
+#define INT_MODE_PS_TRIG			(1 << 0)
+#define INT_MODE_ALS_TRIG			(2 << 0)
+#define INT_MODE_ALSPS_TRIG		(3 << 0)
+#define INT_POLAR_ACT_LO			(0 << 2)
+#define INT_POLAR_ACT_HI			(1 << 2)
+#define INT_MODE_RDBCK				0
+#define INT_POLAR_RDBCK			1
+#define INT_INTERRUPT_RDBCK		2
+
+/* address 0x9E */
+#define ALS_PERSIST_SHIFT	0
+#define PS_PERSIST_SHIFT	4
+#define ALS_PRST_RDBCK		0
+#define PS_PRST_RDBCK		1
+#define ALSPS_PRST_RDBCK	2
+
+#define PON_DELAY		100
+
+#define ALS_MIN_MEASURE_VAL	0
+#define ALS_MAX_MEASURE_VAL	65535
+#define ALS_VALID_MEASURE_MASK	ALS_MAX_MEASURE_VAL
+#define PS_MIN_MEASURE_VAL	0
+#define PS_MAX_MEASURE_VAL	2047
+#define PS_VALID_MEASURE_MASK   PS_MAX_MEASURE_VAL
+#define LO_LIMIT			0
+#define HI_LIMIT			1
+#define LO_N_HI_LIMIT	2
+#define PS_OFFSET_MIN_VAL		0
+#define PS_OFFSET_MAX_VAL		1023
+#define ps_low_thres		800
+#define ps_high_thres		300
+#define		FAR_VAL		1
+#define		NEAR_VAL		0
+
+#define DRIVER_VERSION "1.13"
+#define PARTID 0x92
+#define MANUID 0x05
+
+#define I2C_RETRY 5
+
+#define DEVICE_NAME "LTR553ALSPS"
+
+#define ACT_INTERRUPT 1
+
+#define PS_THRESHOLD_MAX 0xFFF
+#define PS_THRESHOLD_MIN 0x0
+#define MIN_THD    150
+#define MAX_THD    250
+/*
+ * Magic Number
+ * ============
+ * Refer to file ioctl-number.txt for allocation
+ */
+#define LTR553_IOCTL_MAGIC      'c'
+
+/* IOCTLs for ltr553 device */
+#define LTR553_IOCTL_PS_ENABLE		_IOR(LTR553_IOCTL_MAGIC, 1, int *)
+#define LTR553_IOCTL_PS_GET_ENABLED	_IOW(LTR553_IOCTL_MAGIC, 2, int *)
+#define LTR553_IOCTL_ALS_ENABLE		_IOR(LTR553_IOCTL_MAGIC, 3, int *)
+#define LTR553_IOCTL_ALS_GET_ENABLED	_IOW(LTR553_IOCTL_MAGIC, 4, int *)
+
+/* whether disable light or not at phone
+  * calling while the automatic backlight is on.
+  * the default value is 1.
+  */
+#define SUPPORT_AUTO_BACKLIGHT 0
+
+/* POWER SUPPLY VOLTAGE RANGE */
+#define LTR553_VDD_MIN_UV	2000000
+#define LTR553_VDD_MAX_UV	3300000
+#define LTR553_VIO_MIN_UV	1750000
+#define LTR553_VIO_MAX_UV	1950000
+
+#define LUX_LEVEL 6
+static uint16_t lux_level_default[LUX_LEVEL] = {0, 10, 50, 100, 200, 1000};
+static uint16_t lux_level_test01a[LUX_LEVEL] = {0, 10, 50, 100, 200, 1000};
+static uint16_t *lux_level;
+static int spirit_flage = 0;
+
+/*(Linux RTOS)>*/
+struct ltr553_platform_data {
+	/* ALS */
+	uint16_t pfd_levels[5];
+	uint16_t pfd_als_lowthresh;
+	uint16_t pfd_als_highthresh;
+	int pfd_disable_als_on_suspend;
+
+	/* PS */
+	uint16_t pfd_ps_lowthresh;
+	uint16_t pfd_ps_highthresh;
+	int pfd_disable_ps_on_suspend;
+
+	/* Interrupt */
+	int pfd_gpio_int_no;
+
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(bool);
+};
+
+struct ltr553_data {
+	/* Device */
+	struct i2c_client *i2c_client;
+	struct input_dev *als_input_dev;
+	struct input_dev *ps_input_dev;
+	struct workqueue_struct *workqueue;
+	struct wake_lock ps_wake_lock;
+	struct mutex ps_lock;
+	struct mutex bus_lock;
+	struct sensors_classdev als_cdev;
+	struct sensors_classdev ps_cdev;
+
+	struct ltr553_platform_data *platform_data;
+	/* regulator data */
+	bool power_on;
+	struct regulator *vdd;
+	struct regulator *vio;
+
+	/* control flag from HAL */
+	unsigned int enable_ps_sensor;
+	unsigned int enable_als_sensor;
+
+	unsigned int als_enable_state;
+	unsigned int ps_enable_state;
+
+	/* Device mode
+	 * 0 = ALS
+	 * 1 = PS
+	 */
+	uint8_t mode;
+
+	/* ALS */
+	uint8_t als_enable_flag;
+	uint8_t als_suspend_enable_flag;
+	uint8_t als_irq_flag;
+	uint8_t als_opened;
+	uint16_t als_lowthresh;
+	uint16_t als_highthresh;
+	uint16_t default_als_lowthresh;
+	uint16_t default_als_highthresh;
+	uint16_t *adc_levels;
+	/* Flag to suspend ALS on suspend or not */
+	uint8_t disable_als_on_suspend;
+
+	/* PS */
+	uint8_t ps_cali;
+	uint8_t ps_enable_flag;
+	uint8_t ps_suspend_enable_flag;
+	uint8_t ps_irq_flag;
+	uint8_t ps_opened;
+	uint16_t ps_lowthresh;
+	uint16_t ps_highthresh;
+	uint16_t default_ps_lowthresh;
+	uint16_t default_ps_highthresh;
+	/* Flag to suspend PS on suspend or not */
+	uint8_t disable_ps_on_suspend;
+
+	/* LED */
+	int led_pulse_freq;
+	int led_duty_cyc;
+	int led_peak_curr;
+	int led_pulse_count;
+
+	/* Interrupt */
+	int irq;
+	int gpio_int_no;
+	int is_suspend;
+};
+
+/*
+ * Global data
+ */
+static struct ltr553_data *pdev_data;
+
+struct ltr553_data *sensor_info;
+
+static struct sensors_classdev sensors_light_cdev = {
+	.name = "ltr553_light",
+	.vendor = "liteon",
+	.version = 1,
+	.handle = SENSORS_LIGHT_HANDLE,
+	.type = SENSOR_TYPE_LIGHT,
+	.max_range = "30000",
+	.resolution = "0.0125",
+	.sensor_power = "0.20",
+	.min_delay = 1000, /* in microseconds */
+	.fifo_reserved_event_count = 0,
+	.fifo_max_event_count = 0,
+	.enabled = 0,
+	.delay_msec = 100,
+	.sensors_enable = NULL,
+	.sensors_poll_delay = NULL,
+};
+
+static struct sensors_classdev sensors_proximity_cdev = {
+	.name = "ltr553_proximity",
+	.vendor = "liteon",
+	.version = 1,
+	.handle = SENSORS_PROXIMITY_HANDLE,
+	.type = SENSOR_TYPE_PROXIMITY,
+	.max_range = "5",
+	.resolution = "5.0",
+	.sensor_power = "3",
+	.min_delay = 1000, /* in microseconds */
+	.flags = 1,
+	.fifo_reserved_event_count = 0,
+	.fifo_max_event_count = 0,
+	.enabled = 0,
+	.delay_msec = 100,
+	.sensors_enable = NULL,
+	.sensors_poll_delay = NULL,
+};
+
+#define	PS_MAX_INIT_KEPT_DATA_COUNTER		8
+#define	PS_MAX_MOV_AVG_KEPT_DATA_CTR		7
+
+uint16_t winfac1 = 10;/*100;*/
+uint16_t winfac2 = 10;/*80;*/
+uint16_t winfac3 = 10;/*44;*/
+uint8_t eqn_prev;
+uint8_t ratio_old;
+uint16_t ps_init_kept_data[PS_MAX_INIT_KEPT_DATA_COUNTER];
+uint16_t ps_ct_avg;
+uint8_t ps_grabData_stage;
+uint32_t ftn_init;
+uint32_t ftn_final;
+uint32_t ntf_final;
+uint16_t lux_val_prev;
+uint8_t ps_kept_data_counter;
+uint16_t ps_movavg_data[PS_MAX_MOV_AVG_KEPT_DATA_CTR];
+uint8_t ps_movavg_data_counter;
+uint16_t ps_movct_avg;
+/*uint16_t ps_thresh_hi, ps_thresh_lo;*/
+
+static int ltr553_regulator_configure(struct ltr553_data *data, bool on)
+{
+	int rc;
+
+	if (!on) {
+		if (regulator_count_voltages(data->vdd) > 0)
+			regulator_set_voltage(data->vdd, 0,
+				LTR553_VDD_MAX_UV);
+
+		regulator_put(data->vdd);
+
+		if (regulator_count_voltages(data->vio) > 0)
+			regulator_set_voltage(data->vio, 0,
+				LTR553_VIO_MAX_UV);
+
+		regulator_put(data->vio);
+	} else {
+		data->vdd = regulator_get(&data->i2c_client->dev, "vdd");
+		if (IS_ERR(data->vdd)) {
+			rc = PTR_ERR(data->vdd);
+			dev_err(&data->i2c_client->dev,
+				"Regulator get failed vdd rc=%d\n", rc);
+			return rc;
+		}
+
+		if (regulator_count_voltages(data->vdd) > 0) {
+			rc = regulator_set_voltage(data->vdd,
+				LTR553_VDD_MIN_UV, LTR553_VDD_MAX_UV);
+			if (rc) {
+				dev_err(&data->i2c_client->dev,
+					"Regulator set failed vdd rc=%d\n",
+					rc);
+				goto reg_vdd_put;
+			}
+		}
+
+		data->vio = regulator_get(&data->i2c_client->dev, "vio");
+		if (IS_ERR(data->vio)) {
+			rc = PTR_ERR(data->vio);
+			dev_err(&data->i2c_client->dev,
+				"Regulator get failed vio rc=%d\n", rc);
+			goto reg_vdd_set;
+		}
+
+		if (regulator_count_voltages(data->vio) > 0) {
+			rc = regulator_set_voltage(data->vio,
+				LTR553_VIO_MIN_UV, LTR553_VIO_MAX_UV);
+			if (rc) {
+				dev_err(&data->i2c_client->dev,
+				"Regulator set failed vio rc=%d\n", rc);
+				goto reg_vio_put;
+			}
+		}
+	}
+
+	return 0;
+
+reg_vio_put:
+	regulator_put(data->vio);
+reg_vdd_set:
+	if (regulator_count_voltages(data->vdd) > 0)
+		regulator_set_voltage(data->vdd, 0, LTR553_VDD_MAX_UV);
+reg_vdd_put:
+	regulator_put(data->vdd);
+	return rc;
+}
+
+static int ltr553_regulator_power_on(struct ltr553_data *data, bool on)
+{
+	int rc = 0;
+
+	if (!on) {
+		rc = regulator_disable(data->vdd);
+		if (rc) {
+			dev_err(&data->i2c_client->dev,
+				"Regulator vdd disable failed rc=%d\n", rc);
+			return rc;
+		}
+
+		rc = regulator_disable(data->vio);
+		if (rc) {
+			dev_err(&data->i2c_client->dev,
+				"Regulator vio disable failed rc=%d\n", rc);
+			rc = regulator_enable(data->vdd);
+			dev_err(&data->i2c_client->dev,
+					"Regulator vio re-enabled rc=%d\n", rc);
+			/*
+			 * Successfully re-enable regulator.
+			 * Enter poweron delay and returns error.
+			 */
+			if (!rc) {
+				rc = -EBUSY;
+				goto enable_delay;
+			}
+		}
+		return rc;
+	} else {
+		rc = regulator_enable(data->vdd);
+		if (rc) {
+			dev_err(&data->i2c_client->dev,
+				"Regulator vdd enable failed rc=%d\n", rc);
+			return rc;
+		}
+
+		rc = regulator_enable(data->vio);
+		if (rc) {
+			dev_err(&data->i2c_client->dev,
+				"Regulator vio enable failed rc=%d\n", rc);
+			regulator_disable(data->vdd);
+			return rc;
+		}
+	}
+
+enable_delay:
+	msleep(100);
+	dev_dbg(&data->i2c_client->dev,
+		"Sensor regulator power on =%d\n", on);
+	return rc;
+}
+
+static int ltr553_platform_hw_power_on(bool on)
+{
+	struct ltr553_data *data;
+	int err = 0;
+
+	if (pdev_data == NULL)
+		return -ENODEV;
+
+	data = pdev_data;
+	if (data->power_on != on) {
+		err = ltr553_regulator_power_on(data, on);
+		if (err)
+			dev_err(&data->i2c_client->dev,
+					"Can't configure regulator!\n");
+		else
+			data->power_on = on;
+	}
+
+	return err;
+}
+
+static int ltr553_platform_hw_init(void)
+{
+	struct i2c_client *client;
+	struct ltr553_data *data;
+	int error;
+
+	if (pdev_data == NULL)
+		return -ENODEV;
+
+	data = pdev_data;
+	client = data->i2c_client;
+
+	error = ltr553_regulator_configure(data, true);
+	if (error < 0) {
+		dev_err(&client->dev, "unable to configure regulator\n");
+		return error;
+	}
+
+	return 0;
+}
+
+static void ltr553_platform_hw_exit(void)
+{
+	struct ltr553_data *data = pdev_data;
+
+	if (data == NULL)
+		return;
+
+	ltr553_regulator_configure(data, false);
+}
+
+
+
+/* I2C Read */
+/* take note ---------------------------------------
+ for i2c read, need to send the register address follwed by buffer over
+ to register.
+ There should not be a stop in between register address and buffer.
+ There should not be release of lock in between register address and buffer.
+ take note ---------------------------------------*/
+static int8_t I2C_Read(uint8_t *rxData, uint8_t length)
+{
+	int8_t index;
+	struct i2c_msg data[] = {
+		{
+			.addr = sensor_info->i2c_client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = rxData,
+		},
+		{
+			.addr = sensor_info->i2c_client->addr,
+			.flags = I2C_M_RD,
+			.len = length,
+			.buf = rxData,
+		},
+	};
+
+	for (index = 0; index < I2C_RETRY; index++) {
+		if (i2c_transfer(sensor_info->i2c_client->adapter, data, 2) > 0)
+			break;
+
+		usleep(10000);
+	}
+
+	if (index >= I2C_RETRY) {
+		pr_alert("%s I2C Read Fail !!!!\n", __func__);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+
+/* I2C Write */
+static int8_t I2C_Write(uint8_t *txData, uint8_t length)
+{
+	int8_t index;
+	struct i2c_msg data[] = {
+		{
+			.addr = sensor_info->i2c_client->addr,
+			.flags = 0,
+			.len = length,
+			.buf = txData,
+		},
+	};
+
+	for (index = 0; index < I2C_RETRY; index++) {
+		if (i2c_transfer(sensor_info->i2c_client->adapter, data, 1) > 0)
+			break;
+
+		usleep(10000);
+	}
+
+	if (index >= I2C_RETRY) {
+		pr_alert("%s I2C Write Fail !!!!\n", __func__);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+
+/* Set register bit */
+static int8_t _ltr553_set_bit(struct i2c_client *client, uint8_t set,
+						uint8_t cmd, uint8_t data)
+{
+	uint8_t buffer[2];
+	uint8_t value;
+	int8_t ret = 0;
+
+	buffer[0] = cmd;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+
+	if (set)
+		value |= data;
+	else
+		value &= ~data;
+
+	buffer[0] = cmd;
+	buffer[1] = value;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s | 0x%02X", __func__, buffer[0]);
+		return -EIO;
+	}
+
+	return ret;
+}
+
+static uint16_t ltr553_lux_to_level(struct ltr553_data *ltr553, uint16_t lux)
+{
+	uint16_t level;
+	int i;
+
+	for (i = 0; i < LUX_LEVEL; i++) {
+		if (lux < lux_level[i]) {
+			level = lux_level[i - 1];
+			break;
+		}
+	}
+
+	if (i == LUX_LEVEL)
+		level = lux_level[LUX_LEVEL - 1];
+
+	dev_dbg(&ltr553->i2c_client->dev, "the lux_level: %d\n", level);
+
+	return level;
+}
+
+static uint16_t lux_formula(uint16_t ch0_adc, uint16_t ch1_adc, uint8_t eqtn)
+{
+	uint32_t luxval = 0;
+	uint16_t ch0_coeff = 0;
+	uint16_t ch1_coeff = 0;
+	int8_t ret;
+	uint8_t gain = 1, als_int_fac;
+	uint8_t buffer[2];
+	uint16_t win_fac = 0;
+	int8_t fac = 1;
+
+	buffer[0] = LTR553_ALS_PS_STATUS;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		pr_alert("%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	gain = (buffer[0] & 0x70);
+	gain >>= 4;
+
+	if (gain == 0)			/*gain 1*/
+		gain = 1;
+	else if (gain == 1) 	/*gain 2*/
+		gain = 2;
+	else if (gain == 2) /*gain 4*/
+		gain = 4;
+	else if (gain == 3) /*gain 8*/
+		gain = 8;
+	else if (gain == 6) /*gain 48*/
+		gain = 48;
+	else if (gain == 7) /*gain 96*/
+		gain = 96;
+
+	buffer[0] = LTR553_ALS_MEAS_RATE;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		pr_alert("%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+	als_int_fac = buffer[0] & 0x38;
+	als_int_fac >>= 3;
+
+	if (als_int_fac == 0)
+		als_int_fac = 10;
+	else if (als_int_fac == 1)
+		als_int_fac = 5;
+	else if (als_int_fac == 2)
+		als_int_fac = 20;
+	else if (als_int_fac == 3)
+		als_int_fac = 40;
+	else if (als_int_fac == 4)
+		als_int_fac = 15;
+	else if (als_int_fac == 5)
+		als_int_fac = 25;
+	else if (als_int_fac == 6)
+		als_int_fac = 30;
+	else if (als_int_fac == 7)
+		als_int_fac = 35;
+
+	if (eqtn == 1) {
+		ch0_coeff = 17743;
+		ch1_coeff = 11059;
+		fac = 1;
+		if(1 == spirit_flage)
+		{
+			win_fac = 100;
+		}
+		else
+		{
+			win_fac = winfac1;
+		}
+		
+		luxval = ((ch0_adc * ch0_coeff) + (ch1_adc * ch1_coeff)) * win_fac / gain / als_int_fac / 10000;
+		/*luxval = ((17743 * ch0_calc) + (11059 * ch1_adc));*/
+		/*luxval = ((1.7743 * ch0_calc) + (1.1059 * ch1_adc)) /
+		(gain * (als_int_fac / 10));*/
+	}
+	else if (eqtn == 2) {
+		ch0_coeff = 42785;
+		ch1_coeff = 19548;
+		if(1 == spirit_flage)
+		{
+			win_fac = 100;
+		}
+		else
+		{
+			win_fac = winfac2;
+		}
+		
+		luxval = ((ch0_adc * ch0_coeff) - (ch1_adc * ch1_coeff)) * win_fac / gain / als_int_fac / 10000;
+		/*luxval = ((42785 * ch0_calc) - (10696 * ch1_adc));*/
+		/*luxval = ((4.2785 * ch0_calc) - (1.9548 * ch1_adc)) /
+		(gain * (als_int_fac / 10));*/
+	}
+	else if (eqtn == 3) {
+		ch0_coeff = 5926;
+		ch1_coeff = 1185;
+
+		fac = 1;
+		if(1 == spirit_flage)
+		{
+			win_fac = 100;
+		}
+		else
+		{
+			win_fac = winfac3;
+		}
+		luxval = ((ch0_adc * ch0_coeff) + (ch1_adc * ch1_coeff)) * win_fac / gain / als_int_fac / 10000;
+
+		/*luxval = ((5926 * ch0_calc) + (1185 * ch1_adc));*/
+		/*luxval = ((0.5926 * ch0_calc) + (0.1185 * ch1_adc)) /
+		(gain * (als_int_fac / 10));*/
+	}
+	else if (eqtn == 4) {
+		ch0_coeff = 0;
+		ch1_coeff = 0;
+
+		fac = 1;
+		luxval = 0;
+
+		/*luxval = 0;*/
+	}
+	//if((ch0_adc+ch1_adc)<400)
+	//{
+
+	//luxval = ((ch0_adc * ch0_coeff/1000) + (ch1_adc * ch1_coeff/1000))*win_fac/gain/10;
+
+	return luxval;
+}
+
+
+
+static uint16_t ratioHysterisis(uint16_t ch0_adc, uint16_t ch1_adc)
+{
+#define	RATIO_HYSVAL	10
+	int ratio;
+	uint8_t buffer[2], eqn_now;
+	int8_t ret;
+	uint16_t ch0_calc;
+	uint32_t luxval = 0;
+	int abs_ratio_now_old;
+
+	buffer[0] = LTR553_ALS_CONTR;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		pr_alert("%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	ch0_calc = ch0_adc;
+	if ((buffer[0] & 0x20) == 0x20)
+		ch0_calc = ch0_adc - ch1_adc;
+
+	if ((ch1_adc + ch0_calc) == 0)
+		ratio = 100;
+	else
+		ratio = (ch1_adc*100) / (ch1_adc + ch0_calc);
+
+	if (ratio < 45)
+		eqn_now = 1;
+	else if ((ratio >= 45) && (ratio < 68))
+		eqn_now = 2;
+	else if ((ratio >= 68) && (ratio < 99))
+		eqn_now = 3;
+	else if (ratio >= 99)
+		eqn_now = 4;
+
+	if (eqn_prev == 0) {
+		luxval = lux_formula(ch0_calc, ch1_adc, eqn_now);
+		ratio_old = ratio;
+		eqn_prev = eqn_now;
+	} else {
+		if (eqn_now == eqn_prev) {
+			luxval = lux_formula(ch0_calc, ch1_adc, eqn_now);
+			ratio_old = ratio;
+			eqn_prev = eqn_now;
+		} else {
+			abs_ratio_now_old = ratio - ratio_old;
+			if (abs_ratio_now_old < 0)
+				abs_ratio_now_old *= (-1);
+			if (abs_ratio_now_old > RATIO_HYSVAL) {
+				luxval = lux_formula(ch0_calc,
+				ch1_adc, eqn_now);
+				ratio_old = ratio;
+				eqn_prev = eqn_now;
+			} else {
+				luxval = lux_formula(ch0_calc,
+				ch1_adc, eqn_prev);
+			}
+		}
+	}
+
+	return luxval;
+}
+
+static uint16_t read_als_adc_value(struct ltr553_data *ltr553)
+{
+
+	int8_t ret = -99;
+	uint16_t value = -99;
+	int ch0_val;
+	int ch1_val;
+	uint8_t gain, value_temp, gain_chg_req = 0;
+	uint8_t buffer[4], temp;
+
+#define AGC_UP_THRESHOLD		40000
+#define AGC_DOWN_THRESHOLD	5000
+#define AGC_HYS					15
+#define MAX_VAL					50000
+
+	/* ALS */
+	buffer[0] = LTR553_ALS_DATA_CH1_0;
+
+	/* read data bytes from data regs */
+	ret = I2C_Read(buffer, 4);
+
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+
+		return ret;
+	}
+
+	/* ALS Ch0 */
+	ch0_val = (uint16_t)buffer[2] | ((uint16_t)buffer[3] << 8);
+		dev_dbg(&ltr553->i2c_client->dev,
+			"%s | als_ch0 value = 0x%04X\n", __func__,
+				ch0_val);
+
+	if (ch0_val > ALS_MAX_MEASURE_VAL) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS Value Error: 0x%X\n", __func__,
+					ch0_val);
+	}
+	ch0_val &= ALS_VALID_MEASURE_MASK;
+	/*input_report_abs(ltr553->als_input_dev, ABS_MISC, ch0_val);*/
+	/*input_sync(ltr553->als_input_dev);*/
+
+	/* ALS Ch1 */
+	ch1_val = (uint16_t)buffer[0] | ((uint16_t)buffer[1] << 8);
+		dev_dbg(&ltr553->i2c_client->dev,
+			"%s | als_ch1 value = 0x%04X\n", __func__,
+				ch1_val);
+
+	if (ch1_val > ALS_MAX_MEASURE_VAL) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS Value Error: 0x%X\n", __func__,
+					ch1_val);
+	}
+	ch1_val &= ALS_VALID_MEASURE_MASK;
+	/*input_report_abs(ltr553->als_input_dev, ABS_MISC, ch1_val);*/
+	/*input_sync(ltr553->als_input_dev);*/
+
+	buffer[0] = LTR553_ALS_PS_STATUS;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+
+		return ret;
+	}
+
+	value_temp = buffer[0];
+	temp = buffer[0];
+	gain = (value_temp & 0x70);
+	gain >>= 4;
+
+	if (gain == 0) {			/*gain 1*/
+		gain = 1;
+	} else if (gain == 1) {		/*gain 2*/
+		gain = 2;
+	} else if (gain == 2) {		/*gain 4*/
+		gain = 4;
+	} else if (gain == 3) {		/*gain 8*/
+		gain = 8;
+	} else if (gain == 6) {		/*gain 48*/
+		gain = 48;
+	} else if (gain == 7) {		/*gain 96*/
+		gain = 96;
+	}
+
+	buffer[0] = LTR553_ALS_CONTR;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+
+		return ret;
+	}
+	value_temp = buffer[0];
+	value_temp &= 0xE3;
+
+	if ((ch0_val == 0) && (ch1_val > 50))
+		value = lux_val_prev;
+	else {
+		if (gain == 1) {
+			if ((ch0_val + ch1_val) <
+				((AGC_DOWN_THRESHOLD * 10) / AGC_HYS)) {
+				value = ratioHysterisis(ch0_val, ch1_val);
+				value_temp |= ALS_GAIN_8x;
+				gain_chg_req = 1;
+			} else {
+				value = ratioHysterisis(ch0_val, ch1_val);
+			}
+		} else if (gain == 8) {
+			if ((ch0_val + ch1_val) > AGC_UP_THRESHOLD) {
+				value = ratioHysterisis(ch0_val, ch1_val);
+				value_temp |= ALS_GAIN_1x;
+				gain_chg_req = 1;
+			} else {
+				value = ratioHysterisis(ch0_val, ch1_val);
+			}
+		} else {
+			value = ratioHysterisis(ch0_val, ch1_val);
+		}
+		if (gain_chg_req) {
+			buffer[0] = LTR553_ALS_CONTR;
+			buffer[1] = value_temp;
+			ret = I2C_Write(buffer, 2);
+			if (ret < 0) {
+				dev_err(&ltr553->i2c_client->dev,
+					"%s | 0x%02X", __func__, buffer[0]);
+				return ret;
+			}
+		}
+
+		value *= 12;
+		value = ltr553_lux_to_level(ltr553, value);
+	}
+
+	if ((value > MAX_VAL) || (((ch0_val + ch1_val) >
+			MAX_VAL) && (temp & 0x80)))
+		value = MAX_VAL;
+
+	lux_val_prev = value;
+
+	return value;
+}
+
+
+static uint16_t read_ps_adc_value(struct ltr553_data *ltr553)
+{
+	int8_t ret = -99;
+	uint16_t value = -99;
+	uint16_t ps_val;
+	uint8_t buffer[4];
+
+	buffer[0] = LTR553_PS_DATA_0;
+
+	/* read data bytes from data regs */
+	ret = I2C_Read(buffer, 2);
+
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+
+		return ret;
+	}
+
+	ps_val = (uint16_t)buffer[0] | ((uint16_t)buffer[1] << 8);
+		dev_dbg(&ltr553->i2c_client->dev,
+			"%s | ps value = 0x%04X\n", __func__,
+			ps_val);
+
+	if (ps_val > PS_MAX_MEASURE_VAL) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS Value Error: 0x%X\n", __func__,
+					ps_val);
+	}
+	ps_val &= PS_VALID_MEASURE_MASK;
+
+	value = ps_val;
+
+	return value;
+}
+
+
+static int8_t als_mode_setup(uint8_t alsMode_set_reset,
+					 struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+
+	ret = _ltr553_set_bit(ltr553->i2c_client, alsMode_set_reset,
+				LTR553_ALS_CONTR, ALS_MODE_ACTIVE);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s ALS mode setup fail...\n", __func__);
+		return ret;
+	}
+
+	return ret;
+}
+
+
+static int8_t als_sw_reset_setup(uint8_t alsSWReset_set_reset,
+				 struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+
+	ret = _ltr553_set_bit(ltr553->i2c_client, alsSWReset_set_reset,
+				LTR553_ALS_CONTR, ALS_SW_RESET);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s ALS sw reset setup fail...\n", __func__);
+		return ret;
+	}
+
+	return ret;
+}
+
+
+static int8_t als_gain_setup(uint8_t alsgain_range, struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_ALS_CONTR;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+	value &= 0xE3;
+
+	if (alsgain_range == 1)
+		value |= ALS_GAIN_1x;
+	else if (alsgain_range == 2)
+		value |= ALS_GAIN_2x;
+	else if (alsgain_range == 4)
+		value |= ALS_GAIN_4x;
+	else if (alsgain_range == 8)
+		value |= ALS_GAIN_8x;
+	else if (alsgain_range == 48)
+		value |= ALS_GAIN_48x;
+	else if (alsgain_range == 96)
+		value |= ALS_GAIN_96x;
+
+	buffer[0] = LTR553_ALS_CONTR;
+	buffer[1] = value;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s ALS gain setup fail...\n", __func__);
+		return ret;
+	}
+
+	return ret;
+}
+
+
+static int8_t als_contr_setup(uint8_t als_contr_val, struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[3];
+
+	buffer[0] = LTR553_ALS_CONTR;
+
+	/* Default settings used for now. */
+	buffer[1] = als_contr_val;
+	buffer[1] &= 0x1F;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | ALS_CONTR (0x%02X) setup fail...",
+				__func__, buffer[0]);
+	}
+
+	return ret;
+}
+
+
+static int8_t als_contr_readback(uint8_t rdbck_type, uint8_t *retVal,
+				struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_ALS_CONTR;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+
+	if (rdbck_type == ALS_MODE_RDBCK)
+		*retVal = value & 0x01;
+	else if (rdbck_type == ALS_SWRT_RDBCK)
+		*retVal = (value & 0x02) >> 1;
+	else if (rdbck_type == ALS_GAIN_RDBCK)
+		*retVal = (value & 0x1C) >> 2;
+	else if (rdbck_type == ALS_CONTR_RDBCK)
+		*retVal = value & 0x1F;
+
+	return ret;
+}
+
+
+static int8_t ps_mode_setup(uint8_t psMode_set_reset,
+				struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+
+	ret = _ltr553_set_bit(ltr553->i2c_client, psMode_set_reset,
+					LTR553_PS_CONTR, PS_MODE_ACTIVE);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s PS mode setup fail...\n", __func__);
+		return ret;
+	}
+
+	/* default state is far-away */
+	input_report_abs(ltr553->ps_input_dev, ABS_DISTANCE, FAR_VAL);
+	input_sync(ltr553->ps_input_dev);
+
+	return ret;
+}
+
+
+static int8_t ps_gain_setup(uint8_t psgain_range, struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_PS_CONTR;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+	value &= 0xF3;
+
+	if (psgain_range == 16)
+		value |= PS_GAIN_16x;
+	else if (psgain_range == 32)
+		value |= PS_GAIN_32x;
+	else if (psgain_range == 64)
+		value |= PS_GAIN_64x;
+
+	buffer[0] = LTR553_PS_CONTR;
+	buffer[1] = value;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s PS gain setup fail...\n", __func__);
+		return ret;
+	}
+
+	return ret;
+}
+
+
+static int8_t ps_satu_indica_setup(uint8_t pssatuindica_enable,
+				struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+
+	ret = _ltr553_set_bit(ltr553->i2c_client, pssatuindica_enable,
+				LTR553_PS_CONTR, PS_SATUR_INDIC_EN);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s PS saturation indicator setup fail...\n", __func__);
+		return ret;
+	}
+
+	return ret;
+}
+
+
+static int8_t ps_contr_setup(uint8_t ps_contr_val,
+				struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[3];
+
+	buffer[0] = LTR553_PS_CONTR;
+
+	/* Default settings used for now. */
+	buffer[1] = ps_contr_val;
+	buffer[1] &= 0x2F;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | PS_CONTR (0x%02X) setup fail...",
+			__func__, buffer[0]);
+	}
+
+	return ret;
+}
+
+
+static int8_t ps_contr_readback(uint8_t rdbck_type, uint8_t *retVal,
+					struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_PS_CONTR;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+
+	if (rdbck_type == PS_MODE_RDBCK)
+		*retVal = (value & 0x03);
+	else if (rdbck_type == PS_GAIN_RDBCK)
+		*retVal = (value & 0x0C) >> 2;
+	else if (rdbck_type == PS_SATUR_RDBCK)
+		*retVal = (value & 0x20) >> 5;
+	else if (rdbck_type == PS_CONTR_RDBCK)
+		*retVal = value & 0x2F;
+
+	return ret;
+}
+
+
+static int8_t ps_ledCurrent_setup(uint8_t psledcurr_val,
+					struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_PS_LED;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+	value &= 0xF8;
+
+	if (psledcurr_val == 5)
+		value |= LED_CURR_5MA;
+	else if (psledcurr_val == 10)
+		value |= LED_CURR_10MA;
+	else if (psledcurr_val == 20)
+		value |= LED_CURR_20MA;
+	else if (psledcurr_val == 50)
+		value |= LED_CURR_50MA;
+	else if (psledcurr_val == 100)
+		value |= LED_CURR_100MA;
+
+	buffer[0] = LTR553_PS_LED;
+	buffer[1] = value;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s PS LED current setup fail...\n", __func__);
+		return ret;
+	}
+
+	return ret;
+}
+
+
+static int8_t ps_ledCurrDuty_setup(uint8_t psleddutycycle_val,
+					struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_PS_LED;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+	value &= 0xE7;
+
+	if (psleddutycycle_val == 25)
+		value |= LED_CURR_DUTY_25PC;
+	else if (psleddutycycle_val == 50)
+		value |= LED_CURR_DUTY_50PC;
+	else if (psleddutycycle_val == 75)
+		value |= LED_CURR_DUTY_75PC;
+	else if (psleddutycycle_val == 100)
+		value |= LED_CURR_DUTY_100PC;
+
+	buffer[0] = LTR553_PS_LED;
+	buffer[1] = value;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s PS LED current duty setup fail...\n", __func__);
+		return ret;
+	}
+
+	return ret;
+}
+
+
+static int8_t ps_ledPulseFreq_setup(uint8_t pspulreq_val,
+				struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_PS_LED;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+	value &= 0x1F;
+
+	if (pspulreq_val == 30)
+		value |= LED_PUL_FREQ_30KHZ;
+	else if (pspulreq_val == 40)
+		value |= LED_PUL_FREQ_40KHZ;
+	else if (pspulreq_val == 50)
+		value |= LED_PUL_FREQ_50KHZ;
+	else if (pspulreq_val == 60)
+		value |= LED_PUL_FREQ_60KHZ;
+	else if (pspulreq_val == 70)
+		value |= LED_PUL_FREQ_70KHZ;
+	else if (pspulreq_val == 80)
+		value |= LED_PUL_FREQ_80KHZ;
+	else if (pspulreq_val == 90)
+		value |= LED_PUL_FREQ_90KHZ;
+	else if (pspulreq_val == 100)
+		value |= LED_PUL_FREQ_100KHZ;
+
+	buffer[0] = LTR553_PS_LED;
+	buffer[1] = value;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s PS LED pulse frequency setup fail...\n", __func__);
+		return ret;
+	}
+
+	return ret;
+}
+
+
+/* LED Setup */
+static int8_t ps_led_setup(uint8_t ps_led_val, struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[3];
+
+	buffer[0] = LTR553_PS_LED;
+
+	/* Default settings used for now. */
+	buffer[1] = ps_led_val;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | PS_LED (0x%02X) setup fail...",
+				__func__, buffer[0]);
+	}
+
+	return ret;
+}
+
+
+static int8_t ps_led_readback(uint8_t rdbck_type, uint8_t *retVal,
+				struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_PS_LED;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+
+	if (rdbck_type == LED_CURR_RDBCK)
+		*retVal = (value & 0x07);
+	else if (rdbck_type == LED_CURR_DUTY_RDBCK)
+		*retVal = (value & 0x18) >> 3;
+	else if (rdbck_type == LED_PUL_FREQ_RDBCK)
+		*retVal = (value & 0xE0) >> 5;
+	else if (rdbck_type == PS_LED_RDBCK)
+		*retVal = value;
+
+	return ret;
+}
+
+
+static int8_t ps_ledPulseCount_setup(uint8_t pspulsecount_val,
+				struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[3];
+
+	buffer[0] = LTR553_PS_N_PULSES;
+
+	/* Default settings used for now. */
+	if (pspulsecount_val > 15)
+		pspulsecount_val = 15;
+
+	buffer[1] = pspulsecount_val;
+	buffer[1] &= 0x0F;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | PS_LED_COUNT (0x%02X) setup fail...",
+				__func__, buffer[0]);
+	}
+
+	return ret;
+}
+
+
+static int8_t ps_ledPulseCount_readback(uint8_t *retVal,
+				struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[3], value;
+
+	buffer[0] = LTR553_PS_N_PULSES;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+	*retVal = value;
+
+	return ret;
+}
+
+
+static int8_t ps_meas_rate_setup(uint16_t meas_rate_val,
+				struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_PS_MEAS_RATE;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+
+		return ret;
+	}
+
+	value = buffer[0];
+	value &= 0xF0;
+
+	if (meas_rate_val == 50)
+		value |= PS_MEAS_RPT_RATE_50MS;
+	else if (meas_rate_val == 70)
+		value |= PS_MEAS_RPT_RATE_70MS;
+	else if (meas_rate_val == 100)
+		value |= PS_MEAS_RPT_RATE_100MS;
+	else if (meas_rate_val == 200)
+		value |= PS_MEAS_RPT_RATE_200MS;
+	else if (meas_rate_val == 500)
+		value |= PS_MEAS_RPT_RATE_500MS;
+	else if (meas_rate_val == 1000)
+		value |= PS_MEAS_RPT_RATE_1000MS;
+	else if (meas_rate_val == 2000)
+		value |= PS_MEAS_RPT_RATE_2000MS;
+	else if (meas_rate_val == 10)
+		value |= PS_MEAS_RPT_RATE_10MS;
+
+	buffer[0] = LTR553_PS_MEAS_RATE;
+	buffer[1] = value;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s PS measurement rate setup fail...\n", __func__);
+
+		return ret;
+	}
+
+	return ret;
+}
+
+
+static int8_t ps_meas_rate_readback(uint8_t *retVal,
+				struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[3], value;
+
+	buffer[0] = LTR553_PS_MEAS_RATE;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+	*retVal = (value & 0x0F);
+
+	return ret;
+}
+
+
+static int8_t als_meas_rate_setup(uint16_t meas_rate_val,
+					struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_ALS_MEAS_RATE;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+	value &= 0xF8;
+
+	if (meas_rate_val == 50)
+		value |= ALS_MEAS_RPT_RATE_50MS;
+	else if (meas_rate_val == 100)
+		value |= ALS_MEAS_RPT_RATE_100MS;
+	else if (meas_rate_val == 200)
+		value |= ALS_MEAS_RPT_RATE_200MS;
+	else if (meas_rate_val == 500)
+		value |= ALS_MEAS_RPT_RATE_500MS;
+	else if (meas_rate_val == 1000)
+		value |= ALS_MEAS_RPT_RATE_1000MS;
+	else if (meas_rate_val == 2000)
+		value |= ALS_MEAS_RPT_RATE_2000MS;
+
+	buffer[0] = LTR553_ALS_MEAS_RATE;
+	buffer[1] = value;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s ALS measurement rate setup fail...\n", __func__);
+		return ret;
+	}
+
+	return ret;
+}
+
+
+static int8_t als_integ_time_setup(uint16_t integ_time_val,
+					struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_ALS_MEAS_RATE;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+	value &= 0xC7;
+
+	if (integ_time_val == 100)
+		value |= ALS_INTEG_TM_100MS;
+	else if (integ_time_val == 50)
+		value |= ALS_INTEG_TM_50MS;
+	else if (integ_time_val == 200)
+		value |= ALS_INTEG_TM_200MS;
+	else if (integ_time_val == 400)
+		value |= ALS_INTEG_TM_400MS;
+	else if (integ_time_val == 150)
+		value |= ALS_INTEG_TM_150MS;
+	else if (integ_time_val == 250)
+		value |= ALS_INTEG_TM_250MS;
+	else if (integ_time_val == 300)
+		value |= ALS_INTEG_TM_300MS;
+	else if (integ_time_val == 350)
+		value |= ALS_INTEG_TM_350MS;
+
+	buffer[0] = LTR553_ALS_MEAS_RATE;
+	buffer[1] = value;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s ALS integration time setup fail...\n", __func__);
+		return ret;
+	}
+
+	return ret;
+}
+
+
+static int8_t als_meas_rate_reg_setup(uint8_t als_meas_rate_reg_val,
+					struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[3];
+
+	buffer[0] = LTR553_ALS_MEAS_RATE;
+
+	buffer[1] = als_meas_rate_reg_val;
+	buffer[1] &= 0x3F;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | ALS_MEAS_RATE (0x%02X) setup fail...",
+				__func__, buffer[0]);
+	}
+
+	return ret;
+}
+
+
+static int8_t als_meas_rate_readback(uint8_t rdbck_type, uint8_t *retVal,
+						struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_ALS_MEAS_RATE;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+
+	if (rdbck_type == ALS_MEAS_RPT_RATE_RDBCK)
+		*retVal = (value & 0x07);
+	else if (rdbck_type == ALS_INTEG_TM_RDBCK)
+		*retVal = (value & 0x38) >> 3;
+	else if (rdbck_type == ALS_MEAS_RATE_RDBCK)
+		*retVal = (value & 0x3F);
+
+	return ret;
+}
+
+
+static int8_t part_ID_reg_readback(uint8_t rdbck_type, uint8_t *retVal,
+					struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[1], value;
+
+	buffer[0] = LTR553_PART_ID;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+
+	if (rdbck_type == PART_NUM_ID_RDBCK)
+		*retVal = (value & 0xF0) >> 4;
+	else if (rdbck_type == REVISION_ID_RDBCK)
+		*retVal = value & 0x0F;
+	else if (rdbck_type == PART_ID_REG_RDBCK)
+		*retVal = value;
+
+	return ret;
+}
+
+
+static int8_t manu_ID_reg_readback(uint8_t *retVal, struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[1], value;
+
+	buffer[0] = LTR553_MANUFACTURER_ID;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+	*retVal = value;
+
+	return ret;
+}
+
+
+static int8_t als_ps_status_reg(uint8_t data_status_type, uint8_t *retVal,
+						struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_ALS_PS_STATUS;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+
+	if (data_status_type == PS_DATA_STATUS_RDBCK)
+		*retVal = (value & 0x01);
+	else if (data_status_type == PS_INTERR_STATUS_RDBCK)
+		*retVal = (value & 0x02) >> 1;
+	else if (data_status_type == ALS_DATA_STATUS_RDBCK)
+		*retVal = (value & 0x04) >> 2;
+	else if (data_status_type == ALS_INTERR_STATUS_RDBCK)
+		*retVal = (value & 0x08) >> 3;
+	else if (data_status_type == ALS_GAIN_STATUS_RDBCK)
+		*retVal = (value & 0x70) >> 4;
+	else if (data_status_type == ALS_VALID_STATUS_RDBCK)
+		*retVal = (value & 0x80) >> 7;
+	else if (data_status_type == ALS_PS_STATUS_RDBCK)
+		*retVal = value;
+
+	return ret;
+}
+
+
+static int8_t als_ch0ch1raw_calc_readback(uint16_t *retVal1, uint16_t *retVal2,
+			uint16_t *retVal3, struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[11];
+	uint16_t value1, value2, value3;
+
+	buffer[0] = LTR553_ALS_DATA_CH1_0;
+	ret = I2C_Read(buffer, 4);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value1 = ((int)buffer[2]) + ((int)buffer[3] << 8); /* CH0*/
+	value2 = ((int)buffer[0]) + ((int)buffer[1] << 8); /* CH1*/
+
+	value3 = ratioHysterisis(value1, value2);
+
+	*retVal1 = value1;
+	*retVal2 = value2;
+	*retVal3 = value3;
+
+	return ret;
+}
+
+
+static int8_t interrupt_mode_setup(uint8_t interr_mode_val,
+					struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_INTERRUPT;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+	value &= 0xFC;
+
+	if (interr_mode_val == 0)
+		value |= INT_MODE_00;
+	else if (interr_mode_val == 1)
+		value |= INT_MODE_PS_TRIG;
+	else if (interr_mode_val == 2)
+		value |= INT_MODE_ALS_TRIG;
+	else if (interr_mode_val == 3)
+		value |= INT_MODE_ALSPS_TRIG;
+
+	buffer[0] = LTR553_INTERRUPT;
+	buffer[1] = value;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s Interrupt mode setup fail...\n", __func__);
+		return ret;
+	}
+
+	return ret;
+}
+
+
+static int8_t interrupt_polarity_setup(uint8_t interr_polar_val,
+						struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_INTERRUPT;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+	value &= 0xFB;
+
+	if (interr_polar_val == 0)
+		value |= INT_POLAR_ACT_LO;
+	else if (interr_polar_val == 1)
+		value |= INT_POLAR_ACT_HI;
+
+	buffer[0] = LTR553_INTERRUPT;
+	buffer[1] = value;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s Interrupt polarity setup fail...\n", __func__);
+		return ret;
+	}
+
+	return ret;
+}
+
+
+static int8_t interrupt_setup(uint8_t interrupt_val,
+			struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[3];
+
+	buffer[0] = LTR553_INTERRUPT;
+
+	/* Default settings used for now. */
+	buffer[1] = interrupt_val;
+	buffer[1] &= 0x07;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s |Interrupt (0x%02X) setup fail...",
+				__func__, buffer[0]);
+	}
+
+	return ret;
+}
+
+
+static int8_t interrupt_readback(uint8_t rdbck_type, uint8_t *retVal,
+					struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_INTERRUPT;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+
+	if (rdbck_type == INT_MODE_RDBCK)
+		*retVal = (value & 0x03);
+	else if (rdbck_type == INT_POLAR_RDBCK)
+		*retVal = (value & 0x04) >> 2;
+	else if (rdbck_type == INT_INTERRUPT_RDBCK)
+		*retVal = (value & 0x07);
+
+	return ret;
+}
+
+
+static int8_t ps_offset_setup(uint16_t ps_offset_val,
+					struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[3];
+
+	buffer[0] = LTR553_PS_OFFSET_1;
+	buffer[1] = (ps_offset_val >> 8) & 0x03;
+	buffer[2] = (ps_offset_val & 0xFF);
+
+	ret = I2C_Write(buffer, 3);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s PS offset setup fail...\n", __func__);
+		return ret;
+	}
+
+	return ret;
+}
+
+
+static int8_t ps_offset_readback(uint16_t *offsetval,
+				struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2];
+	uint16_t value;
+
+	buffer[0] = LTR553_PS_OFFSET_1;
+	ret = I2C_Read(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+	value <<= 8;
+	value += buffer[1];
+
+	*offsetval = value;
+
+	return ret;
+}
+
+
+static int8_t interrupt_persist_setup(uint8_t interr_persist_val,
+					struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	value = interr_persist_val;
+
+	buffer[0] = LTR553_INTERRUPT_PRST;
+	buffer[1] = value;
+	ret = I2C_Write(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s Interrupt persist setup fail...\n", __func__);
+		return ret;
+	}
+
+	return ret;
+}
+
+
+static int8_t interrupt_prst_readback(uint8_t *retVal,
+						struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[2], value;
+
+	buffer[0] = LTR553_INTERRUPT_PRST;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value = buffer[0];
+
+	*retVal = value;
+
+	return ret;
+}
+
+
+/* Set ALS range */
+static int8_t set_als_range(uint16_t lt, uint16_t ht, uint8_t lo_hi)
+{
+	int8_t ret;
+	uint8_t buffer[5], num_data = 0;
+
+	if (lo_hi == LO_LIMIT) {
+		buffer[0] = LTR553_ALS_THRES_LOW_0;
+		buffer[1] = lt & 0xFF;
+		buffer[2] = (lt >> 8) & 0xFF;
+		num_data = 3;
+	} else if (lo_hi == HI_LIMIT) {
+		buffer[0] = LTR553_ALS_THRES_UP_0;
+		buffer[1] = ht & 0xFF;
+		buffer[2] = (ht >> 8) & 0xFF;
+		num_data = 3;
+	} else if (lo_hi == LO_N_HI_LIMIT) {
+		buffer[0] = LTR553_ALS_THRES_UP_0;
+		buffer[1] = ht & 0xFF;
+		buffer[2] = (ht >> 8) & 0xFF;
+		buffer[3] = lt & 0xFF;
+		buffer[4] = (lt >> 8) & 0xFF;
+		num_data = 5;
+	}
+
+	ret = I2C_Write(buffer, num_data);
+	if (ret < 0) {
+		pr_alert("%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+	dev_dbg(&sensor_info->i2c_client->dev,
+		"%s Set als range:0x%04x - 0x%04x\n", __func__, lt, ht);
+
+	return ret;
+}
+
+
+static int8_t als_range_readback(uint16_t *lt, uint16_t *ht,
+					struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[5];
+	uint16_t value_lo, value_hi;
+
+	buffer[0] = LTR553_ALS_THRES_UP_0;
+	ret = I2C_Read(buffer, 4);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+
+	value_lo = buffer[3];
+	value_lo <<= 8;
+	value_lo += buffer[2];
+	*lt = value_lo;
+
+	value_hi = buffer[1];
+	value_hi <<= 8;
+	value_hi += buffer[0];
+	*ht = value_hi;
+
+	return ret;
+}
+
+
+/* Set PS range */
+static int8_t set_ps_range(uint16_t lt, uint16_t ht, uint8_t lo_hi,
+					struct ltr553_data *ltr553)
+{
+	int8_t ret;
+	uint8_t buffer[5], num_data = 0;
+
+	if (lo_hi == LO_LIMIT) {
+		buffer[0] = LTR553_PS_THRES_LOW_0;
+		buffer[1] = lt & 0xFF;
+		buffer[2] = (lt >> 8) & 0x07;
+		num_data = 3;
+	} else if (lo_hi == HI_LIMIT) {
+		buffer[0] = LTR553_PS_THRES_UP_0;
+		buffer[1] = ht & 0xFF;
+		buffer[2] = (ht >> 8) & 0x07;
+		num_data = 3;
+	} else if (lo_hi == LO_N_HI_LIMIT) {
+		buffer[0] = LTR553_PS_THRES_UP_0;
+		buffer[1] = ht & 0xFF;
+		buffer[2] = (ht >> 8) & 0x07;
+		buffer[3] = lt & 0xFF;
+		buffer[4] = (lt >> 8) & 0x07;
+		num_data = 5;
+	}
+
+	ret = I2C_Write(buffer, num_data);
+	if (ret < 0) {
+		pr_alert("%s | 0x%02X", __func__, buffer[0]);
+
+		return ret;
+	}
+	dev_dbg(&ltr553->i2c_client->dev,
+	"%s Set ps range:0x%04x - 0x%04x\n", __func__, lt, ht);
+
+	return ret;
+}
+
+
+static int8_t ps_range_readback(uint16_t *lt, uint16_t *ht,
+						struct ltr553_data *ltr553)
+{
+	int8_t ret = 0;
+	uint8_t buffer[5];
+	uint16_t value_lo, value_hi;
+
+	buffer[0] = LTR553_PS_THRES_UP_0;
+	ret = I2C_Read(buffer, 4);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+
+		return ret;
+	}
+
+	value_lo = buffer[3];
+	value_lo <<= 8;
+	value_lo += buffer[2];
+	*lt = value_lo;
+
+	value_hi = buffer[1];
+	value_hi <<= 8;
+	value_hi += buffer[0];
+	*ht = value_hi;
+
+	return ret;
+}
+
+#if 0
+static uint16_t discardMinMax_findCTMov_Avg(uint16_t *ps_val)
+{
+#define MAX_NUM_PS_DATA1		PS_MAX_MOV_AVG_KEPT_DATA_CTR
+#define STARTING_PS_INDEX1		0
+#define ENDING_PS_INDEX1		5
+#define NUM_AVG_DATA1			5
+
+	uint8_t i_ctr, i_ctr2, maxIndex, minIndex;
+	uint16_t maxVal, minVal, _ps_val[MAX_NUM_PS_DATA1];
+	uint16_t temp = 0;
+
+	for (i_ctr = STARTING_PS_INDEX1; i_ctr < MAX_NUM_PS_DATA1; i_ctr++)
+		_ps_val[i_ctr] = ps_val[i_ctr];
+
+	maxVal = ps_val[STARTING_PS_INDEX1];
+	maxIndex = STARTING_PS_INDEX1;
+	minVal = ps_val[STARTING_PS_INDEX1];
+	minIndex = STARTING_PS_INDEX1;
+
+	for (i_ctr = STARTING_PS_INDEX1; i_ctr < MAX_NUM_PS_DATA1; i_ctr++) {
+		if (ps_val[i_ctr] > maxVal) {
+			maxVal = ps_val[i_ctr];
+			maxIndex = i_ctr;
+		}
+	}
+
+	for (i_ctr = STARTING_PS_INDEX1; i_ctr < MAX_NUM_PS_DATA1; i_ctr++) {
+		if (ps_val[i_ctr] < minVal) {
+			minVal = ps_val[i_ctr];
+			minIndex = i_ctr;
+		}
+	}
+
+	i_ctr2 = 0;
+
+	if (minIndex != maxIndex) {
+		for (i_ctr = STARTING_PS_INDEX1;
+				i_ctr < MAX_NUM_PS_DATA1; i_ctr++) {
+			if ((i_ctr != minIndex) && (i_ctr != maxIndex)) {
+				ps_val[i_ctr2] = _ps_val[i_ctr];
+				i_ctr2++;
+			}
+		}
+	}
+	ps_val[MAX_NUM_PS_DATA1 - 1] = 0;
+	ps_val[MAX_NUM_PS_DATA1 - 2] = 0;
+
+	for (i_ctr = STARTING_PS_INDEX1; i_ctr < ENDING_PS_INDEX1; i_ctr++)
+		temp += ps_val[i_ctr];
+
+	temp = (temp / NUM_AVG_DATA1);
+
+	return temp;
+}
+
+static uint16_t findCT_Avg(uint16_t *ps_val)
+{
+#define MAX_NUM_PS_DATA2		PS_MAX_INIT_KEPT_DATA_COUNTER
+#define STARTING_PS_INDEX2		3
+#define NUM_AVG_DATA2			3
+
+	uint8_t i_ctr, min_Index, max_Index;
+	uint16_t max_val, min_val;
+	uint16_t temp = 0;
+	/*struct ltr553_data *ltr553 = sensor_info;*/
+
+	max_val = ps_val[STARTING_PS_INDEX2];
+	max_Index = STARTING_PS_INDEX2;
+	min_val = ps_val[STARTING_PS_INDEX2];
+	min_Index = STARTING_PS_INDEX2;
+
+	for (i_ctr = STARTING_PS_INDEX2; i_ctr < MAX_NUM_PS_DATA2; i_ctr++) {
+		if (ps_val[i_ctr] > max_val) {
+			max_val = ps_val[i_ctr];
+			max_Index = i_ctr;
+		}
+	}
+
+	for (i_ctr = STARTING_PS_INDEX2; i_ctr < MAX_NUM_PS_DATA2; i_ctr++) {
+		if (ps_val[i_ctr] < min_val) {
+			min_val = ps_val[i_ctr];
+			min_Index = i_ctr;
+		}
+	}
+
+	if (min_val == max_val)
+		/* all values are the same*/
+		temp = ps_val[STARTING_PS_INDEX2];
+	else {
+		for (i_ctr = STARTING_PS_INDEX2;
+				i_ctr < MAX_NUM_PS_DATA2; i_ctr++) {
+			if ((i_ctr != min_Index) && (i_ctr != max_Index))
+				temp += ps_val[i_ctr];
+		}
+		temp = (temp / NUM_AVG_DATA2);
+	}
+
+	/*temp = (temp / NUM_AVG_DATA2);*/
+
+	return temp;
+}
+#endif
+
+/* take note ------------------------------------------
+ This function should be called in the function which is called
+ when the CALL button is pressed.
+ take note ------------------------------------------*/
+static void setThrDuringCall(void)
+{
+	int8_t ret;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/* set ps measurement rate to 10ms*/
+	ret = ps_meas_rate_setup(10, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS MeasRate Setup Fail...\n", __func__);
+	}
+
+	ps_grabData_stage = 0;
+	ps_kept_data_counter = 0;
+	ps_movavg_data_counter = 0;
+
+	ret = set_ps_range(PS_MIN_MEASURE_VAL, PS_MIN_MEASURE_VAL,
+						LO_N_HI_LIMIT, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s : PS thresholds setting Fail...\n", __func__);
+	}
+
+	ret = ps_contr_setup(0x03, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS Enable Fail...\n", __func__);
+	}
+}
+
+#if 0
+/* Report PS input event */
+static void report_ps_input_event(struct ltr553_data *ltr553)
+{
+	int8_t ret;
+	uint16_t adc_value;
+
+	adc_value = read_ps_adc_value(ltr553);
+	dev_dbg(&ltr553->i2c_client->dev, "value:%d\n", adc_value);
+
+	if (ps_grabData_stage == 0) {
+		if (ps_kept_data_counter < PS_MAX_INIT_KEPT_DATA_COUNTER) {
+			if (adc_value != 0) {
+				ps_init_kept_data[ps_kept_data_counter] =
+					adc_value;
+				ps_kept_data_counter++;
+			}
+		}
+
+		if (ps_kept_data_counter >= PS_MAX_INIT_KEPT_DATA_COUNTER) {
+			ps_ct_avg = findCT_Avg(ps_init_kept_data);
+			ftn_init = ps_ct_avg * 15;
+			ps_grabData_stage = 1;
+		}
+	}
+
+	if (ps_grabData_stage == 1) {
+		if ((ftn_init - (ps_ct_avg * 10)) < 1000)
+			ftn_final = (ps_ct_avg * 10) + 1000;
+		else {
+			if ((ftn_init - (ps_ct_avg * 10)) > 1500)
+				ftn_final = (ps_ct_avg * 10) + 1500;
+			else
+				ftn_final = ftn_init;
+		}
+		ntf_final = (ftn_final - (ps_ct_avg * 10));
+		ntf_final *= 4;
+		ntf_final /= 100;
+		ntf_final += ps_ct_avg;
+		ftn_final /= 10;
+		if (ntf_final >= PS_MAX_MEASURE_VAL)
+			ntf_final = PS_MAX_MEASURE_VAL;
+
+		if (ftn_final >= PS_MAX_MEASURE_VAL)
+			ftn_final = PS_MAX_MEASURE_VAL;
+
+		ret = ps_meas_rate_setup(50, ltr553);
+		if (ret < 0) {
+			dev_err(&ltr553->i2c_client->dev,
+				"%s: PS MeasRate Setup Fail...\n", __func__);
+		}
+
+		ps_grabData_stage = 2;
+	}
+
+	if (ps_grabData_stage == 2) {
+		/* report NEAR or FAR to the user layer */
+		if ((adc_value > ftn_final) || (adc_value < ntf_final)) {
+
+			if (adc_value > ftn_final) {
+				input_report_abs(ltr553->ps_input_dev,
+					ABS_DISTANCE, NEAR_VAL);
+				input_sync(ltr553->ps_input_dev);
+			}
+
+			if (adc_value < ntf_final) {
+				input_report_abs(ltr553->ps_input_dev,
+					ABS_DISTANCE, FAR_VAL);
+				input_sync(ltr553->ps_input_dev);
+			}
+
+		}
+		/* report NEAR or FAR to the user layer */
+
+		if (ps_movavg_data_counter < PS_MAX_MOV_AVG_KEPT_DATA_CTR) {
+			if (adc_value != 0) {
+				ps_movavg_data[ps_movavg_data_counter] =
+					adc_value;
+				ps_movavg_data_counter++;
+			}
+		}
+
+		if (ps_movavg_data_counter >= PS_MAX_MOV_AVG_KEPT_DATA_CTR) {
+			ps_movct_avg =
+				discardMinMax_findCTMov_Avg(ps_movavg_data);
+
+			if (ps_movct_avg < ps_ct_avg) {
+				ps_ct_avg = ps_movct_avg;
+				ftn_init = ps_ct_avg * 17;
+				ps_grabData_stage = 1;
+			}
+			ps_movavg_data_counter = 5;
+		}
+
+	}
+
+}
+#endif
+
+static void report_ps_input_event(struct ltr553_data *ltr553)
+{
+	int8_t ret;
+	uint16_t adc_value;
+	struct timespec timestamp_spec;
+
+	adc_value = read_ps_adc_value(ltr553);
+	dev_dbg(&ltr553->i2c_client->dev, "value:%d\n", adc_value);
+	dev_warn(&ltr553->i2c_client->dev, "report_ps_input_event--value[%d],high[%d],low[%d]\n",
+		adc_value, ltr553->default_ps_highthresh, ltr553->default_ps_lowthresh);
+
+	timestamp_spec = ktime_to_timespec(ktime_get_boottime());
+
+	if (adc_value > ltr553->default_ps_highthresh) {
+		input_report_abs(ltr553->ps_input_dev, ABS_DISTANCE, NEAR_VAL);
+		input_event(ltr553->ps_input_dev, EV_SYN, SYN_TIME_SEC, timestamp_spec.tv_sec);
+		input_event(ltr553->ps_input_dev, EV_SYN, SYN_TIME_NSEC, timestamp_spec.tv_nsec);
+		input_sync(ltr553->ps_input_dev);
+		ret = set_ps_range(ltr553->default_ps_lowthresh, PS_THRESHOLD_MAX,
+				LO_N_HI_LIMIT, ltr553);
+		dev_warn(&ltr553->i2c_client->dev, "report_ps_input_event--low[%d]-MAX\n", ltr553->default_ps_lowthresh);
+	} else {
+		__pm_wakeup_event(&ltr553->ps_wake_lock.ws, 100);
+		input_report_abs(ltr553->ps_input_dev, ABS_DISTANCE, FAR_VAL);
+		input_event(ltr553->ps_input_dev, EV_SYN, SYN_TIME_SEC, timestamp_spec.tv_sec);
+		input_event(ltr553->ps_input_dev, EV_SYN, SYN_TIME_NSEC, timestamp_spec.tv_nsec);
+		input_sync(ltr553->ps_input_dev);
+		ret = set_ps_range(PS_THRESHOLD_MIN, ltr553->default_ps_highthresh,
+				LO_N_HI_LIMIT, ltr553);
+		dev_warn(&ltr553->i2c_client->dev, "report_ps_input_event--MIN-high[%d]\n", ltr553->default_ps_highthresh);
+	}
+
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s : PS Thresholds Write Fail...\n", __func__);
+	}
+}
+
+/* Report ALS input event */
+static void report_als_input_event(struct ltr553_data *ltr553)
+{
+    struct timespec timestamp_spec;
+	/*int8_t ret;*/
+	uint16_t adc_value;
+	/*int thresh_hi, thresh_lo, thresh_delta;*/
+	/*ltr553->mode = ALS;*/
+	/*adc_value = read_adc_value (ltr553);*/
+	adc_value = read_als_adc_value(ltr553);
+
+	timestamp_spec = ktime_to_timespec(ktime_get_boottime());
+
+	input_report_abs(ltr553->als_input_dev, ABS_MISC, adc_value);
+	input_event(ltr553->als_input_dev, EV_SYN, SYN_TIME_SEC, timestamp_spec.tv_sec);
+	input_event(ltr553->als_input_dev, EV_SYN, SYN_TIME_NSEC, timestamp_spec.tv_nsec);
+	input_sync(ltr553->als_input_dev);
+
+}
+
+/* Work when interrupt */
+static void ltr553_schedwork(struct work_struct *work)
+{
+	int8_t ret;
+	uint8_t status;
+	uint8_t	interrupt_stat, newdata;
+	struct ltr553_data *ltr553 = sensor_info;
+	uint8_t buffer[2];
+
+	buffer[0] = LTR553_ALS_PS_STATUS;
+	ret = I2C_Read(buffer, 1);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		enable_irq(ltr553->irq);
+		return;
+	}
+	status = buffer[0];
+	interrupt_stat = status & 0x0A;
+	newdata = status & 0x05;
+
+	/* PS interrupt and PS with new data*/
+	if ((interrupt_stat & 0x02) && (newdata & 0x01)) {
+                mutex_lock(&(ltr553->ps_lock));
+		ltr553->ps_irq_flag = 1;
+		report_ps_input_event(ltr553);
+		ltr553->ps_irq_flag = 0;
+		mutex_unlock(&(ltr553->ps_lock));
+	}
+	/* ALS interrupt and ALS with new data*/
+	if ((interrupt_stat & 0x08) && (newdata & 0x04)) {
+
+		ltr553->als_irq_flag = 1;
+		report_als_input_event(ltr553);
+		ltr553->als_irq_flag = 0;
+	}
+	enable_irq(ltr553->irq);
+}
+
+static DECLARE_WORK(irq_workqueue, ltr553_schedwork);
+
+
+/* IRQ Handler */
+static irqreturn_t ltr553_irq_handler(int irq, void *data)
+{
+	struct ltr553_data *ltr553 = data;
+
+	/* disable an irq without waiting */
+	disable_irq_nosync(ltr553->irq);
+
+	schedule_work(&irq_workqueue);
+
+	return IRQ_HANDLED;
+}
+
+static int ltr553_gpio_irq(struct ltr553_data *ltr553)
+{
+	int rc = 0;
+
+	rc = gpio_request(ltr553->gpio_int_no, DEVICE_NAME);
+	if (rc < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: GPIO %d Request Fail (%d)\n",
+				__func__, ltr553->gpio_int_no, rc);
+		return rc;
+	}
+
+	rc = gpio_direction_input(ltr553->gpio_int_no);
+	if (rc < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: Set GPIO %d as Input Fail (%d)\n", __func__,
+					ltr553->gpio_int_no, rc);
+		goto out1;
+	}
+
+	/* Configure an active low trigger interrupt for the device */
+	/*rc = request_irq(ltr553->irq, ltr553_irq_handler,
+				IRQF_TRIGGER_FALLING, DEVICE_NAME, ltr553);*/
+	rc = request_irq(ltr553->irq, ltr553_irq_handler, IRQF_TRIGGER_LOW,
+				DEVICE_NAME, ltr553);
+	if (rc < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: Request IRQ (%d) for GPIO %d Fail (%d)\n",
+				__func__, ltr553->irq,
+					ltr553->gpio_int_no, rc);
+		goto out1;
+	}
+	disable_irq(ltr553->irq);
+
+	return rc;
+
+out1:
+	gpio_free(ltr553->gpio_int_no);
+
+	return rc;
+}
+
+/* PS Enable */
+static int8_t ps_enable_init(struct ltr553_data *ltr553)
+{
+	int8_t rc = 0;
+	uint8_t buffer[1]; /* for dummy read*/
+
+	setThrDuringCall();
+
+	if (ltr553->ps_enable_flag) {
+		dev_info(&ltr553->i2c_client->dev,
+			"%s: already enabled\n", __func__);
+		return 0;
+	}
+
+	/* Set thresholds where interrupt will *not* be generated */
+#if ACT_INTERRUPT
+	/*rc = set_ps_range(PS_MIN_MEASURE_VAL, PS_MIN_MEASURE_VAL,
+				LO_N_HI_LIMIT);*/
+	/*rc = set_ps_range(PS_MIN_MEASURE_VAL, 400, LO_N_HI_LIMIT);*/
+	rc = set_ps_range(PS_THRESHOLD_MIN, ltr553->default_ps_highthresh,
+			LO_N_HI_LIMIT, ltr553);
+#else
+	rc = set_ps_range(PS_MIN_MEASURE_VAL, PS_MAX_MEASURE_VAL,
+			LO_N_HI_LIMIT, ltr553);
+#endif
+	if (rc < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s : PS Thresholds Write Fail...\n", __func__);
+		return rc;
+	}
+
+	rc = ps_led_setup(0x7F, ltr553);
+	if (rc < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS LED Setup Fail...\n", __func__);
+		return rc;
+	}
+
+	rc = ps_ledPulseCount_setup(0x08, ltr553);
+	if (rc < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS LED pulse count setup Fail...\n", __func__);
+	}
+
+	rc = ps_meas_rate_setup(10, ltr553);
+	if (rc < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS MeasRate Setup Fail...\n", __func__);
+		return rc;
+	}
+
+	rc = ps_contr_setup(0x00, ltr553);
+	if (rc < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS Enable Fail...\n", __func__);
+		return rc;
+	}
+
+	/* dummy read*/
+	buffer[0] = LTR553_PS_CONTR;
+	I2C_Read(buffer, 1);
+	/* dummy read*/
+
+	ltr553->ps_enable_flag = 0;
+
+	return rc;
+}
+
+
+/* PS Disable */
+static int8_t ps_disable(struct ltr553_data *ltr553)
+{
+	int8_t rc = 0;
+
+	if (ltr553->ps_enable_flag == 0) {
+		dev_info(&ltr553->i2c_client->dev,
+			"%s: already disabled\n", __func__);
+		return 0;
+	}
+
+	/*rc = _ltr553_set_bit(ltr553->i2c_client,
+					CLR_BIT, LTR553_PS_CONTR, PS_MODE);*/
+	rc = ps_mode_setup(CLR_BIT, ltr553);
+	if (rc < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS Disable Fail...\n", __func__);
+		return rc;
+	}
+
+	ltr553->ps_enable_flag = 0;
+
+	return rc;
+}
+
+
+/* PS open fops */
+int ps_open(struct inode *inode, struct file *file)
+{
+	struct ltr553_data *ltr553 = sensor_info;
+
+	if (ltr553->ps_opened)
+		return -EBUSY;
+
+	ltr553->ps_opened = 1;
+
+	return 0;
+}
+
+
+/* PS release fops */
+int ps_release(struct inode *inode, struct file *file)
+{
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ltr553->ps_opened = 0;
+
+	return ps_disable(ltr553);
+}
+
+/* PS IOCTL */
+static long ps_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int rc = 0, val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	pr_info("%s cmd %d\n", __func__, _IOC_NR(cmd));
+
+	switch (cmd) {
+	case LTR553_IOCTL_PS_ENABLE:
+			if (get_user(val, (unsigned long __user *)arg)) {
+				rc = -EFAULT;
+				break;
+			}
+			rc = val ? ps_enable_init(ltr553) : ps_disable(ltr553);
+
+			break;
+	case LTR553_IOCTL_PS_GET_ENABLED:
+			rc = put_user(ltr553->ps_enable_flag,
+					(unsigned long __user *)arg);
+
+			break;
+	default:
+			pr_err("%s: INVALID COMMAND %d\n",
+				__func__, _IOC_NR(cmd));
+			rc = -EINVAL;
+	}
+
+	return rc;
+}
+
+static const struct file_operations ps_fops = {
+	.owner = THIS_MODULE,
+	.open = ps_open,
+	.release = ps_release,
+	.unlocked_ioctl = ps_ioctl
+};
+
+struct miscdevice ps_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "ltr553_ps",
+	.fops = &ps_fops
+};
+
+
+static int8_t als_enable_init(struct ltr553_data *ltr553)
+{
+	int8_t rc = 0;
+	uint8_t buffer[1]; /* for dummy read*/
+
+	/* if device not enabled, enable it */
+	if (ltr553->als_enable_flag) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: ALS already enabled...\n", __func__);
+		return rc;
+	}
+    /* change the  ALS_MEAS_RATE register to increase the rate of interupt, so it can avoid
+	"edge jump" with FW. default:0x03 */
+	rc = als_meas_rate_reg_setup(0x08, ltr553);
+	if (rc < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS_Meas_Rate register Setup Fail...\n", __func__);
+		return rc;
+	}
+
+	/* Set minimummax thresholds where interrupt will *not* be generated */
+#if ACT_INTERRUPT
+	/*rc = set_als_range(ALS_MIN_MEASURE_VAL,
+				ALS_MIN_MEASURE_VAL, LO_N_HI_LIMIT);*/
+	rc = set_als_range(ALS_MAX_MEASURE_VAL,
+			ALS_MIN_MEASURE_VAL, LO_N_HI_LIMIT);
+#else
+	rc = set_als_range(ALS_MIN_MEASURE_VAL,
+			ALS_MAX_MEASURE_VAL, LO_N_HI_LIMIT);
+#endif
+	if (rc < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s : ALS Thresholds Write Fail...\n", __func__);
+		return rc;
+	}
+
+	rc = als_contr_setup(0x0C, ltr553);
+	if (rc < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS Enable Fail...\n", __func__);
+		return rc;
+	}
+
+	/* dummy read*/
+	buffer[0] = LTR553_ALS_CONTR;
+	I2C_Read(buffer, 1);
+	/* dumy read*/
+
+	ltr553->als_enable_flag = 0;
+
+	return rc;
+}
+
+
+static int8_t als_disable(struct ltr553_data *ltr553)
+{
+	int8_t rc = 0;
+
+	if (ltr553->als_enable_flag == 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s : ALS already disabled...\n", __func__);
+		return rc;
+	}
+
+	/*rc = _ltr553_set_bit(ltr553->i2c_client,
+				CLR_BIT, LTR553_ALS_CONTR, ALS_MODE);*/
+	rc = als_mode_setup(CLR_BIT, ltr553);
+	if (rc < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS Disable Fail...\n", __func__);
+		return rc;
+	}
+	ltr553->als_enable_flag = 0;
+
+	return rc;
+}
+
+
+int als_open(struct inode *inode, struct file *file)
+{
+	struct ltr553_data *ltr553 = sensor_info;
+	int8_t rc = 0;
+
+	if (ltr553->als_opened) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS already Opened...\n", __func__);
+		rc = -EBUSY;
+	}
+	ltr553->als_opened = 1;
+
+	return rc;
+}
+
+
+int als_release(struct inode *inode, struct file *file)
+{
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ltr553->als_opened = 0;
+
+	return als_disable(ltr553);
+}
+
+static long als_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int rc = 0, val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	pr_debug("%s cmd %d\n", __func__, _IOC_NR(cmd));
+
+	switch (cmd) {
+	case LTR553_IOCTL_ALS_ENABLE:
+			if (get_user(val, (unsigned long __user *)arg)) {
+				rc = -EFAULT;
+				break;
+			}
+			/*pr_info("%s value = %d\n", __func__, val);*/
+		rc = val ? als_enable_init(ltr553) : als_disable(ltr553);
+
+				break;
+	case LTR553_IOCTL_ALS_GET_ENABLED:
+			val = ltr553->als_enable_flag;
+			/*pr_info("%s enabled %d\n", __func__, val);*/
+			rc = put_user(val, (unsigned long __user *)arg);
+
+				break;
+	default:
+			pr_err("%s: INVALID COMMAND %d\n",
+				__func__, _IOC_NR(cmd));
+			rc = -EINVAL;
+	}
+
+	return rc;
+}
+
+
+static const struct file_operations als_fops = {
+	.owner = THIS_MODULE,
+	.open = als_open,
+	.release = als_release,
+	.unlocked_ioctl = als_ioctl
+};
+
+static struct miscdevice als_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "ltr553_ls",
+	.fops = &als_fops
+};
+
+static uint16_t set_ps_offset(struct ltr553_data *ltr553, uint8_t *buf)
+{
+	int8_t ret;
+
+	buf[0] = LTR553_PS_OFFSET_1;
+
+	ret = I2C_Write(buf, 3);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s | 0x%02X", __func__, buf[0]);
+		return ret;
+	}
+
+	return 0;
+}
+
+/* fix psensor poll invalid error in ring up */
+static int ltr553_cdev_set_poll_delay(struct sensors_classdev *sensors_cdev,
+		unsigned int msecs)
+{
+	return 0;
+}
+
+/* qualcomm new sensor calibrate interface */
+static int ltr553_cdev_calibrate(struct sensors_classdev *sensors_cdev,
+		int axis, int apply_now)
+{
+	uint8_t reg_buf[4] = {0};
+	uint16_t value;
+
+	struct ltr553_data *ltr553 = container_of(sensors_cdev, struct ltr553_data,
+			ps_cdev);
+
+	if (sensors_cdev->params == NULL) {
+		sensors_cdev->params = devm_kzalloc(&ltr553->i2c_client->dev, 64, GFP_KERNEL);
+		if (sensors_cdev->params == NULL) {
+			dev_err(&ltr553->i2c_client->dev,
+					"ltr553 sensor_cdev allocate memory error!\n");
+			return -EBUSY;
+		}
+	}
+
+	set_ps_offset(ltr553, reg_buf);
+	value = read_ps_adc_value(ltr553);
+
+	if (value < 50)
+		reg_buf[2] = 10;
+	else if (value < 100)
+		reg_buf[2] = 50;
+	else if (value < 200)
+		reg_buf[2] = 100;
+	else if (value < 400)
+		reg_buf[2] = 200;
+	else
+		reg_buf[2] = 255;
+
+	set_ps_offset(ltr553, reg_buf);
+	snprintf(sensors_cdev->params, 64, "%d,%d,%d", 0, 0, reg_buf[2]);
+
+	return 0;
+}
+
+static int ltr553_cdev_write_cal_params(struct sensors_classdev
+		*sensors_cdev, struct cal_result_t *cal_result)
+{
+	uint8_t reg_buf[3] = {0};
+	struct ltr553_data *ltr553 = container_of(sensors_cdev, struct ltr553_data,
+			ps_cdev);
+
+	if (sensors_cdev->params == NULL) {
+		sensors_cdev->params = devm_kzalloc(&ltr553->i2c_client->dev, 64, GFP_KERNEL);
+		if (sensors_cdev->params == NULL) {
+			dev_err(&ltr553->i2c_client->dev,
+					"ltr553 sensor_cdev allocate memory error!\n");
+			return -EBUSY;
+		}
+	}
+
+	reg_buf[2] = (uint8_t)cal_result->offset[2];
+	ltr553->ps_cali = reg_buf[2];
+	set_ps_offset(ltr553, reg_buf);
+	snprintf(sensors_cdev->params, 64, "%d,%d,%d", 0, 0, reg_buf[2]);
+
+	return 0;
+}
+
+
+static ssize_t als_adc_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	uint16_t value;
+	int ret;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/*ltr553->mode = ALS;*/
+	/*value = read_adc_value(ltr553);*/
+	value = read_als_adc_value(ltr553);
+	input_report_abs(ltr553->als_input_dev, ABS_MISC, value);
+	input_sync(ltr553->als_input_dev);
+	ret = snprintf(buf, sizeof(*buf), "%d", value);
+
+	return ret;
+}
+
+static DEVICE_ATTR(als_adc, 0444, als_adc_show, NULL);
+
+
+static ssize_t ps_adc_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	uint16_t value;
+	int ret;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/*ltr553->mode = PS;*/
+	/*value = read_adc_value(ltr553);*/
+	value = read_ps_adc_value(ltr553);
+	printk("ps_adc:%d\n", value);
+	ret = snprintf(buf, sizeof(*buf), "%d", value);
+
+	return ret;
+}
+
+static DEVICE_ATTR(ps_adc, 0444, ps_adc_show, NULL);
+
+
+static ssize_t psadcsaturationBit_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	uint16_t value;
+	uint8_t saturation_bit;
+	int ret;
+	uint8_t buffer[3];
+	struct ltr553_data *ltr553 = sensor_info;
+
+	buffer[0] = LTR553_PS_DATA_0;
+	ret = I2C_Read(buffer, 2);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s | 0x%02X", __func__, buffer[0]);
+		return ret;
+	}
+	value = (uint16_t)buffer[0] | ((uint16_t)buffer[1] << 8);
+	/*ltr553->mode = PS_W_SATURATION_BIT;*/
+	/*value = read_adc_value(ltr553);*/
+	saturation_bit = (value >> 15);
+	value &= PS_VALID_MEASURE_MASK;
+	ret = snprintf(buf, sizeof(*buf), "%d %d\n", value, saturation_bit);
+
+	return ret;
+}
+
+static DEVICE_ATTR(psadcsaturationBit, 0444, psadcsaturationBit_show, NULL);
+
+
+static ssize_t ltr553help_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	pr_info("To show ALS value : cat als_adc\n");
+	pr_info("To show PS value : cat ps_adc\n");
+	pr_info("To show PS value with saturation bit : cat psadcsaturationBit\n\n");
+
+	/* address 0x80*/
+	pr_info("Address 0x80 (ALS_CONTR)\n");
+	pr_info("ALS active mode : echo 1 > enable\n");
+	pr_info("ALS standby mode : echo 0 > enable\n");
+	pr_info("To read ALS mode : cat enable\n\n");
+
+	pr_info("ALS SW reset : echo 1 > alsswresetsetup\n");
+	pr_info("ALS SW not reset : echo 0 > alsswresetsetup\n");
+	pr_info("To read ALS SW reset bit : cat alsswresetsetup\n\n");
+
+	pr_info("ALS gain 1x : echo 1 > alsgainsetup\n");
+	pr_info("ALS gain 2x : echo 2 > alsgainsetup\n");
+	pr_info("ALS gain 4x : echo 4 > alsgainsetup\n");
+	pr_info("ALS gain 8x : echo 8 > alsgainsetup\n");
+	pr_info("ALS gain 48x : echo 48 > alsgainsetup\n");
+	pr_info("ALS gain 96x : echo 96 > alsgainsetup\n");
+	pr_info("To read ALS gain : cat alsgainsetup\n\n");
+
+	pr_info("Write ALS_CONTR register: echo [hexcode value] > alscontrsetup\n");
+	pr_info("Example...to write 0x13 : echo 13 > alscontrsetup\n");
+	pr_info("To read register ALS_CONTR (0x80) : cat alscontrsetup\n\n");
+	/* address 0x80*/
+
+	/* address 0x81*/
+	pr_info("Address 0x81 (PS_CONTR)\n");
+	pr_info("PS active mode : echo 1 > enable\n");
+	pr_info("PS standby mode : echo 0 > enable\n");
+	pr_info("To read PS mode : cat enable\n\n");
+
+	pr_info("PS gain x16 : echo 16 > psgainsetup\n");
+	pr_info("PS gain x32 : echo 32 > psgainsetup\n");
+	pr_info("PS gain x64 : echo 64 > psgainsetup\n");
+	pr_info("To read PS gain : cat psgainsetup\n\n");
+
+	pr_info("PS saturation indicator enable : echo 1 > pssatuindicasetup\n");
+	pr_info("PS saturation indicator disable : echo 0 > pssatuindicasetup\n");
+	pr_info("To read back PS saturation indicator : cat pssatuindicasetup\n\n");
+
+	pr_info("Example...to write 0x13 : echo 13 > pscontrsetup\n");
+	pr_info("To read register PS_CONTR (0x81) : cat pscontrsetup\n\n");
+	/* address 0x81*/
+
+	/* address 0x82*/
+	pr_info("Address 0x82 (PS_LED)\n");
+	pr_info("LED current 5mA : echo 5 > psledcurrsetup\n");
+	pr_info("LED current 10mA : echo 10 > psledcurrsetup\n");
+	pr_info("LED current 20mA : echo 20 > psledcurrsetup\n");
+	pr_info("LED current 50mA : echo 50 > psledcurrsetup\n");
+	pr_info("LED current 100mA : echo 100 > psledcurrsetup\n");
+	pr_info("To read LED current : cat psledcurrsetup\n\n");
+
+	pr_info("LED current duty 25%% : echo 25 > psledcurrduty\n");
+	pr_info("LED current duty 50%% : echo 50 > psledcurrduty\n");
+	pr_info("LED current duty 75%% : echo 75 > psledcurrduty\n");
+	pr_info("LED current duty 100%% : echo 100 > psledcurrduty\n");
+	pr_info("To read LED current duty : cat psledcurrduty\n\n");
+
+	pr_info("LED pulse freq 30kHz : echo 30 > psledpulsefreqsetup\n");
+	pr_info("LED pulse freq 40kHz : echo 40 > psledpulsefreqsetup\n");
+	pr_info("LED pulse freq 50kHz : echo 50 > psledpulsefreqsetup\n");
+	pr_info("LED pulse freq 60kHz : echo 60 > psledpulsefreqsetup\n");
+	pr_info("LED pulse freq 70kHz : echo 70 > psledpulsefreqsetup\n");
+	pr_info("LED pulse freq 80kHz : echo 80 > psledpulsefreqsetup\n");
+	pr_info("LED pulse freq 90kHz : echo 90 > psledpulsefreqsetup\n");
+	pr_info("LED pulse freq 100kHz : echo 100 > psledpulsefreqsetup\n");
+	pr_info("To read LED pulse freq : cat psledpulsefreqsetup\n\n");
+
+	pr_info("Example...to write 0x13 : echo 13 > psledsetup\n");
+	pr_info("To read register PS_LED (0x82) : cat psledsetup\n\n");
+	/* address 0x82*/
+
+	/* address 0x83*/
+	pr_info("Address 0x83 (PS_N_PULSES)\n");
+	pr_info("[pulse count num] must be 0 to 15, inclusive\n");
+	pr_info("Example...to set 0 count : echo 0 > psledpulsecountsetup\n");
+	pr_info("Example...to set 13 counts : echo 13 > psledpulsecountsetup\n");
+	/* address 0x83*/
+
+	/* address 0x84*/
+	pr_info("Address 0x84 (PS_MEAS_RATE)\n");
+	pr_info("PS meas repeat rate 50ms : echo 50 > psmeasratesetup\n");
+	pr_info("PS meas repeat rate 70ms : echo 70 > psmeasratesetup\n");
+	pr_info("PS meas repeat rate 100ms : echo 100 > psmeasratesetup\n");
+	pr_info("PS meas repeat rate 200ms : echo 200 > psmeasratesetup\n");
+	pr_info("PS meas repeat rate 500ms : echo 500 > psmeasratesetup\n");
+	pr_info("PS meas repeat rate 1000ms : echo 1000 > psmeasratesetup\n");
+	pr_info("PS meas repeat rate 2000ms : echo 2000 > psmeasratesetup\n");
+	pr_info("PS meas repeat rate 10ms : echo 10 > psmeasratesetup\n");
+	pr_info("To read register PS_MEAS_RATE (0x84) : cat psmeasratesetup\n\n");
+	/* address 0x84*/
+
+	/* address 0x85*/
+	pr_info("Address 0x85 (ALS_MEAS_RATE)\n");
+	pr_info("ALS meas repeat rate 50ms : echo 50 > alsmeasratesetup\n");
+	pr_info("ALS meas repeat rate 100ms : echo 100 > alsmeasratesetup\n");
+	pr_info("ALS meas repeat rate 200ms : echo 200 > alsmeasratesetup\n");
+	pr_info("ALS meas repeat rate 500ms : echo 500 > alsmeasratesetup\n");
+	pr_info("ALS meas repeat rate 1000ms : echo 1000 > alsmeasratesetup\n");
+	pr_info("ALS meas repeat rate 2000ms : echo 2000 > alsmeasratesetup\n");
+	pr_info("To read ALS meas repeat rate : cat alsmeasratesetup\n\n");
+
+	pr_info("ALS integration time 100ms : echo 100 > alsintegtimesetup\n");
+	pr_info("ALS integration time 50ms : echo 50 > alsintegtimesetup\n");
+	pr_info("ALS integration time 200ms : echo 200 > alsintegtimesetup\n");
+	pr_info("ALS integration time 400ms : echo 400 > alsintegtimesetup\n");
+	pr_info("ALS integration time 150ms : echo 150 > alsintegtimesetup\n");
+	pr_info("ALS integration time 250ms : echo 250 > alsintegtimesetup\n");
+	pr_info("ALS integration time 300ms : echo 300 > alsintegtimesetup\n");
+	pr_info("ALS integration time 350ms : echo 350 > alsintegtimesetup\n");
+	pr_info("To read ALS integration time : cat alsintegtimesetup\n\n");
+
+	pr_info("Example...to write 0x13 : echo 13 > alsmeasrateregsetup\n");
+	pr_info("To read register ALS_MEAS (0x85) : cat alsmeasrateregsetup\n\n");
+	/* address 0x85*/
+
+	/* address 0x86*/
+	pr_info("To read part ID : cat partid\n");
+	pr_info("To read revision ID : cat revid\n");
+	pr_info("To read PART_ID register (0x86) : cat partidreg\n\n");
+	/* address 0x86*/
+
+	/* address 0x87*/
+	pr_info("To read manufacturing ID : cat manuid\n\n");
+	/* address 0x87*/
+
+	/* address 0x8C*/
+	pr_info("Address 0x8C (ALS_PS_STATUS)\n");
+	pr_info("To read PS data status : cat psdatastatus\n");
+	pr_info("To read PS interrupt status : cat psinterruptstatus\n");
+	pr_info("To read ALS data status : cat alsdatastatus\n");
+	pr_info("To read ALS interrupt status : cat alsinterruptstatus\n");
+	pr_info("To read ALS gain status : cat alsgainstatus\n");
+	pr_info("To read ALS validity status : cat alsdatavaliditystatus\n");
+	pr_info("To read register ALS_PS_STATUS (0x8C) : cat alspsstatusreg\n\n");
+	/* address 0x8C*/
+
+	/* address 0x88, 0x89, 0x8A, 0x8B*/
+	pr_info("ALS raw and calculated data, address 0x88, 0x89, 0x8A, 0x8B\n");
+	pr_info("To read raw and calculated ALS data : cat alsch0ch1rawcalc\n\n");
+	/* address 0x88, 0x89, 0x8A, 0x8B*/
+
+	/* address 0x94, 0x95*/
+	pr_info("Example...to write 55 : echo 55 > setpsoffset\n");
+	pr_info("To read back the offset value : cat setpsoffset\n\n");
+	/* address 0x94, 0x95*/
+
+	/* address 0x8F*/
+	pr_info("Address 0x8F (INTERRUPT)\n");
+	pr_info("INT output pin inactive : echo 0 > interruptmodesetup\n");
+	pr_info("Only PS triggers interrupt : echo 1 > interruptmodesetup\n");
+	pr_info("Only ALS triggers interrupt : echo 2 > interruptmodesetup\n");
+	pr_info("Both ALS PS trigger interrupt : echo 3 > interruptmodesetup\n");
+	pr_info("To read interrupt mode : cat interruptmodesetup\n\n");
+
+	pr_info("INT output pin active low : echo 0 > interruptpolarsetup\n");
+	pr_info("INT output pin active high : echo 1 > interruptpolarsetup\n");
+	pr_info("To read interrupt pin polarity : cat interruptpolarsetup\n\n");
+
+	pr_info("Example...to write 0x13 : echo 13 > interruptsetup\n");
+	pr_info("To read register INTERRUPT (0x8F) : cat interruptsetup\n\n");
+	/* address 0x8F*/
+
+	/* address 0x9E*/
+	pr_info("Address 0x9E (INTERRUPT PERSIST)\n");
+	pr_info("Example...to write 0x13 : echo 13 > interruptpersistsetup\n");
+	/* address 0x9E*/
+
+	/* ALS threshold setting*/
+	pr_info("To read the threshold values : cat dispalsthrerange\n\n");
+	/* ALS threshold setting*/
+
+	/* PS threshold setting*/
+	pr_info("PS threshold setting 0x90, 0x91, 0x92, 0x93\n");
+	pr_info("To read the threshold values : cat disppsthrerange\n\n");
+	/* PS threshold setting*/
+
+	return 0;
+}
+
+static DEVICE_ATTR(ltr553help, 0444, ltr553help_show, NULL);
+
+
+static ssize_t alsmodesetup_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_contr_readback(ALS_MODE_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS_MODE_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+static ssize_t alsmodesetup_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int param;
+	int8_t ret;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	sscanf(buf, "%d", &param);
+	dev_dbg(&ltr553->i2c_client->dev,
+				"%s: store value = %d\n", __func__, param);
+
+	ret = als_mode_setup((uint8_t)param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: ALS mode setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(enable_als_sensor, 0666,
+				alsmodesetup_show, alsmodesetup_store);
+
+
+static ssize_t alsswresetsetup_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_contr_readback(ALS_SWRT_RDBCK, &rdback_val, ltr553);
+
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS_SWRT_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+
+static ssize_t alsswresetsetup_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int param;
+	int8_t ret;
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	sscanf(buf, "%d", &param);
+	dev_dbg(&ltr553->i2c_client->dev,
+			"%s: store value = %d\n", __func__, param);
+
+	ret = als_sw_reset_setup((uint8_t)param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS sw reset setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(alsswresetsetup, 0666,
+				alsswresetsetup_show, alsswresetsetup_store);
+
+
+static ssize_t alsgainsetup_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_contr_readback(ALS_GAIN_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS_GAIN_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+
+static ssize_t alsgainsetup_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint8_t param;
+	/*int *param_temp = buf;*/
+	int param_temp[2];
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/*sscanf(buf, "%d", param_temp);*/
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+
+	if (count <= 1) {
+		param_temp[0] = 0;
+		param_temp[1] = 0;
+	} else if (count == 2) {
+		param_temp[0] -= 48;
+		param_temp[1] = 0;
+
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 0;
+	} else if (count >= 3) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+	}
+
+	param = ((param_temp[0] * 10) + param_temp[1]);
+	dev_dbg(&ltr553->i2c_client->dev,
+				"%s: store value = %d\n", __func__, param);
+
+	ret = als_gain_setup((uint8_t)param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: ALS gain setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static ssize_t alscontrsetup_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_contr_readback(ALS_CONTR_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS_CONTR_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+static DEVICE_ATTR(alsgainsetup, 0666, alsgainsetup_show, alsgainsetup_store);
+
+static ssize_t alscontrsetup_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint8_t param;
+	/*int *param_temp = buf;*/
+	int param_temp[2];
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/*sscanf(buf, "%d", param_temp);*/
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+
+	if (count <= 1) {
+		param_temp[0] = 48;
+		param_temp[1] = 48;
+	} else if (count == 2) {
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 48;
+	}
+
+
+	if (param_temp[0] >= 65 && param_temp[0] <= 70)
+		param_temp[0] -= 55;
+	else if (param_temp[0] >= 97 && param_temp[0] <= 102)
+		param_temp[0] -= 87;
+	else if (param_temp[0] >= 48 && param_temp[0] <= 57)
+		param_temp[0] -= 48;
+	else
+		param_temp[0] = 0;
+
+	if (param_temp[1] >= 65 && param_temp[1] <= 70)
+		param_temp[1] -= 55;
+	else if (param_temp[1] >= 97 && param_temp[1] <= 102)
+		param_temp[1] -= 87;
+	else if (param_temp[1] >= 48 && param_temp[1] <= 57)
+		param_temp[1] -= 48;
+	else
+		param_temp[1] = 0;
+
+	param = ((param_temp[0] << 4) + (param_temp[1]));
+	dev_dbg(&ltr553->i2c_client->dev,
+			"%s: store value = %d\n", __func__, param);
+
+	ret = als_contr_setup(param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: ALS contr setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(alscontrsetup, 0666, alscontrsetup_show,
+					alscontrsetup_store);
+
+
+static int ltr553_enable_ps_sensor(struct i2c_client *client, int val);
+
+static ssize_t ltr553_input_enable_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int param, ret;
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	sscanf(buf, "%d", &param);
+	dev_dbg(&ltr553->i2c_client->dev,
+		"%s: store value = %d\n", __func__, param);
+
+	ret = ltr553_enable_ps_sensor(ltr553->i2c_client, param);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: input enable Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(enable_ps_sensor, 0222, NULL, ltr553_input_enable_store);
+
+static ssize_t ltr553_prox_raw_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint16_t adc_value = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	adc_value = read_ps_adc_value(ltr553);
+	ret = sprintf(buf, "%d\n", adc_value);
+
+	return ret;
+}
+
+static DEVICE_ATTR(prox_raw, 0444, ltr553_prox_raw_show, NULL);
+
+
+static ssize_t psgainsetup_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = ps_contr_readback(PS_GAIN_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: PS_GAIN_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+
+static ssize_t psgainsetup_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint8_t param;
+	int8_t ret;
+	int param_temp[2];
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+
+	if (count <= 2) {
+		param_temp[0] = 0;
+		param_temp[1] = 0;
+	} else if (count >= 3) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+	}
+
+	param = ((param_temp[0] * 10) + param_temp[1]);
+
+	dev_dbg(&ltr553->i2c_client->dev,
+	"%s: store value = %d\n", __func__, param);
+
+	ret = ps_gain_setup(param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS gain setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(psgainsetup, 0666, psgainsetup_show, psgainsetup_store);
+
+
+static ssize_t pssatuindicasetup_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = ps_contr_readback(PS_SATUR_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: PS_SATUR_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+
+static ssize_t pssatuindicasetup_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int param;
+	int8_t ret;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	sscanf(buf, "%d", &param);
+	dev_dbg(&ltr553->i2c_client->dev,
+		"%s: store value = %d\n", __func__, param);
+
+	ret = ps_satu_indica_setup((uint8_t)param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: PS saturation indicator setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(pssatuindicasetup, 0666,
+		pssatuindicasetup_show, pssatuindicasetup_store);
+
+
+static ssize_t pscontrsetup_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = ps_contr_readback(PS_CONTR_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: PS_CONTR_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+
+static ssize_t pscontrsetup_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint8_t param;
+	/*int *param_temp = buf;*/
+	int param_temp[2];
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/*sscanf(buf, "%d", param_temp);*/
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+
+	if (count <= 1) {
+		param_temp[0] = 48;
+		param_temp[1] = 48;
+	} else if (count == 2) {
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 48;
+	}
+
+	if (param_temp[0] >= 65 && param_temp[0] <= 70)
+		param_temp[0] -= 55;
+	else if (param_temp[0] >= 97 && param_temp[0] <= 102)
+		param_temp[0] -= 87;
+	else if (param_temp[0] >= 48 && param_temp[0] <= 57)
+		param_temp[0] -= 48;
+	else
+		param_temp[0] = 0;
+
+	if (param_temp[1] >= 65 && param_temp[1] <= 70)
+		param_temp[1] -= 55;
+	else if (param_temp[1] >= 97 && param_temp[1] <= 102)
+		param_temp[1] -= 87;
+	else if (param_temp[1] >= 48 && param_temp[1] <= 57)
+		param_temp[1] -= 48;
+	else
+		param_temp[1] = 0;
+
+	param = ((param_temp[0] << 4) + (param_temp[1]));
+	dev_dbg(&ltr553->i2c_client->dev,
+		"%s: store value = %d\n", __func__, param);
+
+	ret = ps_contr_setup(param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: PS contr setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(pscontrsetup, 0666, pscontrsetup_show, pscontrsetup_store);
+
+
+static ssize_t psledcurrsetup_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = ps_led_readback(LED_CURR_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: LED_CURR_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+
+}
+
+
+static ssize_t psledcurrsetup_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint8_t param;
+	/*int *param_temp = buf;*/
+	int param_temp[3];
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/*sscanf(buf, "%d", param_temp);*/
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+	param_temp[2] = buf[2];
+
+	if (count <= 1) {
+		param_temp[0] = 0;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+	} else if (count == 2) {
+		param_temp[0] -= 48;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+
+		param_temp[2] = param_temp[0];
+		param_temp[0] = 0;
+		param_temp[1] = 0;
+	} else if (count == 3) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] = 0;
+
+		param_temp[2] = param_temp[1];
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 0;
+	} else if (count > 3) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+	}
+
+	param = ((param_temp[0] * 100) + (param_temp[1] * 10) + param_temp[2]);
+	dev_dbg(&ltr553->i2c_client->dev,
+		"%s: store value = %d\n", __func__, param);
+
+	ret = ps_ledCurrent_setup(param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS LED current setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+
+}
+
+static DEVICE_ATTR(psledcurrsetup, 0666,
+			psledcurrsetup_show, psledcurrsetup_store);
+
+
+static ssize_t psledcurrduty_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = ps_led_readback(LED_CURR_DUTY_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: LED_CURR_DUTY_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+
+}
+
+
+static ssize_t psledcurrduty_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint8_t param;
+	/*int *param_temp = buf;*/
+	int param_temp[3];
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/*sscanf(buf, "%d", param_temp);*/
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+	param_temp[2] = buf[2];
+
+	if (count < 3) {
+		param_temp[0] = 0;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+	} else if (count == 3) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] = 0;
+
+		param_temp[2] = param_temp[1];
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 0;
+	} else if (count > 3) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+	}
+
+	param = ((param_temp[0] * 100) + (param_temp[1] * 10) + param_temp[2]);
+	dev_dbg(&ltr553->i2c_client->dev,
+			"%s: store value = %d\n", __func__, param);
+
+	ret = ps_ledCurrDuty_setup(param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS LED curent duty setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(psledcurrduty, 0666,
+			psledcurrduty_show, psledcurrduty_store);
+
+
+static ssize_t psledpulsefreqsetup_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = ps_led_readback(LED_PUL_FREQ_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: LED_PUL_FREQ_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+
+}
+
+
+static ssize_t psledpulsefreqsetup_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint8_t param;
+	/*int *param_temp = buf;*/
+	int param_temp[3];
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/*sscanf(buf, "%d", param_temp);*/
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+	param_temp[2] = buf[2];
+
+	if (count < 3) {
+		param_temp[0] = 0;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+	} else if (count == 3) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] = 0;
+
+		param_temp[2] = param_temp[1];
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 0;
+	} else if (count > 3) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+	}
+
+	param = ((param_temp[0] * 100) + (param_temp[1] * 10) + param_temp[2]);
+	dev_dbg(&ltr553->i2c_client->dev,
+		"%s: store value = %d\n", __func__, param);
+
+	ret = ps_ledPulseFreq_setup(param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS LED pulse frequency setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(psledpulsefreqsetup, 0666,
+		psledpulsefreqsetup_show, psledpulsefreqsetup_store);
+
+
+static ssize_t psledsetup_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = ps_led_readback(PS_LED_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS_LED_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+
+static ssize_t psledsetup_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint8_t param;
+	/*int *param_temp = buf;*/
+	int param_temp[2];
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/*sscanf(buf, "%d", param_temp);*/
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+
+	if (count <= 1) {
+		param_temp[0] = 48;
+		param_temp[1] = 48;
+	} else if (count == 2) {
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 48;
+	}
+
+	if (param_temp[0] >= 65 && param_temp[0] <= 70)
+		param_temp[0] -= 55;
+	else if (param_temp[0] >= 97 && param_temp[0] <= 102)
+		param_temp[0] -= 87;
+	else if (param_temp[0] >= 48 && param_temp[0] <= 57)
+		param_temp[0] -= 48;
+	else
+		param_temp[0] = 0;
+
+	if (param_temp[1] >= 65 && param_temp[1] <= 70)
+		param_temp[1] -= 55;
+	else if (param_temp[1] >= 97 && param_temp[1] <= 102)
+		param_temp[1] -= 87;
+	else if (param_temp[1] >= 48 && param_temp[1] <= 57)
+		param_temp[1] -= 48;
+	else
+		param_temp[1] = 0;
+
+	param = ((param_temp[0] << 4) + (param_temp[1]));
+	dev_dbg(&ltr553->i2c_client->dev,
+		"%s: store value = %d\n", __func__, param);
+
+	ret = ps_led_setup(param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: PS LED setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(psledsetup, 0666, psledsetup_show, psledsetup_store);
+
+
+static ssize_t psledpulsecountsetup_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = ps_ledPulseCount_readback(&rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS LED pulse count readback Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+
+static ssize_t psledpulsecountsetup_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint8_t param;
+	/*int *param_temp = buf;*/
+	int param_temp[2];
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/*sscanf(buf, "%d", param_temp);*/
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+
+	if ((count <= 1) || (count > 3)) {
+		param_temp[0] = 0;
+		param_temp[1] = 0;
+	} else if (count == 2) {
+		param_temp[0] -= 48;
+		param_temp[1] = 0;
+
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 0;
+	} else if (count == 3) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+	}
+
+	param = ((param_temp[0] * 10) + param_temp[1]);
+	if (param > 15)
+		param = 15;
+
+	dev_dbg(&ltr553->i2c_client->dev,
+		"%s: store value = %d\n", __func__, param);
+
+	ret = ps_ledPulseCount_setup(param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS LED pulse count setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(psledpulsecountsetup, 0666,
+			psledpulsecountsetup_show, psledpulsecountsetup_store);
+
+
+static ssize_t psmeasratesetup_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = ps_meas_rate_readback(&rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS meas rate readback Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+
+}
+
+
+static ssize_t psmeasratesetup_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint16_t param;
+	/*int *param_temp = buf;*/
+	int param_temp[4];
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/*sscanf(buf, "%d", param_temp);*/
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+	param_temp[2] = buf[2];
+	param_temp[3] = buf[3];
+
+	if (count <= 2) {
+		param_temp[0] = 0;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+	} else if (count == 3) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+
+		param_temp[3] = param_temp[1];
+		param_temp[2] = param_temp[0];
+		param_temp[1] = 0;
+		param_temp[0] = 0;
+	} else if (count == 4) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] = 0;
+
+		param_temp[3] = param_temp[2];
+		param_temp[2] = param_temp[1];
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 0;
+	} else if (count > 4) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] -= 48;
+	}
+
+	param = ((param_temp[0] * 1000) + (param_temp[1] * 100) +
+				(param_temp[2] * 10) + param_temp[3]);
+	dev_dbg(&ltr553->i2c_client->dev,
+			"%s: store value = %d\n", __func__, param);
+
+	ret = ps_meas_rate_setup(param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: PS measurement rate setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(psmeasratesetup, 0666,
+		psmeasratesetup_show, psmeasratesetup_store);
+
+
+static ssize_t alsmeasratesetup_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_meas_rate_readback(ALS_MEAS_RPT_RATE_RDBCK,
+		&rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS_MEAS_RPT_RATE_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+
+}
+
+
+static ssize_t alsmeasratesetup_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint16_t param;
+	/*int *param_temp = buf;*/
+	int param_temp[4];
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/*sscanf(buf, "%d", param_temp);*/
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+	param_temp[2] = buf[2];
+	param_temp[3] = buf[3];
+
+	if (count <= 2) {
+		param_temp[0] = 0;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+	} else if (count == 3) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+
+		param_temp[3] = param_temp[1];
+		param_temp[2] = param_temp[0];
+		param_temp[1] = 0;
+		param_temp[0] = 0;
+	} else if (count == 4) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] = 0;
+
+		param_temp[3] = param_temp[2];
+		param_temp[2] = param_temp[1];
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 0;
+	} else if (count > 4) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] -= 48;
+	}
+
+	param = ((param_temp[0] * 1000) + (param_temp[1] * 100) +
+				(param_temp[2] * 10) + param_temp[3]);
+	dev_dbg(&ltr553->i2c_client->dev,
+			"%s: store value = %d\n", __func__, param);
+
+	ret = als_meas_rate_setup(param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS measurement rate setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(alsmeasratesetup, 0666,
+				alsmeasratesetup_show, alsmeasratesetup_store);
+
+
+static ssize_t alsintegtimesetup_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_meas_rate_readback(ALS_INTEG_TM_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: ALS_INTEG_TM_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+
+}
+
+
+static ssize_t alsintegtimesetup_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint16_t param;
+	/*int *param_temp = buf;*/
+
+	int param_temp[3];
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/*sscanf(buf, "%d", param_temp);*/
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+	param_temp[2] = buf[2];
+
+	if (count <= 2) {
+		param_temp[0] = 0;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+	} else if (count == 3) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] = 0;
+
+		param_temp[2] = param_temp[1];
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 0;
+	} else if (count > 3) {
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+	}
+
+	param = ((param_temp[0] * 100) + (param_temp[1] * 10) + param_temp[2]);
+	dev_dbg(&ltr553->i2c_client->dev,
+			"%s: store value = %d\n", __func__, param);
+
+	ret = als_integ_time_setup(param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS integration time setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(alsintegtimesetup, 0666,
+			alsintegtimesetup_show, alsintegtimesetup_store);
+
+
+static ssize_t alsmeasrateregsetup_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_meas_rate_readback(ALS_MEAS_RATE_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS_MEAS_RATE_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+
+}
+
+
+static ssize_t alsmeasrateregsetup_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint8_t param;
+	/*int *param_temp = buf;*/
+	int param_temp[2];
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/*sscanf(buf, "%d", param_temp);*/
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+
+	if (count <= 1) {
+		param_temp[0] = 48;
+		param_temp[1] = 48;
+	} else if (count == 2) {
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 48;
+	}
+
+	if (param_temp[0] >= 65 && param_temp[0] <= 70)
+		param_temp[0] -= 55;
+	else if (param_temp[0] >= 97 && param_temp[0] <= 102)
+		param_temp[0] -= 87;
+	else if (param_temp[0] >= 48 && param_temp[0] <= 57)
+		param_temp[0] -= 48;
+	else
+		param_temp[0] = 0;
+
+	if (param_temp[1] >= 65 && param_temp[1] <= 70)
+		param_temp[1] -= 55;
+	else if (param_temp[1] >= 97 && param_temp[1] <= 102)
+		param_temp[1] -= 87;
+	else if (param_temp[1] >= 48 && param_temp[1] <= 57)
+		param_temp[1] -= 48;
+	else
+		param_temp[1] = 0;
+
+	param = ((param_temp[0] << 4) + (param_temp[1]));
+	dev_dbg(&ltr553->i2c_client->dev,
+		"%s: store value = %d\n", __func__, param);
+
+	ret = als_meas_rate_reg_setup(param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: ALS meas rate register setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(alsmeasrateregsetup, 0666,
+			alsmeasrateregsetup_show, alsmeasrateregsetup_store);
+
+
+static ssize_t partid_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = part_ID_reg_readback(PART_NUM_ID_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: PART_NUM_ID_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+static DEVICE_ATTR(partid, 0444, partid_show, NULL);
+
+
+static ssize_t revid_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = part_ID_reg_readback(REVISION_ID_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: REVISION_ID_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+static DEVICE_ATTR(revid, 0444, revid_show, NULL);
+
+
+static ssize_t partidreg_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = part_ID_reg_readback(PART_ID_REG_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: PART_ID_REG_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+static DEVICE_ATTR(partidreg, 0444, partidreg_show, NULL);
+
+
+static ssize_t manuid_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = manu_ID_reg_readback(&rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: Manufacturing ID readback Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+static DEVICE_ATTR(manuid, 0444, manuid_show, NULL);
+
+
+static ssize_t psdatastatus_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_ps_status_reg(PS_DATA_STATUS_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS_DATA_STATUS_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+static DEVICE_ATTR(psdatastatus, 0444, psdatastatus_show, NULL);
+
+
+static ssize_t psinterruptstatus_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_ps_status_reg(PS_INTERR_STATUS_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS_INTERR_STATUS_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+static DEVICE_ATTR(psinterruptstatus, 0444, psinterruptstatus_show, NULL);
+
+
+static ssize_t alsdatastatus_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_ps_status_reg(ALS_DATA_STATUS_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS_DATA_STATUS_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+static DEVICE_ATTR(alsdatastatus, 0444, alsdatastatus_show, NULL);
+
+
+static ssize_t alsinterruptstatus_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_ps_status_reg(ALS_INTERR_STATUS_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS_INTERR_STATUS_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+static DEVICE_ATTR(alsinterruptstatus, 0444, alsinterruptstatus_show, NULL);
+
+
+static ssize_t alsgainstatus_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_ps_status_reg(ALS_GAIN_STATUS_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS_GAIN_STATUS_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+static DEVICE_ATTR(alsgainstatus, 0444, alsgainstatus_show, NULL);
+
+
+static ssize_t alsdatavaliditystatus_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_ps_status_reg(ALS_VALID_STATUS_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS_VALID_STATUS_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+static DEVICE_ATTR(alsdatavaliditystatus, 0444,
+				alsdatavaliditystatus_show, NULL);
+
+
+static ssize_t alspsstatusreg_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_ps_status_reg(ALS_PS_STATUS_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS_PS_STATUS_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+
+}
+
+static DEVICE_ATTR(alspsstatusreg, 0444, alspsstatusreg_show, NULL);
+
+static ssize_t alsch0ch1rawcalc_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint16_t rdback_val1 = 0, rdback_val2 = 0, rdback_val3 = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_ch0ch1raw_calc_readback(&rdback_val1,
+				&rdback_val2, &rdback_val3, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: ALS CH0 CH1 Calc reading readback Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d %d %d\n",
+			rdback_val1, rdback_val2, rdback_val3);
+
+	return ret;
+
+}
+
+static DEVICE_ATTR(alsch0ch1rawcalc, 0444, alsch0ch1rawcalc_show, NULL);
+
+
+static ssize_t setpsoffset_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint16_t rdback_val;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = ps_offset_readback(&rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: PS offset readback Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+
+static ssize_t setpsoffset_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint16_t ps_offset = 0;
+	uint8_t param_temp[4];
+	struct ltr553_data *ltr553 = sensor_info;
+
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+	param_temp[2] = buf[2];
+	param_temp[3] = buf[3];
+
+	if (count <= 1) {
+		param_temp[0] = 0;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+	} else if (count == 2) { /* 1 digit*/
+		param_temp[0] -= 48;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+
+		param_temp[3] = param_temp[0];
+		param_temp[2] = 0;
+		param_temp[1] = 0;
+		param_temp[0] = 0;
+	} else if (count == 3) { /* 2 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+
+		param_temp[3] = param_temp[1];
+		param_temp[2] = param_temp[0];
+		param_temp[1] = 0;
+		param_temp[0] = 0;
+	} else if (count == 4) { /* 3 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] = 0;
+
+		param_temp[3] = param_temp[2];
+		param_temp[2] = param_temp[1];
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 0;
+	} else if (count >= 5) { /* 4 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] -= 48;
+	}
+
+	ps_offset = ((param_temp[0] * 1000) + (param_temp[1] * 100) +
+					(param_temp[2] * 10) + param_temp[3]);
+	if (ps_offset > 1023)
+		ps_offset = 1023;
+
+	dev_dbg(&ltr553->i2c_client->dev,
+				"%s: store value = %d\n", __func__, ps_offset);
+
+	ret = ps_offset_setup(ps_offset, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: set ps offset Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(setpsoffset, 0666, setpsoffset_show, setpsoffset_store);
+
+
+static ssize_t interruptmodesetup_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = interrupt_readback(INT_MODE_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: INT_MODE_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+
+static ssize_t interruptmodesetup_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int param;
+	int8_t ret;
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	sscanf(buf, "%d", &param);
+	dev_dbg(&ltr553->i2c_client->dev,
+				"%s: store value = %d\n", __func__, param);
+
+	ret = interrupt_mode_setup((uint8_t)param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: interrupt mode setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(interruptmodesetup, 0666,
+		interruptmodesetup_show, interruptmodesetup_store);
+
+
+static ssize_t interruptpolarsetup_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = interrupt_readback(INT_POLAR_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: INT_POLAR_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+
+static ssize_t interruptpolarsetup_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int param;
+	int8_t ret;
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	sscanf(buf, "%d", &param);
+	dev_dbg(&ltr553->i2c_client->dev,
+			"%s: store value = %d\n", __func__, param);
+
+	ret = interrupt_polarity_setup((uint8_t)param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: interrupt polarity setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(interruptpolarsetup, 0666,
+			interruptpolarsetup_show, interruptpolarsetup_store);
+
+
+static ssize_t interruptsetup_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = interrupt_readback(INT_INTERRUPT_RDBCK, &rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: INT_INTERRUPT_RDBCK Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+
+static ssize_t interruptsetup_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint8_t param;
+	/*int *param_temp = buf;*/
+	int param_temp[2];
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	/*sscanf(buf, "%d", param_temp);*/
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+
+	if (count <= 1) {
+		param_temp[0] = 48;
+		param_temp[1] = 48;
+	} else if (count == 2) {
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 48;
+	}
+
+	if (param_temp[0] >= 65 && param_temp[0] <= 70)
+		param_temp[0] -= 55;
+	else if (param_temp[0] >= 97 && param_temp[0] <= 102)
+		param_temp[0] -= 87;
+	else if (param_temp[0] >= 48 && param_temp[0] <= 57)
+		param_temp[0] -= 48;
+	else
+		param_temp[0] = 0;
+
+	if (param_temp[1] >= 65 && param_temp[1] <= 70)
+		param_temp[1] -= 55;
+	else if (param_temp[1] >= 97 && param_temp[1] <= 102)
+		param_temp[1] -= 87;
+	else if (param_temp[1] >= 48 && param_temp[1] <= 57)
+		param_temp[1] -= 48;
+	else
+		param_temp[1] = 0;
+
+	param = ((param_temp[0] << 4) + (param_temp[1]));
+	dev_dbg(&ltr553->i2c_client->dev,
+				"%s: store value = %d\n", __func__, param);
+
+	ret = interrupt_setup(param, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: interrupt setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(interruptsetup, 0666,
+			interruptsetup_show, interruptsetup_store);
+
+
+static ssize_t interruptpersistsetup_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint8_t rdback_val = 0;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = interrupt_prst_readback(&rdback_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: Interrupt persist readback Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d\n", rdback_val);
+
+	return ret;
+}
+
+
+static ssize_t interruptpersistsetup_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret = 0;
+	/*uint8_t als_or_ps, prst_val;*/
+	uint8_t prst_val;
+	/*int *param_temp = buf;*/
+	int param_temp[2];
+
+	struct ltr553_data *ltr553 = sensor_info;
+
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+
+	if (count <= 1) {
+		param_temp[0] = 48;
+		param_temp[1] = 48;
+	} else if (count == 2) {
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 48;
+	}
+
+	if (param_temp[0] >= 65 && param_temp[0] <= 70)
+		param_temp[0] -= 55;
+	else if (param_temp[0] >= 97 && param_temp[0] <= 102)
+		param_temp[0] -= 87;
+	else if (param_temp[0] >= 48 && param_temp[0] <= 57)
+		param_temp[0] -= 48;
+	else
+		param_temp[0] = 0;
+
+	if (param_temp[1] >= 65 && param_temp[1] <= 70)
+		param_temp[1] -= 55;
+	else if (param_temp[1] >= 97 && param_temp[1] <= 102)
+		param_temp[1] -= 87;
+	else if (param_temp[1] >= 48 && param_temp[1] <= 57)
+		param_temp[1] -= 48;
+	else
+		param_temp[1] = 0;
+
+	prst_val = ((param_temp[0] << 4) + (param_temp[1]));
+	dev_dbg(&ltr553->i2c_client->dev,
+			"%s: store value = %d\n", __func__, prst_val);
+
+	/*ret = interrupt_persist_setup(als_or_ps, prst_val, ltr553);*/
+	ret = interrupt_persist_setup(prst_val, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: Interrupt persist setup Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+
+}
+
+static DEVICE_ATTR(interruptpersistsetup, 0666,
+	interruptpersistsetup_show, interruptpersistsetup_store);
+
+
+static ssize_t setalslothrerange_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	int lo_thr = 0;
+	uint8_t param_temp[5];
+	struct ltr553_data *ltr553 = sensor_info;
+
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+	param_temp[2] = buf[2];
+	param_temp[3] = buf[3];
+	param_temp[4] = buf[4];
+
+	if (count <= 1) {
+		param_temp[0] = 0;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+		param_temp[4] = 0;
+	} else if (count == 2) { /* 1 digit*/
+		param_temp[0] -= 48;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+		param_temp[4] = 0;
+
+		param_temp[4] = param_temp[0];
+		param_temp[3] = 0;
+		param_temp[2] = 0;
+		param_temp[1] = 0;
+		param_temp[0] = 0;
+	} else if (count == 3) { /*2 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+		param_temp[4] = 0;
+
+		param_temp[4] = param_temp[1];
+		param_temp[3] = param_temp[0];
+		param_temp[2] = 0;
+		param_temp[1] = 0;
+		param_temp[0] = 0;
+	} else if (count == 4) { /* 3 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] = 0;
+		param_temp[4] = 0;
+
+		param_temp[4] = param_temp[2];
+		param_temp[3] = param_temp[1];
+		param_temp[2] = param_temp[0];
+		param_temp[1] = 0;
+		param_temp[0] = 0;
+	} else if (count == 5) { /* 4 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] -= 48;
+		param_temp[4] = 0;
+
+		param_temp[4] = param_temp[3];
+		param_temp[3] = param_temp[2];
+		param_temp[2] = param_temp[1];
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 0;
+	} else if (count >= 6) { /* 5 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] -= 48;
+		param_temp[4] -= 48;
+	}
+
+	lo_thr = ((param_temp[0] * 10000) + (param_temp[1] * 1000) +
+	(param_temp[2] * 100) + (param_temp[3] * 10) + param_temp[4]);
+	if (lo_thr > 65535)
+		lo_thr = 65535;
+	dev_dbg(&ltr553->i2c_client->dev,
+			"%s: store value = %d\n", __func__, lo_thr);
+
+	ret = set_als_range((uint16_t)lo_thr, 0, LO_LIMIT);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: set ALS lo threshold Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(setalslothrerange, 0222, NULL, setalslothrerange_store);
+
+
+static ssize_t setalshithrerange_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	int hi_thr = 0;
+	uint8_t param_temp[5];
+	struct ltr553_data *ltr553 = sensor_info;
+
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+	param_temp[2] = buf[2];
+	param_temp[3] = buf[3];
+	param_temp[4] = buf[4];
+
+	if (count <= 1) {
+		param_temp[0] = 0;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+		param_temp[4] = 0;
+	} else if (count == 2) { /* 1 digit*/
+		param_temp[0] -= 48;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+		param_temp[4] = 0;
+
+		param_temp[4] = param_temp[0];
+		param_temp[3] = 0;
+		param_temp[2] = 0;
+		param_temp[1] = 0;
+		param_temp[0] = 0;
+	} else if (count == 3) { /* 2 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+		param_temp[4] = 0;
+
+		param_temp[4] = param_temp[1];
+		param_temp[3] = param_temp[0];
+		param_temp[2] = 0;
+		param_temp[1] = 0;
+		param_temp[0] = 0;
+	} else if (count == 4) { /* 3 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] = 0;
+		param_temp[4] = 0;
+
+		param_temp[4] = param_temp[2];
+		param_temp[3] = param_temp[1];
+		param_temp[2] = param_temp[0];
+		param_temp[1] = 0;
+		param_temp[0] = 0;
+	} else if (count == 5) { /* 4 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] -= 48;
+		param_temp[4] = 0;
+
+		param_temp[4] = param_temp[3];
+		param_temp[3] = param_temp[2];
+		param_temp[2] = param_temp[1];
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 0;
+	} else if (count >= 6) { /* 5 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] -= 48;
+		param_temp[4] -= 48;
+	}
+
+	hi_thr = ((param_temp[0] * 10000) + (param_temp[1] * 1000) +
+	(param_temp[2] * 100) + (param_temp[3] * 10) + param_temp[4]);
+	if (hi_thr > 65535)
+		hi_thr = 65535;
+	dev_dbg(&ltr553->i2c_client->dev,
+			"%s: store value = %d\n", __func__, hi_thr);
+
+	ret = set_als_range(0, (uint16_t)hi_thr, HI_LIMIT);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: set ALS hi threshold Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(setalshithrerange, 0222, NULL, setalshithrerange_store);
+
+static ssize_t dispalsthrerange_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint16_t rdback_lo, rdback_hi;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = als_range_readback(&rdback_lo, &rdback_hi, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS threshold range readback Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d %d\n", rdback_lo, rdback_hi);
+
+	return ret;
+}
+
+static DEVICE_ATTR(dispalsthrerange, 0444, dispalsthrerange_show, NULL);
+
+
+static ssize_t setpslothrerange_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint16_t lo_thr = 0;
+	uint8_t param_temp[4];
+	struct ltr553_data *ltr553 = sensor_info;
+
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+	param_temp[2] = buf[2];
+	param_temp[3] = buf[3];
+
+	if (count <= 1) {
+		param_temp[0] = 0;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+	} else if (count == 2) { /* 1 digit*/
+		param_temp[0] -= 48;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+
+		param_temp[3] = param_temp[0];
+		param_temp[2] = 0;
+		param_temp[1] = 0;
+		param_temp[0] = 0;
+	} else if (count == 3) { /* 2 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+
+		param_temp[3] = param_temp[1];
+		param_temp[2] = param_temp[0];
+		param_temp[1] = 0;
+		param_temp[0] = 0;
+	} else if (count == 4) { /* 3 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] = 0;
+
+		param_temp[3] = param_temp[2];
+		param_temp[2] = param_temp[1];
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 0;
+	} else if (count >= 5) { /* 4 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] -= 48;
+	}
+
+	lo_thr = ((param_temp[0] * 1000) + (param_temp[1] * 100) +
+				(param_temp[2] * 10) + param_temp[3]);
+	if (lo_thr > 2047)
+		lo_thr = 2047;
+	dev_dbg(&ltr553->i2c_client->dev,
+			"%s: store value = %d\n", __func__, lo_thr);
+
+	ret = set_ps_range(lo_thr, 0, LO_LIMIT, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: set PS lo threshold Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(setpslothrerange, 0222, NULL, setpslothrerange_store);
+
+
+static ssize_t setpshithrerange_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int8_t ret;
+	uint16_t hi_thr = 0;
+	uint8_t param_temp[4];
+	struct ltr553_data *ltr553 = sensor_info;
+
+	param_temp[0] = buf[0];
+	param_temp[1] = buf[1];
+	param_temp[2] = buf[2];
+	param_temp[3] = buf[3];
+
+	if (count <= 1) {
+		param_temp[0] = 0;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+	} else if (count == 2) { /* 1 digit*/
+		param_temp[0] -= 48;
+		param_temp[1] = 0;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+
+		param_temp[3] = param_temp[0];
+		param_temp[2] = 0;
+		param_temp[1] = 0;
+		param_temp[0] = 0;
+	} else if (count == 3) { /* 2 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] = 0;
+		param_temp[3] = 0;
+
+		param_temp[3] = param_temp[1];
+		param_temp[2] = param_temp[0];
+		param_temp[1] = 0;
+		param_temp[0] = 0;
+	} else if (count == 4) { /* 3 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] = 0;
+
+		param_temp[3] = param_temp[2];
+		param_temp[2] = param_temp[1];
+		param_temp[1] = param_temp[0];
+		param_temp[0] = 0;
+	} else if (count >= 5) { /* 4 digits*/
+		param_temp[0] -= 48;
+		param_temp[1] -= 48;
+		param_temp[2] -= 48;
+		param_temp[3] -= 48;
+	}
+
+	hi_thr = ((param_temp[0] * 1000) + (param_temp[1] * 100) +
+				(param_temp[2] * 10) + param_temp[3]);
+	if (hi_thr > 2047)
+			hi_thr = 2047;
+	dev_dbg(&ltr553->i2c_client->dev,
+			"%s: store value = %d\n", __func__, hi_thr);
+
+	ret = set_ps_range(0, hi_thr, HI_LIMIT, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+				"%s: set PS hi threshold Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(setpshithrerange, 0222, NULL, setpshithrerange_store);
+
+
+static ssize_t disppsthrerange_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int8_t ret = 0;
+	uint16_t rdback_lo, rdback_hi;
+	struct ltr553_data *ltr553 = sensor_info;
+
+	ret = ps_range_readback(&rdback_lo, &rdback_hi, ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: PS threshold range readback Fail...\n", __func__);
+		return -EPERM;
+	}
+
+	ret = snprintf(buf, sizeof(*buf), "%d %d\n", rdback_lo, rdback_hi);
+
+	return ret;
+}
+
+static DEVICE_ATTR(disppsthrerange, 0444, disppsthrerange_show, NULL);
+
+
+static void sysfs_register_device(struct i2c_client *client)
+{
+	int rc = 0;
+
+	rc += device_create_file(&client->dev, &dev_attr_als_adc);
+	rc += device_create_file(&client->dev, &dev_attr_ps_adc);
+	/*rc += device_create_file(&client->dev, &dev_attr_setwinfac1);
+	rc += device_create_file(&client->dev, &dev_attr_setwinfac2);
+	rc += device_create_file(&client->dev, &dev_attr_setwinfac3);*/
+	rc += device_create_file(&client->dev, &dev_attr_psadcsaturationBit);
+	rc += device_create_file(&client->dev, &dev_attr_ltr553help);
+	rc += device_create_file(&client->dev, &dev_attr_enable_als_sensor);
+	rc += device_create_file(&client->dev, &dev_attr_alsswresetsetup);
+	rc += device_create_file(&client->dev, &dev_attr_alsgainsetup);
+	rc += device_create_file(&client->dev, &dev_attr_alscontrsetup);
+	//rc += device_create_file(&client->dev, &dev_attr_enable_ps_sensor);
+	rc += device_create_file(&client->dev, &dev_attr_psgainsetup);
+	rc += device_create_file(&client->dev, &dev_attr_pssatuindicasetup);
+	rc += device_create_file(&client->dev, &dev_attr_pscontrsetup);
+	rc += device_create_file(&client->dev, &dev_attr_psledcurrsetup);
+	rc += device_create_file(&client->dev, &dev_attr_psledcurrduty);
+	rc += device_create_file(&client->dev, &dev_attr_psledpulsefreqsetup);
+	rc += device_create_file(&client->dev, &dev_attr_psledsetup);
+	rc += device_create_file(&client->dev, &dev_attr_psledpulsecountsetup);
+	rc += device_create_file(&client->dev, &dev_attr_psmeasratesetup);
+	rc += device_create_file(&client->dev, &dev_attr_alsmeasratesetup);
+	rc += device_create_file(&client->dev, &dev_attr_alsintegtimesetup);
+	rc += device_create_file(&client->dev, &dev_attr_alsmeasrateregsetup);
+	rc += device_create_file(&client->dev, &dev_attr_partid);
+	rc += device_create_file(&client->dev, &dev_attr_revid);
+	rc += device_create_file(&client->dev, &dev_attr_partidreg);
+	rc += device_create_file(&client->dev, &dev_attr_manuid);
+	rc += device_create_file(&client->dev, &dev_attr_psdatastatus);
+	rc += device_create_file(&client->dev, &dev_attr_psinterruptstatus);
+	rc += device_create_file(&client->dev, &dev_attr_alsdatastatus);
+	rc += device_create_file(&client->dev, &dev_attr_alsinterruptstatus);
+	rc += device_create_file(&client->dev, &dev_attr_alsgainstatus);
+	rc += device_create_file(&client->dev, &dev_attr_alsdatavaliditystatus);
+	rc += device_create_file(&client->dev, &dev_attr_alspsstatusreg);
+	rc += device_create_file(&client->dev, &dev_attr_alsch0ch1rawcalc);
+	rc += device_create_file(&client->dev, &dev_attr_setpsoffset);
+	rc += device_create_file(&client->dev, &dev_attr_interruptmodesetup);
+	rc += device_create_file(&client->dev, &dev_attr_interruptpolarsetup);
+	rc += device_create_file(&client->dev, &dev_attr_interruptsetup);
+	rc += device_create_file(&client->dev, &dev_attr_interruptpersistsetup);
+	rc += device_create_file(&client->dev, &dev_attr_setalslothrerange);
+	rc += device_create_file(&client->dev, &dev_attr_setalshithrerange);
+	rc += device_create_file(&client->dev, &dev_attr_dispalsthrerange);
+	rc += device_create_file(&client->dev, &dev_attr_setpslothrerange);
+	rc += device_create_file(&client->dev, &dev_attr_setpshithrerange);
+	rc += device_create_file(&client->dev, &dev_attr_disppsthrerange);
+
+	if (rc)
+		dev_err(&client->dev,
+			"%s Unable to create sysfs files\n", __func__);
+	else
+		dev_dbg(&client->dev,
+			"%s Created sysfs files\n", __func__);
+}
+
+
+static int als_setup(struct ltr553_data *ltr553)
+{
+	int ret;
+
+	ltr553->als_input_dev = input_allocate_device();
+	if (!ltr553->als_input_dev) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: ALS Input Allocate Device Fail...\n", __func__);
+		return -ENOMEM;
+	}
+	ltr553->als_input_dev->name = "light";
+	set_bit(EV_ABS, ltr553->als_input_dev->evbit);
+	input_set_abs_params(ltr553->als_input_dev, ABS_MISC,
+		ALS_MIN_MEASURE_VAL, ALS_MAX_MEASURE_VAL, 0, 0);
+
+	ret = input_register_device(ltr553->als_input_dev);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS Register Input Device Fail...\n", __func__);
+		goto err_als_register_input_device;
+	}
+
+	ret = misc_register(&als_misc);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: ALS Register Misc Device Fail...\n", __func__);
+		goto err_als_register_misc_device;
+	}
+
+	return ret;
+
+err_als_register_misc_device:
+	input_unregister_device(ltr553->als_input_dev);
+err_als_register_input_device:
+	input_free_device(ltr553->als_input_dev);
+
+	return ret;
+}
+
+
+static int ps_setup(struct ltr553_data *ltr553)
+{
+	int ret;
+
+	ltr553->ps_input_dev = input_allocate_device();
+	if (!ltr553->ps_input_dev) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: PS Input Allocate Device Fail...\n", __func__);
+		return -ENOMEM;
+	}
+	ltr553->ps_input_dev->name = "proximity";
+	set_bit(EV_ABS, ltr553->ps_input_dev->evbit);
+	input_set_abs_params(ltr553->ps_input_dev,
+		ABS_DISTANCE, PS_MIN_MEASURE_VAL, PS_MAX_MEASURE_VAL, 0, 0);
+
+	ret = input_register_device(ltr553->ps_input_dev);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: PS Register Input Device Fail...\n", __func__);
+		goto err_ps_register_input_device;
+	}
+
+	ret = misc_register(&ps_misc);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: PS Register Misc Device Fail...\n", __func__);
+		goto err_ps_register_misc_device;
+	}
+
+	return ret;
+
+err_ps_register_misc_device:
+	input_unregister_device(ltr553->ps_input_dev);
+err_ps_register_input_device:
+	input_free_device(ltr553->ps_input_dev);
+
+	return ret;
+}
+
+static int _check_part_id(struct ltr553_data *ltr553)
+{
+	char ret;
+	uint8_t buffer[2];
+
+	buffer[0] = LTR553_PART_ID;
+	ret = I2C_Read(buffer, 1);
+
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev, "%s: Read failure :0x%02X",
+		__func__, buffer[0]);
+		return -EPERM;
+	}
+
+	if (buffer[0] != PARTID) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: Part failure miscompare act:0x%02x exp:0x%02x\n",
+		__func__, buffer[0], PARTID);
+		return -ENOENT;
+	}
+
+	return 0;
+}
+
+static int ltr553_init_device(struct ltr553_data *ltr553)
+{
+	int ret = 0;
+	/* Reset the devices */
+	ret = _ltr553_set_bit(ltr553->i2c_client, SET_BIT,
+						LTR553_ALS_CONTR, ALS_SW_RESET);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: ALS reset fail...\n", __func__);
+		goto err_out1;
+	}
+
+	ret = _ltr553_set_bit(ltr553->i2c_client, CLR_BIT,
+					LTR553_PS_CONTR, PS_MODE_ACTIVE);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS reset fail...\n", __func__);
+		goto err_out1;
+	}
+
+	msleep(20);
+	dev_dbg(&ltr553->i2c_client->dev,
+		"%s: Reset ltr553 device\n", __func__);
+
+/* Set count of measurements outside data range before interrupt is generated */
+	ret = _ltr553_set_bit(ltr553->i2c_client, SET_BIT,
+						LTR553_INTERRUPT_PRST, 0x01);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS Set Persist Fail...\n", __func__);
+		goto err_out2;
+	}
+
+	ret = _ltr553_set_bit(ltr553->i2c_client,
+					SET_BIT, LTR553_INTERRUPT_PRST, 0x10);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: PS Set Persist Fail...\n", __func__);
+		goto err_out2;
+	}
+	dev_dbg(&ltr553->i2c_client->dev,
+		"%s: Set ltr553 persists\n", __func__);
+
+	/* Enable interrupts on the device and clear only when status is read */
+#if ACT_INTERRUPT
+	ret = _ltr553_set_bit(ltr553->i2c_client,
+			SET_BIT, LTR553_INTERRUPT, INT_MODE_ALSPS_TRIG);
+	/*ret = _ltr553_set_bit(ltr553->i2c_client, SET_BIT,
+				LTR553_INTERRUPT, INT_MODE_PS_TRIG);*/
+#else
+	ret = _ltr553_set_bit(ltr553->i2c_client, SET_BIT,
+						LTR553_INTERRUPT, INT_MODE_00);
+#endif
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: Enabled interrupts failed...\n", __func__);
+		goto err_out2;
+	}
+	dev_dbg(&ltr553->i2c_client->dev,
+			"%s Enabled interrupt to device\n", __func__);
+
+	/* Turn on ALS and PS */
+	ret = als_enable_init(ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s Unable to enable ALS", __func__);
+		goto err_out2;
+	}
+
+	ret = ps_enable_init(ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s Unable to enable PS", __func__);
+		goto err_out2;
+	}
+
+	return ret;
+
+err_out2:
+	free_irq(ltr553->irq, ltr553);
+	gpio_free(ltr553->gpio_int_no);
+
+err_out1:
+	dev_err(&ltr553->i2c_client->dev,
+		"%s Unable to setup device\n", __func__);
+
+	return ret;
+}
+
+static int ltr553_setup(struct ltr553_data *ltr553)
+{
+	int ret = 0;
+
+	/* Reset the devices */
+	ret = _ltr553_set_bit(ltr553->i2c_client, SET_BIT,
+						LTR553_ALS_CONTR, ALS_SW_RESET);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: ALS reset fail...\n", __func__);
+		goto err_out1;
+	}
+
+	ret = _ltr553_set_bit(ltr553->i2c_client, CLR_BIT,
+					LTR553_PS_CONTR, PS_MODE_ACTIVE);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS reset fail...\n", __func__);
+		goto err_out1;
+	}
+
+	msleep(PON_DELAY);
+	dev_dbg(&ltr553->i2c_client->dev,
+		"%s: Reset ltr553 device\n", __func__);
+
+	/* Do another part read to ensure we have exited reset */
+	if (_check_part_id(ltr553) < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: Part ID Read Fail after reset...\n", __func__);
+		goto err_out1;
+	}
+
+	ret = ltr553_gpio_irq(ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: GPIO Request Fail...\n", __func__);
+		goto err_out1;
+	}
+
+/* Set count of measurements outside data range before interrupt is generated */
+	ret = _ltr553_set_bit(ltr553->i2c_client, SET_BIT,
+						LTR553_INTERRUPT_PRST, 0x01);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS Set Persist Fail...\n", __func__);
+		goto err_out2;
+	}
+
+	ret = _ltr553_set_bit(ltr553->i2c_client,
+					SET_BIT, LTR553_INTERRUPT_PRST, 0x10);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: PS Set Persist Fail...\n", __func__);
+		goto err_out2;
+	}
+
+	/* Enable interrupts on the device and clear only when status is read */
+#if ACT_INTERRUPT
+	ret = _ltr553_set_bit(ltr553->i2c_client,
+			SET_BIT, LTR553_INTERRUPT, INT_MODE_ALSPS_TRIG);
+	/*ret = _ltr553_set_bit(ltr553->i2c_client, SET_BIT,
+				LTR553_INTERRUPT, INT_MODE_PS_TRIG);*/
+#else
+	ret = _ltr553_set_bit(ltr553->i2c_client, SET_BIT,
+						LTR553_INTERRUPT, INT_MODE_00);
+#endif
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: Enabled interrupts failed...\n", __func__);
+		goto err_out2;
+	}
+
+	/* Turn on ALS and PS */
+	ret = als_enable_init(ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s Unable to enable ALS", __func__);
+		goto err_out2;
+	}
+
+	ret = ps_enable_init(ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s Unable to enable PS", __func__);
+		goto err_out2;
+	}
+
+	return ret;
+
+err_out2:
+	free_irq(ltr553->irq, ltr553);
+	gpio_free(ltr553->gpio_int_no);
+
+err_out1:
+	dev_err(&ltr553->i2c_client->dev,
+		"%s Unable to setup device\n", __func__);
+
+	return ret;
+}
+
+/*
+ * IOCTL support
+ */
+static int ltr553_enable_als_sensor(struct i2c_client *client, int val)
+{
+	int rc;
+	struct ltr553_data *data = i2c_get_clientdata(client);
+	struct ltr553_platform_data *pdata = data->platform_data;
+	uint8_t buffer[1];
+	pr_debug("%s: val=%d\n", __func__, val);
+
+	if ((val != 0) && (val != 1)) {
+		pr_err("%s: invalid value (val = %d)\n", __func__, val);
+		return -EINVAL;
+	}
+
+	if (val == 1) {
+		/* turn on light  sensor */
+		if ((data->enable_als_sensor == 0) &&
+			(data->enable_ps_sensor == 0)) {
+			if (data->irq) {
+				enable_irq(data->irq);
+			}
+
+			if (pdata->power_on)
+				pdata->power_on(true);
+
+			rc = ltr553_init_device(data);
+			if (rc) {
+				dev_err(&client->dev, "Failed to setup ltr553\n");
+				return rc;
+			}
+		}
+
+		if (data->enable_als_sensor == 0) {
+			data->enable_als_sensor = 1;
+			rc = als_mode_setup((uint8_t)val, data);
+			if (rc) {
+				dev_err(&client->dev, "Failed to setup ltr553\n");
+				return rc;
+			}
+		}
+               buffer[0] = LTR553_ALS_PS_STATUS;
+               I2C_Read(buffer, 1);
+	} else {
+
+		data->enable_als_sensor = 0;
+		rc = als_mode_setup((uint8_t)val, data);
+		if (rc) {
+			dev_err(&client->dev, "Failed to setup ltr553\n");
+			return rc;
+		}
+	}
+
+	/* Vote off  regulators if both light and prox sensor are off */
+	if ((data->enable_als_sensor == 0) && (data->enable_ps_sensor == 0) &&
+			(pdata->power_on)) {
+		disable_irq(data->irq);
+		pdata->power_on(false);
+	}
+
+	return 0;
+}
+static void set_ps_thelod(struct ltr553_data *ltr553)
+{
+    uint16_t ps_val;
+    uint16_t sum = 0;
+    uint16_t lh;
+    uint16_t hh;
+    int8_t rc = 0;
+    int i = 0;
+    for(i = 0; i < 2; i++)
+    {
+        msleep(10);
+        ps_val = read_ps_adc_value(ltr553);
+        sum += ps_val;
+    }
+    sum = sum/2;
+    if(sum < 1799) {
+        lh = sum + MIN_THD;
+        hh = sum + MAX_THD;
+        ltr553->default_ps_highthresh = hh;
+        ltr553->default_ps_lowthresh = lh;
+        rc = set_ps_range(ltr553->default_ps_lowthresh, ltr553->default_ps_highthresh, LO_N_HI_LIMIT, ltr553);
+        if (rc < 0) {
+            dev_err(&ltr553->i2c_client->dev, "%s : PS Thresholds Write Fail...\n", __func__);
+        }else {
+		    dev_warn(&ltr553->i2c_client->dev,"set_ps_thelod--hh[%d],lh[%d]\n", hh, lh);
+        }
+    }
+}
+static int ltr553_enable_ps_sensor(struct i2c_client *client, int val)
+{
+	int rc;
+	struct ltr553_data *data = i2c_get_clientdata(client);
+	struct ltr553_platform_data *pdata = data->platform_data;
+	uint8_t buffer[3];
+	pr_debug("%s: val=%d\n", __func__, val);
+
+	if ((val != 0) && (val != 1)) {
+		pr_err("%s: invalid value (val = %d)\n", __func__, val);
+		return -EINVAL;
+	}
+
+	if (val == 1) {
+		mutex_lock(&(data->ps_lock));
+		/* turn on p sensor */
+		if ((data->enable_als_sensor == 0) && (data->enable_ps_sensor == 0)) {
+			if (data->irq) {
+				enable_irq(data->irq);
+			}
+
+			if (pdata->power_on)
+				pdata->power_on(true);
+
+			rc = ltr553_init_device(data);
+			if (rc) {
+				dev_err(&client->dev, "Failed to setup ltr553\n");
+				return rc;
+			}
+		}
+
+		if (data->enable_ps_sensor == 0) {
+			data->enable_ps_sensor = 1;
+			rc = ps_mode_setup((uint8_t)val, data);
+			if (rc) {
+				dev_err(&client->dev, "Failed to setup ltr553\n");
+				return rc;
+			}
+		}
+
+        /* add read operation for psensor work failure */
+        buffer[0] = LTR553_ALS_PS_STATUS;
+        I2C_Read(buffer, 1);
+        buffer[0] = 0;
+        buffer[1] = 0;
+        buffer[2] = data->ps_cali;
+
+	    set_ps_offset(data,buffer);
+	    set_ps_thelod(data);
+		mutex_unlock(&(data->ps_lock));
+	} else {
+        data->enable_ps_sensor = 0;
+        rc = ps_mode_setup((uint8_t)val, data);
+        if (rc) {
+            dev_err(&client->dev, "Failed to setup ltr553\n");
+            return rc;
+        }
+    }
+
+    /* Vote off  regulators if both light and prox sensor are off */
+    if ((data->enable_als_sensor == 0) && (data->enable_ps_sensor == 0) &&(pdata->power_on)) {
+        disable_irq(data->irq);
+        pdata->power_on(false);
+    }
+
+    return 0;
+}
+
+static int ltr553_als_set_enable(struct sensors_classdev *sensors_cdev,
+			unsigned int enable)
+{
+	struct ltr553_data *data = container_of(sensors_cdev,
+			struct ltr553_data, als_cdev);
+
+	if ((enable != 0) && (enable != 1)) {
+		pr_err("%s: invalid value(%d)\n", __func__, enable);
+		return -EINVAL;
+	}
+
+	return ltr553_enable_als_sensor(data->i2c_client, enable);
+}
+
+static int ltr553_ps_set_enable(struct sensors_classdev *sensors_cdev,
+		unsigned int enable)
+{
+	struct ltr553_data *data = container_of(sensors_cdev,
+			struct ltr553_data, ps_cdev);
+
+	if ((enable != 0) && (enable != 1)) {
+		pr_err("%s: invalid value(%d)\n", __func__, enable);
+		return -EINVAL;
+	}
+
+	return ltr553_enable_ps_sensor(data->i2c_client, enable);
+}
+
+static int ltr553_als_flush(struct sensors_classdev *sensors_cdev){
+	struct timespec ts;
+	struct ltr553_data *data = container_of(sensors_cdev,
+		struct ltr553_data, als_cdev);
+
+	get_monotonic_boottime(&ts);
+	input_event(data->als_input_dev, EV_SYN, SYN_TIME_SEC, ts.tv_sec);
+	input_event(data->als_input_dev, EV_SYN, SYN_TIME_NSEC, ts.tv_nsec);
+	input_sync(data->als_input_dev);
+
+	return 0;
+}
+
+
+static int ltr553_ps_flush(struct sensors_classdev *sensors_cdev){
+	struct timespec ts;
+	struct ltr553_data *data = container_of(sensors_cdev,
+			struct ltr553_data, ps_cdev);
+
+	get_monotonic_boottime(&ts);
+	input_event(data->ps_input_dev, EV_SYN, SYN_TIME_SEC, ts.tv_sec);
+	input_event(data->ps_input_dev, EV_SYN, SYN_TIME_NSEC, ts.tv_nsec);
+	input_sync(data->ps_input_dev);
+
+	return 0;
+}
+
+static int ltr553_suspend(struct device *dev)
+{
+	int ret;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ltr553_data *data = i2c_get_clientdata(client);
+
+	dev_dbg(&data->i2c_client->dev, "ltr553 suspend ok.\n");
+
+	/*
+	  * Save sensor state and disable them,
+	  * this is to ensure internal state flags are set correctly.
+	  * device will power off after both sensors are disabled.
+	  * P sensor will not be disabled because it  is a wakeup sensor.
+	*/
+	data->als_enable_state = data->enable_als_sensor;
+	data->ps_enable_state = data->enable_ps_sensor;
+	pr_info("%s:%d data->ps_enable_state = %d --wanyk\n",
+		__func__, __LINE__, data->ps_enable_state);
+	if (data->ps_enable_state) {
+		ret = enable_irq_wake(data->irq);
+		if (ret)
+			pr_info("%s: enable_irq_wake(%d) failed, err=(%d)\n",
+				__func__, data->irq, ret);
+	}
+
+#if SUPPORT_AUTO_BACKLIGHT
+	if (data->als_enable_state) {
+		ret = ltr553_enable_als_sensor(data->i2c_client, 0);
+		if (ret)
+			dev_err(&data->i2c_client->dev,
+				"Disable light sensor fail! rc=%d\n", ret);
+	}
+#endif
+
+	return 0;
+}
+
+static int ltr553_resume(struct device *dev)
+{
+	int ret;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ltr553_data *data = i2c_get_clientdata(client);
+
+	dev_dbg(&data->i2c_client->dev, "ltr553 resume ok\n");
+
+#if SUPPORT_AUTO_BACKLIGHT
+/* Don't disable light at phone calling
+  * while the automatic backlight is on.
+  */
+	if (data->als_enable_state) {
+		ret = ltr553_enable_als_sensor(data->i2c_client, 1);
+		if (ret)
+			dev_err(&data->i2c_client->dev,
+				"Disable light sensor fail! rc=%d\n", ret);
+	}
+#endif
+
+	pr_info("%s:%d data->ps_enable_state = %d --wanyk\n",
+		__func__, __LINE__, data->ps_enable_state);
+	if (data->ps_enable_state) {
+		ret = disable_irq_wake(data->irq);
+		if (ret)
+			pr_info("%s: disable_irq_wake(%d) failed, err=(%d)\n",
+				__func__, data->irq, ret);
+	}
+
+	return 0;
+}
+
+
+static int ltr553_parse_dt(struct device *dev,
+				struct ltr553_platform_data *ltr_pdata)
+{
+	const char *project_name;
+	struct device_node *np = dev->of_node;
+	u32 temp_val;
+	int rc;
+
+	/* set functions of platform data */
+	ltr_pdata->init = ltr553_platform_hw_init;
+	ltr_pdata->exit = ltr553_platform_hw_exit;
+	ltr_pdata->power_on = ltr553_platform_hw_power_on;
+
+	rc = of_get_named_gpio_flags(dev->of_node,
+				"liteon,intr", 0, NULL);
+	if (rc < 0) {
+		dev_err(dev, "Unable to read intr\n");
+		return rc;
+	}
+	ltr_pdata->pfd_gpio_int_no = rc;
+
+	rc = of_property_read_u32(np, "liteon,highthr", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read high threshold\n");
+		return rc;
+	} else {
+		ltr_pdata->pfd_ps_highthresh = temp_val;
+	}
+
+	rc = of_property_read_u32(np, "liteon,lowthr", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read low threshold\n");
+		return rc;
+	} else {
+		ltr_pdata->pfd_ps_lowthresh = temp_val;
+	}
+
+	rc = of_property_read_string(np, "liteon_project", &project_name);
+	if (rc) {
+		lux_level = lux_level_default;
+	} else {
+                if(!strncmp(project_name, "test01a", strlen("test01a")))
+                {
+                        lux_level = lux_level_test01a;
+                }
+		else
+			lux_level = lux_level_default;
+	}
+
+	return 0;
+}
+
+static int ltr553_probe(struct i2c_client *client,
+						const struct i2c_device_id *id)
+{
+	int ret = 0;
+	struct ltr553_data *ltr553;
+	struct ltr553_platform_data *platdata;
+
+	ltr553 = kzalloc(sizeof(struct ltr553_data), GFP_KERNEL);
+	if (!ltr553) {
+		dev_err(&client->dev,
+			"%s: Mem Alloc Fail...\n", __func__);
+		return -ENOMEM;
+	}
+
+	platdata = kzalloc(sizeof(*platdata), GFP_KERNEL);
+	if (!platdata) {
+		dev_err(&client->dev,
+		"failed to allocate memory for platform data\n");
+		return -ENOMEM;
+	}
+	if (client->dev.of_node) {
+		memset(platdata, 0 , sizeof(*platdata));
+		ret = ltr553_parse_dt(&client->dev, platdata);
+		if (ret) {
+			dev_err(&client->dev, "Unable to parse platfrom data err=%d\n", ret);
+			return ret;
+		}
+	}
+
+	/* Global pointer for this device */
+	sensor_info = ltr553;
+	pdev_data = ltr553;
+
+	/* Set initial defaults */
+	ltr553->als_enable_flag = 0;
+	ltr553->ps_enable_flag = 0;
+
+	ltr553->i2c_client = client;
+	ltr553->platform_data = platdata;
+
+	if (!gpio_is_valid(platdata->pfd_gpio_int_no))
+		goto err_out;
+
+	ltr553->irq = gpio_to_irq(platdata->pfd_gpio_int_no);
+
+	/* h/w initialization */
+	if (platdata->init)
+		ret = platdata->init();
+
+	if (platdata->power_on)
+		ret = platdata->power_on(true);
+
+	i2c_set_clientdata(client, ltr553);
+
+	/* Parse the platform data */
+	ltr553->gpio_int_no = platdata->pfd_gpio_int_no;
+	/*ltr553->adc_levels = platdata->pfd_levels;*/
+	ltr553->default_ps_lowthresh = platdata->pfd_ps_lowthresh;
+	ltr553->default_ps_highthresh = platdata->pfd_ps_highthresh;
+	ltr553->enable_als_sensor = 0;
+	ltr553->enable_ps_sensor = 0;
+
+	ret = _check_part_id(ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: Part ID Read Fail...\n", __func__);
+		goto err_out;
+	}
+
+	/* Setup the input subsystem for the ALS */
+	ret = als_setup(ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: ALS Setup Fail...\n", __func__);
+		goto err_out;
+	}
+
+	/* Setup the input subsystem for the PS */
+	ret = ps_setup(ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+			"%s: PS Setup Fail...\n", __func__);
+		goto err_ps_setup;
+	}
+
+	/* Create the workqueue for the interrup handler */
+	ltr553->workqueue = create_singlethread_workqueue("ltr553_wq");
+	if (!ltr553->workqueue) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: Create WorkQueue Fail...\n", __func__);
+		ret = -ENOMEM;
+		goto err_workqueue;
+	}
+
+	/* Wake lock option for promity sensor */
+	wake_lock_init(&(ltr553->ps_wake_lock), WAKE_LOCK_SUSPEND, "proximity");
+	mutex_init(&(ltr553->ps_lock));
+
+	/* Setup and configure both the ALS and PS on the ltr553 device */
+	ret = ltr553_setup(ltr553);
+	if (ret < 0) {
+		dev_err(&ltr553->i2c_client->dev,
+		"%s: Setup Fail...\n", __func__);
+		goto err_ltr553_setup;
+	}
+
+	/* creat calibration file in input clss */
+	device_create_file(&ltr553->ps_input_dev->dev, &dev_attr_prox_raw);
+	device_create_file(&ltr553->ps_input_dev->dev, &dev_attr_enable_ps_sensor);
+
+	/* Register the sysfs files */
+	sysfs_register_device(client);
+	/*sysfs_register_als_device(client, &ltr553->als_input_dev->dev);*/
+	/*sysfs_register_ps_device(client, &ltr553->ps_input_dev->dev);*/
+
+	/* Register to sensors class */
+	ltr553->als_cdev = sensors_light_cdev;
+	ltr553->als_cdev.sensors_enable = ltr553_als_set_enable;
+    ltr553->als_cdev.sensors_flush = ltr553_als_flush;
+	ltr553->als_cdev.sensors_poll_delay = ltr553_cdev_set_poll_delay;
+
+	ltr553->ps_cdev = sensors_proximity_cdev;
+	ltr553->ps_cdev.sensors_enable = ltr553_ps_set_enable;
+    ltr553->ps_cdev.sensors_flush = ltr553_ps_flush;
+	ltr553->ps_cdev.sensors_calibrate = ltr553_cdev_calibrate;
+	ltr553->ps_cdev.sensors_write_cal_params = ltr553_cdev_write_cal_params;
+	ltr553->ps_cdev.sensors_poll_delay = ltr553_cdev_set_poll_delay;
+
+	ret = sensors_classdev_register(&client->dev, &ltr553->als_cdev);
+	if (ret) {
+		pr_err("%s: Unable to register to sensors class: %d\n",
+				__func__, ret);
+		goto err_ltr553_setup;
+	}
+
+	ret = sensors_classdev_register(&client->dev, &ltr553->ps_cdev);
+	if (ret) {
+		pr_err("%s: Unable to register to sensors class: %d\n",
+			       __func__, ret);
+		goto err_ltr553_class_sysfs;
+	}
+
+	if (platdata->power_on)
+		ret = platdata->power_on(false);
+
+	dev_info(&ltr553->i2c_client->dev, "%s: probe complete\n", __func__);
+
+	return ret;
+
+err_ltr553_class_sysfs:
+	sensors_classdev_unregister(&ltr553->als_cdev);
+err_ltr553_setup:
+	wake_lock_destroy(&ltr553->ps_wake_lock);
+	destroy_workqueue(ltr553->workqueue);
+err_workqueue:
+	input_unregister_device(ltr553->ps_input_dev);
+	input_free_device(ltr553->ps_input_dev);
+err_ps_setup:
+	input_unregister_device(ltr553->als_input_dev);
+	input_free_device(ltr553->als_input_dev);
+err_out:
+	if (platdata->power_on)
+		platdata->power_on(false);
+	if (platdata->exit)
+		platdata->exit();
+	kfree(platdata);
+	kfree(ltr553);
+	return ret;
+}
+
+static const struct i2c_device_id ltr553_id[] = {
+	{ DEVICE_NAME, 0 },
+	{}
+};
+
+#ifdef CONFIG_OF
+static struct of_device_id liteon_match_table[] = {
+		{ .compatible = "liteon,ltr553",},
+		{ },
+};
+#else
+#define liteon_match_table NULL
+#endif
+
+static const struct dev_pm_ops ltr553_pm_ops = {
+	.suspend	= ltr553_suspend,
+	.resume	= ltr553_resume,
+};
+
+static struct i2c_driver ltr553_driver = {
+	.probe = ltr553_probe,
+	.id_table = ltr553_id,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = DEVICE_NAME,
+		.of_match_table = liteon_match_table,
+		.pm = &ltr553_pm_ops,
+
+	},
+};
+
+static int __init ltr553_init(void)
+{
+	return i2c_add_driver(&ltr553_driver);
+}
+
+static void __exit ltr553_exit(void)
+{
+	i2c_del_driver(&ltr553_driver);
+}
+
+module_init(ltr553_init)
+module_exit(ltr553_exit)
+
+MODULE_AUTHOR("Lite-On Technology Corp");
+MODULE_DESCRIPTION("LTR-553ALSPS Driver");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_VERSION(DRIVER_VERSION);
+
diff --git a/drivers/input/misc/st480_test.c b/drivers/input/misc/st480_test.c
new file mode 100755
index 00000000000..f1418ea8202
--- /dev/null
+++ b/drivers/input/misc/st480_test.c
@@ -0,0 +1,905 @@
+/*
+ * Copyright (C) 2012 Senodia.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/i2c/st480.h>
+#include <linux/sensors.h>
+#include <linux/regulator/consumer.h>
+
+struct st480_data {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct platform_data_st480 *pdata;
+	struct delayed_work work;
+	struct sensors_classdev cdev;
+	struct regulator *vdd;
+	struct regulator *vio;
+	unsigned int poll_interval;
+	rwlock_t lock;
+	atomic_t m_flag;
+};
+
+static struct sensors_classdev sensors_cdev = {
+	.name = "st480",
+	.vendor = "Senodia",
+	.version = 1,
+	.handle = SENSORS_MAGNETIC_FIELD_HANDLE,
+	.type = SENSOR_TYPE_MAGNETIC_FIELD,
+	.max_range = "45",
+	.resolution = "0.1",
+	.sensor_power = "0.4",
+	.min_delay = 20000,
+	.max_delay = 1000,
+	.fifo_reserved_event_count = 0,
+	.fifo_max_event_count = 0,
+	.enabled = 0,
+	.delay_msec = ST480_DEFAULT_DELAY,
+	.sensors_enable = NULL,
+	.sensors_poll_delay = NULL,
+};
+
+static struct st480_data *st480;
+
+
+static atomic_t mv_flag;
+static atomic_t rm_flag;
+static atomic_t mrv_flag;
+
+static atomic_t open_count;
+static atomic_t open_flag;
+static atomic_t reserve_open_flag;
+
+volatile static short st480_delay = ST480_DEFAULT_DELAY;
+
+struct mag_3{
+	s16  mag_x,
+	mag_y,
+	mag_z;
+};
+volatile static struct mag_3 mag;
+
+//static struct kobject *st480_kobj;
+
+/*
+ * i2c transfer
+ * read/write
+ */
+static int st480_i2c_transfer_data(struct i2c_client *client, int len, char *buf, int length)
+{
+	int ret;
+
+	struct i2c_msg msgs[] = {
+		{
+			.addr  =  client->addr,
+			.flags  =  0,
+			.len  =  len,
+			.buf  =  buf,
+		},
+		{
+			.addr  =  client->addr,
+			.flags  = I2C_M_RD,
+			.len  =  length,
+			.buf  =  buf,
+		},
+	};
+
+	ret = i2c_transfer(client->adapter, msgs, 2);
+	if (ret < 0)
+		dev_err(&client->dev, "%s error:%d\n", __func__, ret);
+	return (ret == 2) ? 0 : ret;
+}
+
+/*
+ * Device detect and init
+ *
+ */
+static int st480_setup(struct i2c_client *client)
+{
+	int ret;
+	unsigned char buf[5];
+
+	memset(buf, 0, 5);
+
+	buf[0] = READ_REGISTER_CMD;
+	buf[1] = 0x00;
+	ret = 0;
+
+#ifdef IC_CHECK
+	while (st480_i2c_transfer_data(client, 2, buf, 3) != 0)
+	{
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(client, 2, buf, 3)==0)
+		{
+			break;
+		}
+		if (ret > MAX_FAILURE_COUNT)
+		{
+			return -EIO;
+		}
+	}
+
+	if (buf[2] != ST480_DEVICE_ID)
+	{
+		return -ENODEV;
+	}
+#endif
+
+//init register step 1
+	buf[0] = WRITE_REGISTER_CMD;
+	buf[1] = ONE_INIT_DATA_HIGH;
+	buf[2] = ONE_INIT_DATA_LOW;
+	buf[3] = ONE_INIT_REG;
+	ret = 0;
+	while (st480_i2c_transfer_data(client, 4, buf, 1) != 0)
+	{
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(client, 4, buf, 1)==0)
+		{
+			break;
+		}
+		if (ret > MAX_FAILURE_COUNT)
+		{
+			return -EIO;
+		}
+	}
+
+//init register step 2
+	buf[0] = WRITE_REGISTER_CMD;
+	buf[1] = TWO_INIT_DATA_HIGH;
+	buf[2] = TWO_INIT_DATA_LOW;
+	buf[3] = TWO_INIT_REG;
+	ret = 0;
+	while (st480_i2c_transfer_data(client, 4, buf, 1)!=0) {
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(client, 4, buf, 1)==0)
+		{
+			break;
+		}
+		if (ret > MAX_FAILURE_COUNT)
+		{
+			return -EIO;
+		}
+	}
+
+//disable temperature compensation register
+	buf[0] = WRITE_REGISTER_CMD;
+	buf[1] = TEMP_DATA_HIGH;
+	buf[2] = TEMP_DATA_LOW;
+	buf[3] = TEMP_REG;
+
+	ret = 0;
+	while (st480_i2c_transfer_data(client, 4, buf, 1)!=0)
+	{
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(client, 4, buf, 1)==0)
+		{
+			break;
+		}
+		if (ret > MAX_FAILURE_COUNT)
+		{
+			return -EIO;
+		}
+	}
+
+//set calibration register
+	buf[0] = WRITE_REGISTER_CMD;
+	buf[1] = CALIBRATION_DATA_HIGH;
+	buf[2] = CALIBRATION_DATA_LOW;
+	buf[3] = CALIBRATION_REG;
+	ret = 0;
+	while (st480_i2c_transfer_data(client, 4, buf, 1)!=0)
+	{
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(client, 4, buf, 1)==0)
+		{
+			break;
+		}
+		if (ret > MAX_FAILURE_COUNT)
+		{
+			return -EIO;
+		}
+	}
+
+//set mode config
+	buf[0] = SINGLE_MEASUREMENT_MODE_CMD;
+	ret=0;
+	while (st480_i2c_transfer_data(client, 1, buf, 1)!=0)
+	{
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(client, 1, buf, 1)==0)
+		{
+			break;
+		}
+		if( ret > MAX_FAILURE_COUNT)
+		{
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+#if 0
+static ssize_t show_chipinfo_value(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+
+	sprintf(buf, "st480 chip\n");
+	ret = strlen(buf) + 1;
+
+	return ret;
+}
+
+static ssize_t show_status_value(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", atomic_read(&reserve_open_flag));
+}
+
+static DEVICE_ATTR(chipinfo, S_IRUGO, show_chipinfo_value, NULL);
+static DEVICE_ATTR(status, S_IRUGO, show_status_value, NULL);
+static int st480_sysfs_init(void)
+{
+	int ret;
+//TODO: using client->dev.kobj instead
+	st480_kobj = kobject_create_and_add("st480", NULL);
+	if(st480_kobj == NULL)
+	{
+		printk("st480 sysfs init failed!\n");
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	if(sysfs_create_file(st480_kobj, &dev_attr_chipinfo.attr))
+	{
+		printk("device_create_file chipinfo error!\n");
+		ret = -EIO;
+		goto err2;
+	}
+
+	if(sysfs_create_file(st480_kobj, &dev_attr_status.attr))
+	{
+		printk("device_create_file status error!\n");
+		ret = -EIO;
+		goto err2;
+	}
+
+	return ret;
+err2:
+	kobject_del(st480_kobj);
+err1:
+	return ret;
+}
+#endif
+static void st480_work_func(void)
+{
+	char buffer[9];
+	int ret;
+	s16 hw_data[3];
+
+	memset(buffer, 0, 9);
+	memset(hw_data, 0, 3);
+
+	buffer[0] = READ_MEASUREMENT_CMD;
+	ret = 0;
+	while (st480_i2c_transfer_data(st480->client, 1, buffer, 9)!=0)
+	{
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(st480->client, 1, buffer, 9)==0)
+		{
+			break;
+		}
+		if(ret > MAX_FAILURE_COUNT)
+		{
+			return;
+		}
+	}
+
+	if (!((buffer[0]>>4) & 0X01)) {
+		hw_data[0] = (buffer[3]<<8)|buffer[4];
+		hw_data[1] = (buffer[5]<<8)|buffer[6];
+		hw_data[2] = (buffer[7]<<8)|buffer[8];
+
+		mag.mag_x = ((st480->pdata->negate_x) ? (-hw_data[st480->pdata->axis_map_x])
+                : (hw_data[st480->pdata->axis_map_x]));
+		mag.mag_y = ((st480->pdata->negate_y) ? (-hw_data[st480->pdata->axis_map_y])
+                : (hw_data[st480->pdata->axis_map_y]));
+		mag.mag_z = ((st480->pdata->negate_z) ? (-hw_data[st480->pdata->axis_map_z])
+                        : (hw_data[st480->pdata->axis_map_z]));
+
+		if (((buffer[1]<<8)|(buffer[2])) > 46244)
+		{
+			mag.mag_x = mag.mag_x * (1 + (70/128/4096) * (((buffer[1]<<8)|(buffer[2])) - 46244));
+			mag.mag_y = mag.mag_y * (1 + (70/128/4096) * (((buffer[1]<<8)|(buffer[2])) - 46244));
+			mag.mag_z = mag.mag_z * (1 + (70/128/4096) * (((buffer[1]<<8)|(buffer[2])) - 46244));
+		}
+		else if (((buffer[1]<<8)|(buffer[2])) < 46244)
+		{
+			mag.mag_x = mag.mag_x * (1 + (60/128/4096) * (((buffer[1]<<8)|(buffer[2])) - 46244));
+			mag.mag_y = mag.mag_y * (1 + (60/128/4096) * (((buffer[1]<<8)|(buffer[2])) - 46244));
+			mag.mag_z = mag.mag_z * (1 + (60/128/4096) * (((buffer[1]<<8)|(buffer[2])) - 46244));
+		}
+
+		SENODIADBG("st480 raw data: x = %d, y = %d, z = %d \n",mag.mag_x,mag.mag_y,mag.mag_z);
+	} else
+		dev_err(&st480->client->dev, "ecc error detected!\n");
+
+	//set mode config
+	buffer[0] = SINGLE_MEASUREMENT_MODE_CMD;
+	ret=0;
+	while (st480_i2c_transfer_data(st480->client, 1, buffer, 1)!=0)
+	{
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(st480->client, 1, buffer, 1)==0)
+		{
+			break;
+		}
+		if (ret > MAX_FAILURE_COUNT)
+		{
+			return;
+		}
+	}
+}
+
+static void st480_input_func(struct work_struct *work)
+{
+	struct st480_data *st480 = container_of((struct delayed_work *)work, struct st480_data, work);
+	struct timespec timestamp_spec;
+
+	SENODIAFUNC("st480_input_func");
+	st480_work_func();
+
+	if (atomic_read(&st480->m_flag) || atomic_read(&mv_flag) || atomic_read(&rm_flag) || atomic_read(&mrv_flag)) {
+		input_report_abs(st480->input_dev, ABS_X, mag.mag_x);
+		input_report_abs(st480->input_dev, ABS_Y, mag.mag_y);
+		input_report_abs(st480->input_dev, ABS_Z, mag.mag_z);
+
+        timestamp_spec = ktime_to_timespec(ktime_get_boottime());
+		input_event(st480->input_dev, EV_SYN, SYN_TIME_SEC, timestamp_spec.tv_sec);
+		input_event(st480->input_dev, EV_SYN, SYN_TIME_NSEC, timestamp_spec.tv_nsec);
+		input_sync(st480->input_dev);
+	}
+
+	schedule_delayed_work(&st480->work, msecs_to_jiffies(st480->poll_interval));
+}
+
+static void ecs_closedone(void)
+{
+	SENODIAFUNC("ecs_closedone");
+	// atomic_set(&m_flag, 0);
+	atomic_set(&mv_flag, 0);
+	atomic_set(&rm_flag, 0);
+	atomic_set(&mrv_flag, 0);
+}
+
+/***** st480 functions ***************************************/
+static int st480_open(struct inode *inode, struct file *file)
+{
+	int ret = -1;
+
+	SENODIAFUNC("st480_open");
+
+	if (atomic_cmpxchg(&open_count, 0, 1) == 0) {
+		if (atomic_cmpxchg(&open_flag, 0, 1) == 0) {
+			atomic_set(&reserve_open_flag, 1);
+			ret = 0;
+		}
+	}
+
+	if (atomic_read(&reserve_open_flag))
+		schedule_delayed_work(&st480->work, msecs_to_jiffies(st480_delay));
+	return ret;
+}
+
+static int st480_release(struct inode *inode, struct file *file)
+{
+	SENODIAFUNC("st480_release");
+
+	atomic_set(&reserve_open_flag, 0);
+	atomic_set(&open_flag, 0);
+	atomic_set(&open_count, 0);
+
+	ecs_closedone();
+
+	cancel_delayed_work(&st480->work);
+	return 0;
+}
+
+#if OLD_KERNEL_VERSION
+static int
+st480_ioctl(struct inode *inode, struct file *file,
+			  unsigned int cmd, unsigned long arg)
+#else
+static long
+st480_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+#endif
+{
+	void __user *argp = (void __user *)arg;
+	short flag;
+
+	SENODIADBG("enter %s\n", __func__);
+
+	switch (cmd) {
+		case MSENSOR_IOCTL_ST480_SET_MFLAG:
+		case MSENSOR_IOCTL_ST480_SET_MVFLAG:
+		case MSENSOR_IOCTL_ST480_SET_RMFLAG:
+		case MSENSOR_IOCTL_ST480_SET_MRVFLAG:
+			if (copy_from_user(&flag, argp, sizeof(flag))) {
+				return -EFAULT;
+			}
+			if (flag < 0 || flag > 1) {
+				return -EINVAL;
+			}
+			break;
+		case MSENSOR_IOCTL_ST480_SET_DELAY:
+			if (copy_from_user(&flag, argp, sizeof(flag))) {
+				return -EFAULT;
+			}
+			break;
+		default:
+			break;
+	}
+
+	switch (cmd) {
+		case MSENSOR_IOCTL_ST480_SET_MFLAG:
+			//atomic_set(&m_flag, flag);
+			SENODIADBG("MFLAG is set to %d", flag);
+			break;
+		case MSENSOR_IOCTL_ST480_GET_MFLAG:
+			//flag = atomic_read(&m_flag);
+			SENODIADBG("Mflag = %d\n",flag);
+			break;
+		case MSENSOR_IOCTL_ST480_SET_MVFLAG:
+			atomic_set(&mv_flag, flag);
+			SENODIADBG("MVFLAG is set to %d", flag);
+			break;
+		case MSENSOR_IOCTL_ST480_GET_MVFLAG:
+			flag = atomic_read(&mv_flag);
+			SENODIADBG("MVflag = %d\n",flag);
+			break;
+		case MSENSOR_IOCTL_ST480_SET_RMFLAG:
+			atomic_set(&rm_flag, flag);
+			SENODIADBG("RMFLAG is set to %d", flag);
+			break;
+		case MSENSOR_IOCTL_ST480_GET_RMFLAG:
+			flag = atomic_read(&rm_flag);
+			SENODIADBG("RMflag = %d\n",flag);
+			break;
+		case MSENSOR_IOCTL_ST480_SET_MRVFLAG:
+			atomic_set(&mrv_flag, flag);
+			SENODIADBG("MRVFLAG is set to %d", flag);
+			break;
+		case MSENSOR_IOCTL_ST480_GET_MRVFLAG:
+			flag = atomic_read(&mrv_flag);
+			SENODIADBG("MRVflag = %d\n",flag);
+			break;
+		case MSENSOR_IOCTL_ST480_SET_DELAY:
+			st480_delay = flag;
+			break;
+		case MSENSOR_IOCTL_ST480_GET_DELAY:
+			flag = st480_delay;
+			break;
+		default:
+			return -ENOTTY;
+	}
+
+	switch (cmd) {
+		case MSENSOR_IOCTL_ST480_GET_MFLAG:
+		case MSENSOR_IOCTL_ST480_GET_MVFLAG:
+		case MSENSOR_IOCTL_ST480_GET_RMFLAG:
+		case MSENSOR_IOCTL_ST480_GET_MRVFLAG:
+		case MSENSOR_IOCTL_ST480_GET_DELAY:
+			if (copy_to_user(argp, &flag, sizeof(flag))) {
+				return -EFAULT;
+			}
+			break;
+		default:
+			break;
+	}
+
+	return 0;
+}
+
+
+static struct file_operations st480_fops = {
+	.owner = THIS_MODULE,
+	.open = st480_open,
+	.release = st480_release,
+#if OLD_KERNEL_VERSION
+	.ioctl = st480_ioctl,
+#else
+	.unlocked_ioctl = st480_ioctl,
+#endif
+};
+
+
+static struct miscdevice st480_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "st480",
+	.fops = &st480_fops,
+};
+
+/*********************************************/
+#if ST480_AUTO_TEST
+static int sensor_test_read(void)
+
+{
+        st480_work_func();
+        return 0;
+}
+
+static int auto_test_read(void *unused)
+{
+        while(1){
+                sensor_test_read();
+                msleep(200);
+        }
+        return 0;
+}
+#endif
+
+static int st480_set_enable(struct st480_data *st480, bool on)
+{
+	int retval = 0;
+	struct i2c_client *client = st480->client;
+
+	dev_info(&client->dev, "enable:%s\n", on ? "on" : "off");
+
+	if (on) {
+		schedule_delayed_work(&st480->work, msecs_to_jiffies(st480->poll_interval));
+	} else {
+		cancel_delayed_work(&st480->work);
+	}
+	return retval;
+}
+
+static int st480_set_poll_delay(struct st480_data *st480, unsigned int msecs)
+{
+	//msecs = ST480_DEFAULT_DELAY;
+
+	write_lock(&st480->lock);
+	st480->poll_interval = msecs;
+	write_unlock(&st480->lock);
+
+	return 0;
+}
+
+static int st480_cdev_set_enable(struct sensors_classdev *sensors_cdev,
+							unsigned int enable)
+{
+	struct st480_data *st480 =
+		container_of(sensors_cdev, struct st480_data, cdev);
+
+	return st480_set_enable(st480, enable);
+}
+
+static int st480_cdev_set_poll_delay(struct sensors_classdev *sensors_cdev,
+								unsigned int msecs)
+{
+	struct st480_data *st480 =
+		container_of(sensors_cdev, struct st480_data, cdev);
+
+	if (msecs != st480->poll_interval)
+		return st480_set_poll_delay(st480, msecs);
+
+	return 0;
+}
+
+static int st480_power_ctrl(struct st480_data *st480, int on)
+{
+	int retval = 0;
+	struct i2c_client *client = st480->client;
+
+	if (on) {
+		retval = regulator_enable(st480->vdd);
+		if (retval) {
+			dev_err(&client->dev, "regulator vdd enable failed!\n");
+			return retval;
+		}
+		retval = regulator_enable(st480->vio);
+		if (retval) {
+			dev_err(&client->dev, "regulator vio enable failed!\n");
+			retval = regulator_disable(st480->vdd);
+			return retval;
+		}
+	} else {
+		retval = regulator_disable(st480->vdd);
+		if (retval) {
+			dev_err(&client->dev, "regulator vdd disable failed!\n");
+			return retval;
+		}
+		retval = regulator_disable(st480->vio);
+		if (retval) {
+			dev_err(&client->dev, "regulator vio disable failed!\n");
+			retval = regulator_enable(st480->vdd);
+			return retval;
+		}
+	}
+	return retval;
+}
+
+static int st480_power_init(struct st480_data *st480)
+{
+	int retval = 0;
+	struct i2c_client *client = st480->client;
+
+	st480->vdd = devm_regulator_get(&client->dev, "vdd");
+	if (IS_ERR(st480->vdd)) {
+		retval = PTR_ERR(st480->vdd);
+		dev_err(&client->dev, "regulator get failed vdd retval=%d\n", retval);
+		return retval;
+	}
+
+	st480->vio = devm_regulator_get(&client->dev, "vio");
+	if (IS_ERR(st480->vio)) {
+		retval = PTR_ERR(st480->vio);
+		dev_err(&client->dev, "regulator get failed vio retval=%d\n", retval);
+		goto err_reg_vdd_put;
+	}
+
+	return retval;
+
+err_reg_vdd_put:
+	devm_regulator_put(st480->vdd);
+
+	return retval;
+}
+
+#ifdef CONFIG_OF
+static int st480_parse_dt(struct i2c_client *client, struct platform_data_st480 *pdata)
+{
+	struct device_node *np = client->dev.of_node;
+	int rc = 0;
+
+	if (!np) {
+		dev_err(&client->dev, "device don't have associateed dt data!\n");
+		return -EINVAL;
+	}
+
+	rc = of_property_read_u32(np, "senodia,axis-map-x", &pdata->axis_map_x);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(&client->dev, "failed to get senodia,axis-map-x!\n");
+		return rc;
+	}
+
+	rc = of_property_read_u32(np, "senodia,axis-map-y", &pdata->axis_map_y);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(&client->dev, "failed to get senodia,axis-map-y!\n");
+		return rc;
+	}
+
+	rc = of_property_read_u32(np, "senodia,axis-map-z", &pdata->axis_map_z);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(&client->dev, "failed to get senodia,axis-map-z!\n");
+		return rc;
+	}
+	pdata->negate_x = of_property_read_bool(np, "senodia,negate-x");
+	pdata->negate_y = of_property_read_bool(np, "senodia,negate-y");
+	pdata->negate_z = of_property_read_bool(np, "senodia,negate-z");
+
+	return rc;
+}
+#else
+static int st480_parse_dt(struct i2c_client *client, struct platform_data_st480 *pdata)
+{
+	return -ENODEV;
+}
+#endif /* CONFIG_OF */
+
+static int st480_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int err = 0;
+	struct platform_data_st480 *pdata;
+#if ST480_AUTO_TEST
+        struct task_struct *thread;
+#endif
+
+	SENODIAFUNC("st480_probe");
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		printk(KERN_ERR "SENODIA st480_probe: check_functionality failed.\n");
+		err = -ENODEV;
+		goto exit0;
+	}
+
+	/* Allocate memory for driver data */
+	st480 = kzalloc(sizeof(struct st480_data), GFP_KERNEL);
+	if (!st480) {
+		printk(KERN_ERR "SENODIA st480_probe: memory allocation failed.\n");
+		err = -ENOMEM;
+		goto exit1;
+	}
+
+	st480->client = client;
+
+	i2c_set_clientdata(client, st480);
+
+	INIT_DELAYED_WORK(&st480->work, st480_input_func);
+
+	if (client->dev.of_node) {
+		pdata = kzalloc(sizeof(struct platform_data_st480), GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&client->dev, "failed to allocate memory for st480 pdata\n");
+			err = -ENOMEM;
+			goto exit2;
+		}
+		err = st480_parse_dt(client, pdata);
+		if (err) {
+			dev_err(&client->dev, "parse device tree error!\n");
+			goto exit3;
+		}
+	} else {
+		pdata = dev_get_platdata(&client->dev);
+		if (!pdata) {
+			dev_err(&client->dev, "No platform data!\n");
+			goto exit2;
+		}
+	}
+	st480->pdata = pdata;
+
+	/* st480 power intialize */
+	err = st480_power_init(st480);
+	if (err < 0) {
+		dev_err(&client->dev, "failed to get regulator!\n");
+		goto exit2;
+	}
+	/* get the power and never put it unless driver remove */
+	err = st480_power_ctrl(st480, 1);
+	if (err) {
+		dev_err(&client->dev, "failed to set regulator!\n");
+		goto exit2;
+	}
+
+	if (st480_setup(st480->client) != 0) {
+		dev_err(&client->dev, "st480 setup error!\n");
+		goto exit3;
+	}
+
+	/* Declare input device */
+	st480->input_dev = input_allocate_device();
+	if (!st480->input_dev) {
+		err = -ENOMEM;
+		dev_err(&client->dev, "failed to allocate input device\n");
+		goto exit3;
+	}
+
+	/* Setup input device */
+	set_bit(EV_ABS, st480->input_dev->evbit);
+
+	/* x-axis of raw magnetic vector (-32768, 32767) */
+	input_set_abs_params(st480->input_dev, ABS_X, ABSMIN_MAG, ABSMAX_MAG, 0, 0);
+	/* y-axis of raw magnetic vector (-32768, 32767) */
+	input_set_abs_params(st480->input_dev, ABS_Y, ABSMIN_MAG, ABSMAX_MAG, 0, 0);
+	/* z-axis of raw magnetic vector (-32768, 32767) */
+	input_set_abs_params(st480->input_dev, ABS_Z, ABSMIN_MAG, ABSMAX_MAG, 0, 0);
+	/* Set name */
+	st480->input_dev->name = "compass";
+	st480->input_dev->id.bustype = BUS_I2C;
+
+	/* Register */
+	err = input_register_device(st480->input_dev);
+	if (err) {
+		dev_err(&client->dev, "SENODIA st480_probe: Unable to register input device\n");
+		goto exit4;
+	}
+
+	err = misc_register(&st480_device);
+	if (err) {
+		dev_err(&client->dev, "SENODIA st480_probe: st480_device register failed\n");
+		goto exit5;
+	}
+
+	rwlock_init(&st480->lock);
+	/* As default, report all information */
+	atomic_set(&st480->m_flag, 1);
+	atomic_set(&mv_flag, 1);
+	atomic_set(&rm_flag, 1);
+	atomic_set(&mrv_flag, 1);
+	st480->poll_interval = ST480_DEFAULT_DELAY;
+	st480->cdev = sensors_cdev;
+	st480->cdev.sensors_enable = st480_cdev_set_enable;
+	st480->cdev.sensors_poll_delay = st480_cdev_set_poll_delay;
+	err = sensors_classdev_register(&client->dev, &st480->cdev);
+	if (err) {
+		dev_err(&client->dev, "sensors class register failed!\n");
+		goto exit5;
+	}
+/*
+	err = st480_sysfs_init();
+	if (err < 0) {
+		printk("st480 sysfs init error!\n");
+		goto exit5;
+	}
+*/
+#if ST480_AUTO_TEST
+	thread=kthread_run(auto_test_read,NULL,"st480_read_test");
+#endif
+
+	printk("st480 probe done.");
+	return 0;
+
+exit5:
+	misc_deregister(&st480_device);
+	input_unregister_device(st480->input_dev);
+exit4:
+	input_free_device(st480->input_dev);
+exit3:
+	kfree(st480->pdata);
+exit2:
+	kfree(st480);
+exit1:
+exit0:
+	return err;
+
+}
+
+static int st480_remove(struct i2c_client *client)
+{
+	struct st480_data *st480 = i2c_get_clientdata(client);
+
+	sensors_classdev_unregister(&st480->cdev);
+	atomic_set(&st480->m_flag, 0);
+	misc_deregister(&st480_device);
+	input_unregister_device(st480->input_dev);
+	input_free_device(st480->input_dev);
+	cancel_delayed_work(&st480->work);
+	i2c_set_clientdata(client, NULL);
+	kfree(st480->pdata);
+	kfree(st480);
+	return 0;
+}
+
+static const struct i2c_device_id st480_id_table[] = {
+	{ ST480_I2C_NAME, 0 },
+	{ },
+};
+
+static struct of_device_id st480_match_table[] = {
+	{ .compatible = "senodia,st480", },
+	{ },
+};
+
+static struct i2c_driver st480_driver = {
+	.probe		= st480_probe,
+	.remove 	= st480_remove,
+	.id_table	= st480_id_table,
+	.driver = {
+		.name = ST480_I2C_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = st480_match_table,
+	},
+};
+
+static int __init st480_init(void)
+{
+	return i2c_add_driver(&st480_driver);
+}
+
+static void __exit st480_exit(void)
+{
+	i2c_del_driver(&st480_driver);
+}
+
+module_init(st480_init);
+module_exit(st480_exit);
+
+MODULE_AUTHOR("Tori Xu <xuezhi_xu@senodia.com>");
+MODULE_DESCRIPTION("senodia st480 linux driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("2.0.0");
diff --git a/drivers/input/misc/st480_test_plus.c b/drivers/input/misc/st480_test_plus.c
new file mode 100755
index 00000000000..d7c236b3c4e
--- /dev/null
+++ b/drivers/input/misc/st480_test_plus.c
@@ -0,0 +1,904 @@
+/*
+ * Copyright (C) 2012 Senodia.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/i2c/st480.h>
+#include <linux/sensors.h>
+#include <linux/regulator/consumer.h>
+
+struct st480_data {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct platform_data_st480 *pdata;
+	struct delayed_work work;
+	struct sensors_classdev cdev;
+	struct regulator *vdd;
+	struct regulator *vio;
+	unsigned int poll_interval;
+	rwlock_t lock;
+	atomic_t m_flag;
+};
+
+static struct sensors_classdev sensors_cdev = {
+	.name = "st480",
+	.vendor = "Senodia",
+	.version = 1,
+	.handle = SENSORS_MAGNETIC_FIELD_HANDLE,
+	.type = SENSOR_TYPE_MAGNETIC_FIELD,
+	.max_range = "45",
+	.resolution = "0.1",
+	.sensor_power = "0.4",
+	.min_delay = 20000,
+	.max_delay = 1000,
+	.fifo_reserved_event_count = 0,
+	.fifo_max_event_count = 0,
+	.enabled = 0,
+	.delay_msec = ST480_DEFAULT_DELAY,
+	.sensors_enable = NULL,
+	.sensors_poll_delay = NULL,
+};
+
+static struct st480_data *st480;
+
+
+static atomic_t mv_flag;
+static atomic_t rm_flag;
+static atomic_t mrv_flag;
+
+static atomic_t open_count;
+static atomic_t open_flag;
+static atomic_t reserve_open_flag;
+
+volatile static short st480_delay = ST480_DEFAULT_DELAY;
+
+struct mag_3{
+	s16  mag_x,
+	mag_y,
+	mag_z;
+};
+volatile static struct mag_3 mag;
+
+//static struct kobject *st480_kobj;
+
+/*
+ * i2c transfer
+ * read/write
+ */
+static int st480_i2c_transfer_data(struct i2c_client *client, int len, char *buf, int length)
+{
+	int ret;
+
+	struct i2c_msg msgs[] = {
+		{
+			.addr  =  client->addr,
+			.flags  =  0,
+			.len  =  len,
+			.buf  =  buf,
+		},
+		{
+			.addr  =  client->addr,
+			.flags  = I2C_M_RD,
+			.len  =  length,
+			.buf  =  buf,
+		},
+	};
+
+	ret = i2c_transfer(client->adapter, msgs, 2);
+	if (ret < 0)
+		dev_err(&client->dev, "%s error:%d\n", __func__, ret);
+	return (ret == 2) ? 0 : ret;
+}
+
+/*
+ * Device detect and init
+ *
+ */
+static int st480_setup(struct i2c_client *client)
+{
+	int ret;
+	unsigned char buf[5];
+
+	memset(buf, 0, 5);
+
+	buf[0] = READ_REGISTER_CMD;
+	buf[1] = 0x00;
+	ret = 0;
+
+#ifdef IC_CHECK
+	while (st480_i2c_transfer_data(client, 2, buf, 3) != 0)
+	{
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(client, 2, buf, 3)==0)
+		{
+			break;
+		}
+		if (ret > MAX_FAILURE_COUNT)
+		{
+			return -EIO;
+		}
+	}
+
+	if (buf[2] != ST480_DEVICE_ID)
+	{
+		return -ENODEV;
+	}
+#endif
+
+//init register step 1
+	buf[0] = WRITE_REGISTER_CMD;
+	buf[1] = ONE_INIT_DATA_HIGH;
+	buf[2] = ONE_INIT_DATA_LOW;
+	buf[3] = ONE_INIT_REG;
+	ret = 0;
+	while (st480_i2c_transfer_data(client, 4, buf, 1) != 0)
+	{
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(client, 4, buf, 1)==0)
+		{
+			break;
+		}
+		if (ret > MAX_FAILURE_COUNT)
+		{
+			return -EIO;
+		}
+	}
+
+//init register step 2
+	buf[0] = WRITE_REGISTER_CMD;
+	buf[1] = TWO_INIT_DATA_HIGH;
+	buf[2] = TWO_INIT_DATA_LOW;
+	buf[3] = TWO_INIT_REG;
+	ret = 0;
+	while (st480_i2c_transfer_data(client, 4, buf, 1)!=0) {
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(client, 4, buf, 1)==0)
+		{
+			break;
+		}
+		if (ret > MAX_FAILURE_COUNT)
+		{
+			return -EIO;
+		}
+	}
+
+//disable temperature compensation register
+	buf[0] = WRITE_REGISTER_CMD;
+	buf[1] = TEMP_DATA_HIGH;
+	buf[2] = TEMP_DATA_LOW;
+	buf[3] = TEMP_REG;
+
+	ret = 0;
+	while (st480_i2c_transfer_data(client, 4, buf, 1)!=0)
+	{
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(client, 4, buf, 1)==0)
+		{
+			break;
+		}
+		if (ret > MAX_FAILURE_COUNT)
+		{
+			return -EIO;
+		}
+	}
+
+//set calibration register
+	buf[0] = WRITE_REGISTER_CMD;
+	buf[1] = CALIBRATION_DATA_HIGH;
+	buf[2] = CALIBRATION_DATA_LOW;
+	buf[3] = CALIBRATION_REG;
+	ret = 0;
+	while (st480_i2c_transfer_data(client, 4, buf, 1)!=0)
+	{
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(client, 4, buf, 1)==0)
+		{
+			break;
+		}
+		if (ret > MAX_FAILURE_COUNT)
+		{
+			return -EIO;
+		}
+	}
+
+//set mode config
+	buf[0] = SINGLE_MEASUREMENT_MODE_CMD;
+	ret=0;
+	while (st480_i2c_transfer_data(client, 1, buf, 1)!=0)
+	{
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(client, 1, buf, 1)==0)
+		{
+			break;
+		}
+		if( ret > MAX_FAILURE_COUNT)
+		{
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+#if 0
+static ssize_t show_chipinfo_value(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+
+	sprintf(buf, "st480 chip\n");
+	ret = strlen(buf) + 1;
+
+	return ret;
+}
+
+static ssize_t show_status_value(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", atomic_read(&reserve_open_flag));
+}
+
+static DEVICE_ATTR(chipinfo, S_IRUGO, show_chipinfo_value, NULL);
+static DEVICE_ATTR(status, S_IRUGO, show_status_value, NULL);
+static int st480_sysfs_init(void)
+{
+	int ret;
+//TODO: using client->dev.kobj instead
+	st480_kobj = kobject_create_and_add("st480", NULL);
+	if(st480_kobj == NULL)
+	{
+		printk("st480 sysfs init failed!\n");
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	if(sysfs_create_file(st480_kobj, &dev_attr_chipinfo.attr))
+	{
+		printk("device_create_file chipinfo error!\n");
+		ret = -EIO;
+		goto err2;
+	}
+
+	if(sysfs_create_file(st480_kobj, &dev_attr_status.attr))
+	{
+		printk("device_create_file status error!\n");
+		ret = -EIO;
+		goto err2;
+	}
+
+	return ret;
+err2:
+	kobject_del(st480_kobj);
+err1:
+	return ret;
+}
+#endif
+static void st480_work_func(void)
+{
+	char buffer[9];
+	int ret;
+	s16 hw_data[3];
+
+	memset(buffer, 0, 9);
+	memset(hw_data, 0, 3);
+
+	buffer[0] = READ_MEASUREMENT_CMD;
+	ret = 0;
+	while (st480_i2c_transfer_data(st480->client, 1, buffer, 9)!=0)
+	{
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(st480->client, 1, buffer, 9)==0)
+		{
+			break;
+		}
+		if(ret > MAX_FAILURE_COUNT)
+		{
+			return;
+		}
+	}
+
+	if (!((buffer[0]>>4) & 0X01)) {
+		hw_data[0] = (buffer[3]<<8)|buffer[4];
+		hw_data[1] = (buffer[5]<<8)|buffer[6];
+		hw_data[2] = (buffer[7]<<8)|buffer[8];
+
+		mag.mag_x = ((st480->pdata->negate_x) ? (-hw_data[st480->pdata->axis_map_x])
+                : (hw_data[st480->pdata->axis_map_x]));
+		mag.mag_y = ((st480->pdata->negate_y) ? (-hw_data[st480->pdata->axis_map_y])
+                : (hw_data[st480->pdata->axis_map_y]));
+		mag.mag_z = ((st480->pdata->negate_z) ? (-hw_data[st480->pdata->axis_map_z])
+                        : (hw_data[st480->pdata->axis_map_z]));
+
+		if (((buffer[1]<<8)|(buffer[2])) > 46244)
+		{
+			mag.mag_x = mag.mag_x * (1 + (70/128/4096) * (((buffer[1]<<8)|(buffer[2])) - 46244));
+			mag.mag_y = mag.mag_y * (1 + (70/128/4096) * (((buffer[1]<<8)|(buffer[2])) - 46244));
+			mag.mag_z = mag.mag_z * (1 + (70/128/4096) * (((buffer[1]<<8)|(buffer[2])) - 46244));
+		}
+		else if (((buffer[1]<<8)|(buffer[2])) < 46244)
+		{
+			mag.mag_x = mag.mag_x * (1 + (60/128/4096) * (((buffer[1]<<8)|(buffer[2])) - 46244));
+			mag.mag_y = mag.mag_y * (1 + (60/128/4096) * (((buffer[1]<<8)|(buffer[2])) - 46244));
+			mag.mag_z = mag.mag_z * (1 + (60/128/4096) * (((buffer[1]<<8)|(buffer[2])) - 46244));
+		}
+
+		SENODIADBG("st480 raw data: x = %d, y = %d, z = %d \n",mag.mag_x,mag.mag_y,mag.mag_z);
+	} else
+		dev_err(&st480->client->dev, "ecc error detected!\n");
+
+	//set mode config
+	buffer[0] = SINGLE_MEASUREMENT_MODE_CMD;
+	ret=0;
+	while (st480_i2c_transfer_data(st480->client, 1, buffer, 1)!=0)
+	{
+		ret++;
+		msleep(1);
+		if (st480_i2c_transfer_data(st480->client, 1, buffer, 1)==0)
+		{
+			break;
+		}
+		if (ret > MAX_FAILURE_COUNT)
+		{
+			return;
+		}
+	}
+}
+
+static void st480_input_func(struct work_struct *work)
+{
+	struct st480_data *st480 = container_of((struct delayed_work *)work, struct st480_data, work);
+   	ktime_t timestamp;
+
+	SENODIAFUNC("st480_input_func");
+	st480_work_func();
+
+	if (atomic_read(&st480->m_flag) || atomic_read(&mv_flag) || atomic_read(&rm_flag) || atomic_read(&mrv_flag)) {
+		input_report_abs(st480->input_dev, ABS_X, mag.mag_x);
+		input_report_abs(st480->input_dev, ABS_Y, mag.mag_y);
+		input_report_abs(st480->input_dev, ABS_Z, mag.mag_z);
+        timestamp = ktime_get_boottime();
+        input_event(st480->input_dev, EV_SYN, SYN_TIME_SEC, ktime_to_timespec(timestamp).tv_sec);
+        input_event(st480->input_dev, EV_SYN, SYN_TIME_NSEC, ktime_to_timespec(timestamp).tv_nsec);
+		input_sync(st480->input_dev);
+	}
+
+	schedule_delayed_work(&st480->work, msecs_to_jiffies(st480->poll_interval));
+}
+
+static void ecs_closedone(void)
+{
+	SENODIAFUNC("ecs_closedone");
+	// atomic_set(&m_flag, 0);
+	atomic_set(&mv_flag, 0);
+	atomic_set(&rm_flag, 0);
+	atomic_set(&mrv_flag, 0);
+}
+
+/***** st480 functions ***************************************/
+static int st480_open(struct inode *inode, struct file *file)
+{
+	int ret = -1;
+
+	SENODIAFUNC("st480_open");
+
+	if (atomic_cmpxchg(&open_count, 0, 1) == 0) {
+		if (atomic_cmpxchg(&open_flag, 0, 1) == 0) {
+			atomic_set(&reserve_open_flag, 1);
+			ret = 0;
+		}
+	}
+
+	if (atomic_read(&reserve_open_flag))
+		schedule_delayed_work(&st480->work, msecs_to_jiffies(st480_delay));
+	return ret;
+}
+
+static int st480_release(struct inode *inode, struct file *file)
+{
+	SENODIAFUNC("st480_release");
+
+	atomic_set(&reserve_open_flag, 0);
+	atomic_set(&open_flag, 0);
+	atomic_set(&open_count, 0);
+
+	ecs_closedone();
+
+	cancel_delayed_work(&st480->work);
+	return 0;
+}
+
+#if OLD_KERNEL_VERSION
+static int
+st480_ioctl(struct inode *inode, struct file *file,
+			  unsigned int cmd, unsigned long arg)
+#else
+static long
+st480_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+#endif
+{
+	void __user *argp = (void __user *)arg;
+	short flag;
+
+	SENODIADBG("enter %s\n", __func__);
+
+	switch (cmd) {
+		case MSENSOR_IOCTL_ST480_SET_MFLAG:
+		case MSENSOR_IOCTL_ST480_SET_MVFLAG:
+		case MSENSOR_IOCTL_ST480_SET_RMFLAG:
+		case MSENSOR_IOCTL_ST480_SET_MRVFLAG:
+			if (copy_from_user(&flag, argp, sizeof(flag))) {
+				return -EFAULT;
+			}
+			if (flag < 0 || flag > 1) {
+				return -EINVAL;
+			}
+			break;
+		case MSENSOR_IOCTL_ST480_SET_DELAY:
+			if (copy_from_user(&flag, argp, sizeof(flag))) {
+				return -EFAULT;
+			}
+			break;
+		default:
+			break;
+	}
+
+	switch (cmd) {
+		case MSENSOR_IOCTL_ST480_SET_MFLAG:
+			//atomic_set(&m_flag, flag);
+			SENODIADBG("MFLAG is set to %d", flag);
+			break;
+		case MSENSOR_IOCTL_ST480_GET_MFLAG:
+			//flag = atomic_read(&m_flag);
+			SENODIADBG("Mflag = %d\n",flag);
+			break;
+		case MSENSOR_IOCTL_ST480_SET_MVFLAG:
+			atomic_set(&mv_flag, flag);
+			SENODIADBG("MVFLAG is set to %d", flag);
+			break;
+		case MSENSOR_IOCTL_ST480_GET_MVFLAG:
+			flag = atomic_read(&mv_flag);
+			SENODIADBG("MVflag = %d\n",flag);
+			break;
+		case MSENSOR_IOCTL_ST480_SET_RMFLAG:
+			atomic_set(&rm_flag, flag);
+			SENODIADBG("RMFLAG is set to %d", flag);
+			break;
+		case MSENSOR_IOCTL_ST480_GET_RMFLAG:
+			flag = atomic_read(&rm_flag);
+			SENODIADBG("RMflag = %d\n",flag);
+			break;
+		case MSENSOR_IOCTL_ST480_SET_MRVFLAG:
+			atomic_set(&mrv_flag, flag);
+			SENODIADBG("MRVFLAG is set to %d", flag);
+			break;
+		case MSENSOR_IOCTL_ST480_GET_MRVFLAG:
+			flag = atomic_read(&mrv_flag);
+			SENODIADBG("MRVflag = %d\n",flag);
+			break;
+		case MSENSOR_IOCTL_ST480_SET_DELAY:
+			st480_delay = flag;
+			break;
+		case MSENSOR_IOCTL_ST480_GET_DELAY:
+			flag = st480_delay;
+			break;
+		default:
+			return -ENOTTY;
+	}
+
+	switch (cmd) {
+		case MSENSOR_IOCTL_ST480_GET_MFLAG:
+		case MSENSOR_IOCTL_ST480_GET_MVFLAG:
+		case MSENSOR_IOCTL_ST480_GET_RMFLAG:
+		case MSENSOR_IOCTL_ST480_GET_MRVFLAG:
+		case MSENSOR_IOCTL_ST480_GET_DELAY:
+			if (copy_to_user(argp, &flag, sizeof(flag))) {
+				return -EFAULT;
+			}
+			break;
+		default:
+			break;
+	}
+
+	return 0;
+}
+
+
+static struct file_operations st480_fops = {
+	.owner = THIS_MODULE,
+	.open = st480_open,
+	.release = st480_release,
+#if OLD_KERNEL_VERSION
+	.ioctl = st480_ioctl,
+#else
+	.unlocked_ioctl = st480_ioctl,
+#endif
+};
+
+
+static struct miscdevice st480_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "st480",
+	.fops = &st480_fops,
+};
+
+/*********************************************/
+#if ST480_AUTO_TEST
+static int sensor_test_read(void)
+
+{
+        st480_work_func();
+        return 0;
+}
+
+static int auto_test_read(void *unused)
+{
+        while(1){
+                sensor_test_read();
+                msleep(200);
+        }
+        return 0;
+}
+#endif
+
+static int st480_set_enable(struct st480_data *st480, bool on)
+{
+	int retval = 0;
+	struct i2c_client *client = st480->client;
+
+	dev_info(&client->dev, "enable:%s\n", on ? "on" : "off");
+
+	if (on) {
+		schedule_delayed_work(&st480->work, msecs_to_jiffies(st480->poll_interval));
+	} else {
+		cancel_delayed_work(&st480->work);
+	}
+	return retval;
+}
+
+static int st480_set_poll_delay(struct st480_data *st480, unsigned int msecs)
+{
+	//msecs = ST480_DEFAULT_DELAY;
+
+	write_lock(&st480->lock);
+	st480->poll_interval = msecs;
+	write_unlock(&st480->lock);
+
+	return 0;
+}
+
+static int st480_cdev_set_enable(struct sensors_classdev *sensors_cdev,
+							unsigned int enable)
+{
+	struct st480_data *st480 =
+		container_of(sensors_cdev, struct st480_data, cdev);
+
+	return st480_set_enable(st480, enable);
+}
+
+static int st480_cdev_set_poll_delay(struct sensors_classdev *sensors_cdev,
+								unsigned int msecs)
+{
+	struct st480_data *st480 =
+		container_of(sensors_cdev, struct st480_data, cdev);
+
+	if (msecs != st480->poll_interval)
+		return st480_set_poll_delay(st480, msecs);
+
+	return 0;
+}
+
+static int st480_power_ctrl(struct st480_data *st480, int on)
+{
+	int retval = 0;
+	struct i2c_client *client = st480->client;
+
+	if (on) {
+		retval = regulator_enable(st480->vdd);
+		if (retval) {
+			dev_err(&client->dev, "regulator vdd enable failed!\n");
+			return retval;
+		}
+		retval = regulator_enable(st480->vio);
+		if (retval) {
+			dev_err(&client->dev, "regulator vio enable failed!\n");
+			retval = regulator_disable(st480->vdd);
+			return retval;
+		}
+	} else {
+		retval = regulator_disable(st480->vdd);
+		if (retval) {
+			dev_err(&client->dev, "regulator vdd disable failed!\n");
+			return retval;
+		}
+		retval = regulator_disable(st480->vio);
+		if (retval) {
+			dev_err(&client->dev, "regulator vio disable failed!\n");
+			retval = regulator_enable(st480->vdd);
+			return retval;
+		}
+	}
+	return retval;
+}
+
+static int st480_power_init(struct st480_data *st480)
+{
+	int retval = 0;
+	struct i2c_client *client = st480->client;
+
+	st480->vdd = devm_regulator_get(&client->dev, "vdd");
+	if (IS_ERR(st480->vdd)) {
+		retval = PTR_ERR(st480->vdd);
+		dev_err(&client->dev, "regulator get failed vdd retval=%d\n", retval);
+		return retval;
+	}
+
+	st480->vio = devm_regulator_get(&client->dev, "vio");
+	if (IS_ERR(st480->vio)) {
+		retval = PTR_ERR(st480->vio);
+		dev_err(&client->dev, "regulator get failed vio retval=%d\n", retval);
+		goto err_reg_vdd_put;
+	}
+
+	return retval;
+
+err_reg_vdd_put:
+	devm_regulator_put(st480->vdd);
+
+	return retval;
+}
+
+#ifdef CONFIG_OF
+static int st480_parse_dt(struct i2c_client *client, struct platform_data_st480 *pdata)
+{
+	struct device_node *np = client->dev.of_node;
+	int rc = 0;
+
+	if (!np) {
+		dev_err(&client->dev, "device don't have associateed dt data!\n");
+		return -EINVAL;
+	}
+
+	rc = of_property_read_u32(np, "senodia,axis-map-x", &pdata->axis_map_x);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(&client->dev, "failed to get senodia,axis-map-x!\n");
+		return rc;
+	}
+
+	rc = of_property_read_u32(np, "senodia,axis-map-y", &pdata->axis_map_y);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(&client->dev, "failed to get senodia,axis-map-y!\n");
+		return rc;
+	}
+
+	rc = of_property_read_u32(np, "senodia,axis-map-z", &pdata->axis_map_z);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(&client->dev, "failed to get senodia,axis-map-z!\n");
+		return rc;
+	}
+	pdata->negate_x = of_property_read_bool(np, "senodia,negate-x");
+	pdata->negate_y = of_property_read_bool(np, "senodia,negate-y");
+	pdata->negate_z = of_property_read_bool(np, "senodia,negate-z");
+
+	return rc;
+}
+#else
+static int st480_parse_dt(struct i2c_client *client, struct platform_data_st480 *pdata)
+{
+	return -ENODEV;
+}
+#endif /* CONFIG_OF */
+
+static int st480_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int err = 0;
+	struct platform_data_st480 *pdata;
+#if ST480_AUTO_TEST
+        struct task_struct *thread;
+#endif
+
+	SENODIAFUNC("st480_probe");
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		printk(KERN_ERR "SENODIA st480_probe: check_functionality failed.\n");
+		err = -ENODEV;
+		goto exit0;
+	}
+
+	/* Allocate memory for driver data */
+	st480 = kzalloc(sizeof(struct st480_data), GFP_KERNEL);
+	if (!st480) {
+		printk(KERN_ERR "SENODIA st480_probe: memory allocation failed.\n");
+		err = -ENOMEM;
+		goto exit1;
+	}
+
+	st480->client = client;
+
+	i2c_set_clientdata(client, st480);
+
+	INIT_DELAYED_WORK(&st480->work, st480_input_func);
+
+	if (client->dev.of_node) {
+		pdata = kzalloc(sizeof(struct platform_data_st480), GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&client->dev, "failed to allocate memory for st480 pdata\n");
+			err = -ENOMEM;
+			goto exit2;
+		}
+		err = st480_parse_dt(client, pdata);
+		if (err) {
+			dev_err(&client->dev, "parse device tree error!\n");
+			goto exit3;
+		}
+	} else {
+		pdata = dev_get_platdata(&client->dev);
+		if (!pdata) {
+			dev_err(&client->dev, "No platform data!\n");
+			goto exit2;
+		}
+	}
+	st480->pdata = pdata;
+
+	/* st480 power intialize */
+	err = st480_power_init(st480);
+	if (err < 0) {
+		dev_err(&client->dev, "failed to get regulator!\n");
+		goto exit2;
+	}
+	/* get the power and never put it unless driver remove */
+	err = st480_power_ctrl(st480, 1);
+	if (err) {
+		dev_err(&client->dev, "failed to set regulator!\n");
+		goto exit2;
+	}
+
+	if (st480_setup(st480->client) != 0) {
+		dev_err(&client->dev, "st480 setup error!\n");
+		goto exit3;
+	}
+
+	/* Declare input device */
+	st480->input_dev = input_allocate_device();
+	if (!st480->input_dev) {
+		err = -ENOMEM;
+		dev_err(&client->dev, "failed to allocate input device\n");
+		goto exit3;
+	}
+
+	/* Setup input device */
+	set_bit(EV_ABS, st480->input_dev->evbit);
+
+	/* x-axis of raw magnetic vector (-32768, 32767) */
+	input_set_abs_params(st480->input_dev, ABS_X, ABSMIN_MAG, ABSMAX_MAG, 0, 0);
+	/* y-axis of raw magnetic vector (-32768, 32767) */
+	input_set_abs_params(st480->input_dev, ABS_Y, ABSMIN_MAG, ABSMAX_MAG, 0, 0);
+	/* z-axis of raw magnetic vector (-32768, 32767) */
+	input_set_abs_params(st480->input_dev, ABS_Z, ABSMIN_MAG, ABSMAX_MAG, 0, 0);
+	/* Set name */
+	st480->input_dev->name = "compass";
+	st480->input_dev->id.bustype = BUS_I2C;
+
+	/* Register */
+	err = input_register_device(st480->input_dev);
+	if (err) {
+		dev_err(&client->dev, "SENODIA st480_probe: Unable to register input device\n");
+		goto exit4;
+	}
+
+	err = misc_register(&st480_device);
+	if (err) {
+		dev_err(&client->dev, "SENODIA st480_probe: st480_device register failed\n");
+		goto exit5;
+	}
+
+	rwlock_init(&st480->lock);
+	/* As default, report all information */
+	atomic_set(&st480->m_flag, 1);
+	atomic_set(&mv_flag, 1);
+	atomic_set(&rm_flag, 1);
+	atomic_set(&mrv_flag, 1);
+	st480->poll_interval = ST480_DEFAULT_DELAY;
+	st480->cdev = sensors_cdev;
+	st480->cdev.sensors_enable = st480_cdev_set_enable;
+	st480->cdev.sensors_poll_delay = st480_cdev_set_poll_delay;
+	err = sensors_classdev_register(&client->dev, &st480->cdev);
+	if (err) {
+		dev_err(&client->dev, "sensors class register failed!\n");
+		goto exit5;
+	}
+/*
+	err = st480_sysfs_init();
+	if (err < 0) {
+		printk("st480 sysfs init error!\n");
+		goto exit5;
+	}
+*/
+#if ST480_AUTO_TEST
+	thread=kthread_run(auto_test_read,NULL,"st480_read_test");
+#endif
+
+	printk("st480 probe done.");
+	return 0;
+
+exit5:
+	misc_deregister(&st480_device);
+	input_unregister_device(st480->input_dev);
+exit4:
+	input_free_device(st480->input_dev);
+exit3:
+	kfree(st480->pdata);
+exit2:
+	kfree(st480);
+exit1:
+exit0:
+	return err;
+
+}
+
+static int st480_remove(struct i2c_client *client)
+{
+	struct st480_data *st480 = i2c_get_clientdata(client);
+
+	sensors_classdev_unregister(&st480->cdev);
+	atomic_set(&st480->m_flag, 0);
+	misc_deregister(&st480_device);
+	input_unregister_device(st480->input_dev);
+	input_free_device(st480->input_dev);
+	cancel_delayed_work(&st480->work);
+	i2c_set_clientdata(client, NULL);
+	kfree(st480->pdata);
+	kfree(st480);
+	return 0;
+}
+
+static const struct i2c_device_id st480_id_table[] = {
+	{ ST480_I2C_NAME, 0 },
+	{ },
+};
+
+static struct of_device_id st480_match_table[] = {
+	{ .compatible = "senodia,st480", },
+	{ },
+};
+
+static struct i2c_driver st480_driver = {
+	.probe		= st480_probe,
+	.remove 	= st480_remove,
+	.id_table	= st480_id_table,
+	.driver = {
+		.name = ST480_I2C_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = st480_match_table,
+	},
+};
+
+static int __init st480_init(void)
+{
+	return i2c_add_driver(&st480_driver);
+}
+
+static void __exit st480_exit(void)
+{
+	i2c_del_driver(&st480_driver);
+}
+
+module_init(st480_init);
+module_exit(st480_exit);
+
+MODULE_AUTHOR("Tori Xu <xuezhi_xu@senodia.com>");
+MODULE_DESCRIPTION("senodia st480 linux driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("2.0.0");
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index d4a8fa97493..e072d980215 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1072,6 +1072,8 @@ config INPUT_MT_WRAPPER
 
 	  If unsure, say N.
 
+source "drivers/input/touchscreen/melfas_mip4_test/Kconfig"
+
 config TOUCHSCREEN_IT7260_I2C
 	tristate "IT7260 Touchscreen Driver"
 	depends on I2C
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 28b3dc10fa8..2971f56c265 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -83,4 +83,5 @@ obj-$(CONFIG_TOUCHSCREEN_GT9XX)		+= gt9xx/
 obj-$(CONFIG_TOUCHSCREEN_BU21150)	+= bu21150.o
 obj-$(CONFIG_INPUT_MT_WRAPPER)		+= input_mt_wrapper.o
 obj-$(CONFIG_TOUCHSCREEN_IT7260_I2C)    += it7258_ts_i2c.o
-obj-$(CONFIG_TOUCHSCREEN_HIMAX_HX852xES)      += hx852xes/
+obj-$(CONFIG_TESTPLUS_ONLY)            += melfas_mip4_testplus/
+obj-$(CONFIG_TEST_ONLY)                += melfas_mip4_test/
diff --git a/drivers/input/touchscreen/gt9xx/goodix_tool.c b/drivers/input/touchscreen/gt9xx/goodix_tool.c
index f087982fbf9..b94f159b804 100644
--- a/drivers/input/touchscreen/gt9xx/goodix_tool.c
+++ b/drivers/input/touchscreen/gt9xx/goodix_tool.c
@@ -307,7 +307,7 @@ static s32 fill_update_info(char __user *user_buf,
 Output:
     Return write length.
 ********************************************************/
-static s32 goodix_tool_write(struct file *filp, const char __user *userbuf,
+static ssize_t goodix_tool_write(struct file *filp, const char __user *userbuf,
 						size_t count, loff_t *ppos)
 {
 	s32 ret = 0;
@@ -386,7 +386,7 @@ static s32 goodix_tool_write(struct file *filp, const char __user *userbuf,
 		if (cmd_head.data_len > sizeof(ic_type)) {
 			dev_err(&gt_client->dev,
 				"data len %d > data buff %d, rejected!\n",
-				cmd_head.data_len, sizeof(ic_type));
+				cmd_head.data_len, (int)sizeof(ic_type));
 			ret = -EINVAL;
 			goto exit;
 		}
@@ -479,7 +479,7 @@ static s32 goodix_tool_write(struct file *filp, const char __user *userbuf,
 Output:
     Return read length.
 ********************************************************/
-static s32 goodix_tool_read(struct file *file, char __user *user_buf,
+static ssize_t goodix_tool_read(struct file *file, char __user *user_buf,
 					size_t count, loff_t *ppos)
 {
 	u16 data_len = 0;
diff --git a/drivers/input/touchscreen/gt9xx/gt9xx.c b/drivers/input/touchscreen/gt9xx/gt9xx.c
index 46dfeed0b2a..7a791f6ed8d 100644
--- a/drivers/input/touchscreen/gt9xx/gt9xx.c
+++ b/drivers/input/touchscreen/gt9xx/gt9xx.c
@@ -45,7 +45,7 @@
 
 #include <linux/regulator/consumer.h>
 #include "gt9xx.h"
-
+#include <linux/interrupt.h>
 #include <linux/of_gpio.h>
 #include <linux/irq.h>
 #include <linux/module.h>
@@ -111,6 +111,8 @@ bool init_done;
 static u8 chip_gt9xxs;  /* true if ic is gt9xxs, like gt915s */
 u8 grp_cfg_version;
 struct i2c_client  *i2c_connect_client;
+static struct class *touchscreen_class;
+static char *ts_info;
 
 #define GTP_DEBUGFS_DIR			"ts_debug"
 #define GTP_DEBUGFS_FILE_SUSPEND	"suspend"
@@ -142,7 +144,7 @@ int gtp_i2c_read(struct i2c_client *client, u8 *buf, int len)
 			.buf	= &buf[0],
 		},
 		{
-			.flags	= I2C_M_RD,
+			.flags	= client->flags | I2C_M_RD,
 			.addr	= client->addr,
 			.len	= len - GTP_ADDR_LENGTH,
 			.buf	= &buf[GTP_ADDR_LENGTH],
@@ -645,20 +647,20 @@ void gtp_reset_guitar(struct goodix_ts_data *ts, int ms)
 {
 	/* This reset sequence will selcet I2C slave address */
 	gpio_direction_output(ts->pdata->reset_gpio, 0);
-	msleep(ms);
+//	msleep(ms);
 
 	if (ts->client->addr == GTP_I2C_ADDRESS_HIGH)
 		gpio_direction_output(ts->pdata->irq_gpio, 1);
 	else
 		gpio_direction_output(ts->pdata->irq_gpio, 0);
 
-	usleep(RESET_DELAY_T3_US);
+	udelay(RESET_DELAY_T3_US);
 	gpio_direction_output(ts->pdata->reset_gpio, 1);
-	msleep(RESET_DELAY_T4);
+	msleep(20);
 
 	gpio_direction_input(ts->pdata->reset_gpio);
 
-	gtp_int_sync(ts, 50);
+	gtp_int_sync(ts, 20);
 
 #if GTP_ESD_PROTECT
 	gtp_init_ext_watchdog(ts->client);
@@ -733,11 +735,12 @@ static u8 gtp_enter_sleep(struct goodix_ts_data *ts)
 			"GTP sleep: Cannot reconfig gpio %d.\n",
 			ts->pdata->irq_gpio);
 	if (ts->pdata->enable_power_off) {
-		ret = gpio_direction_output(ts->pdata->reset_gpio, 0);
-		if (ret)
-			dev_err(&ts->client->dev,
-				"GTP sleep: Cannot reconfig gpio %d.\n",
-				ts->pdata->reset_gpio);
+		usleep(5000);
+		ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
+		if (ret == 1) {
+			dev_dbg(&ts->client->dev, "GTP enter sleep!");
+			return 0;
+		}
 		ret = goodix_power_off(ts);
 		if (ret) {
 			dev_err(&ts->client->dev, "GTP power off failed.\n");
@@ -1181,7 +1184,7 @@ static int gtp_request_irq(struct goodix_ts_data *ts)
 
 	ret = request_threaded_irq(ts->client->irq, NULL,
 			goodix_ts_irq_handler,
-			irq_table[ts->int_trigger_type],
+			irq_table[ts->int_trigger_type] | IRQF_ONESHOT,
 			ts->client->name, ts);
 	if (ret) {
 		ts->use_irq = false;
@@ -1473,6 +1476,22 @@ static int goodix_power_init(struct goodix_ts_data *ts)
 	return 0;
 }
 
+static int goodix_pinctrl_init(struct goodix_ts_data *ts)
+{
+	ts->ts_pinctrl = devm_pinctrl_get(&ts->client->dev);
+	if (IS_ERR_OR_NULL(ts->ts_pinctrl)) {
+		return PTR_ERR(ts->ts_pinctrl);
+	}
+	ts->pinctrl_state_active = pinctrl_lookup_state(ts->ts_pinctrl, "pmx_ts_active");
+	if (IS_ERR_OR_NULL(ts->pinctrl_state_active))
+		return PTR_ERR(ts->pinctrl_state_active);
+	ts->pinctrl_state_suspend = pinctrl_lookup_state(ts->ts_pinctrl, "pmx_ts_suspend");
+	if (IS_ERR_OR_NULL(ts->pinctrl_state_suspend))
+		return PTR_ERR(ts->pinctrl_state_suspend);
+
+	return 0;
+}
+
 /**
  * goodix_power_deinit - Deinitialize device power
  * @ts: driver private data
@@ -1773,6 +1792,61 @@ static int gtp_debugfs_init(struct goodix_ts_data *data)
 	return 0;
 }
 
+static ssize_t class_gtp_ts_info_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	return snprintf(buf, GTP_INFO_MAX_SIZE, "%s\n", ts_info);
+}
+
+static CLASS_ATTR(ts_info, S_IRUSR, class_gtp_ts_info_show, NULL);
+
+static ssize_t class_gtp_ts_version_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	return snprintf(buf, GTP_INFO_MAX_SIZE, "00_00_00_%02x\n",
+					grp_cfg_version);
+}
+
+static CLASS_ATTR(ts_version, S_IRUSR, class_gtp_ts_version_show, NULL);
+
+
+static int gtp_device_info_init(struct goodix_ts_data *data)
+{
+	int rc = 0;
+	struct i2c_client *client = data->client;
+	struct goodix_ts_platform_data *pdata = data->pdata;
+
+	ts_info = devm_kzalloc(&client->dev, GTP_INFO_MAX_SIZE, GFP_KERNEL);
+	if (!ts_info) {
+		dev_err(&client->dev, "Out of memory!\n");
+		return -ENOMEM;
+	}
+
+	touchscreen_class = class_create(THIS_MODULE, "touchscreen");
+	if (IS_ERR_OR_NULL(touchscreen_class)) {
+		dev_err(&client->dev, "%s: create class error!\n", __func__);
+		return -PTR_ERR(touchscreen_class);
+	}
+
+	rc = class_create_file(touchscreen_class, &class_attr_ts_info);
+	if (rc < 0) {
+		dev_err(&client->dev, "%s class_create_file failed!\n", __func__);
+		class_destroy(touchscreen_class);
+		return rc;
+	}
+
+	rc = class_create_file(touchscreen_class, &class_attr_ts_version);
+	if (rc < 0) {
+		dev_err(&client->dev, "%s class_create_file failed!\n", __func__);
+		class_destroy(touchscreen_class);
+		return rc;
+	}
+
+	snprintf(ts_info, GTP_INFO_MAX_SIZE, "goodix %s", pdata->product_id);
+
+	return 0;
+}
+
 static int goodix_ts_get_dt_coords(struct device *dev, char *name,
 				struct goodix_ts_platform_data *pdata)
 {
@@ -1996,6 +2070,13 @@ static int goodix_ts_probe(struct i2c_client *client,
 	ts->gtp_rawdiff_mode = 0;
 	ts->power_on = false;
 
+	ret = goodix_pinctrl_init(ts);
+	if (ret)
+		dev_err(&client->dev, "GTP pinctrl init failed!\n");
+
+	if (ts->ts_pinctrl)
+		pinctrl_select_state(ts->ts_pinctrl, ts->pinctrl_state_active);
+
 	ret = gtp_request_io_port(ts);
 	if (ret) {
 		dev_err(&client->dev, "GTP request IO port failed.\n");
@@ -2108,6 +2189,12 @@ static int goodix_ts_probe(struct i2c_client *client,
 		goto exit_remove_sysfs;
 	}
 
+	ret = gtp_device_info_init(ts);
+	if (ret) {
+		dev_err(&client->dev, "failed to add device info!\n");
+		goto exit_remove_sysfs;
+	}
+
 	init_done = true;
 	return 0;
 exit_free_irq:
@@ -2176,7 +2263,6 @@ static int goodix_ts_remove(struct i2c_client *client)
 #endif
 
 #if GTP_ESD_PROTECT
-	cancel_work_sync(gtp_esd_check_workqueue);
 	flush_workqueue(gtp_esd_check_workqueue);
 	destroy_workqueue(gtp_esd_check_workqueue);
 #endif
@@ -2256,6 +2342,10 @@ static int goodix_ts_suspend(struct device *dev)
 		if (ret < 0)
 			dev_err(&ts->client->dev, "GTP early suspend failed.\n");
 	}
+/*
+	if (ts->ts_pinctrl)
+		pinctrl_select_state(ts->ts_pinctrl, ts->pinctrl_state_suspend);
+*/
 	/* to avoid waking up while not sleeping,
 	 * delay 48 + 10ms to ensure reliability
 	 */
@@ -2285,6 +2375,10 @@ static int goodix_ts_resume(struct device *dev)
 	}
 
 	mutex_lock(&ts->lock);
+/*
+	if (ts->ts_pinctrl)
+		pinctrl_select_state(ts->ts_pinctrl, ts->pinctrl_state_active);
+*/
 	ret = gtp_wakeup_sleep(ts);
 
 	if (ts->pdata->slide_wakeup)
@@ -2314,7 +2408,7 @@ static int fb_notifier_callback(struct notifier_block *self,
 	struct goodix_ts_data *ts =
 		container_of(self, struct goodix_ts_data, fb_notif);
 
-	if (evdata && evdata->data && event == FB_EVENT_BLANK &&
+	if (evdata && evdata->data && event == FB_EARLY_EVENT_BLANK &&
 			ts && ts->client) {
 		blank = evdata->data;
 		if (*blank == FB_BLANK_UNBLANK)
diff --git a/drivers/input/touchscreen/gt9xx/gt9xx.h b/drivers/input/touchscreen/gt9xx/gt9xx.h
index 3cedf26f564..5a8de7695c0 100644
--- a/drivers/input/touchscreen/gt9xx/gt9xx.h
+++ b/drivers/input/touchscreen/gt9xx/gt9xx.h
@@ -40,6 +40,7 @@
 #define MAX_BUTTONS 4
 #define GOODIX_MAX_CFG_GROUP	6
 #define GTP_FW_NAME_MAXSIZE	50
+#define GTP_INFO_MAX_SIZE	128
 
 struct goodix_ts_platform_data {
 	int irq_gpio;
@@ -59,7 +60,7 @@ struct goodix_ts_platform_data {
 	bool force_update;
 	bool i2c_pull_up;
 	bool enable_power_off;
-	size_t config_data_len[GOODIX_MAX_CFG_GROUP];
+	int config_data_len[GOODIX_MAX_CFG_GROUP];
 	u8 *config_data[GOODIX_MAX_CFG_GROUP];
 	u32 button_map[MAX_BUTTONS];
 	u8 num_button;
@@ -104,6 +105,9 @@ struct goodix_ts_data {
 	struct regulator *avdd;
 	struct regulator *vdd;
 	struct regulator *vcc_i2c;
+	struct pinctrl *ts_pinctrl;
+	struct pinctrl_state *pinctrl_state_active;
+	struct pinctrl_state *pinctrl_state_suspend;
 #if defined(CONFIG_FB)
 	struct notifier_block fb_notif;
 #elif defined(CONFIG_HAS_EARLYSUSPEND)
@@ -117,7 +121,7 @@ extern u16 total_len;
 
 /***************************PART1:ON/OFF define*******************************/
 #define GTP_CUSTOM_CFG			0
-#define GTP_ESD_PROTECT			0
+#define GTP_ESD_PROTECT			1
 
 #define GTP_IRQ_TAB            {\
 				IRQ_TYPE_EDGE_RISING,\
@@ -134,8 +138,8 @@ extern u16 total_len;
 #define GTP_MAX_WIDTH		480
 #define GTP_INT_TRIGGER		GTP_IRQ_TAB_RISING
 #else
-#define GTP_MAX_HEIGHT		4096
-#define GTP_MAX_WIDTH		4096
+#define GTP_MAX_HEIGHT		1920
+#define GTP_MAX_WIDTH		1080
 #define GTP_INT_TRIGGER		GTP_IRQ_TAB_FALLING
 #endif
 
diff --git a/drivers/input/touchscreen/gt9xx/gt9xx_update.c b/drivers/input/touchscreen/gt9xx/gt9xx_update.c
index af80eefbc9d..868988acae4 100644
--- a/drivers/input/touchscreen/gt9xx/gt9xx_update.c
+++ b/drivers/input/touchscreen/gt9xx/gt9xx_update.c
@@ -565,7 +565,7 @@ static s8 gup_update_config(struct i2c_client *client,
 		!memcmp(&pid[GTP_ADDR_LENGTH], "960", 3)) {
 		chip_cfg_len = 228;
 	}
-	pr_debug("config file ASCII len:%d", cfg->size);
+	pr_debug("config file ASCII len:%ld", cfg->size);
 	pr_debug("need config binary len:%d", chip_cfg_len);
 	if ((cfg->size + 5) < chip_cfg_len * 5) {
 		pr_err("Config length error");
@@ -649,7 +649,7 @@ static s32 gup_get_firmware_file(struct i2c_client *client,
 		return -EEXIST;
 	}
 
-	dev_dbg(&client->dev, "Config File: %s size=%d", path, fw->size);
+	dev_dbg(&client->dev, "Config File: %s size=%ld", path, fw->size);
 	msg->fw_data =
 		devm_kzalloc(&client->dev, fw->size, GFP_KERNEL);
 	if (!msg->fw_data) {
diff --git a/drivers/input/touchscreen/melfas_mip4_test/Kconfig b/drivers/input/touchscreen/melfas_mip4_test/Kconfig
new file mode 100755
index 00000000000..4f2c27684fb
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_test/Kconfig
@@ -0,0 +1,42 @@
+#
+# Kconfig for MELFAS MIP4 Touchscreen Driver
+#
+config TOUCHSCREEN_MELFAS_MMS438
+        tristate "MELFAS MMS438 Touchscreen"
+        depends on I2C
+        help
+          Say Y here if you have a MELFAS MMS438 touchscreen device in your system.
+
+          If unsure, say N.
+
+          To compile this driver as a module, choose M here: the module will be called mip4_ts.
+
+config TOUCHSCREEN_MELFAS_MMS449
+        tristate "MELFAS MMS449 Touchscreen"
+        depends on I2C
+        help
+          Say Y here if you have a MELFAS MMS449 touchscreen device in your system.
+
+          If unsure, say N.
+
+          To compile this driver as a module, choose M here: the module will be called mip4_ts.
+
+config TOUCHSCREEN_MELFAS_MMS458
+        tristate "MELFAS MMS458 Touchscreen"
+        depends on I2C
+        help
+          Say Y here if you have a MELFAS MMS458 touchscreen device in your system.
+
+          If unsure, say N.
+
+          To compile this driver as a module, choose M here: the module will be called mip4_ts.
+
+config TOUCHSCREEN_MELFAS_MIT300
+        tristate "MELFAS MIT300 Touchscreen"
+        depends on I2C
+        help
+          Say Y here if you have a MELFAS MIT300 touchscreen device in your system.
+
+          If unsure, say N.
+
+          To compile this driver as a module, choose M here: the module will be called mip4_ts.
diff --git a/drivers/input/touchscreen/melfas_mip4_test/Makefile b/drivers/input/touchscreen/melfas_mip4_test/Makefile
new file mode 100755
index 00000000000..feac86c83c6
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_test/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for MELFAS MIP4 Touchscreen driver
+#
+
+obj-$(CONFIG_TOUCHSCREEN_MELFAS_MMS449)	+= mip4.o mip4_mod.o mip4_debug.o mip4_fw_mms438.o
+
diff --git a/drivers/input/touchscreen/melfas_mip4_test/mip4.c b/drivers/input/touchscreen/melfas_mip4_test/mip4.c
new file mode 100755
index 00000000000..c9c5b5b3dd9
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_test/mip4.c
@@ -0,0 +1,1460 @@
+/*
+ * MELFAS MIP4 Touchscreen
+ *
+ * Copyright (C) 2015 MELFAS Inc.
+ *
+ *
+ * mip4.c : Main functions
+ *
+ *
+ * Version : 2015.05.08
+ *
+ */
+//#define DEBUG 1
+#include "mip4.h"
+
+
+#if defined(CONFIG_FB)
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+#endif
+
+#define TS_INFO_MAX 512
+
+static struct class *touchscreen_class;
+static struct mip_ts_info *class_ts_info;
+
+#if MIP_USE_WAKEUP_GESTURE
+struct wake_lock mip_wake_lock;
+#endif
+
+static ssize_t class_melfs_ts_info_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	return snprintf(buf, TS_INFO_MAX, "%s\n", "MELFAS_MMS449");
+}
+
+static CLASS_ATTR(ts_info, S_IRUSR, class_melfs_ts_info_show, NULL);
+
+static ssize_t class_melfs_ts_version_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	u8 data[256] = {0};
+	u8 rbuf[16] = {0};
+
+	mip_get_fw_version(class_ts_info, rbuf);
+	sprintf(data, "%02X.%02X_%02X.%02X_%02X.%02X_%02X"".%02X",
+			rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4], rbuf[5], rbuf[6], rbuf[7]);
+	return snprintf(buf, TS_INFO_MAX, "%s\n", data);
+}
+
+static CLASS_ATTR(ts_version, S_IRUSR, class_melfs_ts_version_show, NULL);
+
+/**
+* Reboot chip
+*
+* Caution : IRQ must be disabled before mip_reboot and enabled after mip_reboot.
+*/
+void mip_reboot(struct mip_ts_info *info)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(info->client->dev.parent);
+		
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	
+	i2c_lock_adapter(adapter);
+	
+	mip_power_off(info);
+	mip_power_on(info);
+	mdelay(10);
+	i2c_unlock_adapter(adapter);
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+}
+
+/**
+* I2C Read
+*/
+int mip_i2c_read(struct mip_ts_info *info, char *write_buf, unsigned int write_len, char *read_buf, unsigned int read_len)
+{
+	int retry = I2C_RETRY_COUNT;
+	int res;
+
+	struct i2c_msg msg[] = {
+		{
+			.addr = info->client->addr,
+			.flags = 0,
+			.buf = write_buf,
+			.len = write_len,
+		}, {
+			.addr = info->client->addr,
+			.flags = I2C_M_RD,
+			.buf = read_buf,
+			.len = read_len,
+		},
+	};
+
+	while(retry--){	
+		res = i2c_transfer(info->client->adapter, msg, ARRAY_SIZE(msg));
+
+		if (res == ARRAY_SIZE(msg))
+			goto DONE;
+		else if (res < 0)
+			dev_err(&info->client->dev, "%s [ERROR] i2c_transfer - errno[%d]\n",
+					__func__, res);
+		else if (res != ARRAY_SIZE(msg))
+			dev_err(&info->client->dev, "%s [ERROR] i2c_transfer - size[%d] result[%d]\n",
+					__func__, (int)ARRAY_SIZE(msg), res);
+		else
+			dev_err(&info->client->dev, "%s [ERROR] unknown error [%d]\n", __func__, res);
+	}
+
+	goto ERROR_REBOOT;
+	
+ERROR_REBOOT:
+	mip_reboot(info);
+	return 1;
+	
+DONE:
+	return 0;
+}
+
+
+/**
+* I2C Read (Continue)
+*/
+int mip_i2c_read_next(struct mip_ts_info *info, char *write_buf, unsigned int write_len, char *read_buf, int start_idx, unsigned int read_len)
+{
+	int retry = I2C_RETRY_COUNT;
+	int res;
+	u8 rbuf[read_len];
+
+	/*
+	while(retry--){
+		res = i2c_master_recv(info->client, rbuf, read_len);
+		
+		if(res == read_len){
+			goto DONE;
+		}
+		else if(res < 0){
+			dev_err(&info->client->dev, "%s [ERROR] i2c_master_recv - errno [%d]\n", __func__, res);
+		}
+		else if(res != read_len){
+			dev_err(&info->client->dev, "%s [ERROR] length mismatch - read[%d] result[%d]\n", __func__, read_len, res);
+		}			
+		else{
+			dev_err(&info->client->dev, "%s [ERROR] unknown error [%d]\n", __func__, res);
+		}
+	}
+	*/
+
+	struct i2c_msg msg[] = {
+		{
+			.addr = info->client->addr,
+			.flags = 0,
+			.buf = write_buf,
+			.len = write_len,
+		}, {
+			.addr = info->client->addr,
+			.flags = I2C_M_RD,
+			.buf = rbuf,
+			.len = read_len,
+		},
+	};
+	
+	while(retry--){	
+		res = i2c_transfer(info->client->adapter, msg, ARRAY_SIZE(msg));
+
+		if(res == ARRAY_SIZE(msg)){
+			goto DONE;
+		}
+		else if(res < 0){
+			dev_err(&info->client->dev, "%s [ERROR] i2c_transfer - errno[%d]\n", __func__, res);
+		}
+		else if(res != ARRAY_SIZE(msg)){
+			dev_err(&info->client->dev, "%s [ERROR] i2c_transfer - size[%d] result[%d]\n",
+					__func__, (int)ARRAY_SIZE(msg), res);
+		}			
+		else{
+			dev_err(&info->client->dev, "%s [ERROR] unknown error [%d]\n", __func__, res);
+		}
+	}
+	
+	goto ERROR_REBOOT;
+	
+ERROR_REBOOT:
+	mip_reboot(info);
+	return 1;
+
+DONE:
+	memcpy(&read_buf[start_idx], rbuf, read_len);
+	
+	return 0;
+}
+
+/**
+* I2C Write
+*/
+int mip_i2c_write(struct mip_ts_info *info, char *write_buf, unsigned int write_len)
+{
+	int retry = I2C_RETRY_COUNT;
+	int res;
+
+	while(retry--){
+		res = i2c_master_send(info->client, write_buf, write_len);
+
+		if(res == write_len){
+			goto DONE;
+		}
+		else if(res < 0){
+			dev_err(&info->client->dev, "%s [ERROR] i2c_master_send - errno [%d]\n", __func__, res);
+		}
+		else if(res != write_len){
+			dev_err(&info->client->dev, "%s [ERROR] length mismatch - write[%d] result[%d]\n", __func__, write_len, res);
+		}			
+		else{
+			dev_err(&info->client->dev, "%s [ERROR] unknown error [%d]\n", __func__, res);
+		}
+	}
+	
+	goto ERROR_REBOOT;
+	
+ERROR_REBOOT:
+	mip_reboot(info);
+	return 1;
+	
+DONE:
+	return 0;
+}
+
+/**
+* Enable device
+*/
+int mip_enable(struct mip_ts_info *info)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	
+	if (info->enabled){
+		dev_err(&info->client->dev, "%s [ERROR] device already enabled\n", __func__);
+		goto EXIT;
+	}
+
+#if MIP_USE_WAKEUP_GESTURE
+	mip_set_power_state(info, MIP_CTRL_POWER_ACTIVE);
+
+	if(wake_lock_active(&mip_wake_lock)){
+		wake_unlock(&mip_wake_lock);
+		dev_dbg(&info->client->dev, "%s - wake_unlock\n", __func__);
+	}
+	
+	info->nap_mode = false;
+	dev_dbg(&info->client->dev, "%s - nap mode : off\n", __func__);	
+#else	
+	mip_power_on(info);
+#endif
+
+#if 1
+	if(info->disable_esd == true){
+		//Disable ESD alert
+		mip_disable_esd_alert(info);
+	}	
+#endif
+
+	mutex_lock(&info->lock);
+
+	enable_irq(info->client->irq);
+	info->enabled = true;
+
+	mutex_unlock(&info->lock);
+	
+EXIT:
+	dev_info(&info->client->dev, MIP_DEVICE_NAME" - Enabled\n");
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+}
+
+/**
+* Disable device
+*/
+int mip_disable(struct mip_ts_info *info)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	
+	if (!info->enabled){
+		dev_err(&info->client->dev, "%s [ERROR] device already disabled\n", __func__);
+		goto EXIT;
+	}
+	
+	mip_clear_input(info);
+
+#if MIP_USE_WAKEUP_GESTURE
+	info->wakeup_gesture_code = 0;
+
+	mip_set_wakeup_gesture_type(info, MIP_EVENT_GESTURE_ALL);
+	mip_set_power_state(info, MIP_CTRL_POWER_LOW);
+	
+	info->nap_mode = true;
+	dev_dbg(&info->client->dev, "%s - nap mode : on\n", __func__);
+
+	if(!wake_lock_active(&mip_wake_lock)) {
+		wake_lock(&mip_wake_lock);
+		dev_dbg(&info->client->dev, "%s - wake_lock\n", __func__);
+	}
+#else
+	mutex_lock(&info->lock);
+
+	disable_irq(info->client->irq);
+	mip_power_off(info);
+
+	mutex_unlock(&info->lock);	
+#endif
+
+	info->enabled = false;
+
+EXIT:	
+	dev_info(&info->client->dev, MIP_DEVICE_NAME" - Disabled\n");
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+}
+
+#if MIP_USE_INPUT_OPEN_CLOSE
+/**
+* Open input device
+*/
+static int mip_input_open(struct input_dev *dev) 
+{
+	struct mip_ts_info *info = input_get_drvdata(dev);
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	if(info->init == true){
+		info->init = false;
+	} 
+	else{
+		mip_enable(info);
+	}
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	
+	return 0;
+}
+
+/**
+* Close input device
+*/
+static void mip_input_close(struct input_dev *dev) 
+{
+	struct mip_ts_info *info = input_get_drvdata(dev);
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	mip_disable(info);
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+
+	return;
+}
+#endif
+
+/**
+* Get ready status
+*/
+int mip_get_ready_status(struct mip_ts_info *info)
+{
+	u8 wbuf[16];
+	u8 rbuf[16];
+	int ret = 0;
+	
+	//dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	wbuf[0] = MIP_R0_CTRL;
+	wbuf[1] = MIP_R1_CTRL_READY_STATUS;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 1)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_read\n", __func__);
+		goto ERROR;
+	}
+	ret = rbuf[0];
+
+	//check status
+	if((ret == MIP_CTRL_STATUS_NONE) || (ret == MIP_CTRL_STATUS_LOG) || (ret == MIP_CTRL_STATUS_READY)){
+		//dev_dbg(&info->client->dev, "%s - status [0x%02X]\n", __func__, ret);
+	}
+	else{
+		dev_err(&info->client->dev, "%s [ERROR] Unknown status [0x%02X]\n", __func__, ret);
+		goto ERROR;
+	}
+
+	if(ret == MIP_CTRL_STATUS_LOG){
+		//skip log event
+		wbuf[0] = MIP_R0_LOG;
+		wbuf[1] = MIP_R1_LOG_TRIGGER;
+		wbuf[2] = 0;
+		if(mip_i2c_write(info, wbuf, 3)){
+			dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__);
+		}
+	}
+	
+	//dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return ret;
+	
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return -1;
+}
+
+/**
+* Read chip firmware version
+*/
+int mip_get_fw_version(struct mip_ts_info *info, u8 *ver_buf)
+{
+	u8 rbuf[8];
+	u8 wbuf[2];
+	int i;
+	
+	wbuf[0] = MIP_R0_INFO;
+	wbuf[1] = MIP_R1_INFO_VERSION_BOOT;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 8)){
+		goto ERROR;
+	};
+
+	for(i = 0; i < MIP_FW_MAX_SECT_NUM; i++){
+		ver_buf[0 + i * 2] = rbuf[1 + i * 2];
+		ver_buf[1 + i * 2] = rbuf[0 + i * 2];
+	}	
+	
+	return 0;
+
+ERROR:
+	//memset(ver_buf, 0xFF, sizeof(ver_buf));
+	
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return 1;	
+}
+
+/**
+* Read chip firmware version for u16
+*/
+int mip_get_fw_version_u16(struct mip_ts_info *info, u16 *ver_buf_u16)
+{
+	u8 rbuf[8];
+	int i;
+	
+	if(mip_get_fw_version(info, rbuf)){
+		goto ERROR;
+	}
+
+	for(i = 0; i < MIP_FW_MAX_SECT_NUM; i++){
+		ver_buf_u16[i] = (rbuf[0 + i * 2] << 8) | rbuf[1 + i * 2];
+	}	
+	
+	return 0;
+
+ERROR:
+	//memset(ver_buf_u16, 0xFFFF, sizeof(ver_buf_u16));
+	
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return 1;	
+}
+
+/**
+* Set power state
+*/
+int mip_set_power_state(struct mip_ts_info *info, u8 mode)
+{
+	u8 wbuf[3];
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	dev_dbg(&info->client->dev, "%s - mode[%02X]\n", __func__, mode);
+	
+	wbuf[0] = MIP_R0_CTRL;
+	wbuf[1] = MIP_R1_CTRL_POWER_STATE;
+	wbuf[2] = mode;
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__);
+		goto ERROR;
+	}	
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return 1;
+}
+
+/**
+* Set wake-up gesture type
+*/
+int mip_set_wakeup_gesture_type(struct mip_ts_info *info, u32 type)
+{
+	u8 wbuf[6];
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	dev_dbg(&info->client->dev, "%s - type[%08X]\n", __func__, type);
+	
+	wbuf[0] = MIP_R0_CTRL;
+	wbuf[1] = MIP_R1_CTRL_GESTURE_TYPE;
+	wbuf[2] = (type >> 24) & 0xFF;
+	wbuf[3] = (type >> 16) & 0xFF;
+	wbuf[4] = (type >> 8) & 0xFF;
+	wbuf[5] = type & 0xFF;
+	if(mip_i2c_write(info, wbuf, 6)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__);
+		goto ERROR;
+	}	
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return 1;
+}
+
+/**
+* Disable ESD alert
+*/
+int mip_disable_esd_alert(struct mip_ts_info *info)
+{
+	u8 wbuf[4];
+	u8 rbuf[4];
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	
+	wbuf[0] = MIP_R0_CTRL;
+	wbuf[1] = MIP_R1_CTRL_DISABLE_ESD_ALERT;
+	wbuf[2] = 1;
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__);
+		goto ERROR;
+	}	
+
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 1)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_read\n", __func__);
+		goto ERROR;
+	}	
+
+	if(rbuf[0] != 1){
+		dev_dbg(&info->client->dev, "%s [ERROR] failed\n", __func__);
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+	
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return 1;
+}
+
+/**
+* Alert event handler - ESD
+*/
+static int mip_alert_handler_esd(struct mip_ts_info *info, u8 *rbuf)
+{
+	//u8 frame_cnt = rbuf[2];
+	u8 frame_cnt = rbuf[1];
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	dev_dbg(&info->client->dev, "%s - frame_cnt[%d]\n", __func__, frame_cnt);
+
+	if(frame_cnt == 0){
+		//sensor crack, not ESD
+		info->esd_cnt++;
+		dev_dbg(&info->client->dev, "%s - esd_cnt[%d]\n", __func__, info->esd_cnt);
+
+		if(info->disable_esd == true){
+			mip_disable_esd_alert(info);
+			info->esd_cnt = 0;
+		}
+		else if(info->esd_cnt > ESD_COUNT_FOR_DISABLE){
+			//Disable ESD alert
+			if(mip_disable_esd_alert(info)){
+			}
+			else{
+				info->disable_esd = true;
+				info->esd_cnt = 0;
+			}
+		}
+		else{
+			//Reset chip
+			mip_reboot(info);
+		}
+	}
+	else{
+		//ESD detected
+		//Reset chip
+		mip_reboot(info);
+		info->esd_cnt = 0;
+	}
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+
+//ERROR:	
+	//dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	//return 1;
+}
+
+/**
+* Alert event handler - Wake-up
+*/
+static int mip_alert_handler_wakeup(struct mip_ts_info *info, u8 *rbuf)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	if(mip_wakeup_event_handler(info, rbuf)){
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+	
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return 1;
+}
+
+/**
+* Alert event handler - Input type
+*/
+static int mip_alert_handler_inputtype(struct mip_ts_info *info, u8 *rbuf)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	//?
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+	
+//ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return 1;
+}
+
+/**
+* Interrupt handler
+*/
+static irqreturn_t mip_interrupt(int irq, void *dev_id)
+{
+	struct mip_ts_info *info = dev_id;
+	struct i2c_client *client = info->client;
+	u8 wbuf[8];
+	u8 rbuf[256];
+	unsigned int size = 0;
+	//int event_size = info->event_size;
+	u8 category = 0;
+	u8 alert_type = 0;
+	
+	dev_dbg(&client->dev, "%s [START]\n", __func__);
+#if 0
+ 	//Read first packet
+	wbuf[0] = MIP_R0_EVENT;
+	wbuf[1] = MIP_R1_EVENT_PACKET_INFO;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, (1 + event_size))){
+		dev_err(&client->dev, "%s [ERROR] Read packet info\n", __func__);
+		goto ERROR;
+	}
+
+	//Check event
+	size = (rbuf[0] & 0x7F);	
+	category = ((rbuf[0] >> 7) & 0x1);
+	dev_dbg(&client->dev, "%s - packet info : size[%d] category[%d]\n", __func__, size, category);	
+
+	//Check size
+	if(size <= 0){
+		goto EXIT;
+	}
+	
+	if(category == 0){
+		//Touch event
+		if(size > event_size){
+			//Read next packet
+			wbuf[0] = MIP_R0_EVENT;
+			wbuf[1] = MIP_R1_EVENT_PACKET_INFO + (1 + event_size);
+			if(mip_i2c_read_next(info, wbuf, 2, rbuf, (1 + event_size), (size - event_size))){
+				dev_err(&client->dev, "%s [ERROR] Read next packet\n", __func__);
+				goto ERROR;
+			}
+		}
+		
+		info->esd_cnt = 0;
+		
+		mip_input_event_handler(info, size, rbuf);
+	}
+#else
+	//Read packet info
+	wbuf[0] = MIP_R0_EVENT;
+	wbuf[1] = MIP_R1_EVENT_PACKET_INFO;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 1)){
+		dev_err(&client->dev, "%s [ERROR] Read packet info\n", __func__);
+		goto ERROR;
+	}
+
+	size = (rbuf[0] & 0x7F);	
+	category = ((rbuf[0] >> 7) & 0x1);
+	dev_dbg(&client->dev, "%s - packet info : size[%d] category[%d]\n", __func__, size, category);	
+	
+	//Check size
+	if(size <= 0){
+		dev_err(&client->dev, "%s [ERROR] Packet size [%d]\n", __func__, size);
+		goto EXIT;
+	}
+
+	//Read packet data
+	wbuf[0] = MIP_R0_EVENT;
+	wbuf[1] = MIP_R1_EVENT_PACKET_DATA;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, size)){
+		dev_err(&client->dev, "%s [ERROR] Read packet data\n", __func__);
+		goto ERROR;
+	}
+
+	//Event handler
+	if(category == 0){
+		//Touch event
+		info->esd_cnt = 0;
+		
+		mip_input_event_handler(info, size, rbuf);
+	}
+#endif
+	else{
+		//Alert event
+		//alert_type = rbuf[1];
+		alert_type = rbuf[0];
+		
+		dev_dbg(&client->dev, "%s - alert type [%d]\n", __func__, alert_type);
+				
+		if(alert_type == MIP_ALERT_ESD){
+			//ESD detection
+			if(mip_alert_handler_esd(info, rbuf)){
+				goto ERROR;
+			}
+		}
+		else if(alert_type == MIP_ALERT_WAKEUP){
+			//Wake-up gesture
+			if(mip_alert_handler_wakeup(info, rbuf)){
+				goto ERROR;
+			}
+		}
+		else if(alert_type == MIP_ALERT_INPUTTYPE){
+			//Input type
+			if(mip_alert_handler_inputtype(info, rbuf)){
+				goto ERROR;
+			}
+		}
+		else{
+			dev_err(&client->dev, "%s [ERROR] Unknown alert type [%d]\n", __func__, alert_type);
+			goto ERROR;
+		}		
+	}
+
+EXIT:
+	dev_dbg(&client->dev, "%s [DONE]\n", __func__);
+	return IRQ_HANDLED;
+	
+ERROR:
+	if(RESET_ON_EVENT_ERROR){	
+		dev_info(&client->dev, "%s - Reset on error\n", __func__);
+		
+		mip_disable(info);
+		mip_clear_input(info);
+		mip_enable(info);
+	}
+
+	dev_err(&client->dev, "%s [ERROR]\n", __func__);
+	return IRQ_HANDLED;
+}
+
+/**
+* Update firmware from kernel built-in binary
+*/
+int mip_fw_update_from_kernel(struct mip_ts_info *info)
+{
+	const char *fw_name = info->pdata->fw_name;
+	const struct firmware *fw;
+	int retires = 3;
+	int ret;
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	//Disable IRQ	
+	mutex_lock(&info->lock);	
+	disable_irq(info->client->irq);
+
+	//Get firmware
+	request_firmware(&fw, fw_name, &info->client->dev);
+	
+	if (!fw) {
+		dev_err(&info->client->dev, "%s [ERROR] request_firmware\n", __func__);
+		enable_irq(info->client->irq);
+		mutex_unlock(&info->lock);
+		goto ERROR;
+	}
+
+	//Update fw
+	do {
+		ret = mip_flash_fw(info, fw->data, fw->size, false, true);
+		if(ret >= fw_err_none){
+			break;
+		}
+	} while (--retires);
+
+	if (!retires) {
+		dev_err(&info->client->dev, "%s [ERROR] mip_flash_fw failed\n", __func__);
+		ret = -1;
+	}
+	
+	release_firmware(fw);
+
+	//Enable IRQ
+	enable_irq(info->client->irq);	
+	mutex_unlock(&info->lock);
+
+	if(ret < 0){
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return -1;
+}
+
+/**
+* Update firmware from external storage
+*/
+int mip_fw_update_from_storage(struct mip_ts_info *info, char *path, bool force)
+{
+	struct file *fp; 
+	mm_segment_t old_fs;
+	size_t fw_size, nread;
+	int ret = 0;
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	//Disable IRQ
+	mutex_lock(&info->lock);	
+ 	disable_irq(info->client->irq);
+
+	//Get firmware
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);  
+
+	//fp = filp_open(EXTERNAL_FW_PATH, O_RDONLY, S_IRUSR);
+	fp = filp_open(path, O_RDONLY, S_IRUSR);
+	if (IS_ERR(fp)) {
+		dev_err(&info->client->dev, "%s [ERROR] file_open - path[%s]\n", __func__, path);
+		ret = fw_err_file_open;
+		goto ERROR;
+	}
+	
+ 	fw_size = fp->f_path.dentry->d_inode->i_size;
+	if (0 < fw_size) {
+		//Read firmware
+		unsigned char *fw_data;
+		fw_data = kzalloc(fw_size, GFP_KERNEL);
+		nread = vfs_read(fp, (char __user *)fw_data, fw_size, &fp->f_pos);
+		dev_dbg(&info->client->dev, "%s - path[%s] size[%u]\n", __func__, path,
+				(unsigned int)fw_size);
+		
+		if (nread != fw_size) {
+			dev_err(&info->client->dev, "%s [ERROR] vfs_read - size[%d] read[%d]\n",
+					__func__, (int)fw_size, (int)nread);
+			ret = fw_err_file_read;
+		}
+		else{
+			//Update firmware
+			ret = mip_flash_fw(info, fw_data, fw_size, force, true);
+		}
+		
+		kfree(fw_data);
+	}
+	else{
+		dev_err(&info->client->dev, "%s [ERROR] fw_size [%d]\n", __func__,
+				(int)fw_size);
+		ret = fw_err_file_read;
+	}
+	
+ 	filp_close(fp, current->files);
+
+ERROR:
+	set_fs(old_fs);	
+
+	//Enable IRQ
+	enable_irq(info->client->irq);	
+	mutex_unlock(&info->lock);
+
+	if(ret == 0){
+		dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	}
+	else{
+		dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	}
+	
+	return ret;
+}
+
+static ssize_t mip_sys_fw_update(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mip_ts_info *info = i2c_get_clientdata(client);
+	int result = 0;
+	u8 data[255];
+	int ret = 0;
+	
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	ret = mip_fw_update_from_storage(info, info->fw_path_ext, true);
+	
+	switch(ret){
+		case fw_err_none:
+			sprintf(data, "F/W update success.\n");
+			break;
+		case fw_err_uptodate:
+			sprintf(data, "F/W is already up-to-date.\n");
+			break;
+		case fw_err_download:
+			sprintf(data, "F/W update failed : Download error\n");
+			break;
+		case fw_err_file_type:
+			sprintf(data, "F/W update failed : File type error\n");
+			break;
+		case fw_err_file_open:			
+			sprintf(data, "F/W update failed : File open error [%s]\n", info->fw_path_ext);
+			break;
+		case fw_err_file_read:
+			sprintf(data, "F/W update failed : File read error\n");
+			break;
+		default:
+			sprintf(data, "F/W update failed.\n");
+			break;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	
+	strcat(info->print_buf, data);
+	result = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return result;
+}
+static DEVICE_ATTR(fw_update, 0666, mip_sys_fw_update, NULL);
+
+/**
+* Sysfs attr info
+*/
+static struct attribute *mip_attrs[] = {
+	&dev_attr_fw_update.attr,
+	NULL,
+};
+
+/**
+* Sysfs attr group info
+*/
+static const struct attribute_group mip_attr_group = {
+	.attrs = mip_attrs,
+};
+
+/**
+* Initial config
+*/
+static int mip_init_config(struct mip_ts_info *info)
+{
+	u8 wbuf[8];
+	u8 rbuf[64];
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	//Product name
+	wbuf[0] = MIP_R0_INFO;
+	wbuf[1] = MIP_R1_INFO_PRODUCT_NAME;
+	mip_i2c_read(info, wbuf, 2, rbuf, 16);
+	memcpy(info->product_name, rbuf, 16);
+	dev_dbg(&info->client->dev, "%s - product_name[%s]\n", __func__, info->product_name);
+
+	//Firmware version
+	mip_get_fw_version(info, rbuf);
+	memcpy(info->fw_version, rbuf, 8);
+	dev_info(&info->client->dev, "%s - F/W Version : %02X.%02X %02X.%02X %02X.%02X %02X.%02X\n", __func__, info->fw_version[0], info->fw_version[1], info->fw_version[2], info->fw_version[3], info->fw_version[4], info->fw_version[5], info->fw_version[6], info->fw_version[7]);	
+
+	//Resolution
+	wbuf[0] = MIP_R0_INFO;
+	wbuf[1] = MIP_R1_INFO_RESOLUTION_X;
+	mip_i2c_read(info, wbuf, 2, rbuf, 7);
+
+#if MIP_AUTOSET_RESOLUTION
+	//Set resolution using chip info
+	info->max_x = (rbuf[0]) | (rbuf[1] << 8);
+	info->max_y = (rbuf[2]) | (rbuf[3] << 8);
+#else
+	//Set resolution using platform data
+	info->max_x = info->pdata->max_x;
+	info->max_y = info->pdata->max_y;
+#endif
+	dev_dbg(&info->client->dev, "%s - max_x[%d] max_y[%d]\n", __func__, info->max_x, info->max_y);
+
+	//Node info
+	info->node_x = rbuf[4];
+	info->node_y = rbuf[5];
+	info->node_key = rbuf[6];
+	dev_dbg(&info->client->dev, "%s - node_x[%d] node_y[%d] node_key[%d]\n", __func__, info->node_x, info->node_y, info->node_key);
+
+	//Key info
+	if(info->node_key > 0){
+		//Enable touchkey
+		info->key_enable = true;
+		info->key_num = info->node_key;
+	}
+
+	//Protocol
+#if MIP_AUTOSET_EVENT_FORMAT
+	wbuf[0] = MIP_R0_EVENT;
+	wbuf[1] = MIP_R1_EVENT_SUPPORTED_FUNC;
+	mip_i2c_read(info, wbuf, 2, rbuf, 7);
+	info->event_format = (rbuf[4]) | (rbuf[5] << 8);
+	info->event_size = rbuf[6];
+#else
+	info->event_format = 0;
+	info->event_size = 6;
+#endif
+	dev_dbg(&info->client->dev, "%s - event_format[%d] event_size[%d] \n", __func__, info->event_format, info->event_size);
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+	
+//ERROR:
+	//dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	//return 1;
+}
+
+/**
+* Initialize driver
+*/
+static int mip_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct mip_ts_info *info;
+	struct input_dev *input_dev;
+	int ret = 0;	
+	
+	dev_dbg(&client->dev, "%s [START]\n", __func__);
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)){
+		dev_err(&client->dev, "%s [ERROR] i2c_check_functionality\n", __func__);		
+		ret = -EIO;
+		goto ERROR;
+	}
+
+	//Init info data
+	info = kzalloc(sizeof(struct mip_ts_info), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!info || !input_dev) {
+		dev_err(&client->dev, "%s [ERROR]\n", __func__);
+		ret = -ENOMEM;
+		goto ERROR;
+	}
+
+	class_ts_info = info;
+	info->client = client;
+	info->input_dev = input_dev;
+	info->irq = -1;
+	info->init = true;
+	info->power = -1;
+	info->fw_path_ext = kstrdup(FW_PATH_EXTERNAL, GFP_KERNEL);
+	
+	mutex_init(&info->lock);
+
+	//Get platform data
+#if MIP_USE_DEVICETREE
+	if (client->dev.of_node) {
+		info->pdata  = devm_kzalloc(&client->dev, sizeof(struct melfas_platform_data), GFP_KERNEL);
+		if (!info->pdata) {
+			dev_err(&client->dev, "%s [ERROR] pdata devm_kzalloc\n", __func__);
+			//goto error_platform_data;
+		}
+
+		ret = mip_parse_devicetree(&client->dev, info);
+		if (ret){
+			dev_err(&client->dev, "%s [ERROR] mip_parse_dt\n", __func__);
+			goto ERROR;
+		}
+	} else
+#endif
+	{
+		info->pdata = client->dev.platform_data;
+		if (info->pdata == NULL) {
+			dev_err(&client->dev, "%s [ERROR] pdata is null\n", __func__);
+			ret = -EINVAL;
+			goto ERROR;
+		}
+	}
+
+	//Init input device
+	info->input_dev->name = "MELFAS_" CHIP_NAME "_Touchscreen";
+	snprintf(info->phys, sizeof(info->phys), "%s/input1", info->input_dev->name);
+	
+	info->input_dev->phys = info->phys;
+	info->input_dev->id.bustype = BUS_I2C;
+	info->input_dev->dev.parent = &client->dev;
+	
+#if MIP_USE_INPUT_OPEN_CLOSE	
+	info->input_dev->open = mip_input_open;
+	info->input_dev->close = mip_input_close;
+#endif
+     //set input event buffer size
+	input_set_events_per_packet(input_dev, 200); 
+	//Create device
+	input_set_drvdata(input_dev, info);
+	i2c_set_clientdata(client, info);
+
+	ret = input_register_device(input_dev);
+	if (ret) {
+		dev_err(&client->dev, "%s [ERROR] input_register_device\n", __func__);
+		ret = -EIO;
+		goto ERROR;
+	}
+	//dev_dbg(&client->dev, "%s - input_register_device\n", __func__);
+
+	//Power on
+	mip_power_on(info);
+
+	//Firmware update
+#if MIP_USE_AUTO_FW_UPDATE
+	/*	
+	info->fw_name = kstrdup(INTERNAL_FW_PATH, GFP_KERNEL);
+	ret = request_firmware_nowait(THIS_MODULE, true, fw_name, &client->dev, GFP_KERNEL, info, mip_fw_update_boot);
+	if (ret) {
+		dev_err(&client->dev, "%s [ERROR] request_firmware_nowait\n", __func__);
+		ret = -EIO;
+		//goto ERROR;	
+	}
+	*/
+	ret = mip_fw_update_from_kernel(info);
+	if(ret){
+		dev_err(&client->dev, "%s [ERROR] mip_fw_update_from_kernel\n", __func__);
+	}
+#endif
+
+	//Initial config
+	mip_init_config(info);
+
+	//Config input interface	
+	mip_config_input(info);
+
+#if MIP_USE_CALLBACK
+	//Config callback functions
+	mip_config_callback(info);
+#endif
+
+	//Set interrupt handler	
+	ret = request_threaded_irq(client->irq, NULL, mip_interrupt, IRQF_TRIGGER_LOW | IRQF_ONESHOT, MIP_DEVICE_NAME, info);
+	//ret = request_threaded_irq(client->irq, NULL, mip_interrupt, IRQF_TRIGGER_FALLING | IRQF_ONESHOT, MIP_DEVICE_NAME, info);
+	if (ret) {
+		dev_err(&client->dev, "%s [ERROR] request_threaded_irq\n", __func__);
+		goto ERROR;
+	}
+
+	disable_irq(client->irq);
+	info->irq = client->irq;
+
+#if MIP_USE_WAKEUP_GESTURE
+	//Wake-lock for wake-up gesture mode
+	wake_lock_init(&mip_wake_lock, WAKE_LOCK_SUSPEND, "mip_wake_lock");
+#endif
+
+#if defined(CONFIG_FB)
+	info->fb_notif.notifier_call = fb_notifier_callback;
+	ret = fb_register_client(&info->fb_notif);
+	if (ret)
+		dev_err(&client->dev, "Unable to register fb_notifier: %d\n",
+			ret);
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	info->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN +1;
+	info->early_suspend.suspend = mip_early_suspend;
+	info->early_suspend.resume = mip_late_resume;       
+	register_early_suspend(&info->early_suspend);       
+	dev_dbg(&client->dev, "%s - register_early_suspend\n", __func__);
+
+#endif
+	//Enable device
+	mip_enable(info);
+
+#if MIP_USE_DEV
+	//Create dev node (optional)
+	if(mip_dev_create(info)){
+		dev_err(&client->dev, "%s [ERROR] mip_dev_create\n", __func__);
+		ret = -EAGAIN;
+		goto ERROR;
+	}	
+
+	//Create dev
+	info->class = class_create(THIS_MODULE, MIP_DEVICE_NAME);
+	device_create(info->class, NULL, info->mip_dev, NULL, MIP_DEVICE_NAME);
+#endif
+
+#if MIP_USE_SYS
+	//Create sysfs for test mode (optional)
+	if (mip_sysfs_create(info)){
+		dev_err(&client->dev, "%s [ERROR] mip_sysfs_create\n", __func__);
+		ret = -EAGAIN;
+		goto ERROR;
+	}
+#endif
+
+#if MIP_USE_CMD
+	//Create sysfs for command mode (optional)
+	if (mip_sysfs_cmd_create(info)){
+		dev_err(&client->dev, "%s [ERROR] mip_sysfs_cmd_create\n", __func__);
+		ret = -EAGAIN;
+		goto ERROR;
+	}
+#endif
+	
+	//Create sysfs
+	if (sysfs_create_group(&client->dev.kobj, &mip_attr_group)) {
+		dev_err(&client->dev, "%s [ERROR] sysfs_create_group\n", __func__);
+		ret = -EAGAIN;
+		goto ERROR;
+	}
+
+	if (sysfs_create_link(NULL, &client->dev.kobj, MIP_DEVICE_NAME)) {
+		dev_err(&client->dev, "%s [ERROR] sysfs_create_link\n", __func__);
+		ret = -EAGAIN;
+		goto ERROR;
+	}
+
+	touchscreen_class = class_create(THIS_MODULE, "touchscreen");
+	if (IS_ERR(touchscreen_class)) {
+		pr_err("%s: create class error!\n", __func__);
+		goto END;
+	}
+
+	ret = class_create_file(touchscreen_class, &class_attr_ts_info);
+	if (ret < 0) {
+		pr_err("%s class_create_file failed!\n", __func__);
+	}
+
+	ret = class_create_file(touchscreen_class, &class_attr_ts_version);
+	if (ret < 0) {
+		pr_err("%s class_create_file failed!\n", __func__);
+	}
+
+	dev_dbg(&client->dev, "%s [DONE]\n", __func__);
+	dev_info(&client->dev, "MELFAS " CHIP_NAME " Touchscreen is initialized successfully.\n");	
+	return 0;
+
+END:
+	dev_dbg(&client->dev, "%s [DONE]\n", __func__);
+	dev_info(&client->dev, "MELFAS " CHIP_NAME " Touchscreen is initialized "
+			"successfully.\n");
+	return 0;
+
+ERROR:
+	dev_dbg(&client->dev, "%s [ERROR]\n", __func__);
+	dev_err(&client->dev, "MELFAS " CHIP_NAME " Touchscreen initialization failed.\n");	
+	return ret;
+}
+
+/**
+* Remove driver
+*/
+static int mip_remove(struct i2c_client *client)
+{
+	struct mip_ts_info *info = i2c_get_clientdata(client);
+
+	if (info->irq >= 0){
+		free_irq(info->irq, info);
+	}
+
+#if MIP_USE_CMD
+	mip_sysfs_cmd_remove(info);
+#endif
+
+#if MIP_USE_SYS
+	mip_sysfs_remove(info);
+#endif
+
+	sysfs_remove_group(&info->client->dev.kobj, &mip_attr_group);
+	sysfs_remove_link(NULL, MIP_DEVICE_NAME);
+	kfree(info->print_buf);
+
+#if MIP_USE_DEV
+	device_destroy(info->class, info->mip_dev);
+	class_destroy(info->class);
+#endif
+#if defined(CONFIG_FB)
+	if (fb_unregister_client(&info->fb_notif))
+		dev_err(&client->dev,
+		"Error occurred while unregistering fb_notifier.\n");
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	unregister_early_suspend(&info->early_suspend);
+#endif
+
+	input_unregister_device(info->input_dev);
+	kfree(info->fw_name);
+	kfree(info);
+
+	return 0;
+}
+
+#if defined(CONFIG_FB) || defined(CONFIG_HAS_EARLYSUSPEND)
+/**
+* Device suspend event handler
+*/
+int mip_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mip_ts_info *info = i2c_get_clientdata(client);
+	dev_dbg(&client->dev, "%s [START]\n", __func__);	
+	mip_disable(info);	
+	dev_dbg(&client->dev, "%s [DONE]\n", __func__);
+
+	return 0;
+
+}
+
+/**
+* Device resume event handler
+*/
+int mip_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mip_ts_info *info = i2c_get_clientdata(client);
+	int ret = 0;
+
+	dev_dbg(&client->dev, "%s [START]\n", __func__);
+	mip_clear_input(info);
+	mip_enable(info);
+
+	dev_dbg(&client->dev, "%s [DONE]\n", __func__);
+
+	return ret;
+}
+#if defined(CONFIG_FB)
+int fb_notifier_callback(struct notifier_block *self,
+				 unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	int *blank;
+	struct mip_ts_info *mip_info =
+		container_of(self, struct mip_ts_info, fb_notif);
+
+	if (evdata && evdata->data && event == FB_EARLY_EVENT_BLANK &&
+			mip_info && mip_info->client) {
+		blank = evdata->data;
+		if (*blank == FB_BLANK_UNBLANK)
+			mip_resume(&mip_info->client->dev);
+		else if (*blank == FB_BLANK_POWERDOWN)
+			mip_suspend(&mip_info->client->dev);
+	}
+
+	return 0; 
+}
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+/**
+* Early suspend handler
+*/
+void mip_early_suspend(struct early_suspend *h)
+{
+	struct mip_ts_info *info = container_of(h, struct mip_ts_info, early_suspend);
+	
+	mip_suspend(&info->client->dev);
+}
+
+/**
+* Late resume handler
+*/
+void mip_late_resume(struct early_suspend *h)
+{
+	struct mip_ts_info *info = container_of(h, struct mip_ts_info, early_suspend);
+
+	mip_resume(&info->client->dev);
+}
+#endif
+#endif
+#if (!defined(CONFIG_FB) && !defined(CONFIG_HAS_EARLYSUSPEND))
+/**
+* PM info
+*/
+const struct dev_pm_ops mip_pm_ops = {
+#if 0
+ 	SET_SYSTEM_SLEEP_PM_OPS(mip_suspend, mip_resume)
+#else
+
+	.suspend	= mip_suspend,
+	.resume = mip_resume,
+#endif
+};
+
+#else 
+const struct dev_pm_ops mip_pm_ops = {
+};
+#endif
+
+#if MIP_USE_DEVICETREE
+/**
+* Device tree match table
+*/
+static const struct of_device_id mip_match_table[] = {
+	{ .compatible = "melfas,"MIP_DEVICE_NAME,},
+	{},
+};
+MODULE_DEVICE_TABLE(of, mip_match_table);
+#endif
+
+/**
+* I2C Device ID
+*/
+static const struct i2c_device_id mip_id[] = {
+	{MIP_DEVICE_NAME, 0},
+};
+MODULE_DEVICE_TABLE(i2c, mip_id);
+
+/**
+* I2C driver info
+*/
+static struct i2c_driver mip_driver = {
+	.id_table = mip_id,
+	.probe = mip_probe,
+	.remove = mip_remove,
+	.driver = {
+		.name = MIP_DEVICE_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = mip_match_table,
+#if defined(CONFIG_PM) && !defined(CONFIG_HAS_EARLYSUSPEND)
+		.pm 	= &mip_pm_ops,
+#endif
+	},
+};
+
+/**
+* Init driver
+*/
+static int __init mip_init(void)
+{	
+	return i2c_add_driver(&mip_driver);
+}
+
+/**
+* Exit driver
+*/
+static void __exit mip_exit(void)
+{
+	i2c_del_driver(&mip_driver);
+}
+
+module_init(mip_init);
+module_exit(mip_exit);
+
+MODULE_DESCRIPTION("MELFAS MIP4 Touchscreen");
+MODULE_VERSION("2015.05.08");
+MODULE_AUTHOR("Jee, SangWon <jeesw@melfas.com>");
+MODULE_LICENSE("GPL"); 
+
diff --git a/drivers/input/touchscreen/melfas_mip4_test/mip4.h b/drivers/input/touchscreen/melfas_mip4_test/mip4.h
new file mode 100755
index 00000000000..f678e2be1fc
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_test/mip4.h
@@ -0,0 +1,373 @@
+/*
+ * MELFAS MIP4 Touchscreen
+ *
+ * Copyright (C) 2015 MELFAS Inc.
+ *
+ *
+ * mip4.h : Main header
+ *
+ */
+
+//Config debug msg : Must be disabled for production builds
+//Include
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/kobject.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/firmware.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/fs.h>
+#include <linux/sysfs.h>
+#include <linux/debugfs.h>
+#include <linux/cdev.h>
+#include <linux/err.h>
+#include <linux/limits.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/gpio_event.h>
+#include <linux/wakelock.h>
+#include <asm/uaccess.h>
+#include <linux/regulator/consumer.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+//Include platform data
+#include <linux/platform_data/melfas_mip4.h>
+
+//Include register map
+#include "mip4_reg.h"
+//Chip info
+#ifdef CONFIG_TOUCHSCREEN_MELFAS_MMS438
+#define CHIP_MMS438
+#define CHIP_NAME		"MMS438"
+#define CHIP_FW_CODE	"M4H0"
+#define FW_UPDATE_TYPE	"MMS438"
+#endif
+#ifdef CONFIG_TOUCHSCREEN_MELFAS_MMS449
+#define CHIP_MMS449
+#define CHIP_NAME		"MMS449"
+#define CHIP_FW_CODE	"M4HP"
+#define FW_UPDATE_TYPE	"MMS438"
+#endif
+#ifdef CONFIG_TOUCHSCREEN_MELFAS_MMS458
+#define CHIP_MMS458
+#define CHIP_NAME		"MMS458"
+#define CHIP_FW_CODE	"M4HN"
+#define FW_UPDATE_TYPE	"MMS438"
+#endif
+#ifdef CONFIG_TOUCHSCREEN_MELFAS_MMS492
+#define CHIP_MMS492
+#define CHIP_NAME		"MMS492"
+#define CHIP_FW_CODE	"M4HL"
+#define FW_UPDATE_TYPE	"MMS492"
+#endif
+#ifdef CONFIG_TOUCHSCREEN_MELFAS_MIT300
+#define CHIP_MIT300
+#define CHIP_NAME		"MIT300"
+#define CHIP_FW_CODE	"T3H0"
+#define FW_UPDATE_TYPE	"MIT300"
+#endif
+
+//Config driver
+#define MIP_USE_INPUT_OPEN_CLOSE		0	// 0 (defualt) or 1
+#define MIP_AUTOSET_RESOLUTION		1	// 0 or 1 (defualt)
+#define MIP_AUTOSET_EVENT_FORMAT		1	// 0 or 1 (defualt)
+#define I2C_RETRY_COUNT				3	// 2~
+#define RESET_ON_EVENT_ERROR			0	// 0 (defualt) or 1
+#define ESD_COUNT_FOR_DISABLE		7	// 7~
+#define INPUT_SYNC_TYPE				0	// 0 (defualt) or 1
+
+//Driver features
+#define MIP_USE_DEV			1	// 0 or 1 (defualt) : Optional - Required for development
+#define MIP_USE_SYS			1	// 0 or 1 (defualt) : Optional - Required for development
+#define MIP_USE_CMD			0	// 0 (defualt) or 1 : Optional
+
+//Module features
+#define MIP_USE_WAKEUP_GESTURE	0	// 0 (defualt) or 1
+
+//Input value
+#define MAX_FINGER_NUM 			10
+#define MAX_KEY_NUM				3
+#define INPUT_PRESSURE_MIN 		0
+#define INPUT_PRESSURE_MAX 		255
+#define INPUT_TOUCH_MAJOR_MIN 	0
+#define INPUT_TOUCH_MAJOR_MAX 	255
+#define INPUT_TOUCH_MINOR_MIN 	0
+#define INPUT_TOUCH_MINOR_MAX 	255
+#define INPUT_ANGLE_MIN 			0
+#define INPUT_ANGLE_MAX 			255
+#define INPUT_PALM_MIN 			0
+#define INPUT_PALM_MAX 			1
+
+//Firmware update
+#define FW_PATH_INTERNAL			"melfas/melfas_mip4.bin"	//path of firmware included in the kernel image (/firmware)
+#define FW_PATH_EXTERNAL			"/sdcard/melfas_mip4.mfsb"	//path of firmware in external storage
+#define MIP_USE_AUTO_FW_UPDATE	0	// 0 or 1
+#define MIP_FW_MAX_SECT_NUM		4
+#define MIP_FW_UPDATE_DEBUG		0	// 0 (defualt) or 1
+#define MIP_FW_UPDATE_SECTION  	1	// 0 (defualt) or 1
+#define MIP_EXT_FW_FORCE_UPDATE	1	// 0 or 1 (defualt)
+
+//Command function
+#if MIP_USE_CMD
+#define CMD_LEN 					32
+#define CMD_RESULT_LEN 			512
+#define CMD_PARAM_NUM 			8
+#endif
+
+#if MIP_USE_CALLBACK
+//Callback functions
+struct mip_callbacks {
+	void (*inform_charger) (struct mip_callbacks *, int);
+	//void (*inform_display) (struct mip_callbacks *, int);
+	//...
+};
+
+extern struct mip_callbacks *mip_inform_callbacks;
+#endif
+
+/**
+* Device info structure
+*/
+struct mip_ts_info {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	char phys[32];
+
+	struct melfas_platform_data *pdata;
+
+	dev_t mip_dev;
+	struct class *class;
+	
+	struct mutex lock;
+	struct mutex lock_test;
+	struct mutex lock_cmd;
+	struct mutex lock_dev;
+#if defined(CONFIG_FB)
+	struct notifier_block fb_notif;
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	struct early_suspend early_suspend;
+#endif
+	
+	int irq;
+	bool enabled;
+	int power;
+	bool init;	
+	char *fw_name;
+	char *fw_path_ext;
+		
+	u8 product_name[16];
+	int max_x;
+	int max_y;
+	u8 node_x;
+	u8 node_y;
+	u8 node_key;
+	u8 fw_version[8];
+	
+	u8 event_size;
+	int event_format;
+
+	bool key_enable;
+	int key_num;
+	int key_code[MAX_KEY_NUM];
+	
+	u8 nap_mode;
+	u8 glove_mode;
+	u8 charger_mode;
+	u8 cover_mode;
+	
+	u8 esd_cnt;
+	bool disable_esd;
+	u8 wakeup_gesture_code;
+	
+	u8 *print_buf;	
+	int *image_buf;
+	
+	bool test_busy;
+	bool cmd_busy;
+	bool dev_busy;
+
+#if MIP_USE_CMD
+	dev_t cmd_dev_t;
+	struct device *cmd_dev;
+	struct class *cmd_class;
+	struct list_head cmd_list_head;
+	u8 cmd_state;
+	char cmd[CMD_LEN];
+	char cmd_result[CMD_RESULT_LEN];
+	int cmd_param[CMD_PARAM_NUM];
+	int cmd_buffer_size;
+	struct device *key_dev;
+#endif	
+
+#if MIP_USE_DEV
+	struct cdev cdev;
+	u8 *dev_fs_buf;
+#endif	
+
+#if MIP_USE_CALLBACK
+	void (*register_callback)(void *);
+	struct mip_callbacks callbacks;
+#endif
+
+};
+
+/**
+* Firmware binary header 
+*/
+struct mip_bin_hdr {
+	char tag[8];
+	u16	core_version;
+	u16	section_num;
+	u16	contains_full_binary;
+	u16	reserved0;
+
+	u32	binary_offset;
+	u32	binary_length;	
+	u32	extention_offset;	
+	u32	reserved1;
+} __attribute__ ((packed));
+
+/**
+* Firmware image info
+*/
+struct mip_fw_img {
+	u16	type;
+	u16	version;
+	u16	start_page;
+	u16	end_page;
+
+	u32	offset;
+	u32	length;
+} __attribute__ ((packed));
+
+/**
+* Firmware binary tail info
+*/
+struct mip_bin_tail {
+	u8 tail_mark[4];
+	char chip_name[4];
+	u32 bin_start_addr;
+	u32 bin_length;
+
+	u16 ver_boot;
+	u16 ver_core;
+	u16 ver_app;
+	u16 ver_param;
+	u8 boot_start;
+	u8 boot_end;
+	u8 core_start;
+	u8 core_end;
+	u8 app_start;
+	u8 app_end;
+	u8 param_start;
+	u8 param_end;
+
+	u8 checksum_type;
+	u8 hw_category;
+	u16 param_id;
+	u32 param_length;
+	u32 build_date;
+	u32 build_time;
+	
+	u32 reserved1;
+	u32 reserved2;
+	u16 reserved3;
+	u16 tail_size;
+	u32 crc;
+} __attribute__ ((packed));
+
+#define MIP_BIN_TAIL_MARK		{0x4D, 0x42, 0x54, 0x01}	// M B T 0x01
+#define MIP_BIN_TAIL_SIZE		64
+
+/**
+* Firmware update error code
+*/
+enum fw_update_errno{
+	fw_err_file_read = -4,
+	fw_err_file_open = -3,
+	fw_err_file_type = -2,
+	fw_err_download = -1,
+	fw_err_none = 0,
+	fw_err_uptodate = 1,
+};
+
+/**
+* Function declarations
+*/
+//main
+void mip_reboot(struct mip_ts_info *info);
+int mip_i2c_read(struct mip_ts_info *info, char *write_buf, unsigned int write_len, char *read_buf, unsigned int read_len);
+int mip_i2c_read_next(struct mip_ts_info *info, char *write_buf, unsigned int write_len, char *read_buf, int start_idx, unsigned int read_len);
+int mip_i2c_write(struct mip_ts_info *info, char *write_buf, unsigned int write_len);
+int mip_enable(struct mip_ts_info *info);
+int mip_disable(struct mip_ts_info *info);
+int mip_get_ready_status(struct mip_ts_info *info);
+int mip_get_fw_version(struct mip_ts_info *info, u8 *ver_buf);
+int mip_get_fw_version_u16(struct mip_ts_info *info, u16 *ver_buf_u16);
+int mip_set_power_state(struct mip_ts_info *info, u8 mode);
+int mip_set_wakeup_gesture_type(struct mip_ts_info *info, u32 type);
+int mip_disable_esd_alert(struct mip_ts_info *info);
+int mip_fw_update_from_kernel(struct mip_ts_info *info);
+int mip_fw_update_from_storage(struct mip_ts_info *info, char *path, bool force);
+int mip_suspend(struct device *dev);
+int mip_resume(struct device *dev);
+int fb_notifier_callback(struct notifier_block *self,
+				unsigned long event, void *data);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void mip_early_suspend(struct early_suspend *h);
+void mip_late_resume(struct early_suspend *h);
+#endif
+
+//mod
+int mip_regulator_control(struct mip_ts_info *info, int enable);
+int mip_power_on(struct mip_ts_info *info);
+int mip_power_off(struct mip_ts_info *info);
+void mip_clear_input(struct mip_ts_info *info);
+int mip_wakeup_event_handler(struct mip_ts_info *info, u8 *rbuf);
+void mip_input_event_handler(struct mip_ts_info *info, u8 sz, u8 *buf);
+#if MIP_USE_DEVICETREE
+int mip_parse_devicetree(struct device *dev, struct mip_ts_info *info);
+#endif
+void mip_config_input(struct mip_ts_info *info);
+#if MIP_USE_CALLBACK
+void mip_config_callback(struct mip_ts_info *info);
+#endif
+
+//fw
+int mip_flash_fw(struct mip_ts_info *info, const u8 *fw_data, size_t fw_size, bool force, bool section);
+
+//debug
+#if MIP_USE_DEV
+int mip_dev_create(struct mip_ts_info *info);
+int mip_get_log(struct mip_ts_info *info);
+#endif
+#if MIP_USE_SYS || MIP_USE_CMD
+int mip_run_test(struct mip_ts_info *info, u8 test_type);
+int mip_get_image(struct mip_ts_info *info, u8 image_type);
+#endif
+#if MIP_USE_SYS
+int mip_sysfs_create(struct mip_ts_info *info);
+void mip_sysfs_remove(struct mip_ts_info *info);
+static const struct attribute_group mip_test_attr_group;
+#endif
+
+//cmd
+#if MIP_USE_CMD
+int mip_sysfs_cmd_create(struct mip_ts_info *info);
+void mip_sysfs_cmd_remove(struct mip_ts_info *info);
+static const struct attribute_group mip_cmd_attr_group;
+#endif
+
+
diff --git a/drivers/input/touchscreen/melfas_mip4_test/mip4_debug.c b/drivers/input/touchscreen/melfas_mip4_test/mip4_debug.c
new file mode 100755
index 00000000000..9bc2629bac7
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_test/mip4_debug.c
@@ -0,0 +1,1300 @@
+/*
+ * MELFAS MIP4 Touchscreen
+ *
+ * Copyright (C) 2015 MELFAS Inc.
+ *
+ *
+ * mip4_debug.c : Debug functions (Optional)
+ *
+ */
+ 
+#include "mip4.h"
+
+#if MIP_USE_DEV
+
+/**
+* Dev node output to user
+*/
+static ssize_t mip_dev_fs_read(struct file *fp, char *rbuf, size_t cnt, loff_t *fpos)
+{
+	struct mip_ts_info *info = fp->private_data;
+	int ret = 0;
+
+	//dev_dbg(&info->client->dev, "%s [START]\n", __func__); 
+
+	ret = copy_to_user(rbuf, info->dev_fs_buf, cnt);
+	
+	//dev_dbg(&info->client->dev, "%s [DONE]\n", __func__); 
+
+	return ret;
+}
+
+/**
+* Dev node input from user
+*/
+static ssize_t mip_dev_fs_write(struct file *fp, const char *wbuf, size_t cnt, loff_t *fpos)
+{
+	struct mip_ts_info *info = fp->private_data;
+	u8 *buf;
+	int ret = 0;
+	int cmd = 0;
+	
+	//dev_dbg(&info->client->dev, "%s [START]\n", __func__); 
+
+	buf = kzalloc(cnt + 1, GFP_KERNEL);
+
+	if ((buf == NULL) || copy_from_user(buf, wbuf, cnt)) {
+		dev_err(&info->client->dev, "%s [ERROR] copy_from_user\n", __func__);
+		ret = -EIO;
+		goto EXIT;
+	}
+
+	cmd = buf[cnt - 1];
+
+	if(cmd == 1){
+		//dev_dbg(&info->client->dev, "%s - cmd[%d] w_len[%d] r_len[%d]\n", __func__, cmd, (cnt - 2), buf[cnt - 2]); 
+		
+		if(mip_i2c_read(info, buf, (cnt - 2), info->dev_fs_buf, buf[cnt - 2])){
+			dev_err(&info->client->dev, "%s [ERROR] mip_i2c_read\n", __func__);
+		}		
+		//print_hex_dump(KERN_ERR, MIP_DEVICE_NAME" : input ", DUMP_PREFIX_OFFSET, 16, 1, wbuf, cnt, false);
+		//print_hex_dump(KERN_ERR, MIP_DEVICE_NAME" : output ", DUMP_PREFIX_OFFSET, 16, 1, info->dev_fs_buf, buf[cnt - 2], false);
+	}
+	else if(cmd == 2){
+		//dev_dbg(&info->client->dev, "%s - cmd[%d] w_len[%d]\n", __func__, cmd, (cnt - 1)); 
+		if(mip_i2c_write(info, buf, (cnt - 1))){
+			dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__);
+		}
+		//print_hex_dump(KERN_ERR, MIP_DEVICE_NAME" : input ", DUMP_PREFIX_OFFSET, 16, 1, wbuf, cnt, false);
+	}
+	else{
+		goto EXIT;
+	}
+	
+EXIT:	
+	kfree(buf);
+
+	//dev_dbg(&info->client->dev, "%s [DONE]\n", __func__); 
+
+	return ret;
+}
+
+/**
+* Open dev node
+*/
+static int mip_dev_fs_open(struct inode *node, struct file *fp)
+{
+	struct mip_ts_info *info = container_of(node->i_cdev, struct mip_ts_info, cdev);
+
+	//dev_dbg(&info->client->dev, "%s [START]\n", __func__); 
+	
+	fp->private_data = info;
+	
+	info->dev_fs_buf = kzalloc(1024 * 4, GFP_KERNEL);
+	
+	//dev_dbg(&info->client->dev, "%s [DONE]\n", __func__); 
+
+	return 0;
+}
+
+/**
+* Close dev node
+*/
+static int mip_dev_fs_release(struct inode *node, struct file *fp)
+{
+	struct mip_ts_info *info = fp->private_data;
+
+	//dev_dbg(&info->client->dev, "%s [START]\n", __func__); 
+
+	kfree(info->dev_fs_buf);
+
+	//dev_dbg(&info->client->dev, "%s [DONE]\n", __func__); 
+
+	return 0;
+}
+
+/**
+* Dev node info
+*/
+static struct file_operations mip_dev_fops = {
+	.owner	= THIS_MODULE,
+	.open	= mip_dev_fs_open,
+	.release	= mip_dev_fs_release,
+	.read	= mip_dev_fs_read,
+	.write	= mip_dev_fs_write,
+};
+
+/**
+* Create dev node
+*/
+int mip_dev_create(struct mip_ts_info *info)
+{
+	struct i2c_client *client = info->client;
+	int ret = 0;
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__); 
+	
+	if (alloc_chrdev_region(&info->mip_dev, 0, 1, MIP_DEVICE_NAME)) {
+		dev_err(&client->dev, "%s [ERROR] alloc_chrdev_region\n", __func__);
+		ret = -ENOMEM;
+		goto ERROR;
+	}
+	
+	cdev_init(&info->cdev, &mip_dev_fops);
+	info->cdev.owner = THIS_MODULE;
+
+	if (cdev_add(&info->cdev, info->mip_dev, 1)) {
+		dev_err(&client->dev, "%s [ERROR] cdev_add\n", __func__);
+		ret = -EIO;
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__); 	
+	return 0;
+	
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__); 	
+	return 0;
+}
+
+#endif
+
+#if MIP_USE_SYS || MIP_USE_CMD
+
+/**
+* Process table data
+*/
+static int mip_proc_table_data(struct mip_ts_info *info, u8 size, u8 data_type_size, u8 data_type_sign, u8 buf_addr_h, u8 buf_addr_l, u8 row_num, u8 col_num, u8 buf_col_num, u8 rotate, u8 key_num)
+{
+	char data[10];
+	int i_col, i_row;
+	int i_x, i_y;
+	int lim_x, lim_y;
+	int lim_col, lim_row;
+	int max_x = 0;
+	int max_y = 0;
+	bool flip_x = false;
+	int sValue = 0;
+	unsigned int uValue = 0;
+	int value = 0;
+	u8 wbuf[8];
+	u8 rbuf[512];
+	unsigned int buf_addr;
+	int offset;
+	int data_size = data_type_size;
+	int data_sign = data_type_sign;
+	int has_key = 0;
+	int size_screen = col_num * row_num;
+
+	memset(data, 0, 10);
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__); 
+
+	//set axis
+	if(rotate == 0){
+		max_x = col_num;
+		max_y = row_num;
+		if(key_num > 0){
+			max_y += 1;
+			has_key = 1;
+		}
+		flip_x = false;
+	}
+	else if(rotate == 1){
+		max_x = row_num;
+		max_y = col_num;
+		if(key_num > 0){
+			max_y += 1;
+			has_key = 1;
+		}
+		flip_x = true;
+	}
+	else{
+		dev_err(&info->client->dev, "%s [ERROR] rotate [%d]\n", __func__, rotate); 
+		goto ERROR;
+	}
+
+	//get table data
+	lim_row = row_num + has_key;
+	for(i_row = 0; i_row < lim_row; i_row++){
+		//get line data
+		offset = buf_col_num * data_type_size;
+		size = col_num * data_type_size;
+		
+		buf_addr = (buf_addr_h << 8) | buf_addr_l | (offset * i_row);
+		wbuf[0] = (buf_addr >> 8) & 0xFF;
+		wbuf[1] = buf_addr & 0xFF;
+		if(mip_i2c_read(info, wbuf, 2, rbuf, size)){
+			dev_err(&info->client->dev, "%s [ERROR] Read data buffer\n", __func__); 
+			goto ERROR;
+		}
+
+		//save data
+		if((key_num > 0) && (i_row == (lim_row - 1))){
+			lim_col = key_num;
+		}
+		else{
+			lim_col = col_num;
+		}
+		for(i_col = 0; i_col < lim_col; i_col++){
+			if(data_sign == 0){
+				//unsigned
+				if(data_size == 1){
+					uValue = (u8)rbuf[i_col];
+				}
+				else if(data_size == 2){
+					uValue = (u16)(rbuf[data_size * i_col] | (rbuf[data_size * i_col + 1] << 8));
+				}
+				else if(data_size == 4){
+					uValue = (u32)(rbuf[data_size * i_col] | (rbuf[data_size * i_col + 1] << 8) | (rbuf[data_size * i_col + 2] << 16) | (rbuf[data_size * i_col + 3] << 24));
+				}
+				else{
+					dev_err(&info->client->dev, "%s [ERROR] data_size [%d]\n", __func__, data_size); 
+					goto ERROR;
+				}				
+				value = (int)uValue;
+			}			
+			else{
+				//signed
+				if(data_size == 1){
+					sValue = (s8)rbuf[i_col];
+				}
+				else if(data_size == 2){
+					sValue = (s16)(rbuf[data_size * i_col] | (rbuf[data_size * i_col + 1] << 8));
+				}
+				else if(data_size == 4){
+					sValue = (s32)(rbuf[data_size * i_col] | (rbuf[data_size * i_col + 1] << 8) | (rbuf[data_size * i_col + 2] << 16) | (rbuf[data_size * i_col + 3] << 24));
+				}
+				else{
+					dev_err(&info->client->dev, "%s [ERROR] data_size [%d]\n", __func__, data_size); 
+					goto ERROR;
+				}
+				value = (int)sValue;
+			}
+
+			switch(rotate){
+				case 0:
+					info->image_buf[i_row * col_num + i_col] = value; 
+					break;
+				case 1:
+					if((key_num > 0) && (i_row == (lim_row - 1))){
+						info->image_buf[size_screen + i_col] = value; 
+					}
+					else{
+						info->image_buf[i_col * row_num + (row_num - 1 - i_row)] = value; 
+					}
+					break;
+				default:
+					dev_err(&info->client->dev, "%s [ERROR] rotate [%d]\n", __func__, rotate); 
+					goto ERROR;
+					break;
+			}
+		}
+	}	
+	
+	//print table header
+	printk("    ");
+	sprintf(data, "    ");
+	strcat(info->print_buf, data);
+	memset(data, 0, 10);	
+	
+	switch(data_size){
+		case 1:
+			for(i_x = 0; i_x < max_x; i_x++){ 	
+				printk("[%2d]", i_x);
+				sprintf(data, "[%2d]", i_x);
+				strcat(info->print_buf, data);
+				memset(data, 0, 10);
+			}			
+			break;
+		case 2:
+			for(i_x = 0; i_x < max_x; i_x++){ 	
+				printk("[%4d]", i_x);
+				sprintf(data, "[%4d]", i_x);
+				strcat(info->print_buf, data);
+				memset(data, 0, 10);
+			}
+			break;
+		case 4:
+			for(i_x = 0; i_x < max_x; i_x++){ 	
+				printk("[%5d]", i_x);
+				sprintf(data, "[%5d]", i_x);
+				strcat(info->print_buf, data);
+				memset(data, 0, 10);
+			}
+			break;
+		default:
+			dev_err(&info->client->dev, "%s [ERROR] data_size [%d]\n", __func__, data_size); 
+			goto ERROR;
+			break;
+	}
+	
+	printk("\n");
+	sprintf(data, "\n");
+	strcat(info->print_buf, data);
+	memset(data, 0, 10);	
+	
+	//print table
+	lim_y = max_y;
+	for(i_y = 0; i_y < lim_y; i_y++){
+		//print line header
+		if((key_num > 0) && (i_y == (lim_y -1))){
+			printk("[TK]");
+			sprintf(data, "[TK]");
+		}
+		else{
+			printk("[%2d]", i_y);
+			sprintf(data, "[%2d]", i_y);
+		}
+		strcat(info->print_buf, data);
+		memset(data, 0, 10);
+		
+		//print line
+		if((key_num > 0) && (i_y == (lim_y - 1))){
+			lim_x = key_num;
+		}
+		else{
+			lim_x = max_x;
+		}
+		for(i_x = 0; i_x < lim_x; i_x++){				
+			switch(data_size){
+				case 1:
+					printk(" %3d", info->image_buf[i_y * max_x + i_x]);
+					sprintf(data, " %3d", info->image_buf[i_y * max_x + i_x]);
+					break;
+				case 2:
+					printk(" %5d", info->image_buf[i_y * max_x + i_x]);
+					sprintf(data, " %5d", info->image_buf[i_y * max_x + i_x]);
+					break;
+				case 4:
+					printk(" %6d", info->image_buf[i_y * max_x + i_x]);
+					sprintf(data, " %6u", info->image_buf[i_y * max_x + i_x]);
+					break;
+				default:
+					dev_err(&info->client->dev, "%s [ERROR] data_size [%d]\n", __func__, data_size); 
+					goto ERROR;
+					break;
+			}				
+			
+			strcat(info->print_buf, data);
+			memset(data, 0, 10);
+		}
+		
+		printk("\n");
+		sprintf(data, "\n");
+		strcat(info->print_buf, data);
+		memset(data, 0, 10);		
+	}
+	
+	printk("\n");
+	sprintf(data, "\n");
+	strcat(info->print_buf, data);
+	memset(data, 0, 10);		
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__); 
+	return 0;
+
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__); 
+	return 1;
+}
+
+/**
+* Run test
+*/
+int mip_run_test(struct mip_ts_info *info, u8 test_type)
+{
+	int busy_cnt = 50;
+	int wait_cnt = 50;
+	u8 wbuf[8];
+	u8 rbuf[512];
+	u8 size = 0;
+	u8 row_num;
+	u8 col_num;
+	u8 buffer_col_num;
+	u8 rotate;
+	u8 key_num;
+	u8 data_type;
+	u8 data_type_size;
+	u8 data_type_sign;
+	u8 buf_addr_h;
+	u8 buf_addr_l;
+		
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__); 
+	dev_dbg(&info->client->dev, "%s - test_type[%d]\n", __func__, test_type);	
+
+	while(busy_cnt--){
+		if(info->test_busy == false){
+			break;
+		}
+		msleep(10);
+	}
+	mutex_lock(&info->lock);
+	info->test_busy = true;
+	mutex_unlock(&info->lock);
+
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	//check test type
+	switch(test_type){
+		case MIP_TEST_TYPE_CM_DELTA:
+			//printk("=== Cm Delta Test ===\n"); 
+			sprintf(info->print_buf, "\n=== Cm Delta Test ===\n\n");
+			break;
+		case MIP_TEST_TYPE_CM_JITTER:
+			//printk("=== Cm Jitter Test ===\n"); 
+			sprintf(info->print_buf, "\n=== Cm Jitter Test ===\n\n");
+			break;
+		case MIP_TEST_TYPE_SHORT:
+			//printk("=== Short Test ===\n"); 
+			sprintf(info->print_buf, "\n=== Short Test ===\n\n");
+			break;
+		default:
+			dev_err(&info->client->dev, "%s [ERROR] Unknown test type\n", __func__); 
+			sprintf(info->print_buf, "\nERROR : Unknown test type\n\n");
+			goto ERROR;
+			break;
+	}
+
+	//set test mode
+	wbuf[0] = MIP_R0_CTRL;
+	wbuf[1] = MIP_R1_CTRL_MODE;
+	wbuf[2] = MIP_CTRL_MODE_TEST_CM;
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] Write test mode\n", __func__); 
+		goto ERROR;
+	}
+
+	//wait ready status
+	wait_cnt = 50;
+	while(wait_cnt--){
+		if(mip_get_ready_status(info) == MIP_CTRL_STATUS_READY){
+			break;
+		}
+		msleep(50);
+		
+		dev_dbg(&info->client->dev, "%s - wait [%d]\n", __func__, wait_cnt); 
+	}
+	
+	if(wait_cnt <= 0){
+		dev_err(&info->client->dev, "%s [ERROR] Wait timeout\n", __func__); 
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s - set control mode\n", __func__);	
+	
+	//set test type
+	wbuf[0] = MIP_R0_TEST;
+	wbuf[1] = MIP_R1_TEST_TYPE;
+	wbuf[2] = test_type;
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] Write test type\n", __func__); 
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s - set test type\n", __func__);	
+
+	//wait ready status
+	wait_cnt = 50;
+	while(wait_cnt--){
+		if(mip_get_ready_status(info) == MIP_CTRL_STATUS_READY){
+			break;
+		}
+		msleep(10);
+		
+		dev_dbg(&info->client->dev, "%s - wait [%d]\n", __func__, wait_cnt); 
+	}
+	
+	if(wait_cnt <= 0){
+		dev_err(&info->client->dev, "%s [ERROR] Wait timeout\n", __func__); 
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s - ready\n", __func__);	
+	
+	//data format
+	wbuf[0] = MIP_R0_TEST;
+	wbuf[1] = MIP_R1_TEST_DATA_FORMAT;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 6)){
+		dev_err(&info->client->dev, "%s [ERROR] Read data format\n", __func__); 
+		goto ERROR;
+	}
+	row_num = rbuf[0];
+	col_num = rbuf[1];
+	buffer_col_num = rbuf[2];
+	rotate = rbuf[3];
+	key_num = rbuf[4];
+	data_type = rbuf[5];
+	
+	data_type_sign = (data_type & 0x80) >> 7;
+	data_type_size = data_type & 0x7F;	
+	
+	dev_dbg(&info->client->dev, "%s - row_num[%d] col_num[%d] buffer_col_num[%d] rotate[%d] key_num[%d]\n", __func__, row_num, col_num, buffer_col_num, rotate, key_num);	
+	dev_dbg(&info->client->dev, "%s - data_type[0x%02X] data_sign[%d] data_size[%d]\n", __func__, data_type, data_type_sign, data_type_size);	
+	
+	//get buf addr
+	wbuf[0] = MIP_R0_TEST;
+	wbuf[1] = MIP_R1_TEST_BUF_ADDR;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 2)){
+		dev_err(&info->client->dev, "%s [ERROR] Read buf addr\n", __func__); 
+		goto ERROR;
+	}
+	
+	buf_addr_l = rbuf[0];
+	buf_addr_h = rbuf[1];
+	dev_dbg(&info->client->dev, "%s - buf_addr[0x%02X 0x%02X]\n", __func__, buf_addr_h, buf_addr_l); 
+	
+	//print data
+	if(mip_proc_table_data(info, size, data_type_size, data_type_sign, buf_addr_h, buf_addr_l, row_num, col_num, buffer_col_num, rotate, key_num)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_proc_table_data\n", __func__); 
+		goto ERROR;
+	}
+
+	//set normal mode
+	wbuf[0] = MIP_R0_CTRL;
+	wbuf[1] = MIP_R1_CTRL_MODE;
+	wbuf[2] = MIP_CTRL_MODE_NORMAL;
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__); 
+		goto ERROR;
+	}
+
+	//wait ready status
+	wait_cnt = 50;
+	while(wait_cnt--){
+		if(mip_get_ready_status(info) == MIP_CTRL_STATUS_READY){
+			break;
+		}
+		msleep(10);
+		
+		dev_dbg(&info->client->dev, "%s - wait [%d]\n", __func__, wait_cnt); 
+	}
+	
+	if(wait_cnt <= 0){
+		dev_err(&info->client->dev, "%s [ERROR] Wait timeout\n", __func__); 
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s - set normal mode\n", __func__);	
+
+	//exit
+	mutex_lock(&info->lock);
+	info->test_busy = false;
+	mutex_unlock(&info->lock);
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);	
+	return 0;
+	
+ERROR:
+	mutex_lock(&info->lock);
+	info->test_busy = false;
+	mutex_unlock(&info->lock);
+	
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__); 
+	return 1;
+}
+
+/**
+* Read image data
+*/
+int mip_get_image(struct mip_ts_info *info, u8 image_type)
+{
+	int busy_cnt = 100;
+	int wait_cnt = 100;
+	u8 wbuf[8];
+	u8 rbuf[512];
+	u8 size = 0;
+	u8 row_num;
+	u8 col_num;
+	u8 buffer_col_num;
+	u8 rotate;
+	u8 key_num;
+	u8 data_type;
+	u8 data_type_size;
+	u8 data_type_sign;
+	u8 buf_addr_h;
+	u8 buf_addr_l;
+		
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+	dev_dbg(&info->client->dev, "%s - image_type[%d]\n", __func__, image_type);	
+
+	while(busy_cnt--){
+		if(info->test_busy == false){
+			break;
+		}
+		dev_dbg(&info->client->dev, "%s - busy_cnt[%d]\n", __func__, busy_cnt);	
+		msleep(5);
+	}
+	mutex_lock(&info->lock);
+	info->test_busy = true;
+	mutex_unlock(&info->lock);
+
+	memset(info->print_buf, 0, PAGE_SIZE);
+	
+	//check image type
+	switch(image_type){
+		case MIP_IMG_TYPE_INTENSITY:
+			dev_dbg(&info->client->dev, "=== Intensity Image ===\n"); 
+			sprintf(info->print_buf, "\n=== Intensity Image ===\n\n");
+			break;
+		case MIP_IMG_TYPE_RAWDATA:
+			dev_dbg(&info->client->dev, "=== Rawdata Image ===\n"); 
+			sprintf(info->print_buf, "\n=== Rawdata Image ===\n\n");
+			break;
+		default:
+			dev_err(&info->client->dev, "%s [ERROR] Unknown image type\n", __func__); 
+			sprintf(info->print_buf, "\nERROR : Unknown image type\n\n");
+			goto ERROR;
+			break;
+	}
+	
+	//set image type
+	wbuf[0] = MIP_R0_IMAGE;
+	wbuf[1] = MIP_R1_IMAGE_TYPE;
+	wbuf[2] = image_type;
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] Write image type\n", __func__); 
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s - set image type\n", __func__);	
+
+	//wait ready status
+	wait_cnt = 50;
+	while(wait_cnt--){
+		if(mip_get_ready_status(info) == MIP_CTRL_STATUS_READY){
+			break;
+		}
+		msleep(10);
+		
+		dev_dbg(&info->client->dev, "%s - wait [%d]\n", __func__, wait_cnt); 
+	}
+	
+	if(wait_cnt <= 0){
+		dev_err(&info->client->dev, "%s [ERROR] Wait timeout\n", __func__); 
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s - ready\n", __func__);	
+	
+	//data format
+	wbuf[0] = MIP_R0_IMAGE;
+	wbuf[1] = MIP_R1_IMAGE_DATA_FORMAT;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 6)){
+		dev_err(&info->client->dev, "%s [ERROR] Read data format\n", __func__); 
+		goto ERROR;
+	}
+	row_num = rbuf[0];
+	col_num = rbuf[1];
+	buffer_col_num = rbuf[2];
+	rotate = rbuf[3];
+	key_num = rbuf[4];
+	data_type = rbuf[5];
+
+	data_type_sign = (data_type & 0x80) >> 7;
+	data_type_size = data_type & 0x7F;
+	
+	dev_dbg(&info->client->dev, "%s - row_num[%d] col_num[%d] buffer_col_num[%d] rotate[%d] key_num[%d]\n", __func__, row_num, col_num, buffer_col_num, rotate, key_num);	
+	dev_dbg(&info->client->dev, "%s - data_type[0x%02X] data_sign[%d] data_size[%d]\n", __func__, data_type, data_type_sign, data_type_size);	
+
+	//get buf addr
+	wbuf[0] = MIP_R0_IMAGE;
+	wbuf[1] = MIP_R1_IMAGE_BUF_ADDR;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 2)){
+		dev_err(&info->client->dev, "%s [ERROR] Read buf addr\n", __func__); 
+		goto ERROR;
+	}
+	
+	buf_addr_l = rbuf[0];
+	buf_addr_h = rbuf[1];
+	dev_dbg(&info->client->dev, "%s - buf_addr[0x%02X 0x%02X]\n", __func__, buf_addr_h, buf_addr_l); 
+
+	//print data
+	if(mip_proc_table_data(info, size, data_type_size, data_type_sign, buf_addr_h, buf_addr_l, row_num, col_num, buffer_col_num, rotate, key_num)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_proc_table_data\n", __func__); 
+		goto ERROR;
+	}
+	
+	//clear image type
+	wbuf[0] = MIP_R0_IMAGE;
+	wbuf[1] = MIP_R1_IMAGE_TYPE;
+	wbuf[2] = MIP_IMG_TYPE_NONE;
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] Clear image type\n", __func__); 
+		goto ERROR;
+	}
+
+	//exit
+	mutex_lock(&info->lock);
+	info->test_busy = false;
+	mutex_unlock(&info->lock);
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);	
+	return 0;
+	
+ERROR:
+	mutex_lock(&info->lock);
+	info->test_busy = false;
+	mutex_unlock(&info->lock);
+
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);	
+	return 1;
+}
+
+#endif
+
+#if MIP_USE_SYS
+
+/**
+* Firmware update (section)
+*/
+static ssize_t mip_sys_fw_update_section(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mip_ts_info *info = i2c_get_clientdata(client);
+	int result = 0;
+	u8 data[255];
+	int ret = 0;
+	
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	ret = mip_fw_update_from_storage(info, info->fw_path_ext, false);
+	
+	switch(ret){
+		case fw_err_none:
+			sprintf(data, "F/W update success.\n");
+			break;
+		case fw_err_uptodate:
+			sprintf(data, "F/W is already up-to-date.\n");
+			break;
+		case fw_err_download:
+			sprintf(data, "F/W update failed : Download error\n");
+			break;
+		case fw_err_file_type:
+			sprintf(data, "F/W update failed : File type error\n");
+			break;
+		case fw_err_file_open:			
+			sprintf(data, "F/W update failed : File open error [%s]\n", info->fw_path_ext);
+			break;
+		case fw_err_file_read:
+			sprintf(data, "F/W update failed : File read error\n");
+			break;
+		default:
+			sprintf(data, "F/W update failed.\n");
+			break;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	
+	strcat(info->print_buf, data);
+	result = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return result;
+}
+
+/**
+* Print chip firmware version
+*/
+static ssize_t mip_sys_fw_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	u8 data[255];
+	int ret;
+	u8 rbuf[16];
+
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	if(mip_get_fw_version(info, rbuf)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_get_fw_version\n", __func__);
+
+		sprintf(data, "F/W Version : ERROR\n");	
+		goto ERROR;
+	}
+	
+	dev_info(&info->client->dev, "%s - F/W Version : %02X.%02X_%02X.%02X_%02X.%02X_%02X.%02X\n", __func__, rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4], rbuf[5], rbuf[6], rbuf[7]);	
+	sprintf(data, "melfas_%s,fw_ver:%02X.%02X_%02X.%02X_%02X.%02X_%02X.%02X\n",MIP_DEVICE_NAME, rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4], rbuf[5], rbuf[6], rbuf[7]);
+
+ERROR:	
+	strcat(info->print_buf, data);
+		
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return ret;
+}
+
+/**
+* Set firmware path
+*/
+static ssize_t mip_sys_fw_path_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	char *path;
+	
+	dev_dbg(&info->client->dev, "%s [START] \n", __func__);
+
+	if(count <= 1){
+		dev_err(&info->client->dev, "%s [ERROR] Wrong value [%s]\n", __func__, buf);
+		goto ERROR;
+	}	
+
+	path = kzalloc(count - 1, GFP_KERNEL);
+	memcpy(path, buf, count - 1);
+		
+	info->fw_path_ext = kstrdup(path, GFP_KERNEL);
+	
+	dev_dbg(&info->client->dev, "%s - Path : %s\n", __func__, info->fw_path_ext);
+
+	dev_dbg(&info->client->dev, "%s [DONE] \n", __func__);
+	return count;
+
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR] \n", __func__);
+	return count;
+}
+
+/**
+* Print firmware path
+*/
+static ssize_t mip_sys_fw_path_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	u8 data[255];
+	int ret;
+	
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	dev_dbg(&info->client->dev, "%s [START] \n", __func__);
+
+	sprintf(data, "Path : %s\n", info->fw_path_ext);
+
+	dev_dbg(&info->client->dev, "%s [DONE] \n", __func__);
+
+	strcat(info->print_buf, data);
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return ret;
+}
+
+/**
+* Print channel info
+*/
+static ssize_t mip_sys_info(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	u8 data[255];
+	int ret;
+	u8 rbuf[32];
+	u8 wbuf[8];
+	int res_x, res_y;
+	
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	sprintf(data, "\n");		
+	strcat(info->print_buf, data);
+	
+	mip_get_fw_version(info, rbuf);
+	sprintf(data, "F/W Version : %02X.%02X_%02X.%02X_%02X.%02X_%02X.%02X\n", rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4], rbuf[5], rbuf[6], rbuf[7]);	
+	strcat(info->print_buf, data);
+	
+	wbuf[0] = MIP_R0_INFO;
+	wbuf[1] = MIP_R1_INFO_PRODUCT_NAME;
+	mip_i2c_read(info, wbuf, 2, rbuf, 16);
+	sprintf(data, "Product Name : %s\n", rbuf);		
+	strcat(info->print_buf, data);
+	
+	wbuf[0] = MIP_R0_INFO;
+	wbuf[1] = MIP_R1_INFO_RESOLUTION_X;
+	mip_i2c_read(info, wbuf, 2, rbuf, 7);
+	res_x = (rbuf[0]) | (rbuf[1] << 8);
+	res_y = (rbuf[2]) | (rbuf[3] << 8);
+	sprintf(data, "Resolution : X[%d] Y[%d]\n", res_x, res_y);		
+	strcat(info->print_buf, data);
+
+	sprintf(data, "Node Num : X[%d] Y[%d] Key[%d]\n", rbuf[4], rbuf[5], rbuf[6]);		
+	strcat(info->print_buf, data);
+	
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return ret;
+	
+}
+
+/**
+* Power on
+*/
+static ssize_t mip_sys_power_on(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+	u8 data[255];
+	int ret;
+
+	memset(info->print_buf,0,PAGE_SIZE);
+
+	mip_power_on(info);
+
+	dev_info(&client->dev, "%s", __func__);	
+	
+	sprintf(data, "Power : On\n");	
+	strcat(info->print_buf,data);
+	
+	ret = snprintf(buf,PAGE_SIZE,"%s\n",info->print_buf);
+	return ret;
+	
+}
+
+/**
+* Power off
+*/
+static ssize_t mip_sys_power_off(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+	u8 data[255];
+	int ret;
+
+	memset(info->print_buf,0,PAGE_SIZE);
+
+	mip_power_off(info);
+
+	dev_info(&client->dev, "%s", __func__);	
+	
+	sprintf(data, "Power : Off\n");	
+	strcat(info->print_buf,data);
+	
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return ret;
+	
+}
+
+/**
+* Reboot chip
+*/
+static ssize_t mip_sys_reboot(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+	u8 data[255];
+	int ret;
+
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	dev_info(&client->dev, "%s", __func__); 
+	
+	disable_irq(info->irq);	
+	mip_clear_input(info);	
+	mip_reboot(info);	
+	enable_irq(info->irq);
+	
+	sprintf(data, "Reboot\n");	
+	strcat(info->print_buf,data);
+		
+	ret = snprintf(buf,PAGE_SIZE,"%s\n",info->print_buf);
+	return ret;
+	
+}
+
+/**
+* Set mode
+*/
+static ssize_t mip_sys_mode_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	u8 wbuf[8];
+	u8 value = 0;
+	
+	dev_dbg(&info->client->dev, "%s [START] \n", __func__);
+
+	wbuf[0] = MIP_R0_CTRL;
+
+	if (!strcmp(attr->attr.name, "mode_glove")){		
+		wbuf[1] = MIP_R1_CTRL_GLOVE_MODE;
+	}
+	else if (!strcmp(attr->attr.name, "mode_charger")){
+		wbuf[1] = MIP_R1_CTRL_CHARGER_MODE;
+	}
+	else if (!strcmp(attr->attr.name, "mode_cover_window")){
+		wbuf[1] = MIP_R1_CTRL_WINDOW_MODE;
+	}
+	else if (!strcmp(attr->attr.name, "mode_palm_rejection")){
+		wbuf[1] = MIP_R1_CTRL_PALM_REJECTION;
+	}
+	else {
+		dev_err(&info->client->dev, "%s [ERROR] Unknown mode [%s]\n", __func__, attr->attr.name);		
+		goto ERROR;
+	}
+
+	if(buf[0] == 48){
+		value = 0;
+	}
+	else if(buf[0] == 49){
+		value = 1;
+	}
+	else{
+		dev_err(&info->client->dev, "%s [ERROR] Unknown value [%c]\n", __func__, buf[0]);
+		goto EXIT;
+	}	
+	wbuf[2] = value;
+	
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__);
+	}
+	else{
+		dev_info(&info->client->dev, "%s - value[%d]\n", __func__, value);
+	}
+		
+EXIT:
+	dev_dbg(&info->client->dev, "%s [DONE] \n", __func__);
+	return count;
+
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR] \n", __func__);
+	return count;
+}
+
+/**
+* Print mode
+*/
+static ssize_t mip_sys_mode_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	u8 data[255];
+	int ret;
+	u8 wbuf[8];
+	u8 rbuf[4];
+	
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	dev_dbg(&info->client->dev, "%s [START] \n", __func__);
+
+	wbuf[0] = MIP_R0_CTRL;
+	
+	if (!strcmp(attr->attr.name, "mode_glove")){		
+		wbuf[1] = MIP_R1_CTRL_GLOVE_MODE;
+	}
+	else if (!strcmp(attr->attr.name, "mode_charger")){
+		wbuf[1] = MIP_R1_CTRL_CHARGER_MODE;
+	}
+	else if (!strcmp(attr->attr.name, "mode_cover_window")){
+		wbuf[1] = MIP_R1_CTRL_WINDOW_MODE;
+	}
+	else if (!strcmp(attr->attr.name, "mode_palm_rejection")){
+		wbuf[1] = MIP_R1_CTRL_PALM_REJECTION;
+	}
+	else {
+		dev_err(&info->client->dev, "%s [ERROR] Unknown mode [%s]\n", __func__, attr->attr.name);		
+		sprintf(data, "%s : Unknown Mode\n", attr->attr.name);
+		goto EXIT;
+	}
+	
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 1)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_read\n", __func__);
+		sprintf(data, "%s : ERROR\n", attr->attr.name);
+	}
+	else{
+		dev_info(&info->client->dev, "%s - value[%d]\n", __func__, rbuf[0]);
+		sprintf(data, "%s : %d\n", attr->attr.name, rbuf[0]);
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE] \n", __func__);
+
+EXIT:	
+	strcat(info->print_buf, data);
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return ret;
+}
+
+/**
+* Sysfs print image
+*/
+static ssize_t mip_sys_image(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	int ret;
+	u8 type;
+
+	dev_dbg(&info->client->dev, "%s [START] \n", __func__);
+
+	if (!strcmp(attr->attr.name, "image_intensity")){		
+		type = MIP_IMG_TYPE_INTENSITY;
+	}
+	else if (!strcmp(attr->attr.name, "image_rawdata")){
+		type = MIP_IMG_TYPE_RAWDATA;
+	}
+	else {
+		dev_err(&info->client->dev, "%s [ERROR] Unknown image [%s]\n", __func__, attr->attr.name);		
+		ret = snprintf(buf, PAGE_SIZE, "%s\n", "ERROR : Unknown image type");
+		goto ERROR;
+	}
+
+	if(mip_get_image(info, type)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_get_image\n", __func__);
+		ret = snprintf(buf, PAGE_SIZE, "%s\n", "ERROR");
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s [DONE] \n", __func__);
+	
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return ret;
+	
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return ret;
+}
+
+/**
+* Sysfs run test
+*/
+static ssize_t mip_sys_test(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	int ret;
+	u8 test_type;
+	
+	dev_dbg(&info->client->dev, "%s [START] \n", __func__);
+
+	if (!strcmp(attr->attr.name, "test_cm_delta")){		
+		test_type = MIP_TEST_TYPE_CM_DELTA;
+	}
+	else if (!strcmp(attr->attr.name, "test_cm_jitter")){
+		test_type = MIP_TEST_TYPE_CM_JITTER;
+	}
+	else if (!strcmp(attr->attr.name, "test_short")){
+		test_type = MIP_TEST_TYPE_SHORT;
+	}
+	else {
+		dev_err(&info->client->dev, "%s [ERROR] Unknown test [%s]\n", __func__, attr->attr.name);		
+		ret = snprintf(buf, PAGE_SIZE, "%s\n", "ERROR : Unknown test type");
+		goto ERROR;
+	}
+
+	if(mip_run_test(info, test_type)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_run_test\n", __func__);
+		ret = snprintf(buf, PAGE_SIZE, "%s\n", "ERROR");
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return ret;
+
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return ret;
+}
+
+/**
+* Print wake-up gesture code
+*/
+static ssize_t mip_sys_wakeup_gesture(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+	u8 data[255];
+	int ret;
+
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	dev_info(&client->dev, "%s", __func__); 
+		
+	sprintf(data, "gesture:%d\n", info->wakeup_gesture_code);	
+	strcat(info->print_buf,data);
+	
+	ret = snprintf(buf,PAGE_SIZE,"%s\n",info->print_buf);
+	return ret;
+	
+}
+
+/**
+* Sysfs functions
+*/
+static DEVICE_ATTR(fw_update_section, 0666, mip_sys_fw_update_section, NULL);
+static DEVICE_ATTR(fw_version, 0666, mip_sys_fw_version, NULL);
+static DEVICE_ATTR(fw_path, 0666, mip_sys_fw_path_show, mip_sys_fw_path_store);
+static DEVICE_ATTR(info, 0666, mip_sys_info, NULL);
+static DEVICE_ATTR(power_on, 0666, mip_sys_power_on, NULL);
+static DEVICE_ATTR(power_off, 0666, mip_sys_power_off, NULL);
+static DEVICE_ATTR(reboot, 0666, mip_sys_reboot, NULL);
+static DEVICE_ATTR(mode_glove, 0666, mip_sys_mode_show, mip_sys_mode_store);
+static DEVICE_ATTR(mode_charger, 0666, mip_sys_mode_show, mip_sys_mode_store);
+static DEVICE_ATTR(mode_cover_window, 0666, mip_sys_mode_show, mip_sys_mode_store);
+static DEVICE_ATTR(mode_palm_rejection, 0666, mip_sys_mode_show, mip_sys_mode_store);
+static DEVICE_ATTR(image_intensity, 0666, mip_sys_image, NULL);
+static DEVICE_ATTR(image_rawdata, 0666, mip_sys_image, NULL);
+static DEVICE_ATTR(test_cm_delta, 0600, mip_sys_test, NULL);
+static DEVICE_ATTR(test_cm_jitter, 0666, mip_sys_test, NULL);
+static DEVICE_ATTR(test_short, 0600, mip_sys_test, NULL);
+static DEVICE_ATTR(wakeup_gesture, 0666, mip_sys_wakeup_gesture, NULL);
+
+/**
+* Sysfs attr list info
+*/
+static struct attribute *mip_sys_attr[] = {
+	&dev_attr_fw_update_section.attr,
+	&dev_attr_fw_version.attr,
+	&dev_attr_fw_path.attr,
+	&dev_attr_info.attr,
+	&dev_attr_power_on.attr,
+	&dev_attr_power_off.attr,
+	&dev_attr_reboot.attr,
+	&dev_attr_mode_glove.attr,
+	&dev_attr_mode_charger.attr,
+	&dev_attr_mode_cover_window.attr,
+	&dev_attr_mode_palm_rejection.attr,
+	&dev_attr_image_intensity.attr,
+	&dev_attr_image_rawdata.attr,
+	&dev_attr_test_cm_delta.attr,
+	&dev_attr_test_cm_jitter.attr,
+	&dev_attr_test_short.attr,
+	&dev_attr_wakeup_gesture.attr,
+	NULL,
+};
+
+/**
+* Sysfs attr group info
+*/
+static const struct attribute_group mip_sys_attr_group = {
+	.attrs = mip_sys_attr,
+};
+
+/**
+* Create sysfs test functions
+*/
+int mip_sysfs_create(struct mip_ts_info *info)
+{
+	struct i2c_client *client = info->client;
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	if (sysfs_create_group(&client->dev.kobj, &mip_sys_attr_group)) {
+		dev_err(&client->dev, "%s [ERROR] sysfs_create_group\n", __func__);
+		return -EAGAIN;
+	}
+	
+	info->print_buf = kzalloc(sizeof(u8) * 4096, GFP_KERNEL);
+	info->image_buf = kzalloc(sizeof(int) * ((info->node_x * info->node_y) + info->node_key), GFP_KERNEL);
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+
+	return 0;
+}
+
+/**
+* Remove sysfs test functions
+*/
+void mip_sysfs_remove(struct mip_ts_info *info)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	
+	sysfs_remove_group(&info->client->dev.kobj, &mip_sys_attr_group);
+		
+	kfree(info->print_buf);
+	kfree(info->image_buf);
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	
+	return;
+}
+
+#endif
+
diff --git a/drivers/input/touchscreen/melfas_mip4_test/mip4_fw_mms438.c b/drivers/input/touchscreen/melfas_mip4_test/mip4_fw_mms438.c
new file mode 100755
index 00000000000..cc39fafbb88
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_test/mip4_fw_mms438.c
@@ -0,0 +1,503 @@
+/*
+ * MELFAS MIP4 Touchscreen
+ *
+ * Copyright (C) 2015 MELFAS Inc.
+ *
+ *
+ * mip4_fw_mms438.c : Firmware update functions for MMS438/449/458
+ *
+ */
+
+#include "mip4.h"
+
+//ISC Info
+#define ISC_PAGE_SIZE				128
+
+//ISC Command
+//#define ISC_CMD_ERASE_ALL			{0xFB,0x4A,0x00,0x15,0x00,0x00}
+#define ISC_CMD_ERASE_PAGE		{0xFB,0x4A,0x00,0x8F,0x00,0x00}
+#define ISC_CMD_READ_PAGE			{0xFB,0x4A,0x00,0xC2,0x00,0x00}
+//#define ISC_CMD_WRITE_PAGE		{0xFB,0x4A,0x00,0xA5,0x00,0x00}
+#define ISC_CMD_PROGRAM_PAGE		{0xFB,0x4A,0x00,0x54,0x00,0x00}
+#define ISC_CMD_READ_STATUS		{0xFB,0x4A,0x36,0xC2,0x00,0x00}
+#define ISC_CMD_EXIT				{0xFB,0x4A,0x00,0x66,0x00,0x00}
+
+//ISC Status
+#define ISC_STATUS_BUSY			0x96
+#define ISC_STATUS_DONE			0xAD
+
+/**
+* Read ISC status
+*/
+static int mip_isc_read_status(struct mip_ts_info *info)
+{
+	struct i2c_client *client = info->client;
+	u8 cmd[6] =  ISC_CMD_READ_STATUS;
+	u8 result = 0;
+	int cnt = 100;
+	int ret = 0;
+	struct i2c_msg msg[2] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.buf = cmd,
+			.len = 6,
+		}, {
+			.addr = client->addr,
+			.flags = I2C_M_RD,
+			.buf = &result,
+			.len = 1,
+		},
+	};
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+	
+	do {
+		if(i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg))!=ARRAY_SIZE(msg)){
+			dev_err(&info->client->dev, "%s [ERROR] i2c_transfer\n", __func__);
+			return -1;
+		}
+		
+		if(result == ISC_STATUS_DONE){
+			ret = 0;
+			break;
+		}
+		else if(result == ISC_STATUS_BUSY){
+			ret = -1;
+			msleep(1);
+		}
+		else{
+			dev_err(&info->client->dev, "%s [ERROR] wrong value [0x%02X]\n", __func__, result);
+			ret = -1;
+			msleep(1);
+		}	
+	} while (--cnt);
+
+	if (!cnt) {
+		dev_err(&info->client->dev, "%s [ERROR] count overflow - cnt [%d] status [0x%02X]\n", __func__, cnt, result);
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);	
+	
+	return ret;
+
+ERROR:
+	return ret;	
+}
+
+/**
+* Command : Erase Page
+*/
+static int mip_isc_erase_page(struct mip_ts_info *info, int offset)
+{
+	u8 write_buf[6] = ISC_CMD_ERASE_PAGE;
+
+	struct i2c_msg msg[1] = {
+		{
+			.addr = info->client->addr,
+			.flags = 0,
+			.buf = write_buf,
+			.len = 6,
+		}, 
+	};
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+
+	write_buf[4] = (u8)(((offset)>>8)&0xFF );
+	write_buf[5] = (u8)(((offset)>>0)&0xFF );
+	if(i2c_transfer(info->client->adapter, msg, ARRAY_SIZE(msg)) != ARRAY_SIZE(msg)){
+		dev_err(&info->client->dev, "%s [ERROR] i2c_transfer\n", __func__);
+		goto ERROR;
+	}
+	
+	if(mip_isc_read_status(info) != 0){
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE] - Offset [0x%04X]\n", __func__, offset);	
+		
+	return 0;
+
+ERROR:
+	return -1;
+}
+
+/**
+* Command : Read Page
+*/
+static int mip_isc_read_page(struct mip_ts_info *info, int offset, u8 *data)
+{
+	u8 write_buf[6] =ISC_CMD_READ_PAGE;
+
+	struct i2c_msg msg[2] = {
+		{
+			.addr = info->client->addr,
+			.flags = 0,
+			.buf = write_buf,
+			.len = 6,
+		}, {
+			.addr = info->client->addr,
+			.flags = I2C_M_RD,
+			.buf = data,
+			.len = ISC_PAGE_SIZE,
+		},
+	};
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+
+	write_buf[4] = (u8)(((offset)>>8)&0xFF );
+	write_buf[5] = (u8)(((offset)>>0)&0xFF );
+	if(i2c_transfer(info->client->adapter, msg, ARRAY_SIZE(msg)) != ARRAY_SIZE(msg)){
+		dev_err(&info->client->dev, "%s [ERROR] i2c_transfer\n", __func__);
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE] - Offset [0x%04X]\n", __func__, offset);	
+		
+	return 0;
+
+ERROR:
+	return -1;
+}
+
+#if 0
+/**
+* Command : Write Page
+*/
+static int mip_isc_write_page(struct mip_ts_info *info, int offset,const u8 *data, int length)
+{
+	u8 write_buf[134] = ISC_CMD_WRITE_PAGE;
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+
+	if( length > 128 ){
+		dev_err(&info->client->dev, "%s [ERROR] page length overflow\n", __func__);
+		goto ERROR;
+	}
+		
+	write_buf[4] = (u8)(((offset)>>8)&0xFF );
+	write_buf[5] = (u8)(((offset)>>0)&0xFF );
+	
+	memcpy( &write_buf[6], data, length);
+	
+	if(i2c_master_send(info->client, write_buf, length+6 )!=length+6){
+		dev_err(&info->client->dev, "%s [ERROR] i2c_master_send\n", __func__);	
+		goto ERROR;
+	}
+	
+	if(mip_isc_read_status(info) != 0){
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE] - Offset[0x%04X] Length[%d]\n", __func__, offset, length);	
+	
+	return 0;
+
+ERROR:
+	return -1;
+}
+#endif
+
+/**
+* Command : Program Page
+*/
+static int mip_isc_program_page(struct mip_ts_info *info, int offset, const u8 *data, int length)
+{
+	u8 write_buf[134] = ISC_CMD_PROGRAM_PAGE;
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+
+	if(length > ISC_PAGE_SIZE){
+		dev_err(&info->client->dev, "%s [ERROR] page length overflow\n", __func__);
+		goto ERROR;
+	}
+		
+	write_buf[4] = (u8)(((offset)>>8)&0xFF ); 
+	write_buf[5] = (u8)(((offset)>>0)&0xFF );
+	
+	memcpy(&write_buf[6], data, length);
+	
+	if(i2c_master_send(info->client, write_buf, (length + 6)) != (length + 6)){
+		dev_err(&info->client->dev, "%s [ERROR] i2c_master_send\n", __func__);	
+		goto ERROR;
+	}
+	
+	if(mip_isc_read_status(info) != 0){
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE] - Offset[0x%04X] Length[%d]\n", __func__, offset, length);	
+	
+	return 0;
+
+ERROR:
+	return -1;
+}
+
+/**
+* Command : Exit ISC
+*/
+static int mip_isc_exit(struct mip_ts_info *info)
+{
+	u8 write_buf[6] = ISC_CMD_EXIT;
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+
+	if(i2c_master_send(info->client, write_buf, 6 )!=6){
+		dev_err(&info->client->dev, "%s [ERROR] i2c_master_send\n", __func__);	
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);	
+	
+	return 0;
+
+ERROR:
+	return -1;
+}
+
+/**
+* Flash chip firmware (main function)
+*/
+int mip_flash_fw(struct mip_ts_info *info, const u8 *fw_data, size_t fw_size, bool force, bool section)
+{
+
+	struct mip_bin_hdr *fw_hdr;
+	struct mip_fw_img **img;
+	struct i2c_client *client = info->client;
+	int i;
+	int retires = 3;
+	int nRet;
+	int nStartAddr;
+	int nWriteLength;
+	int nLast;
+	int nOffset;
+	int nTransferLength;
+	int size;
+	u8 *data;
+	u8 *cpydata;
+	
+	int offset = sizeof(struct mip_bin_hdr);
+
+	bool update_flag = false;
+	bool update_flags[MIP_FW_MAX_SECT_NUM] = {false, };
+	
+	u16 ver_chip[MIP_FW_MAX_SECT_NUM];
+	u16 ver_file[MIP_FW_MAX_SECT_NUM];
+
+	int offsetStart = 0;
+	u8 initData[ISC_PAGE_SIZE];
+	memset(initData, 0xFF, sizeof(initData));
+	
+	dev_dbg(&client->dev,"%s [START]\n", __func__);
+
+	//Read firmware file
+	fw_hdr = (struct mip_bin_hdr *)fw_data;
+	img = kzalloc(sizeof(*img) * fw_hdr->section_num, GFP_KERNEL);
+
+	//Check firmware file
+	if(memcmp(CHIP_FW_CODE, &fw_hdr->tag[4], 4)){
+		dev_err(&client->dev, "%s [ERROR] F/W file is not for %s\n", __func__, CHIP_NAME);
+
+		nRet = fw_err_file_type;
+		goto ERROR;
+	}
+	
+	//Reboot chip
+	mip_reboot(info);
+	
+	//Check chip firmware version
+	while (retires--) {
+		if (!mip_get_fw_version_u16(info, ver_chip)){
+			break;
+		}
+		else {
+			mip_reboot(info);
+		}
+	}
+	if (retires < 0) {
+		dev_err(&client->dev, "%s [ERROR] cannot read chip firmware version\n", __func__);
+		
+		memset(ver_chip, 0xFFFF, sizeof(ver_chip));		
+		dev_info(&client->dev, "%s - Chip firmware version is set to [0xFFFF]\n", __func__);
+	} 
+	else {
+		dev_info(&client->dev, "%s - Chip firmware version [0x%04X 0x%04X 0x%04X 0x%04X]\n", __func__, ver_chip[0], ver_chip[1], ver_chip[2], ver_chip[3]);
+	}
+
+	//Set update flag
+	dev_info(&client->dev, "%s - Firmware file info : Sections[%d] Offset[0x%08X] Length[0x%08X]\n", __func__, fw_hdr->section_num, fw_hdr->binary_offset, fw_hdr->binary_length);
+
+	for (i = 0; i < fw_hdr->section_num; i++, offset += sizeof(struct mip_fw_img)) {
+		img[i] = (struct mip_fw_img *)(fw_data + offset);
+		ver_file[i] = img[i]->version;
+		
+		dev_info(&client->dev, "%s - Section info : Section[%d] Version[0x%04X] StartPage[%d] EndPage[%d] Offset[0x%08X] Length[0x%08X]\n", __func__, i, img[i]->version, img[i]->start_page, img[i]->end_page, img[i]->offset, img[i]->length);
+		
+		//Compare section version
+		if (ver_chip[i] != ver_file[i]) {
+			//Set update flag
+			update_flag = true;
+			update_flags[i] = true;
+			
+			dev_info(&client->dev, "%s - Section [%d] is need to be updated. Version : Chip[0x%04X] File[0x%04X]\n", __func__, i, ver_chip[i], ver_file[i]);
+		}
+	}
+
+	//Set force update flag
+	if(force == true){
+		update_flag = true;
+		update_flags[0] = true;
+		update_flags[1] = true;
+		update_flags[2] = true;
+		update_flags[3] = true;
+		
+		dev_info(&client->dev, "%s - Force update\n", __func__);
+	}
+
+	//Exit when up-to-date
+	if(update_flag == false){
+		nRet = fw_err_uptodate;
+		dev_dbg(&client->dev, "%s [DONE] Chip firmware is already up-to-date\n", __func__);
+		goto EXIT;
+	}
+	
+	//Set start addr offset
+	if(section == true){
+		if(update_flags[0] == true){
+			//boot
+			offsetStart = img[0]->start_page;
+		}
+		else if(update_flags[1] == true){
+			//core
+			offsetStart = img[1]->start_page;
+		}
+		else if(update_flags[2] == true){
+			//custom
+			offsetStart = img[2]->start_page;
+		}
+		else if(update_flags[3] == true){
+			//param
+			offsetStart = img[3]->start_page;
+		}
+	}
+	else{
+		offsetStart = 0;
+	}
+	
+	offsetStart = offsetStart * 1024;
+	
+	//Load firmware data
+	data = kzalloc(sizeof(u8) * fw_hdr->binary_length, GFP_KERNEL);
+	size = fw_hdr->binary_length;
+	cpydata = kzalloc(ISC_PAGE_SIZE, GFP_KERNEL);	
+
+	//Check firmware size
+	if(size % ISC_PAGE_SIZE != 0){
+		size += ( ISC_PAGE_SIZE - (size % ISC_PAGE_SIZE) );
+	}
+
+	nStartAddr = 0;	
+	nWriteLength = size;
+	nLast = nStartAddr + nWriteLength;
+
+	if((nLast) % 8 != 0){
+		nRet = fw_err_file_type;
+		dev_err(&client->dev, "%s [ERROR] Firmware size mismatch\n", __func__);
+		goto ERROR;
+	}
+	else{
+		memcpy(data, fw_data + fw_hdr->binary_offset, fw_hdr->binary_length);		
+	}
+
+	//Set address
+	nOffset = nStartAddr + nWriteLength - ISC_PAGE_SIZE;
+	nTransferLength = ISC_PAGE_SIZE;
+
+	//Erase first page
+	dev_info(&client->dev, "%s - Erase first page : Offset[0x%04X]\n", __func__, offsetStart);
+	nRet = mip_isc_erase_page(info, offsetStart);
+	if( nRet != 0 ) {
+		dev_err(&client->dev,"%s [ERROR] clear first page failed\n", __func__);
+		goto ERROR;
+	}
+
+	//Flash firmware
+	dev_info(&client->dev, "%s - Start Download : Offset Start[0x%04X] End[0x%04X]\n", __func__, nOffset, offsetStart);
+	while( nOffset >= offsetStart )
+	{
+		dev_info(&client->dev, "%s - Downloading : Offset[0x%04X]\n", __func__, nOffset);
+		
+		//Program (erase and write) a page
+		nRet = mip_isc_program_page(info, nOffset, &data[nOffset], nTransferLength);
+		if( nRet != 0 ) {
+			dev_err(&client->dev,"%s [ERROR] isc_program_page\n", __func__);
+			goto ERROR;
+		}
+
+		//Verify (read and compare)
+		if (mip_isc_read_page(info, nOffset, cpydata)) {
+			dev_err(&client->dev,"%s [ERROR] mip_isc_read_page\n", __func__);
+			goto ERROR;
+		}
+		
+		if (memcmp(&data[nOffset], cpydata, ISC_PAGE_SIZE)) {
+#if MIP_FW_UPDATE_DEBUG
+			print_hex_dump(KERN_ERR, "Firmware Page Write : ", DUMP_PREFIX_OFFSET, 16, 1, data, ISC_PAGE_SIZE, false);
+			print_hex_dump(KERN_ERR, "Firmware Page Read : ", DUMP_PREFIX_OFFSET, 16, 1, cpydata, ISC_PAGE_SIZE, false);
+#endif
+			dev_err(&client->dev, "%s [ERROR] verify page failed\n", __func__);
+
+			nRet = -1;
+			goto ERROR;
+		}
+		
+		nOffset -= nTransferLength;
+	}
+
+	//Exit ISC
+	nRet = mip_isc_exit(info);
+	if( nRet != 0 ) {
+		dev_err(&client->dev,"%s [ERROR] mip_isc_exit\n", __func__);
+		goto ERROR;
+	}
+	
+	//Reboot chip
+	mip_reboot(info);
+	
+	//Check chip firmware version
+	if (mip_get_fw_version_u16(info, ver_chip)) {
+		dev_err(&client->dev, "%s [ERROR] cannot read chip firmware version after flash\n", __func__);
+
+		nRet = -1;
+		goto ERROR;
+	} 
+	else {
+		for (i = 0; i < fw_hdr->section_num; i++) {
+			if (ver_chip[i] != ver_file[i]) {
+				dev_err(&client->dev, "%s [ERROR] version mismatch after flash. Section[%d] : Chip[0x%04X] != File[0x%04X]\n", __func__, i, ver_chip[i], ver_file[i]);
+
+				nRet = -1;
+				goto ERROR;
+			}
+		}
+	}
+
+	nRet = 0;
+	dev_dbg(&client->dev,"%s [DONE]\n", __func__);
+	dev_info(&client->dev,"Firmware update completed\n");
+ 	goto EXIT;
+
+ERROR:
+	dev_err(&client->dev,"%s [ERROR]\n", __func__);
+	dev_err(&client->dev,"Firmware update failed\n");
+	goto EXIT;
+
+EXIT:
+	kfree(img);
+
+	return nRet;
+	
+}
+
diff --git a/drivers/input/touchscreen/melfas_mip4_test/mip4_mod.c b/drivers/input/touchscreen/melfas_mip4_test/mip4_mod.c
new file mode 100755
index 00000000000..e606d60196b
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_test/mip4_mod.c
@@ -0,0 +1,612 @@
+/*
+ * MELFAS MIP4 Touchscreen
+ *
+ * Copyright (C) 2015 MELFAS Inc.
+ *
+ *
+ * mip4_mod.c : Model dependent functions
+ * 
+ */
+//#define DEBUG 1
+#include "mip4.h"
+
+/**
+* Control regulator
+*/
+int mip_regulator_control(struct mip_ts_info *info, int enable)
+{
+	//int ret = 0;
+
+	//////////////////////////
+	// MODIFY REQUIRED
+	//
+
+#if 0
+	static struct regulator *reg_vd33;
+
+	dev_dbg(&client->dev, "%s [START]\n", __func__);
+
+	if (!reg_vd33) {
+		reg_vd33 = regulator_get(&client->dev, "vd33");
+		//reg_vd33 = regulator_get(NULL, "8941_l22");		
+		if (IS_ERR(reg_vd33)) {
+			dev_err(&client->dev, "%s [ERROR] regulator_get\n", __func__);
+			goto ERROR;
+		}
+		
+		ret = regulator_set_voltage(reg_vd33, 3300000, 3300000);
+		if (ret) {
+			dev_err(&client->dev, "%s [ERROR] regulator_set_voltage\n", __func__);
+			goto ERROR;
+		}
+	}
+
+	if (enable) {
+		ret = regulator_enable(reg_vd33);
+		if (ret) {
+			dev_err(&client->dev, "%s [ERROR] regulator_enable [%d]\n", __func__, ret);
+			goto ERROR;
+		}
+	}
+	else{
+		if (regulator_is_enabled(reg_vd33)){
+			ret = regulator_disable(reg_vd33);
+			if (ret) {
+				dev_err(&client->dev, "%s [ERROR] regulator_disable [%d]\n", __func__, ret);
+				goto ERROR;
+			}
+		}
+	}
+
+	regulator_put(reg_vd33);
+
+#endif
+
+	//
+	//////////////////////////
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+
+/*
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return -1;
+*/
+}
+
+/**
+* Turn off power supply
+*/
+int mip_power_off(struct mip_ts_info *info)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	//Control regulator
+	//mip_regulator_control(info, 0);
+
+	//Control power switch
+	gpio_direction_output(info->pdata->vdd_supply, 0);
+	mdelay(2);
+	gpio_direction_output(info->pdata->gpio_vdd_en, 0);
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+}
+
+/**
+* Turn on power supply
+*/
+int mip_power_on(struct mip_ts_info *info)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	//Control regulator
+	//mip_regulator_control(info, 1);
+
+	//Control power switch
+	gpio_direction_output(info->pdata->vdd_supply, 1);
+	mdelay(2);
+	gpio_direction_output(info->pdata->gpio_vdd_en, 1);
+	mdelay(20);
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+}
+
+/**
+* Clear touch input status in the set
+*/
+void mip_clear_input(struct mip_ts_info *info)
+{
+	int i;
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	//Screen
+	for(i = 0; i < MAX_FINGER_NUM; i++){
+		/////////////////////////////////
+		// MODIFY REQUIRED
+		//
+		
+		input_mt_slot(info->input_dev, i);
+		input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 0);
+		//input_report_key(info->input_dev, BTN_TOUCH, 0);
+		//input_report_key(info->input_dev, BTN_TOOL_FINGER, 0);
+
+		#if INPUT_SYNC_TYPE
+		input_sync(info->input_dev);
+		#endif
+		
+		//
+		/////////////////////////////////
+	}
+
+	//Key
+	if(info->key_enable == true){
+		for(i = 0; i < info->key_num; i++){
+			input_report_key(info->input_dev, info->key_code[i], 0);
+
+			#if INPUT_SYNC_TYPE
+			input_sync(info->input_dev);
+			#endif
+		}
+	}
+	
+#if !INPUT_SYNC_TYPE
+	input_sync(info->input_dev);
+#endif
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+		
+	return;
+}
+
+/**
+* Input event handler - Report touch input event
+*/
+void mip_input_event_handler(struct mip_ts_info *info, u8 sz, u8 *buf)
+{
+	int i;
+	int id, x, y;
+	int pressure = 0;
+	int size = 0;
+	int touch_major = 0;
+	int touch_minor = 0;
+	int palm = 0;
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	//dev_dbg(&info->client->dev, "%s - sz[%d] buf[0x%02X]\n", __func__, sz, buf[0]);
+	//print_hex_dump(KERN_ERR, "Event Packet : ", DUMP_PREFIX_OFFSET, 16, 1, buf, sz, false);
+
+	for (i = 0; i < sz; i += info->event_size) {
+		u8 *tmp = &buf[i];
+
+		//Report input data
+		if ((tmp[0] & MIP_EVENT_INPUT_SCREEN) == 0) {
+			//Touchkey Event
+			int key = tmp[0] & 0xf;
+			int key_state = (tmp[0] & MIP_EVENT_INPUT_PRESS) ? 1 : 0;
+			int key_code = 0;
+			
+			//Report touchkey event
+			if((key > 0) && (key <= info->key_num)){
+				key_code = info->key_code[key - 1];
+				
+				input_report_key(info->input_dev, key_code, key_state);
+				
+				#if INPUT_SYNC_TYPE
+				input_sync(info->input_dev);
+				#endif
+				
+				dev_dbg(&info->client->dev, "%s - Key : ID[%d] Code[%d] State[%d]\n", __func__, key, key_code, key_state);	
+			}
+			else{
+				dev_err(&info->client->dev, "%s [ERROR] Unknown key id [%d]\n", __func__, key);
+				continue;
+			}
+		}
+		else
+		{
+			//Touchscreen Event
+			
+			//Protocol Type
+			if(info->event_format == 0){
+				id = (tmp[0] & 0xf) - 1;
+				x = tmp[2] | ((tmp[1] & 0xf) << 8);
+				y = tmp[3] | (((tmp[1] >> 4) & 0xf) << 8);
+				pressure = tmp[4];
+				touch_major = tmp[5];								
+				palm = (tmp[0] & MIP_EVENT_INPUT_PALM) >> 4;			
+			}
+			else if(info->event_format == 1){
+				id = (tmp[0] & 0xf) - 1;
+				x = tmp[2] | ((tmp[1] & 0xf) << 8);
+				y = tmp[3] | (((tmp[1] >> 4) & 0xf) << 8);
+				pressure = tmp[4];
+				size = tmp[5];
+				touch_major = tmp[6];
+				touch_minor = tmp[7];							
+				palm = (tmp[0] & MIP_EVENT_INPUT_PALM) >> 4;			
+			}
+			else if(info->event_format == 2){
+				id = (tmp[0] & 0xf) - 1;
+				x = tmp[2] | ((tmp[1] & 0xf) << 8);
+				y = tmp[3] | (((tmp[1] >> 4) & 0xf) << 8);
+				pressure = tmp[4];
+				touch_major = tmp[5];
+				touch_minor = tmp[6];							
+				palm = (tmp[0] & MIP_EVENT_INPUT_PALM) >> 4;			
+			}
+			else{
+				dev_err(&info->client->dev, "%s [ERROR] Unknown event format [%d]\n", __func__, info->event_format);
+				goto ERROR;
+			}
+						
+			/////////////////////////////////
+			// MODIFY REQUIRED
+			//
+
+			//Report touchscreen event
+			if((tmp[0] & MIP_EVENT_INPUT_PRESS) == 0) {
+				//Release
+				input_mt_slot(info->input_dev, id);
+				input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 0);
+				//input_report_key(info->input_dev, BTN_TOUCH, 0);
+				//input_report_key(info->input_dev, BTN_TOOL_FINGER, 0);
+					
+				dev_dbg(&info->client->dev, "%s - Touch : ID[%d] Release\n", __func__, id);
+				
+				#if INPUT_SYNC_TYPE
+				input_sync(info->input_dev);
+				#endif
+				
+				continue;
+			}			
+			
+			//Press or Move
+			input_mt_slot(info->input_dev, id);
+			input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 1);
+			//input_report_key(info->input_dev, BTN_TOUCH, 1);
+			//input_report_key(info->input_dev, BTN_TOOL_FINGER, 1);
+			
+			input_report_abs(info->input_dev, ABS_MT_POSITION_X, x);
+			input_report_abs(info->input_dev, ABS_MT_POSITION_Y, y);
+			input_report_abs(info->input_dev, ABS_MT_PRESSURE, pressure);
+			input_report_abs(info->input_dev, ABS_MT_TOUCH_MAJOR, touch_major);
+			input_report_abs(info->input_dev, ABS_MT_TOUCH_MINOR, touch_minor);			
+			//input_report_abs(info->input_dev, ABS_MT_SUMSIZE, size);
+			//input_report_abs(info->input_dev, ABS_MT_PALM, palm);
+			
+			dev_dbg(&info->client->dev, "%s - Touch : ID[%d] X[%d] Y[%d] Z[%d] Major[%d] Minor[%d] Size[%d] Palm[%d]\n", __func__, id, x, y, pressure, touch_major, touch_minor, size, palm);
+
+			#if INPUT_SYNC_TYPE
+			input_sync(info->input_dev);
+			#endif
+			
+			//
+			/////////////////////////////////
+		}
+	}
+	
+#if !INPUT_SYNC_TYPE
+	input_sync(info->input_dev);
+#endif
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return;
+
+ERROR:	
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return;
+}
+
+/**
+* Wake-up event handler
+*/
+int mip_wakeup_event_handler(struct mip_ts_info *info, u8 *rbuf)
+{
+	u8 wbuf[4];
+	//u8 gesture_code = rbuf[2];
+	u8 gesture_code = rbuf[1];
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	
+	/////////////////////////////////
+	// MODIFY REQUIRED
+	//
+
+	//Report wake-up event
+
+	dev_dbg(&info->client->dev, "%s - gesture[%d]\n", __func__, gesture_code);
+
+	info->wakeup_gesture_code = gesture_code;
+
+	switch(gesture_code){
+		case MIP_EVENT_GESTURE_C:
+		case MIP_EVENT_GESTURE_W:
+		case MIP_EVENT_GESTURE_V:
+		case MIP_EVENT_GESTURE_M:				
+		case MIP_EVENT_GESTURE_S:				
+		case MIP_EVENT_GESTURE_Z:				
+		case MIP_EVENT_GESTURE_O:				
+		case MIP_EVENT_GESTURE_E:				
+		case MIP_EVENT_GESTURE_V_90:
+		case MIP_EVENT_GESTURE_V_180:		
+		case MIP_EVENT_GESTURE_FLICK_RIGHT:	
+		case MIP_EVENT_GESTURE_FLICK_DOWN:	
+		case MIP_EVENT_GESTURE_FLICK_LEFT:	
+		case MIP_EVENT_GESTURE_FLICK_UP:		
+		case MIP_EVENT_GESTURE_DOUBLE_TAP:
+			//Example : emulate power key
+			input_report_key(info->input_dev, KEY_POWER, 1);
+			input_sync(info->input_dev);
+			input_report_key(info->input_dev, KEY_POWER, 0);
+			input_sync(info->input_dev);
+			break;
+			
+		default:
+			//Re-enter nap mode
+			wbuf[0] = MIP_R0_CTRL;
+			wbuf[1] = MIP_R1_CTRL_POWER_STATE;
+			wbuf[2] = MIP_CTRL_POWER_LOW;
+			if(mip_i2c_write(info, wbuf, 3)){
+				dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__);
+				goto ERROR;
+			}	
+				
+			break;
+	}
+
+	//
+	//
+	/////////////////////////////////
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+	
+ERROR:
+	return 1;
+}
+
+#if MIP_USE_DEVICETREE
+/**
+* Parse device tree
+*/
+int mip_parse_devicetree(struct device *dev, struct mip_ts_info *info)
+{
+	//struct i2c_client *client = to_i2c_client(dev);
+	//struct mip_ts_info *info = i2c_get_clientdata(client);
+	struct device_node *np = dev->of_node;
+	int ret;
+	//u32 val;
+	
+	dev_dbg(dev, "%s [START]\n", __func__);
+	
+	/////////////////////////////////
+	// MODIFY REQUIRED
+	//
+	
+	//Read property
+	/*
+	ret = of_property_read_u32(np, MIP_DEVICE_NAME",max_x", &val);
+	if (ret) {
+		dev_err(dev, "%s [ERROR] max_x\n", __func__);
+		info->pdata->max_x = 1080;
+	} 
+	else {
+		info->pdata->max_x = val;
+	}
+
+	ret = of_property_read_u32(np, MIP_DEVICE_NAME",max_y", &val);
+	if (ret) {
+		dev_err(dev, "%s [ERROR] max_y\n", __func__);
+		info->pdata->max_y = 1920;
+	}
+	else {
+		info->pdata->max_y = val;
+	}
+	*/
+	
+	//Get GPIO 
+	ret = of_get_named_gpio(np, MIP_DEVICE_NAME",irq-gpio", 0);
+	if (!gpio_is_valid(ret)) {
+		dev_err(dev, "%s [ERROR] of_get_named_gpio : irq-gpio\n", __func__);
+		goto ERROR;
+	}
+	else{
+		info->pdata->gpio_intr = ret;
+	}
+
+	/*
+	ret = of_get_named_gpio(np, MIP_DEVICE_NAME",reset-gpio", 0);
+	if (!gpio_is_valid(ret)) {
+		dev_err(dev, "%s [ERROR] of_get_named_gpio : reset-gpio\n", __func__);
+		goto ERROR;
+	}
+	else{
+		info->pdata->gpio_reset = ret;
+	}
+	*/
+	
+	//Config GPIO
+	ret = gpio_request(info->pdata->gpio_intr, "irq-gpio");
+	if (ret < 0) {
+		dev_err(dev, "%s [ERROR] gpio_request : irq-gpio\n", __func__);
+		goto ERROR;
+	}	
+	gpio_direction_input(info->pdata->gpio_intr);
+
+	info->pdata->melfas_pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR_OR_NULL(info->pdata->melfas_pinctrl)) {
+		dev_err(dev, "%s:melfas pinctrl get error!\n", __func__);
+		ret = PTR_ERR(info->pdata->melfas_pinctrl);
+		goto ERROR;
+	}
+
+	info->pdata->pinctrl_default = pinctrl_lookup_state(
+			info->pdata->melfas_pinctrl, "default");
+	if (IS_ERR_OR_NULL(info->pdata->pinctrl_default)) {
+		dev_err(dev, "%s:Can not get ts default state\n", __func__);
+		ret = PTR_ERR(info->pdata->pinctrl_default);
+		goto ERROR;
+	}
+
+	ret = pinctrl_select_state(info->pdata->melfas_pinctrl,
+			info->pdata->pinctrl_default);
+	if (ret) {		
+		dev_err(dev, "%s:pinctrl select error!\n", __func__);
+		goto ERROR;
+	}
+	
+	ret = of_property_read_string(np, "mip4_ts,fw_name", &info->pdata->fw_name);
+        if (ret && (ret != -EINVAL)) {
+               	dev_err(dev, "Unable to read fw name\n");
+               	return ret;
+        }
+
+	/*
+	ret = gpio_request(info->pdata->gpio_reset, "reset-gpio");
+	if (ret < 0) {
+		dev_err(dev, "%s [ERROR] gpio_request : reset-gpio\n", __func__);
+		goto ERROR;
+	}		
+	gpio_direction_output(info->pdata->gpio_reset, 1);
+	*/
+	
+	//Set IRQ
+	//info->client->irq = gpio_to_irq(info->pdata->gpio_intr); 
+	dev_dbg(dev, "%s - gpio_to_irq : irq[%d]\n", __func__, info->client->irq);
+
+	//Get  Reset GPIO 
+	ret = of_get_named_gpio(np, MIP_DEVICE_NAME",reset-gpio", 0);
+	if (!gpio_is_valid(ret)) {
+		dev_err(dev, "%s [ERROR] of_get_named_gpio : irq-gpio\n", __func__);
+		goto ERROR;
+	}
+	else{
+		info->pdata->gpio_vdd_en = ret;
+	}
+
+	ret = gpio_request(info->pdata->gpio_vdd_en, "reset-gpio");
+	if (ret < 0) {
+		dev_err(dev, "%s [ERROR] gpio_request : reset-gpio\n", __func__);
+		goto ERROR;
+	}
+	
+	ret = of_get_named_gpio(np, MIP_DEVICE_NAME",vdd-supply", 0);
+	if (!gpio_is_valid(ret)) {
+		dev_err(dev, "%s [ERROR] of_get_named_gpio : irq-gpio\n", __func__);
+		goto ERROR;
+	}
+	else{
+		info->pdata->vdd_supply = ret;
+	}
+
+	ret = gpio_request(info->pdata->vdd_supply, "vdd-supply");
+	if (ret < 0) {
+		dev_err(dev, "%s [ERROR] gpio_request : reset-gpio\n", __func__);
+		goto ERROR;
+	}
+	//
+	/////////////////////////////////
+	
+	dev_dbg(dev, "%s [DONE]\n", __func__);	
+	return 0;
+
+ERROR:
+	dev_err(dev, "%s [ERROR]\n", __func__);	
+	return 1;
+}
+#endif
+
+/**
+* Config input interface	
+*/
+void mip_config_input(struct mip_ts_info *info)
+{
+	struct input_dev *input_dev = info->input_dev;
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+
+	/////////////////////////////
+	// MODIFY REQUIRED
+	//
+
+	set_bit(EV_SYN, input_dev->evbit);
+	set_bit(EV_ABS, input_dev->evbit);
+	set_bit(EV_KEY, input_dev->evbit);	
+	
+	//Screen
+	set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+	//set_bit(BTN_TOUCH, input_dev->keybit);
+	//set_bit(BTN_TOOL_FINGER, input_dev->keybit);	
+	
+	input_mt_init_slots(input_dev, MAX_FINGER_NUM, 0);
+	//input_mt_init_slots(input_dev, MAX_FINGER_NUM, INPUT_MT_DIRECT);
+	
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, info->max_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, info->max_y, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_PRESSURE, 0, INPUT_PRESSURE_MAX, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, INPUT_TOUCH_MAJOR_MAX, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0, INPUT_TOUCH_MINOR_MAX, 0, 0);	
+	//input_set_abs_params(input_dev, ABS_MT_SUMSIZE, 0, 255, 0, 0);
+	//input_set_abs_params(input_dev, ABS_MT_PALM, 0, 1, 0, 0);
+	
+	//Key
+	set_bit(KEY_BACK, input_dev->keybit);
+	set_bit(KEY_MENU, input_dev->keybit);
+	set_bit(KEY_HOME, input_dev->keybit);
+	
+	info->key_code[0] = KEY_BACK;
+	info->key_code[1] = KEY_HOME;
+	info->key_code[2] = KEY_MENU;
+
+#if MIP_USE_WAKEUP_GESTURE
+	set_bit(KEY_POWER, input_dev->keybit);
+#endif	
+		
+	//
+	/////////////////////////////
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);	
+	return;
+}
+
+#if MIP_USE_CALLBACK
+/**
+* Callback - get charger status
+*/
+void mip_callback_charger(struct mip_callbacks *cb, int charger_status)
+{
+	struct mip_ts_info *info = container_of(cb, struct mip_ts_info, callbacks);
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	dev_info(&info->client->dev, "%s - charger_status[%d]\n", __func__, charger_status);
+	
+	//...
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+}
+
+/**
+* Config callback functions
+*/
+void mip_config_callback(struct mip_ts_info *info)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+
+	info->register_callback = info->pdata->register_callback;
+
+	//callback functions
+	info->callbacks.inform_charger = mip_callback_charger;
+	//info->callbacks.inform_display = mip_callback_display;
+	//...
+	
+	if (info->register_callback){
+		info->register_callback(&info->callbacks);
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);	
+	return;
+}
+#endif
+
diff --git a/drivers/input/touchscreen/melfas_mip4_test/mip4_reg.h b/drivers/input/touchscreen/melfas_mip4_test/mip4_reg.h
new file mode 100755
index 00000000000..bb8572f1560
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_test/mip4_reg.h
@@ -0,0 +1,155 @@
+/*
+ * MELFAS MIP4 Touchscreen
+ *
+ * Copyright (C) 2015 MELFAS Inc.
+ *
+ *
+ * mip4_reg.h : Protocol information
+ * 
+ *
+ * Protocol Version : MIP 4.0 Rev 3.2
+ *
+ */
+
+//Address
+#define MIP_R0_INFO						0x01
+#define MIP_R1_INFO_PRODUCT_NAME			0x00
+#define MIP_R1_INFO_RESOLUTION_X			0x10
+#define MIP_R1_INFO_RESOLUTION_Y			0x12
+#define MIP_R1_INFO_NODE_NUM_X			0x14
+#define MIP_R1_INFO_NODE_NUM_Y			0x15
+#define MIP_R1_INFO_KEY_NUM				0x16
+#define MIP_R1_INFO_VERSION_BOOT			0x20
+#define MIP_R1_INFO_VERSION_CORE			0x22
+#define MIP_R1_INFO_VERSION_CUSTOM		0x24
+#define MIP_R1_INFO_VERSION_PARAM		0x26
+#define MIP_R1_INFO_SECT_BOOT_START		0x30
+#define MIP_R1_INFO_SECT_BOOT_END		0x31
+#define MIP_R1_INFO_SECT_CORE_START		0x32
+#define MIP_R1_INFO_SECT_CORE_END		0x33
+#define MIP_R1_INFO_SECT_CUSTOM_START	0x34
+#define MIP_R1_INFO_SECT_CUSTOM_END		0x35
+#define MIP_R1_INFO_SECT_PARAM_START	0x36
+#define MIP_R1_INFO_SECT_PARAM_END		0x37
+#define MIP_R1_INFO_BUILD_DATE			0x40
+#define MIP_R1_INFO_BUILD_TIME			0x44
+#define MIP_R1_INFO_CHECKSUM_PRECALC	0x48
+#define MIP_R1_INFO_CHECKSUM_REALTIME	0x4A
+#define MIP_R1_INFO_CHECKSUM_CALC		0x4C
+#define MIP_R1_INFO_PROTOCOL_NAME		0x50
+#define MIP_R1_INFO_PROTOCOL_VERSION	0x58
+#define MIP_R1_INFO_IC_ID					0x70
+
+#define MIP_R0_EVENT						0x02
+#define MIP_R1_EVENT_SUPPORTED_FUNC		0x00
+#define MIP_R1_EVENT_FORMAT				0x04
+#define MIP_R1_EVENT_SIZE					0x06
+#define MIP_R1_EVENT_PACKET_INFO			0x10
+#define MIP_R1_EVENT_PACKET_DATA			0x11
+
+#define MIP_R0_CTRL						0x06	
+#define MIP_R1_CTRL_READY_STATUS			0x00
+#define MIP_R1_CTRL_EVENT_READY			0x01
+#define MIP_R1_CTRL_MODE					0x10
+#define MIP_R1_CTRL_EVENT_TRIGGER_TYPE	0x11
+#define MIP_R1_CTRL_RECALIBRATE			0x12
+#define MIP_R1_CTRL_POWER_STATE			0x13
+#define MIP_R1_CTRL_GESTURE_TYPE			0x14
+#define MIP_R1_CTRL_DISABLE_ESD_ALERT	0x18
+#define MIP_R1_CTRL_CHARGER_MODE			0x19
+#define MIP_R1_CTRL_GLOVE_MODE			0x1A
+#define MIP_R1_CTRL_WINDOW_MODE			0x1B
+#define MIP_R1_CTRL_PALM_REJECTION		0x1C
+#define MIP_R1_CTRL_EDGE_EXPAND			0x1D
+
+#define MIP_R0_PARAM						0x08
+#define MIP_R1_PARAM_BUFFER_ADDR			0x00
+#define MIP_R1_PARAM_PROTOCOL			0x04
+#define MIP_R1_PARAM_MODE					0x10
+
+#define MIP_R0_TEST						0x0A
+#define MIP_R1_TEST_BUF_ADDR				0x00
+#define MIP_R1_TEST_PROTOCOL				0x02
+#define MIP_R1_TEST_TYPE					0x10
+#define MIP_R1_TEST_DATA_FORMAT			0x20
+#define MIP_R1_TEST_ROW_NUM				0x20
+#define MIP_R1_TEST_COL_NUM				0x21
+#define MIP_R1_TEST_BUFFER_COL_NUM		0x22
+#define MIP_R1_TEST_COL_AXIS				0x23
+#define MIP_R1_TEST_KEY_NUM				0x24
+#define MIP_R1_TEST_DATA_TYPE			0x25
+
+#define MIP_R0_IMAGE						0x0C
+#define MIP_R1_IMAGE_BUF_ADDR			0x00
+#define MIP_R1_IMAGE_PROTOCOL_ID			0x04
+#define MIP_R1_IMAGE_TYPE					0x10
+#define MIP_R1_IMAGE_DATA_FORMAT			0x20
+#define MIP_R1_IMAGE_ROW_NUM				0x20
+#define MIP_R1_IMAGE_COL_NUM				0x21
+#define MIP_R1_IMAGE_BUFFER_COL_NUM		0x22
+#define MIP_R1_IMAGE_COL_AXIS			0x23
+#define MIP_R1_IMAGE_KEY_NUM				0x24
+#define MIP_R1_IMAGE_DATA_TYPE			0x25
+#define MIP_R1_IMAGE_FINGER_NUM			0x30
+#define MIP_R1_IMAGE_FINGER_AREA			0x31
+
+#define MIP_R0_LOG							0x10
+#define MIP_R1_LOG_TRIGGER				0x14
+
+//Value
+#define MIP_EVENT_INPUT_PRESS			0x80
+#define MIP_EVENT_INPUT_SCREEN			0x40
+#define MIP_EVENT_INPUT_HOVER			0x20
+#define MIP_EVENT_INPUT_PALM				0x10
+#define MIP_EVENT_INPUT_ID				0x0F
+
+#define MIP_EVENT_GESTURE_C				1
+#define MIP_EVENT_GESTURE_W				2
+#define MIP_EVENT_GESTURE_V				3	
+#define MIP_EVENT_GESTURE_M				4
+#define MIP_EVENT_GESTURE_S				5
+#define MIP_EVENT_GESTURE_Z				6
+#define MIP_EVENT_GESTURE_O				7
+#define MIP_EVENT_GESTURE_E				8
+#define MIP_EVENT_GESTURE_V_90			9
+#define MIP_EVENT_GESTURE_V_180			10
+#define MIP_EVENT_GESTURE_FLICK_RIGHT	20			
+#define MIP_EVENT_GESTURE_FLICK_DOWN	21		
+#define MIP_EVENT_GESTURE_FLICK_LEFT	22	
+#define MIP_EVENT_GESTURE_FLICK_UP		23
+#define MIP_EVENT_GESTURE_DOUBLE_TAP	24
+#define MIP_EVENT_GESTURE_ALL			0xFFFFFFFF
+
+#define MIP_ALERT_ESD					1
+#define MIP_ALERT_WAKEUP				2
+#define MIP_ALERT_INPUTTYPE			3
+
+#define MIP_CTRL_STATUS_NONE			0x05
+#define MIP_CTRL_STATUS_READY		0xA0
+#define MIP_CTRL_STATUS_LOG			0x77
+
+#define MIP_CTRL_MODE_NORMAL			0		
+#define MIP_CTRL_MODE_PARAM			1
+#define MIP_CTRL_MODE_TEST_CM		2
+
+#define MIP_CTRL_POWER_ACTIVE		0
+#define MIP_CTRL_POWER_LOW			1
+
+#define MIP_TEST_TYPE_NONE			0
+#define MIP_TEST_TYPE_CM_DELTA		1
+#define MIP_TEST_TYPE_CM_ABS			2
+#define MIP_TEST_TYPE_CM_JITTER		3
+#define MIP_TEST_TYPE_SHORT			4
+
+#define MIP_IMG_TYPE_NONE				0
+#define MIP_IMG_TYPE_INTENSITY		1
+#define MIP_IMG_TYPE_RAWDATA			2
+#define MIP_IMG_TYPE_WAIT				255
+
+#define MIP_TRIGGER_TYPE_NONE		0
+#define MIP_TRIGGER_TYPE_INTR		1
+#define MIP_TRIGGER_TYPE_REG			2
+
+#define MIP_LOG_MODE_NONE				0
+#define MIP_LOG_MODE_TRIG				1
+
diff --git a/drivers/input/touchscreen/melfas_mip4_testplus/Kconfig b/drivers/input/touchscreen/melfas_mip4_testplus/Kconfig
new file mode 100755
index 00000000000..4f2c27684fb
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_testplus/Kconfig
@@ -0,0 +1,42 @@
+#
+# Kconfig for MELFAS MIP4 Touchscreen Driver
+#
+config TOUCHSCREEN_MELFAS_MMS438
+        tristate "MELFAS MMS438 Touchscreen"
+        depends on I2C
+        help
+          Say Y here if you have a MELFAS MMS438 touchscreen device in your system.
+
+          If unsure, say N.
+
+          To compile this driver as a module, choose M here: the module will be called mip4_ts.
+
+config TOUCHSCREEN_MELFAS_MMS449
+        tristate "MELFAS MMS449 Touchscreen"
+        depends on I2C
+        help
+          Say Y here if you have a MELFAS MMS449 touchscreen device in your system.
+
+          If unsure, say N.
+
+          To compile this driver as a module, choose M here: the module will be called mip4_ts.
+
+config TOUCHSCREEN_MELFAS_MMS458
+        tristate "MELFAS MMS458 Touchscreen"
+        depends on I2C
+        help
+          Say Y here if you have a MELFAS MMS458 touchscreen device in your system.
+
+          If unsure, say N.
+
+          To compile this driver as a module, choose M here: the module will be called mip4_ts.
+
+config TOUCHSCREEN_MELFAS_MIT300
+        tristate "MELFAS MIT300 Touchscreen"
+        depends on I2C
+        help
+          Say Y here if you have a MELFAS MIT300 touchscreen device in your system.
+
+          If unsure, say N.
+
+          To compile this driver as a module, choose M here: the module will be called mip4_ts.
diff --git a/drivers/input/touchscreen/melfas_mip4_testplus/Makefile b/drivers/input/touchscreen/melfas_mip4_testplus/Makefile
new file mode 100755
index 00000000000..feac86c83c6
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_testplus/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for MELFAS MIP4 Touchscreen driver
+#
+
+obj-$(CONFIG_TOUCHSCREEN_MELFAS_MMS449)	+= mip4.o mip4_mod.o mip4_debug.o mip4_fw_mms438.o
+
diff --git a/drivers/input/touchscreen/melfas_mip4_testplus/mip4.c b/drivers/input/touchscreen/melfas_mip4_testplus/mip4.c
new file mode 100755
index 00000000000..c9c5b5b3dd9
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_testplus/mip4.c
@@ -0,0 +1,1460 @@
+/*
+ * MELFAS MIP4 Touchscreen
+ *
+ * Copyright (C) 2015 MELFAS Inc.
+ *
+ *
+ * mip4.c : Main functions
+ *
+ *
+ * Version : 2015.05.08
+ *
+ */
+//#define DEBUG 1
+#include "mip4.h"
+
+
+#if defined(CONFIG_FB)
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+#endif
+
+#define TS_INFO_MAX 512
+
+static struct class *touchscreen_class;
+static struct mip_ts_info *class_ts_info;
+
+#if MIP_USE_WAKEUP_GESTURE
+struct wake_lock mip_wake_lock;
+#endif
+
+static ssize_t class_melfs_ts_info_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	return snprintf(buf, TS_INFO_MAX, "%s\n", "MELFAS_MMS449");
+}
+
+static CLASS_ATTR(ts_info, S_IRUSR, class_melfs_ts_info_show, NULL);
+
+static ssize_t class_melfs_ts_version_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	u8 data[256] = {0};
+	u8 rbuf[16] = {0};
+
+	mip_get_fw_version(class_ts_info, rbuf);
+	sprintf(data, "%02X.%02X_%02X.%02X_%02X.%02X_%02X"".%02X",
+			rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4], rbuf[5], rbuf[6], rbuf[7]);
+	return snprintf(buf, TS_INFO_MAX, "%s\n", data);
+}
+
+static CLASS_ATTR(ts_version, S_IRUSR, class_melfs_ts_version_show, NULL);
+
+/**
+* Reboot chip
+*
+* Caution : IRQ must be disabled before mip_reboot and enabled after mip_reboot.
+*/
+void mip_reboot(struct mip_ts_info *info)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(info->client->dev.parent);
+		
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	
+	i2c_lock_adapter(adapter);
+	
+	mip_power_off(info);
+	mip_power_on(info);
+	mdelay(10);
+	i2c_unlock_adapter(adapter);
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+}
+
+/**
+* I2C Read
+*/
+int mip_i2c_read(struct mip_ts_info *info, char *write_buf, unsigned int write_len, char *read_buf, unsigned int read_len)
+{
+	int retry = I2C_RETRY_COUNT;
+	int res;
+
+	struct i2c_msg msg[] = {
+		{
+			.addr = info->client->addr,
+			.flags = 0,
+			.buf = write_buf,
+			.len = write_len,
+		}, {
+			.addr = info->client->addr,
+			.flags = I2C_M_RD,
+			.buf = read_buf,
+			.len = read_len,
+		},
+	};
+
+	while(retry--){	
+		res = i2c_transfer(info->client->adapter, msg, ARRAY_SIZE(msg));
+
+		if (res == ARRAY_SIZE(msg))
+			goto DONE;
+		else if (res < 0)
+			dev_err(&info->client->dev, "%s [ERROR] i2c_transfer - errno[%d]\n",
+					__func__, res);
+		else if (res != ARRAY_SIZE(msg))
+			dev_err(&info->client->dev, "%s [ERROR] i2c_transfer - size[%d] result[%d]\n",
+					__func__, (int)ARRAY_SIZE(msg), res);
+		else
+			dev_err(&info->client->dev, "%s [ERROR] unknown error [%d]\n", __func__, res);
+	}
+
+	goto ERROR_REBOOT;
+	
+ERROR_REBOOT:
+	mip_reboot(info);
+	return 1;
+	
+DONE:
+	return 0;
+}
+
+
+/**
+* I2C Read (Continue)
+*/
+int mip_i2c_read_next(struct mip_ts_info *info, char *write_buf, unsigned int write_len, char *read_buf, int start_idx, unsigned int read_len)
+{
+	int retry = I2C_RETRY_COUNT;
+	int res;
+	u8 rbuf[read_len];
+
+	/*
+	while(retry--){
+		res = i2c_master_recv(info->client, rbuf, read_len);
+		
+		if(res == read_len){
+			goto DONE;
+		}
+		else if(res < 0){
+			dev_err(&info->client->dev, "%s [ERROR] i2c_master_recv - errno [%d]\n", __func__, res);
+		}
+		else if(res != read_len){
+			dev_err(&info->client->dev, "%s [ERROR] length mismatch - read[%d] result[%d]\n", __func__, read_len, res);
+		}			
+		else{
+			dev_err(&info->client->dev, "%s [ERROR] unknown error [%d]\n", __func__, res);
+		}
+	}
+	*/
+
+	struct i2c_msg msg[] = {
+		{
+			.addr = info->client->addr,
+			.flags = 0,
+			.buf = write_buf,
+			.len = write_len,
+		}, {
+			.addr = info->client->addr,
+			.flags = I2C_M_RD,
+			.buf = rbuf,
+			.len = read_len,
+		},
+	};
+	
+	while(retry--){	
+		res = i2c_transfer(info->client->adapter, msg, ARRAY_SIZE(msg));
+
+		if(res == ARRAY_SIZE(msg)){
+			goto DONE;
+		}
+		else if(res < 0){
+			dev_err(&info->client->dev, "%s [ERROR] i2c_transfer - errno[%d]\n", __func__, res);
+		}
+		else if(res != ARRAY_SIZE(msg)){
+			dev_err(&info->client->dev, "%s [ERROR] i2c_transfer - size[%d] result[%d]\n",
+					__func__, (int)ARRAY_SIZE(msg), res);
+		}			
+		else{
+			dev_err(&info->client->dev, "%s [ERROR] unknown error [%d]\n", __func__, res);
+		}
+	}
+	
+	goto ERROR_REBOOT;
+	
+ERROR_REBOOT:
+	mip_reboot(info);
+	return 1;
+
+DONE:
+	memcpy(&read_buf[start_idx], rbuf, read_len);
+	
+	return 0;
+}
+
+/**
+* I2C Write
+*/
+int mip_i2c_write(struct mip_ts_info *info, char *write_buf, unsigned int write_len)
+{
+	int retry = I2C_RETRY_COUNT;
+	int res;
+
+	while(retry--){
+		res = i2c_master_send(info->client, write_buf, write_len);
+
+		if(res == write_len){
+			goto DONE;
+		}
+		else if(res < 0){
+			dev_err(&info->client->dev, "%s [ERROR] i2c_master_send - errno [%d]\n", __func__, res);
+		}
+		else if(res != write_len){
+			dev_err(&info->client->dev, "%s [ERROR] length mismatch - write[%d] result[%d]\n", __func__, write_len, res);
+		}			
+		else{
+			dev_err(&info->client->dev, "%s [ERROR] unknown error [%d]\n", __func__, res);
+		}
+	}
+	
+	goto ERROR_REBOOT;
+	
+ERROR_REBOOT:
+	mip_reboot(info);
+	return 1;
+	
+DONE:
+	return 0;
+}
+
+/**
+* Enable device
+*/
+int mip_enable(struct mip_ts_info *info)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	
+	if (info->enabled){
+		dev_err(&info->client->dev, "%s [ERROR] device already enabled\n", __func__);
+		goto EXIT;
+	}
+
+#if MIP_USE_WAKEUP_GESTURE
+	mip_set_power_state(info, MIP_CTRL_POWER_ACTIVE);
+
+	if(wake_lock_active(&mip_wake_lock)){
+		wake_unlock(&mip_wake_lock);
+		dev_dbg(&info->client->dev, "%s - wake_unlock\n", __func__);
+	}
+	
+	info->nap_mode = false;
+	dev_dbg(&info->client->dev, "%s - nap mode : off\n", __func__);	
+#else	
+	mip_power_on(info);
+#endif
+
+#if 1
+	if(info->disable_esd == true){
+		//Disable ESD alert
+		mip_disable_esd_alert(info);
+	}	
+#endif
+
+	mutex_lock(&info->lock);
+
+	enable_irq(info->client->irq);
+	info->enabled = true;
+
+	mutex_unlock(&info->lock);
+	
+EXIT:
+	dev_info(&info->client->dev, MIP_DEVICE_NAME" - Enabled\n");
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+}
+
+/**
+* Disable device
+*/
+int mip_disable(struct mip_ts_info *info)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	
+	if (!info->enabled){
+		dev_err(&info->client->dev, "%s [ERROR] device already disabled\n", __func__);
+		goto EXIT;
+	}
+	
+	mip_clear_input(info);
+
+#if MIP_USE_WAKEUP_GESTURE
+	info->wakeup_gesture_code = 0;
+
+	mip_set_wakeup_gesture_type(info, MIP_EVENT_GESTURE_ALL);
+	mip_set_power_state(info, MIP_CTRL_POWER_LOW);
+	
+	info->nap_mode = true;
+	dev_dbg(&info->client->dev, "%s - nap mode : on\n", __func__);
+
+	if(!wake_lock_active(&mip_wake_lock)) {
+		wake_lock(&mip_wake_lock);
+		dev_dbg(&info->client->dev, "%s - wake_lock\n", __func__);
+	}
+#else
+	mutex_lock(&info->lock);
+
+	disable_irq(info->client->irq);
+	mip_power_off(info);
+
+	mutex_unlock(&info->lock);	
+#endif
+
+	info->enabled = false;
+
+EXIT:	
+	dev_info(&info->client->dev, MIP_DEVICE_NAME" - Disabled\n");
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+}
+
+#if MIP_USE_INPUT_OPEN_CLOSE
+/**
+* Open input device
+*/
+static int mip_input_open(struct input_dev *dev) 
+{
+	struct mip_ts_info *info = input_get_drvdata(dev);
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	if(info->init == true){
+		info->init = false;
+	} 
+	else{
+		mip_enable(info);
+	}
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	
+	return 0;
+}
+
+/**
+* Close input device
+*/
+static void mip_input_close(struct input_dev *dev) 
+{
+	struct mip_ts_info *info = input_get_drvdata(dev);
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	mip_disable(info);
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+
+	return;
+}
+#endif
+
+/**
+* Get ready status
+*/
+int mip_get_ready_status(struct mip_ts_info *info)
+{
+	u8 wbuf[16];
+	u8 rbuf[16];
+	int ret = 0;
+	
+	//dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	wbuf[0] = MIP_R0_CTRL;
+	wbuf[1] = MIP_R1_CTRL_READY_STATUS;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 1)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_read\n", __func__);
+		goto ERROR;
+	}
+	ret = rbuf[0];
+
+	//check status
+	if((ret == MIP_CTRL_STATUS_NONE) || (ret == MIP_CTRL_STATUS_LOG) || (ret == MIP_CTRL_STATUS_READY)){
+		//dev_dbg(&info->client->dev, "%s - status [0x%02X]\n", __func__, ret);
+	}
+	else{
+		dev_err(&info->client->dev, "%s [ERROR] Unknown status [0x%02X]\n", __func__, ret);
+		goto ERROR;
+	}
+
+	if(ret == MIP_CTRL_STATUS_LOG){
+		//skip log event
+		wbuf[0] = MIP_R0_LOG;
+		wbuf[1] = MIP_R1_LOG_TRIGGER;
+		wbuf[2] = 0;
+		if(mip_i2c_write(info, wbuf, 3)){
+			dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__);
+		}
+	}
+	
+	//dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return ret;
+	
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return -1;
+}
+
+/**
+* Read chip firmware version
+*/
+int mip_get_fw_version(struct mip_ts_info *info, u8 *ver_buf)
+{
+	u8 rbuf[8];
+	u8 wbuf[2];
+	int i;
+	
+	wbuf[0] = MIP_R0_INFO;
+	wbuf[1] = MIP_R1_INFO_VERSION_BOOT;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 8)){
+		goto ERROR;
+	};
+
+	for(i = 0; i < MIP_FW_MAX_SECT_NUM; i++){
+		ver_buf[0 + i * 2] = rbuf[1 + i * 2];
+		ver_buf[1 + i * 2] = rbuf[0 + i * 2];
+	}	
+	
+	return 0;
+
+ERROR:
+	//memset(ver_buf, 0xFF, sizeof(ver_buf));
+	
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return 1;	
+}
+
+/**
+* Read chip firmware version for u16
+*/
+int mip_get_fw_version_u16(struct mip_ts_info *info, u16 *ver_buf_u16)
+{
+	u8 rbuf[8];
+	int i;
+	
+	if(mip_get_fw_version(info, rbuf)){
+		goto ERROR;
+	}
+
+	for(i = 0; i < MIP_FW_MAX_SECT_NUM; i++){
+		ver_buf_u16[i] = (rbuf[0 + i * 2] << 8) | rbuf[1 + i * 2];
+	}	
+	
+	return 0;
+
+ERROR:
+	//memset(ver_buf_u16, 0xFFFF, sizeof(ver_buf_u16));
+	
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return 1;	
+}
+
+/**
+* Set power state
+*/
+int mip_set_power_state(struct mip_ts_info *info, u8 mode)
+{
+	u8 wbuf[3];
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	dev_dbg(&info->client->dev, "%s - mode[%02X]\n", __func__, mode);
+	
+	wbuf[0] = MIP_R0_CTRL;
+	wbuf[1] = MIP_R1_CTRL_POWER_STATE;
+	wbuf[2] = mode;
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__);
+		goto ERROR;
+	}	
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return 1;
+}
+
+/**
+* Set wake-up gesture type
+*/
+int mip_set_wakeup_gesture_type(struct mip_ts_info *info, u32 type)
+{
+	u8 wbuf[6];
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	dev_dbg(&info->client->dev, "%s - type[%08X]\n", __func__, type);
+	
+	wbuf[0] = MIP_R0_CTRL;
+	wbuf[1] = MIP_R1_CTRL_GESTURE_TYPE;
+	wbuf[2] = (type >> 24) & 0xFF;
+	wbuf[3] = (type >> 16) & 0xFF;
+	wbuf[4] = (type >> 8) & 0xFF;
+	wbuf[5] = type & 0xFF;
+	if(mip_i2c_write(info, wbuf, 6)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__);
+		goto ERROR;
+	}	
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return 1;
+}
+
+/**
+* Disable ESD alert
+*/
+int mip_disable_esd_alert(struct mip_ts_info *info)
+{
+	u8 wbuf[4];
+	u8 rbuf[4];
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	
+	wbuf[0] = MIP_R0_CTRL;
+	wbuf[1] = MIP_R1_CTRL_DISABLE_ESD_ALERT;
+	wbuf[2] = 1;
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__);
+		goto ERROR;
+	}	
+
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 1)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_read\n", __func__);
+		goto ERROR;
+	}	
+
+	if(rbuf[0] != 1){
+		dev_dbg(&info->client->dev, "%s [ERROR] failed\n", __func__);
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+	
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return 1;
+}
+
+/**
+* Alert event handler - ESD
+*/
+static int mip_alert_handler_esd(struct mip_ts_info *info, u8 *rbuf)
+{
+	//u8 frame_cnt = rbuf[2];
+	u8 frame_cnt = rbuf[1];
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	dev_dbg(&info->client->dev, "%s - frame_cnt[%d]\n", __func__, frame_cnt);
+
+	if(frame_cnt == 0){
+		//sensor crack, not ESD
+		info->esd_cnt++;
+		dev_dbg(&info->client->dev, "%s - esd_cnt[%d]\n", __func__, info->esd_cnt);
+
+		if(info->disable_esd == true){
+			mip_disable_esd_alert(info);
+			info->esd_cnt = 0;
+		}
+		else if(info->esd_cnt > ESD_COUNT_FOR_DISABLE){
+			//Disable ESD alert
+			if(mip_disable_esd_alert(info)){
+			}
+			else{
+				info->disable_esd = true;
+				info->esd_cnt = 0;
+			}
+		}
+		else{
+			//Reset chip
+			mip_reboot(info);
+		}
+	}
+	else{
+		//ESD detected
+		//Reset chip
+		mip_reboot(info);
+		info->esd_cnt = 0;
+	}
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+
+//ERROR:	
+	//dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	//return 1;
+}
+
+/**
+* Alert event handler - Wake-up
+*/
+static int mip_alert_handler_wakeup(struct mip_ts_info *info, u8 *rbuf)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	if(mip_wakeup_event_handler(info, rbuf)){
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+	
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return 1;
+}
+
+/**
+* Alert event handler - Input type
+*/
+static int mip_alert_handler_inputtype(struct mip_ts_info *info, u8 *rbuf)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	//?
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+	
+//ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return 1;
+}
+
+/**
+* Interrupt handler
+*/
+static irqreturn_t mip_interrupt(int irq, void *dev_id)
+{
+	struct mip_ts_info *info = dev_id;
+	struct i2c_client *client = info->client;
+	u8 wbuf[8];
+	u8 rbuf[256];
+	unsigned int size = 0;
+	//int event_size = info->event_size;
+	u8 category = 0;
+	u8 alert_type = 0;
+	
+	dev_dbg(&client->dev, "%s [START]\n", __func__);
+#if 0
+ 	//Read first packet
+	wbuf[0] = MIP_R0_EVENT;
+	wbuf[1] = MIP_R1_EVENT_PACKET_INFO;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, (1 + event_size))){
+		dev_err(&client->dev, "%s [ERROR] Read packet info\n", __func__);
+		goto ERROR;
+	}
+
+	//Check event
+	size = (rbuf[0] & 0x7F);	
+	category = ((rbuf[0] >> 7) & 0x1);
+	dev_dbg(&client->dev, "%s - packet info : size[%d] category[%d]\n", __func__, size, category);	
+
+	//Check size
+	if(size <= 0){
+		goto EXIT;
+	}
+	
+	if(category == 0){
+		//Touch event
+		if(size > event_size){
+			//Read next packet
+			wbuf[0] = MIP_R0_EVENT;
+			wbuf[1] = MIP_R1_EVENT_PACKET_INFO + (1 + event_size);
+			if(mip_i2c_read_next(info, wbuf, 2, rbuf, (1 + event_size), (size - event_size))){
+				dev_err(&client->dev, "%s [ERROR] Read next packet\n", __func__);
+				goto ERROR;
+			}
+		}
+		
+		info->esd_cnt = 0;
+		
+		mip_input_event_handler(info, size, rbuf);
+	}
+#else
+	//Read packet info
+	wbuf[0] = MIP_R0_EVENT;
+	wbuf[1] = MIP_R1_EVENT_PACKET_INFO;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 1)){
+		dev_err(&client->dev, "%s [ERROR] Read packet info\n", __func__);
+		goto ERROR;
+	}
+
+	size = (rbuf[0] & 0x7F);	
+	category = ((rbuf[0] >> 7) & 0x1);
+	dev_dbg(&client->dev, "%s - packet info : size[%d] category[%d]\n", __func__, size, category);	
+	
+	//Check size
+	if(size <= 0){
+		dev_err(&client->dev, "%s [ERROR] Packet size [%d]\n", __func__, size);
+		goto EXIT;
+	}
+
+	//Read packet data
+	wbuf[0] = MIP_R0_EVENT;
+	wbuf[1] = MIP_R1_EVENT_PACKET_DATA;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, size)){
+		dev_err(&client->dev, "%s [ERROR] Read packet data\n", __func__);
+		goto ERROR;
+	}
+
+	//Event handler
+	if(category == 0){
+		//Touch event
+		info->esd_cnt = 0;
+		
+		mip_input_event_handler(info, size, rbuf);
+	}
+#endif
+	else{
+		//Alert event
+		//alert_type = rbuf[1];
+		alert_type = rbuf[0];
+		
+		dev_dbg(&client->dev, "%s - alert type [%d]\n", __func__, alert_type);
+				
+		if(alert_type == MIP_ALERT_ESD){
+			//ESD detection
+			if(mip_alert_handler_esd(info, rbuf)){
+				goto ERROR;
+			}
+		}
+		else if(alert_type == MIP_ALERT_WAKEUP){
+			//Wake-up gesture
+			if(mip_alert_handler_wakeup(info, rbuf)){
+				goto ERROR;
+			}
+		}
+		else if(alert_type == MIP_ALERT_INPUTTYPE){
+			//Input type
+			if(mip_alert_handler_inputtype(info, rbuf)){
+				goto ERROR;
+			}
+		}
+		else{
+			dev_err(&client->dev, "%s [ERROR] Unknown alert type [%d]\n", __func__, alert_type);
+			goto ERROR;
+		}		
+	}
+
+EXIT:
+	dev_dbg(&client->dev, "%s [DONE]\n", __func__);
+	return IRQ_HANDLED;
+	
+ERROR:
+	if(RESET_ON_EVENT_ERROR){	
+		dev_info(&client->dev, "%s - Reset on error\n", __func__);
+		
+		mip_disable(info);
+		mip_clear_input(info);
+		mip_enable(info);
+	}
+
+	dev_err(&client->dev, "%s [ERROR]\n", __func__);
+	return IRQ_HANDLED;
+}
+
+/**
+* Update firmware from kernel built-in binary
+*/
+int mip_fw_update_from_kernel(struct mip_ts_info *info)
+{
+	const char *fw_name = info->pdata->fw_name;
+	const struct firmware *fw;
+	int retires = 3;
+	int ret;
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	//Disable IRQ	
+	mutex_lock(&info->lock);	
+	disable_irq(info->client->irq);
+
+	//Get firmware
+	request_firmware(&fw, fw_name, &info->client->dev);
+	
+	if (!fw) {
+		dev_err(&info->client->dev, "%s [ERROR] request_firmware\n", __func__);
+		enable_irq(info->client->irq);
+		mutex_unlock(&info->lock);
+		goto ERROR;
+	}
+
+	//Update fw
+	do {
+		ret = mip_flash_fw(info, fw->data, fw->size, false, true);
+		if(ret >= fw_err_none){
+			break;
+		}
+	} while (--retires);
+
+	if (!retires) {
+		dev_err(&info->client->dev, "%s [ERROR] mip_flash_fw failed\n", __func__);
+		ret = -1;
+	}
+	
+	release_firmware(fw);
+
+	//Enable IRQ
+	enable_irq(info->client->irq);	
+	mutex_unlock(&info->lock);
+
+	if(ret < 0){
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return -1;
+}
+
+/**
+* Update firmware from external storage
+*/
+int mip_fw_update_from_storage(struct mip_ts_info *info, char *path, bool force)
+{
+	struct file *fp; 
+	mm_segment_t old_fs;
+	size_t fw_size, nread;
+	int ret = 0;
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	//Disable IRQ
+	mutex_lock(&info->lock);	
+ 	disable_irq(info->client->irq);
+
+	//Get firmware
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);  
+
+	//fp = filp_open(EXTERNAL_FW_PATH, O_RDONLY, S_IRUSR);
+	fp = filp_open(path, O_RDONLY, S_IRUSR);
+	if (IS_ERR(fp)) {
+		dev_err(&info->client->dev, "%s [ERROR] file_open - path[%s]\n", __func__, path);
+		ret = fw_err_file_open;
+		goto ERROR;
+	}
+	
+ 	fw_size = fp->f_path.dentry->d_inode->i_size;
+	if (0 < fw_size) {
+		//Read firmware
+		unsigned char *fw_data;
+		fw_data = kzalloc(fw_size, GFP_KERNEL);
+		nread = vfs_read(fp, (char __user *)fw_data, fw_size, &fp->f_pos);
+		dev_dbg(&info->client->dev, "%s - path[%s] size[%u]\n", __func__, path,
+				(unsigned int)fw_size);
+		
+		if (nread != fw_size) {
+			dev_err(&info->client->dev, "%s [ERROR] vfs_read - size[%d] read[%d]\n",
+					__func__, (int)fw_size, (int)nread);
+			ret = fw_err_file_read;
+		}
+		else{
+			//Update firmware
+			ret = mip_flash_fw(info, fw_data, fw_size, force, true);
+		}
+		
+		kfree(fw_data);
+	}
+	else{
+		dev_err(&info->client->dev, "%s [ERROR] fw_size [%d]\n", __func__,
+				(int)fw_size);
+		ret = fw_err_file_read;
+	}
+	
+ 	filp_close(fp, current->files);
+
+ERROR:
+	set_fs(old_fs);	
+
+	//Enable IRQ
+	enable_irq(info->client->irq);	
+	mutex_unlock(&info->lock);
+
+	if(ret == 0){
+		dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	}
+	else{
+		dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	}
+	
+	return ret;
+}
+
+static ssize_t mip_sys_fw_update(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mip_ts_info *info = i2c_get_clientdata(client);
+	int result = 0;
+	u8 data[255];
+	int ret = 0;
+	
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	ret = mip_fw_update_from_storage(info, info->fw_path_ext, true);
+	
+	switch(ret){
+		case fw_err_none:
+			sprintf(data, "F/W update success.\n");
+			break;
+		case fw_err_uptodate:
+			sprintf(data, "F/W is already up-to-date.\n");
+			break;
+		case fw_err_download:
+			sprintf(data, "F/W update failed : Download error\n");
+			break;
+		case fw_err_file_type:
+			sprintf(data, "F/W update failed : File type error\n");
+			break;
+		case fw_err_file_open:			
+			sprintf(data, "F/W update failed : File open error [%s]\n", info->fw_path_ext);
+			break;
+		case fw_err_file_read:
+			sprintf(data, "F/W update failed : File read error\n");
+			break;
+		default:
+			sprintf(data, "F/W update failed.\n");
+			break;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	
+	strcat(info->print_buf, data);
+	result = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return result;
+}
+static DEVICE_ATTR(fw_update, 0666, mip_sys_fw_update, NULL);
+
+/**
+* Sysfs attr info
+*/
+static struct attribute *mip_attrs[] = {
+	&dev_attr_fw_update.attr,
+	NULL,
+};
+
+/**
+* Sysfs attr group info
+*/
+static const struct attribute_group mip_attr_group = {
+	.attrs = mip_attrs,
+};
+
+/**
+* Initial config
+*/
+static int mip_init_config(struct mip_ts_info *info)
+{
+	u8 wbuf[8];
+	u8 rbuf[64];
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	//Product name
+	wbuf[0] = MIP_R0_INFO;
+	wbuf[1] = MIP_R1_INFO_PRODUCT_NAME;
+	mip_i2c_read(info, wbuf, 2, rbuf, 16);
+	memcpy(info->product_name, rbuf, 16);
+	dev_dbg(&info->client->dev, "%s - product_name[%s]\n", __func__, info->product_name);
+
+	//Firmware version
+	mip_get_fw_version(info, rbuf);
+	memcpy(info->fw_version, rbuf, 8);
+	dev_info(&info->client->dev, "%s - F/W Version : %02X.%02X %02X.%02X %02X.%02X %02X.%02X\n", __func__, info->fw_version[0], info->fw_version[1], info->fw_version[2], info->fw_version[3], info->fw_version[4], info->fw_version[5], info->fw_version[6], info->fw_version[7]);	
+
+	//Resolution
+	wbuf[0] = MIP_R0_INFO;
+	wbuf[1] = MIP_R1_INFO_RESOLUTION_X;
+	mip_i2c_read(info, wbuf, 2, rbuf, 7);
+
+#if MIP_AUTOSET_RESOLUTION
+	//Set resolution using chip info
+	info->max_x = (rbuf[0]) | (rbuf[1] << 8);
+	info->max_y = (rbuf[2]) | (rbuf[3] << 8);
+#else
+	//Set resolution using platform data
+	info->max_x = info->pdata->max_x;
+	info->max_y = info->pdata->max_y;
+#endif
+	dev_dbg(&info->client->dev, "%s - max_x[%d] max_y[%d]\n", __func__, info->max_x, info->max_y);
+
+	//Node info
+	info->node_x = rbuf[4];
+	info->node_y = rbuf[5];
+	info->node_key = rbuf[6];
+	dev_dbg(&info->client->dev, "%s - node_x[%d] node_y[%d] node_key[%d]\n", __func__, info->node_x, info->node_y, info->node_key);
+
+	//Key info
+	if(info->node_key > 0){
+		//Enable touchkey
+		info->key_enable = true;
+		info->key_num = info->node_key;
+	}
+
+	//Protocol
+#if MIP_AUTOSET_EVENT_FORMAT
+	wbuf[0] = MIP_R0_EVENT;
+	wbuf[1] = MIP_R1_EVENT_SUPPORTED_FUNC;
+	mip_i2c_read(info, wbuf, 2, rbuf, 7);
+	info->event_format = (rbuf[4]) | (rbuf[5] << 8);
+	info->event_size = rbuf[6];
+#else
+	info->event_format = 0;
+	info->event_size = 6;
+#endif
+	dev_dbg(&info->client->dev, "%s - event_format[%d] event_size[%d] \n", __func__, info->event_format, info->event_size);
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+	
+//ERROR:
+	//dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	//return 1;
+}
+
+/**
+* Initialize driver
+*/
+static int mip_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct mip_ts_info *info;
+	struct input_dev *input_dev;
+	int ret = 0;	
+	
+	dev_dbg(&client->dev, "%s [START]\n", __func__);
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)){
+		dev_err(&client->dev, "%s [ERROR] i2c_check_functionality\n", __func__);		
+		ret = -EIO;
+		goto ERROR;
+	}
+
+	//Init info data
+	info = kzalloc(sizeof(struct mip_ts_info), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!info || !input_dev) {
+		dev_err(&client->dev, "%s [ERROR]\n", __func__);
+		ret = -ENOMEM;
+		goto ERROR;
+	}
+
+	class_ts_info = info;
+	info->client = client;
+	info->input_dev = input_dev;
+	info->irq = -1;
+	info->init = true;
+	info->power = -1;
+	info->fw_path_ext = kstrdup(FW_PATH_EXTERNAL, GFP_KERNEL);
+	
+	mutex_init(&info->lock);
+
+	//Get platform data
+#if MIP_USE_DEVICETREE
+	if (client->dev.of_node) {
+		info->pdata  = devm_kzalloc(&client->dev, sizeof(struct melfas_platform_data), GFP_KERNEL);
+		if (!info->pdata) {
+			dev_err(&client->dev, "%s [ERROR] pdata devm_kzalloc\n", __func__);
+			//goto error_platform_data;
+		}
+
+		ret = mip_parse_devicetree(&client->dev, info);
+		if (ret){
+			dev_err(&client->dev, "%s [ERROR] mip_parse_dt\n", __func__);
+			goto ERROR;
+		}
+	} else
+#endif
+	{
+		info->pdata = client->dev.platform_data;
+		if (info->pdata == NULL) {
+			dev_err(&client->dev, "%s [ERROR] pdata is null\n", __func__);
+			ret = -EINVAL;
+			goto ERROR;
+		}
+	}
+
+	//Init input device
+	info->input_dev->name = "MELFAS_" CHIP_NAME "_Touchscreen";
+	snprintf(info->phys, sizeof(info->phys), "%s/input1", info->input_dev->name);
+	
+	info->input_dev->phys = info->phys;
+	info->input_dev->id.bustype = BUS_I2C;
+	info->input_dev->dev.parent = &client->dev;
+	
+#if MIP_USE_INPUT_OPEN_CLOSE	
+	info->input_dev->open = mip_input_open;
+	info->input_dev->close = mip_input_close;
+#endif
+     //set input event buffer size
+	input_set_events_per_packet(input_dev, 200); 
+	//Create device
+	input_set_drvdata(input_dev, info);
+	i2c_set_clientdata(client, info);
+
+	ret = input_register_device(input_dev);
+	if (ret) {
+		dev_err(&client->dev, "%s [ERROR] input_register_device\n", __func__);
+		ret = -EIO;
+		goto ERROR;
+	}
+	//dev_dbg(&client->dev, "%s - input_register_device\n", __func__);
+
+	//Power on
+	mip_power_on(info);
+
+	//Firmware update
+#if MIP_USE_AUTO_FW_UPDATE
+	/*	
+	info->fw_name = kstrdup(INTERNAL_FW_PATH, GFP_KERNEL);
+	ret = request_firmware_nowait(THIS_MODULE, true, fw_name, &client->dev, GFP_KERNEL, info, mip_fw_update_boot);
+	if (ret) {
+		dev_err(&client->dev, "%s [ERROR] request_firmware_nowait\n", __func__);
+		ret = -EIO;
+		//goto ERROR;	
+	}
+	*/
+	ret = mip_fw_update_from_kernel(info);
+	if(ret){
+		dev_err(&client->dev, "%s [ERROR] mip_fw_update_from_kernel\n", __func__);
+	}
+#endif
+
+	//Initial config
+	mip_init_config(info);
+
+	//Config input interface	
+	mip_config_input(info);
+
+#if MIP_USE_CALLBACK
+	//Config callback functions
+	mip_config_callback(info);
+#endif
+
+	//Set interrupt handler	
+	ret = request_threaded_irq(client->irq, NULL, mip_interrupt, IRQF_TRIGGER_LOW | IRQF_ONESHOT, MIP_DEVICE_NAME, info);
+	//ret = request_threaded_irq(client->irq, NULL, mip_interrupt, IRQF_TRIGGER_FALLING | IRQF_ONESHOT, MIP_DEVICE_NAME, info);
+	if (ret) {
+		dev_err(&client->dev, "%s [ERROR] request_threaded_irq\n", __func__);
+		goto ERROR;
+	}
+
+	disable_irq(client->irq);
+	info->irq = client->irq;
+
+#if MIP_USE_WAKEUP_GESTURE
+	//Wake-lock for wake-up gesture mode
+	wake_lock_init(&mip_wake_lock, WAKE_LOCK_SUSPEND, "mip_wake_lock");
+#endif
+
+#if defined(CONFIG_FB)
+	info->fb_notif.notifier_call = fb_notifier_callback;
+	ret = fb_register_client(&info->fb_notif);
+	if (ret)
+		dev_err(&client->dev, "Unable to register fb_notifier: %d\n",
+			ret);
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	info->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN +1;
+	info->early_suspend.suspend = mip_early_suspend;
+	info->early_suspend.resume = mip_late_resume;       
+	register_early_suspend(&info->early_suspend);       
+	dev_dbg(&client->dev, "%s - register_early_suspend\n", __func__);
+
+#endif
+	//Enable device
+	mip_enable(info);
+
+#if MIP_USE_DEV
+	//Create dev node (optional)
+	if(mip_dev_create(info)){
+		dev_err(&client->dev, "%s [ERROR] mip_dev_create\n", __func__);
+		ret = -EAGAIN;
+		goto ERROR;
+	}	
+
+	//Create dev
+	info->class = class_create(THIS_MODULE, MIP_DEVICE_NAME);
+	device_create(info->class, NULL, info->mip_dev, NULL, MIP_DEVICE_NAME);
+#endif
+
+#if MIP_USE_SYS
+	//Create sysfs for test mode (optional)
+	if (mip_sysfs_create(info)){
+		dev_err(&client->dev, "%s [ERROR] mip_sysfs_create\n", __func__);
+		ret = -EAGAIN;
+		goto ERROR;
+	}
+#endif
+
+#if MIP_USE_CMD
+	//Create sysfs for command mode (optional)
+	if (mip_sysfs_cmd_create(info)){
+		dev_err(&client->dev, "%s [ERROR] mip_sysfs_cmd_create\n", __func__);
+		ret = -EAGAIN;
+		goto ERROR;
+	}
+#endif
+	
+	//Create sysfs
+	if (sysfs_create_group(&client->dev.kobj, &mip_attr_group)) {
+		dev_err(&client->dev, "%s [ERROR] sysfs_create_group\n", __func__);
+		ret = -EAGAIN;
+		goto ERROR;
+	}
+
+	if (sysfs_create_link(NULL, &client->dev.kobj, MIP_DEVICE_NAME)) {
+		dev_err(&client->dev, "%s [ERROR] sysfs_create_link\n", __func__);
+		ret = -EAGAIN;
+		goto ERROR;
+	}
+
+	touchscreen_class = class_create(THIS_MODULE, "touchscreen");
+	if (IS_ERR(touchscreen_class)) {
+		pr_err("%s: create class error!\n", __func__);
+		goto END;
+	}
+
+	ret = class_create_file(touchscreen_class, &class_attr_ts_info);
+	if (ret < 0) {
+		pr_err("%s class_create_file failed!\n", __func__);
+	}
+
+	ret = class_create_file(touchscreen_class, &class_attr_ts_version);
+	if (ret < 0) {
+		pr_err("%s class_create_file failed!\n", __func__);
+	}
+
+	dev_dbg(&client->dev, "%s [DONE]\n", __func__);
+	dev_info(&client->dev, "MELFAS " CHIP_NAME " Touchscreen is initialized successfully.\n");	
+	return 0;
+
+END:
+	dev_dbg(&client->dev, "%s [DONE]\n", __func__);
+	dev_info(&client->dev, "MELFAS " CHIP_NAME " Touchscreen is initialized "
+			"successfully.\n");
+	return 0;
+
+ERROR:
+	dev_dbg(&client->dev, "%s [ERROR]\n", __func__);
+	dev_err(&client->dev, "MELFAS " CHIP_NAME " Touchscreen initialization failed.\n");	
+	return ret;
+}
+
+/**
+* Remove driver
+*/
+static int mip_remove(struct i2c_client *client)
+{
+	struct mip_ts_info *info = i2c_get_clientdata(client);
+
+	if (info->irq >= 0){
+		free_irq(info->irq, info);
+	}
+
+#if MIP_USE_CMD
+	mip_sysfs_cmd_remove(info);
+#endif
+
+#if MIP_USE_SYS
+	mip_sysfs_remove(info);
+#endif
+
+	sysfs_remove_group(&info->client->dev.kobj, &mip_attr_group);
+	sysfs_remove_link(NULL, MIP_DEVICE_NAME);
+	kfree(info->print_buf);
+
+#if MIP_USE_DEV
+	device_destroy(info->class, info->mip_dev);
+	class_destroy(info->class);
+#endif
+#if defined(CONFIG_FB)
+	if (fb_unregister_client(&info->fb_notif))
+		dev_err(&client->dev,
+		"Error occurred while unregistering fb_notifier.\n");
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	unregister_early_suspend(&info->early_suspend);
+#endif
+
+	input_unregister_device(info->input_dev);
+	kfree(info->fw_name);
+	kfree(info);
+
+	return 0;
+}
+
+#if defined(CONFIG_FB) || defined(CONFIG_HAS_EARLYSUSPEND)
+/**
+* Device suspend event handler
+*/
+int mip_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mip_ts_info *info = i2c_get_clientdata(client);
+	dev_dbg(&client->dev, "%s [START]\n", __func__);	
+	mip_disable(info);	
+	dev_dbg(&client->dev, "%s [DONE]\n", __func__);
+
+	return 0;
+
+}
+
+/**
+* Device resume event handler
+*/
+int mip_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mip_ts_info *info = i2c_get_clientdata(client);
+	int ret = 0;
+
+	dev_dbg(&client->dev, "%s [START]\n", __func__);
+	mip_clear_input(info);
+	mip_enable(info);
+
+	dev_dbg(&client->dev, "%s [DONE]\n", __func__);
+
+	return ret;
+}
+#if defined(CONFIG_FB)
+int fb_notifier_callback(struct notifier_block *self,
+				 unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	int *blank;
+	struct mip_ts_info *mip_info =
+		container_of(self, struct mip_ts_info, fb_notif);
+
+	if (evdata && evdata->data && event == FB_EARLY_EVENT_BLANK &&
+			mip_info && mip_info->client) {
+		blank = evdata->data;
+		if (*blank == FB_BLANK_UNBLANK)
+			mip_resume(&mip_info->client->dev);
+		else if (*blank == FB_BLANK_POWERDOWN)
+			mip_suspend(&mip_info->client->dev);
+	}
+
+	return 0; 
+}
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+/**
+* Early suspend handler
+*/
+void mip_early_suspend(struct early_suspend *h)
+{
+	struct mip_ts_info *info = container_of(h, struct mip_ts_info, early_suspend);
+	
+	mip_suspend(&info->client->dev);
+}
+
+/**
+* Late resume handler
+*/
+void mip_late_resume(struct early_suspend *h)
+{
+	struct mip_ts_info *info = container_of(h, struct mip_ts_info, early_suspend);
+
+	mip_resume(&info->client->dev);
+}
+#endif
+#endif
+#if (!defined(CONFIG_FB) && !defined(CONFIG_HAS_EARLYSUSPEND))
+/**
+* PM info
+*/
+const struct dev_pm_ops mip_pm_ops = {
+#if 0
+ 	SET_SYSTEM_SLEEP_PM_OPS(mip_suspend, mip_resume)
+#else
+
+	.suspend	= mip_suspend,
+	.resume = mip_resume,
+#endif
+};
+
+#else 
+const struct dev_pm_ops mip_pm_ops = {
+};
+#endif
+
+#if MIP_USE_DEVICETREE
+/**
+* Device tree match table
+*/
+static const struct of_device_id mip_match_table[] = {
+	{ .compatible = "melfas,"MIP_DEVICE_NAME,},
+	{},
+};
+MODULE_DEVICE_TABLE(of, mip_match_table);
+#endif
+
+/**
+* I2C Device ID
+*/
+static const struct i2c_device_id mip_id[] = {
+	{MIP_DEVICE_NAME, 0},
+};
+MODULE_DEVICE_TABLE(i2c, mip_id);
+
+/**
+* I2C driver info
+*/
+static struct i2c_driver mip_driver = {
+	.id_table = mip_id,
+	.probe = mip_probe,
+	.remove = mip_remove,
+	.driver = {
+		.name = MIP_DEVICE_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = mip_match_table,
+#if defined(CONFIG_PM) && !defined(CONFIG_HAS_EARLYSUSPEND)
+		.pm 	= &mip_pm_ops,
+#endif
+	},
+};
+
+/**
+* Init driver
+*/
+static int __init mip_init(void)
+{	
+	return i2c_add_driver(&mip_driver);
+}
+
+/**
+* Exit driver
+*/
+static void __exit mip_exit(void)
+{
+	i2c_del_driver(&mip_driver);
+}
+
+module_init(mip_init);
+module_exit(mip_exit);
+
+MODULE_DESCRIPTION("MELFAS MIP4 Touchscreen");
+MODULE_VERSION("2015.05.08");
+MODULE_AUTHOR("Jee, SangWon <jeesw@melfas.com>");
+MODULE_LICENSE("GPL"); 
+
diff --git a/drivers/input/touchscreen/melfas_mip4_testplus/mip4.h b/drivers/input/touchscreen/melfas_mip4_testplus/mip4.h
new file mode 100755
index 00000000000..f678e2be1fc
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_testplus/mip4.h
@@ -0,0 +1,373 @@
+/*
+ * MELFAS MIP4 Touchscreen
+ *
+ * Copyright (C) 2015 MELFAS Inc.
+ *
+ *
+ * mip4.h : Main header
+ *
+ */
+
+//Config debug msg : Must be disabled for production builds
+//Include
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/kobject.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/firmware.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/fs.h>
+#include <linux/sysfs.h>
+#include <linux/debugfs.h>
+#include <linux/cdev.h>
+#include <linux/err.h>
+#include <linux/limits.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/gpio_event.h>
+#include <linux/wakelock.h>
+#include <asm/uaccess.h>
+#include <linux/regulator/consumer.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+//Include platform data
+#include <linux/platform_data/melfas_mip4.h>
+
+//Include register map
+#include "mip4_reg.h"
+//Chip info
+#ifdef CONFIG_TOUCHSCREEN_MELFAS_MMS438
+#define CHIP_MMS438
+#define CHIP_NAME		"MMS438"
+#define CHIP_FW_CODE	"M4H0"
+#define FW_UPDATE_TYPE	"MMS438"
+#endif
+#ifdef CONFIG_TOUCHSCREEN_MELFAS_MMS449
+#define CHIP_MMS449
+#define CHIP_NAME		"MMS449"
+#define CHIP_FW_CODE	"M4HP"
+#define FW_UPDATE_TYPE	"MMS438"
+#endif
+#ifdef CONFIG_TOUCHSCREEN_MELFAS_MMS458
+#define CHIP_MMS458
+#define CHIP_NAME		"MMS458"
+#define CHIP_FW_CODE	"M4HN"
+#define FW_UPDATE_TYPE	"MMS438"
+#endif
+#ifdef CONFIG_TOUCHSCREEN_MELFAS_MMS492
+#define CHIP_MMS492
+#define CHIP_NAME		"MMS492"
+#define CHIP_FW_CODE	"M4HL"
+#define FW_UPDATE_TYPE	"MMS492"
+#endif
+#ifdef CONFIG_TOUCHSCREEN_MELFAS_MIT300
+#define CHIP_MIT300
+#define CHIP_NAME		"MIT300"
+#define CHIP_FW_CODE	"T3H0"
+#define FW_UPDATE_TYPE	"MIT300"
+#endif
+
+//Config driver
+#define MIP_USE_INPUT_OPEN_CLOSE		0	// 0 (defualt) or 1
+#define MIP_AUTOSET_RESOLUTION		1	// 0 or 1 (defualt)
+#define MIP_AUTOSET_EVENT_FORMAT		1	// 0 or 1 (defualt)
+#define I2C_RETRY_COUNT				3	// 2~
+#define RESET_ON_EVENT_ERROR			0	// 0 (defualt) or 1
+#define ESD_COUNT_FOR_DISABLE		7	// 7~
+#define INPUT_SYNC_TYPE				0	// 0 (defualt) or 1
+
+//Driver features
+#define MIP_USE_DEV			1	// 0 or 1 (defualt) : Optional - Required for development
+#define MIP_USE_SYS			1	// 0 or 1 (defualt) : Optional - Required for development
+#define MIP_USE_CMD			0	// 0 (defualt) or 1 : Optional
+
+//Module features
+#define MIP_USE_WAKEUP_GESTURE	0	// 0 (defualt) or 1
+
+//Input value
+#define MAX_FINGER_NUM 			10
+#define MAX_KEY_NUM				3
+#define INPUT_PRESSURE_MIN 		0
+#define INPUT_PRESSURE_MAX 		255
+#define INPUT_TOUCH_MAJOR_MIN 	0
+#define INPUT_TOUCH_MAJOR_MAX 	255
+#define INPUT_TOUCH_MINOR_MIN 	0
+#define INPUT_TOUCH_MINOR_MAX 	255
+#define INPUT_ANGLE_MIN 			0
+#define INPUT_ANGLE_MAX 			255
+#define INPUT_PALM_MIN 			0
+#define INPUT_PALM_MAX 			1
+
+//Firmware update
+#define FW_PATH_INTERNAL			"melfas/melfas_mip4.bin"	//path of firmware included in the kernel image (/firmware)
+#define FW_PATH_EXTERNAL			"/sdcard/melfas_mip4.mfsb"	//path of firmware in external storage
+#define MIP_USE_AUTO_FW_UPDATE	0	// 0 or 1
+#define MIP_FW_MAX_SECT_NUM		4
+#define MIP_FW_UPDATE_DEBUG		0	// 0 (defualt) or 1
+#define MIP_FW_UPDATE_SECTION  	1	// 0 (defualt) or 1
+#define MIP_EXT_FW_FORCE_UPDATE	1	// 0 or 1 (defualt)
+
+//Command function
+#if MIP_USE_CMD
+#define CMD_LEN 					32
+#define CMD_RESULT_LEN 			512
+#define CMD_PARAM_NUM 			8
+#endif
+
+#if MIP_USE_CALLBACK
+//Callback functions
+struct mip_callbacks {
+	void (*inform_charger) (struct mip_callbacks *, int);
+	//void (*inform_display) (struct mip_callbacks *, int);
+	//...
+};
+
+extern struct mip_callbacks *mip_inform_callbacks;
+#endif
+
+/**
+* Device info structure
+*/
+struct mip_ts_info {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	char phys[32];
+
+	struct melfas_platform_data *pdata;
+
+	dev_t mip_dev;
+	struct class *class;
+	
+	struct mutex lock;
+	struct mutex lock_test;
+	struct mutex lock_cmd;
+	struct mutex lock_dev;
+#if defined(CONFIG_FB)
+	struct notifier_block fb_notif;
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	struct early_suspend early_suspend;
+#endif
+	
+	int irq;
+	bool enabled;
+	int power;
+	bool init;	
+	char *fw_name;
+	char *fw_path_ext;
+		
+	u8 product_name[16];
+	int max_x;
+	int max_y;
+	u8 node_x;
+	u8 node_y;
+	u8 node_key;
+	u8 fw_version[8];
+	
+	u8 event_size;
+	int event_format;
+
+	bool key_enable;
+	int key_num;
+	int key_code[MAX_KEY_NUM];
+	
+	u8 nap_mode;
+	u8 glove_mode;
+	u8 charger_mode;
+	u8 cover_mode;
+	
+	u8 esd_cnt;
+	bool disable_esd;
+	u8 wakeup_gesture_code;
+	
+	u8 *print_buf;	
+	int *image_buf;
+	
+	bool test_busy;
+	bool cmd_busy;
+	bool dev_busy;
+
+#if MIP_USE_CMD
+	dev_t cmd_dev_t;
+	struct device *cmd_dev;
+	struct class *cmd_class;
+	struct list_head cmd_list_head;
+	u8 cmd_state;
+	char cmd[CMD_LEN];
+	char cmd_result[CMD_RESULT_LEN];
+	int cmd_param[CMD_PARAM_NUM];
+	int cmd_buffer_size;
+	struct device *key_dev;
+#endif	
+
+#if MIP_USE_DEV
+	struct cdev cdev;
+	u8 *dev_fs_buf;
+#endif	
+
+#if MIP_USE_CALLBACK
+	void (*register_callback)(void *);
+	struct mip_callbacks callbacks;
+#endif
+
+};
+
+/**
+* Firmware binary header 
+*/
+struct mip_bin_hdr {
+	char tag[8];
+	u16	core_version;
+	u16	section_num;
+	u16	contains_full_binary;
+	u16	reserved0;
+
+	u32	binary_offset;
+	u32	binary_length;	
+	u32	extention_offset;	
+	u32	reserved1;
+} __attribute__ ((packed));
+
+/**
+* Firmware image info
+*/
+struct mip_fw_img {
+	u16	type;
+	u16	version;
+	u16	start_page;
+	u16	end_page;
+
+	u32	offset;
+	u32	length;
+} __attribute__ ((packed));
+
+/**
+* Firmware binary tail info
+*/
+struct mip_bin_tail {
+	u8 tail_mark[4];
+	char chip_name[4];
+	u32 bin_start_addr;
+	u32 bin_length;
+
+	u16 ver_boot;
+	u16 ver_core;
+	u16 ver_app;
+	u16 ver_param;
+	u8 boot_start;
+	u8 boot_end;
+	u8 core_start;
+	u8 core_end;
+	u8 app_start;
+	u8 app_end;
+	u8 param_start;
+	u8 param_end;
+
+	u8 checksum_type;
+	u8 hw_category;
+	u16 param_id;
+	u32 param_length;
+	u32 build_date;
+	u32 build_time;
+	
+	u32 reserved1;
+	u32 reserved2;
+	u16 reserved3;
+	u16 tail_size;
+	u32 crc;
+} __attribute__ ((packed));
+
+#define MIP_BIN_TAIL_MARK		{0x4D, 0x42, 0x54, 0x01}	// M B T 0x01
+#define MIP_BIN_TAIL_SIZE		64
+
+/**
+* Firmware update error code
+*/
+enum fw_update_errno{
+	fw_err_file_read = -4,
+	fw_err_file_open = -3,
+	fw_err_file_type = -2,
+	fw_err_download = -1,
+	fw_err_none = 0,
+	fw_err_uptodate = 1,
+};
+
+/**
+* Function declarations
+*/
+//main
+void mip_reboot(struct mip_ts_info *info);
+int mip_i2c_read(struct mip_ts_info *info, char *write_buf, unsigned int write_len, char *read_buf, unsigned int read_len);
+int mip_i2c_read_next(struct mip_ts_info *info, char *write_buf, unsigned int write_len, char *read_buf, int start_idx, unsigned int read_len);
+int mip_i2c_write(struct mip_ts_info *info, char *write_buf, unsigned int write_len);
+int mip_enable(struct mip_ts_info *info);
+int mip_disable(struct mip_ts_info *info);
+int mip_get_ready_status(struct mip_ts_info *info);
+int mip_get_fw_version(struct mip_ts_info *info, u8 *ver_buf);
+int mip_get_fw_version_u16(struct mip_ts_info *info, u16 *ver_buf_u16);
+int mip_set_power_state(struct mip_ts_info *info, u8 mode);
+int mip_set_wakeup_gesture_type(struct mip_ts_info *info, u32 type);
+int mip_disable_esd_alert(struct mip_ts_info *info);
+int mip_fw_update_from_kernel(struct mip_ts_info *info);
+int mip_fw_update_from_storage(struct mip_ts_info *info, char *path, bool force);
+int mip_suspend(struct device *dev);
+int mip_resume(struct device *dev);
+int fb_notifier_callback(struct notifier_block *self,
+				unsigned long event, void *data);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void mip_early_suspend(struct early_suspend *h);
+void mip_late_resume(struct early_suspend *h);
+#endif
+
+//mod
+int mip_regulator_control(struct mip_ts_info *info, int enable);
+int mip_power_on(struct mip_ts_info *info);
+int mip_power_off(struct mip_ts_info *info);
+void mip_clear_input(struct mip_ts_info *info);
+int mip_wakeup_event_handler(struct mip_ts_info *info, u8 *rbuf);
+void mip_input_event_handler(struct mip_ts_info *info, u8 sz, u8 *buf);
+#if MIP_USE_DEVICETREE
+int mip_parse_devicetree(struct device *dev, struct mip_ts_info *info);
+#endif
+void mip_config_input(struct mip_ts_info *info);
+#if MIP_USE_CALLBACK
+void mip_config_callback(struct mip_ts_info *info);
+#endif
+
+//fw
+int mip_flash_fw(struct mip_ts_info *info, const u8 *fw_data, size_t fw_size, bool force, bool section);
+
+//debug
+#if MIP_USE_DEV
+int mip_dev_create(struct mip_ts_info *info);
+int mip_get_log(struct mip_ts_info *info);
+#endif
+#if MIP_USE_SYS || MIP_USE_CMD
+int mip_run_test(struct mip_ts_info *info, u8 test_type);
+int mip_get_image(struct mip_ts_info *info, u8 image_type);
+#endif
+#if MIP_USE_SYS
+int mip_sysfs_create(struct mip_ts_info *info);
+void mip_sysfs_remove(struct mip_ts_info *info);
+static const struct attribute_group mip_test_attr_group;
+#endif
+
+//cmd
+#if MIP_USE_CMD
+int mip_sysfs_cmd_create(struct mip_ts_info *info);
+void mip_sysfs_cmd_remove(struct mip_ts_info *info);
+static const struct attribute_group mip_cmd_attr_group;
+#endif
+
+
diff --git a/drivers/input/touchscreen/melfas_mip4_testplus/mip4_debug.c b/drivers/input/touchscreen/melfas_mip4_testplus/mip4_debug.c
new file mode 100755
index 00000000000..9bc2629bac7
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_testplus/mip4_debug.c
@@ -0,0 +1,1300 @@
+/*
+ * MELFAS MIP4 Touchscreen
+ *
+ * Copyright (C) 2015 MELFAS Inc.
+ *
+ *
+ * mip4_debug.c : Debug functions (Optional)
+ *
+ */
+ 
+#include "mip4.h"
+
+#if MIP_USE_DEV
+
+/**
+* Dev node output to user
+*/
+static ssize_t mip_dev_fs_read(struct file *fp, char *rbuf, size_t cnt, loff_t *fpos)
+{
+	struct mip_ts_info *info = fp->private_data;
+	int ret = 0;
+
+	//dev_dbg(&info->client->dev, "%s [START]\n", __func__); 
+
+	ret = copy_to_user(rbuf, info->dev_fs_buf, cnt);
+	
+	//dev_dbg(&info->client->dev, "%s [DONE]\n", __func__); 
+
+	return ret;
+}
+
+/**
+* Dev node input from user
+*/
+static ssize_t mip_dev_fs_write(struct file *fp, const char *wbuf, size_t cnt, loff_t *fpos)
+{
+	struct mip_ts_info *info = fp->private_data;
+	u8 *buf;
+	int ret = 0;
+	int cmd = 0;
+	
+	//dev_dbg(&info->client->dev, "%s [START]\n", __func__); 
+
+	buf = kzalloc(cnt + 1, GFP_KERNEL);
+
+	if ((buf == NULL) || copy_from_user(buf, wbuf, cnt)) {
+		dev_err(&info->client->dev, "%s [ERROR] copy_from_user\n", __func__);
+		ret = -EIO;
+		goto EXIT;
+	}
+
+	cmd = buf[cnt - 1];
+
+	if(cmd == 1){
+		//dev_dbg(&info->client->dev, "%s - cmd[%d] w_len[%d] r_len[%d]\n", __func__, cmd, (cnt - 2), buf[cnt - 2]); 
+		
+		if(mip_i2c_read(info, buf, (cnt - 2), info->dev_fs_buf, buf[cnt - 2])){
+			dev_err(&info->client->dev, "%s [ERROR] mip_i2c_read\n", __func__);
+		}		
+		//print_hex_dump(KERN_ERR, MIP_DEVICE_NAME" : input ", DUMP_PREFIX_OFFSET, 16, 1, wbuf, cnt, false);
+		//print_hex_dump(KERN_ERR, MIP_DEVICE_NAME" : output ", DUMP_PREFIX_OFFSET, 16, 1, info->dev_fs_buf, buf[cnt - 2], false);
+	}
+	else if(cmd == 2){
+		//dev_dbg(&info->client->dev, "%s - cmd[%d] w_len[%d]\n", __func__, cmd, (cnt - 1)); 
+		if(mip_i2c_write(info, buf, (cnt - 1))){
+			dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__);
+		}
+		//print_hex_dump(KERN_ERR, MIP_DEVICE_NAME" : input ", DUMP_PREFIX_OFFSET, 16, 1, wbuf, cnt, false);
+	}
+	else{
+		goto EXIT;
+	}
+	
+EXIT:	
+	kfree(buf);
+
+	//dev_dbg(&info->client->dev, "%s [DONE]\n", __func__); 
+
+	return ret;
+}
+
+/**
+* Open dev node
+*/
+static int mip_dev_fs_open(struct inode *node, struct file *fp)
+{
+	struct mip_ts_info *info = container_of(node->i_cdev, struct mip_ts_info, cdev);
+
+	//dev_dbg(&info->client->dev, "%s [START]\n", __func__); 
+	
+	fp->private_data = info;
+	
+	info->dev_fs_buf = kzalloc(1024 * 4, GFP_KERNEL);
+	
+	//dev_dbg(&info->client->dev, "%s [DONE]\n", __func__); 
+
+	return 0;
+}
+
+/**
+* Close dev node
+*/
+static int mip_dev_fs_release(struct inode *node, struct file *fp)
+{
+	struct mip_ts_info *info = fp->private_data;
+
+	//dev_dbg(&info->client->dev, "%s [START]\n", __func__); 
+
+	kfree(info->dev_fs_buf);
+
+	//dev_dbg(&info->client->dev, "%s [DONE]\n", __func__); 
+
+	return 0;
+}
+
+/**
+* Dev node info
+*/
+static struct file_operations mip_dev_fops = {
+	.owner	= THIS_MODULE,
+	.open	= mip_dev_fs_open,
+	.release	= mip_dev_fs_release,
+	.read	= mip_dev_fs_read,
+	.write	= mip_dev_fs_write,
+};
+
+/**
+* Create dev node
+*/
+int mip_dev_create(struct mip_ts_info *info)
+{
+	struct i2c_client *client = info->client;
+	int ret = 0;
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__); 
+	
+	if (alloc_chrdev_region(&info->mip_dev, 0, 1, MIP_DEVICE_NAME)) {
+		dev_err(&client->dev, "%s [ERROR] alloc_chrdev_region\n", __func__);
+		ret = -ENOMEM;
+		goto ERROR;
+	}
+	
+	cdev_init(&info->cdev, &mip_dev_fops);
+	info->cdev.owner = THIS_MODULE;
+
+	if (cdev_add(&info->cdev, info->mip_dev, 1)) {
+		dev_err(&client->dev, "%s [ERROR] cdev_add\n", __func__);
+		ret = -EIO;
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__); 	
+	return 0;
+	
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__); 	
+	return 0;
+}
+
+#endif
+
+#if MIP_USE_SYS || MIP_USE_CMD
+
+/**
+* Process table data
+*/
+static int mip_proc_table_data(struct mip_ts_info *info, u8 size, u8 data_type_size, u8 data_type_sign, u8 buf_addr_h, u8 buf_addr_l, u8 row_num, u8 col_num, u8 buf_col_num, u8 rotate, u8 key_num)
+{
+	char data[10];
+	int i_col, i_row;
+	int i_x, i_y;
+	int lim_x, lim_y;
+	int lim_col, lim_row;
+	int max_x = 0;
+	int max_y = 0;
+	bool flip_x = false;
+	int sValue = 0;
+	unsigned int uValue = 0;
+	int value = 0;
+	u8 wbuf[8];
+	u8 rbuf[512];
+	unsigned int buf_addr;
+	int offset;
+	int data_size = data_type_size;
+	int data_sign = data_type_sign;
+	int has_key = 0;
+	int size_screen = col_num * row_num;
+
+	memset(data, 0, 10);
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__); 
+
+	//set axis
+	if(rotate == 0){
+		max_x = col_num;
+		max_y = row_num;
+		if(key_num > 0){
+			max_y += 1;
+			has_key = 1;
+		}
+		flip_x = false;
+	}
+	else if(rotate == 1){
+		max_x = row_num;
+		max_y = col_num;
+		if(key_num > 0){
+			max_y += 1;
+			has_key = 1;
+		}
+		flip_x = true;
+	}
+	else{
+		dev_err(&info->client->dev, "%s [ERROR] rotate [%d]\n", __func__, rotate); 
+		goto ERROR;
+	}
+
+	//get table data
+	lim_row = row_num + has_key;
+	for(i_row = 0; i_row < lim_row; i_row++){
+		//get line data
+		offset = buf_col_num * data_type_size;
+		size = col_num * data_type_size;
+		
+		buf_addr = (buf_addr_h << 8) | buf_addr_l | (offset * i_row);
+		wbuf[0] = (buf_addr >> 8) & 0xFF;
+		wbuf[1] = buf_addr & 0xFF;
+		if(mip_i2c_read(info, wbuf, 2, rbuf, size)){
+			dev_err(&info->client->dev, "%s [ERROR] Read data buffer\n", __func__); 
+			goto ERROR;
+		}
+
+		//save data
+		if((key_num > 0) && (i_row == (lim_row - 1))){
+			lim_col = key_num;
+		}
+		else{
+			lim_col = col_num;
+		}
+		for(i_col = 0; i_col < lim_col; i_col++){
+			if(data_sign == 0){
+				//unsigned
+				if(data_size == 1){
+					uValue = (u8)rbuf[i_col];
+				}
+				else if(data_size == 2){
+					uValue = (u16)(rbuf[data_size * i_col] | (rbuf[data_size * i_col + 1] << 8));
+				}
+				else if(data_size == 4){
+					uValue = (u32)(rbuf[data_size * i_col] | (rbuf[data_size * i_col + 1] << 8) | (rbuf[data_size * i_col + 2] << 16) | (rbuf[data_size * i_col + 3] << 24));
+				}
+				else{
+					dev_err(&info->client->dev, "%s [ERROR] data_size [%d]\n", __func__, data_size); 
+					goto ERROR;
+				}				
+				value = (int)uValue;
+			}			
+			else{
+				//signed
+				if(data_size == 1){
+					sValue = (s8)rbuf[i_col];
+				}
+				else if(data_size == 2){
+					sValue = (s16)(rbuf[data_size * i_col] | (rbuf[data_size * i_col + 1] << 8));
+				}
+				else if(data_size == 4){
+					sValue = (s32)(rbuf[data_size * i_col] | (rbuf[data_size * i_col + 1] << 8) | (rbuf[data_size * i_col + 2] << 16) | (rbuf[data_size * i_col + 3] << 24));
+				}
+				else{
+					dev_err(&info->client->dev, "%s [ERROR] data_size [%d]\n", __func__, data_size); 
+					goto ERROR;
+				}
+				value = (int)sValue;
+			}
+
+			switch(rotate){
+				case 0:
+					info->image_buf[i_row * col_num + i_col] = value; 
+					break;
+				case 1:
+					if((key_num > 0) && (i_row == (lim_row - 1))){
+						info->image_buf[size_screen + i_col] = value; 
+					}
+					else{
+						info->image_buf[i_col * row_num + (row_num - 1 - i_row)] = value; 
+					}
+					break;
+				default:
+					dev_err(&info->client->dev, "%s [ERROR] rotate [%d]\n", __func__, rotate); 
+					goto ERROR;
+					break;
+			}
+		}
+	}	
+	
+	//print table header
+	printk("    ");
+	sprintf(data, "    ");
+	strcat(info->print_buf, data);
+	memset(data, 0, 10);	
+	
+	switch(data_size){
+		case 1:
+			for(i_x = 0; i_x < max_x; i_x++){ 	
+				printk("[%2d]", i_x);
+				sprintf(data, "[%2d]", i_x);
+				strcat(info->print_buf, data);
+				memset(data, 0, 10);
+			}			
+			break;
+		case 2:
+			for(i_x = 0; i_x < max_x; i_x++){ 	
+				printk("[%4d]", i_x);
+				sprintf(data, "[%4d]", i_x);
+				strcat(info->print_buf, data);
+				memset(data, 0, 10);
+			}
+			break;
+		case 4:
+			for(i_x = 0; i_x < max_x; i_x++){ 	
+				printk("[%5d]", i_x);
+				sprintf(data, "[%5d]", i_x);
+				strcat(info->print_buf, data);
+				memset(data, 0, 10);
+			}
+			break;
+		default:
+			dev_err(&info->client->dev, "%s [ERROR] data_size [%d]\n", __func__, data_size); 
+			goto ERROR;
+			break;
+	}
+	
+	printk("\n");
+	sprintf(data, "\n");
+	strcat(info->print_buf, data);
+	memset(data, 0, 10);	
+	
+	//print table
+	lim_y = max_y;
+	for(i_y = 0; i_y < lim_y; i_y++){
+		//print line header
+		if((key_num > 0) && (i_y == (lim_y -1))){
+			printk("[TK]");
+			sprintf(data, "[TK]");
+		}
+		else{
+			printk("[%2d]", i_y);
+			sprintf(data, "[%2d]", i_y);
+		}
+		strcat(info->print_buf, data);
+		memset(data, 0, 10);
+		
+		//print line
+		if((key_num > 0) && (i_y == (lim_y - 1))){
+			lim_x = key_num;
+		}
+		else{
+			lim_x = max_x;
+		}
+		for(i_x = 0; i_x < lim_x; i_x++){				
+			switch(data_size){
+				case 1:
+					printk(" %3d", info->image_buf[i_y * max_x + i_x]);
+					sprintf(data, " %3d", info->image_buf[i_y * max_x + i_x]);
+					break;
+				case 2:
+					printk(" %5d", info->image_buf[i_y * max_x + i_x]);
+					sprintf(data, " %5d", info->image_buf[i_y * max_x + i_x]);
+					break;
+				case 4:
+					printk(" %6d", info->image_buf[i_y * max_x + i_x]);
+					sprintf(data, " %6u", info->image_buf[i_y * max_x + i_x]);
+					break;
+				default:
+					dev_err(&info->client->dev, "%s [ERROR] data_size [%d]\n", __func__, data_size); 
+					goto ERROR;
+					break;
+			}				
+			
+			strcat(info->print_buf, data);
+			memset(data, 0, 10);
+		}
+		
+		printk("\n");
+		sprintf(data, "\n");
+		strcat(info->print_buf, data);
+		memset(data, 0, 10);		
+	}
+	
+	printk("\n");
+	sprintf(data, "\n");
+	strcat(info->print_buf, data);
+	memset(data, 0, 10);		
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__); 
+	return 0;
+
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__); 
+	return 1;
+}
+
+/**
+* Run test
+*/
+int mip_run_test(struct mip_ts_info *info, u8 test_type)
+{
+	int busy_cnt = 50;
+	int wait_cnt = 50;
+	u8 wbuf[8];
+	u8 rbuf[512];
+	u8 size = 0;
+	u8 row_num;
+	u8 col_num;
+	u8 buffer_col_num;
+	u8 rotate;
+	u8 key_num;
+	u8 data_type;
+	u8 data_type_size;
+	u8 data_type_sign;
+	u8 buf_addr_h;
+	u8 buf_addr_l;
+		
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__); 
+	dev_dbg(&info->client->dev, "%s - test_type[%d]\n", __func__, test_type);	
+
+	while(busy_cnt--){
+		if(info->test_busy == false){
+			break;
+		}
+		msleep(10);
+	}
+	mutex_lock(&info->lock);
+	info->test_busy = true;
+	mutex_unlock(&info->lock);
+
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	//check test type
+	switch(test_type){
+		case MIP_TEST_TYPE_CM_DELTA:
+			//printk("=== Cm Delta Test ===\n"); 
+			sprintf(info->print_buf, "\n=== Cm Delta Test ===\n\n");
+			break;
+		case MIP_TEST_TYPE_CM_JITTER:
+			//printk("=== Cm Jitter Test ===\n"); 
+			sprintf(info->print_buf, "\n=== Cm Jitter Test ===\n\n");
+			break;
+		case MIP_TEST_TYPE_SHORT:
+			//printk("=== Short Test ===\n"); 
+			sprintf(info->print_buf, "\n=== Short Test ===\n\n");
+			break;
+		default:
+			dev_err(&info->client->dev, "%s [ERROR] Unknown test type\n", __func__); 
+			sprintf(info->print_buf, "\nERROR : Unknown test type\n\n");
+			goto ERROR;
+			break;
+	}
+
+	//set test mode
+	wbuf[0] = MIP_R0_CTRL;
+	wbuf[1] = MIP_R1_CTRL_MODE;
+	wbuf[2] = MIP_CTRL_MODE_TEST_CM;
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] Write test mode\n", __func__); 
+		goto ERROR;
+	}
+
+	//wait ready status
+	wait_cnt = 50;
+	while(wait_cnt--){
+		if(mip_get_ready_status(info) == MIP_CTRL_STATUS_READY){
+			break;
+		}
+		msleep(50);
+		
+		dev_dbg(&info->client->dev, "%s - wait [%d]\n", __func__, wait_cnt); 
+	}
+	
+	if(wait_cnt <= 0){
+		dev_err(&info->client->dev, "%s [ERROR] Wait timeout\n", __func__); 
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s - set control mode\n", __func__);	
+	
+	//set test type
+	wbuf[0] = MIP_R0_TEST;
+	wbuf[1] = MIP_R1_TEST_TYPE;
+	wbuf[2] = test_type;
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] Write test type\n", __func__); 
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s - set test type\n", __func__);	
+
+	//wait ready status
+	wait_cnt = 50;
+	while(wait_cnt--){
+		if(mip_get_ready_status(info) == MIP_CTRL_STATUS_READY){
+			break;
+		}
+		msleep(10);
+		
+		dev_dbg(&info->client->dev, "%s - wait [%d]\n", __func__, wait_cnt); 
+	}
+	
+	if(wait_cnt <= 0){
+		dev_err(&info->client->dev, "%s [ERROR] Wait timeout\n", __func__); 
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s - ready\n", __func__);	
+	
+	//data format
+	wbuf[0] = MIP_R0_TEST;
+	wbuf[1] = MIP_R1_TEST_DATA_FORMAT;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 6)){
+		dev_err(&info->client->dev, "%s [ERROR] Read data format\n", __func__); 
+		goto ERROR;
+	}
+	row_num = rbuf[0];
+	col_num = rbuf[1];
+	buffer_col_num = rbuf[2];
+	rotate = rbuf[3];
+	key_num = rbuf[4];
+	data_type = rbuf[5];
+	
+	data_type_sign = (data_type & 0x80) >> 7;
+	data_type_size = data_type & 0x7F;	
+	
+	dev_dbg(&info->client->dev, "%s - row_num[%d] col_num[%d] buffer_col_num[%d] rotate[%d] key_num[%d]\n", __func__, row_num, col_num, buffer_col_num, rotate, key_num);	
+	dev_dbg(&info->client->dev, "%s - data_type[0x%02X] data_sign[%d] data_size[%d]\n", __func__, data_type, data_type_sign, data_type_size);	
+	
+	//get buf addr
+	wbuf[0] = MIP_R0_TEST;
+	wbuf[1] = MIP_R1_TEST_BUF_ADDR;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 2)){
+		dev_err(&info->client->dev, "%s [ERROR] Read buf addr\n", __func__); 
+		goto ERROR;
+	}
+	
+	buf_addr_l = rbuf[0];
+	buf_addr_h = rbuf[1];
+	dev_dbg(&info->client->dev, "%s - buf_addr[0x%02X 0x%02X]\n", __func__, buf_addr_h, buf_addr_l); 
+	
+	//print data
+	if(mip_proc_table_data(info, size, data_type_size, data_type_sign, buf_addr_h, buf_addr_l, row_num, col_num, buffer_col_num, rotate, key_num)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_proc_table_data\n", __func__); 
+		goto ERROR;
+	}
+
+	//set normal mode
+	wbuf[0] = MIP_R0_CTRL;
+	wbuf[1] = MIP_R1_CTRL_MODE;
+	wbuf[2] = MIP_CTRL_MODE_NORMAL;
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__); 
+		goto ERROR;
+	}
+
+	//wait ready status
+	wait_cnt = 50;
+	while(wait_cnt--){
+		if(mip_get_ready_status(info) == MIP_CTRL_STATUS_READY){
+			break;
+		}
+		msleep(10);
+		
+		dev_dbg(&info->client->dev, "%s - wait [%d]\n", __func__, wait_cnt); 
+	}
+	
+	if(wait_cnt <= 0){
+		dev_err(&info->client->dev, "%s [ERROR] Wait timeout\n", __func__); 
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s - set normal mode\n", __func__);	
+
+	//exit
+	mutex_lock(&info->lock);
+	info->test_busy = false;
+	mutex_unlock(&info->lock);
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);	
+	return 0;
+	
+ERROR:
+	mutex_lock(&info->lock);
+	info->test_busy = false;
+	mutex_unlock(&info->lock);
+	
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__); 
+	return 1;
+}
+
+/**
+* Read image data
+*/
+int mip_get_image(struct mip_ts_info *info, u8 image_type)
+{
+	int busy_cnt = 100;
+	int wait_cnt = 100;
+	u8 wbuf[8];
+	u8 rbuf[512];
+	u8 size = 0;
+	u8 row_num;
+	u8 col_num;
+	u8 buffer_col_num;
+	u8 rotate;
+	u8 key_num;
+	u8 data_type;
+	u8 data_type_size;
+	u8 data_type_sign;
+	u8 buf_addr_h;
+	u8 buf_addr_l;
+		
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+	dev_dbg(&info->client->dev, "%s - image_type[%d]\n", __func__, image_type);	
+
+	while(busy_cnt--){
+		if(info->test_busy == false){
+			break;
+		}
+		dev_dbg(&info->client->dev, "%s - busy_cnt[%d]\n", __func__, busy_cnt);	
+		msleep(5);
+	}
+	mutex_lock(&info->lock);
+	info->test_busy = true;
+	mutex_unlock(&info->lock);
+
+	memset(info->print_buf, 0, PAGE_SIZE);
+	
+	//check image type
+	switch(image_type){
+		case MIP_IMG_TYPE_INTENSITY:
+			dev_dbg(&info->client->dev, "=== Intensity Image ===\n"); 
+			sprintf(info->print_buf, "\n=== Intensity Image ===\n\n");
+			break;
+		case MIP_IMG_TYPE_RAWDATA:
+			dev_dbg(&info->client->dev, "=== Rawdata Image ===\n"); 
+			sprintf(info->print_buf, "\n=== Rawdata Image ===\n\n");
+			break;
+		default:
+			dev_err(&info->client->dev, "%s [ERROR] Unknown image type\n", __func__); 
+			sprintf(info->print_buf, "\nERROR : Unknown image type\n\n");
+			goto ERROR;
+			break;
+	}
+	
+	//set image type
+	wbuf[0] = MIP_R0_IMAGE;
+	wbuf[1] = MIP_R1_IMAGE_TYPE;
+	wbuf[2] = image_type;
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] Write image type\n", __func__); 
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s - set image type\n", __func__);	
+
+	//wait ready status
+	wait_cnt = 50;
+	while(wait_cnt--){
+		if(mip_get_ready_status(info) == MIP_CTRL_STATUS_READY){
+			break;
+		}
+		msleep(10);
+		
+		dev_dbg(&info->client->dev, "%s - wait [%d]\n", __func__, wait_cnt); 
+	}
+	
+	if(wait_cnt <= 0){
+		dev_err(&info->client->dev, "%s [ERROR] Wait timeout\n", __func__); 
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s - ready\n", __func__);	
+	
+	//data format
+	wbuf[0] = MIP_R0_IMAGE;
+	wbuf[1] = MIP_R1_IMAGE_DATA_FORMAT;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 6)){
+		dev_err(&info->client->dev, "%s [ERROR] Read data format\n", __func__); 
+		goto ERROR;
+	}
+	row_num = rbuf[0];
+	col_num = rbuf[1];
+	buffer_col_num = rbuf[2];
+	rotate = rbuf[3];
+	key_num = rbuf[4];
+	data_type = rbuf[5];
+
+	data_type_sign = (data_type & 0x80) >> 7;
+	data_type_size = data_type & 0x7F;
+	
+	dev_dbg(&info->client->dev, "%s - row_num[%d] col_num[%d] buffer_col_num[%d] rotate[%d] key_num[%d]\n", __func__, row_num, col_num, buffer_col_num, rotate, key_num);	
+	dev_dbg(&info->client->dev, "%s - data_type[0x%02X] data_sign[%d] data_size[%d]\n", __func__, data_type, data_type_sign, data_type_size);	
+
+	//get buf addr
+	wbuf[0] = MIP_R0_IMAGE;
+	wbuf[1] = MIP_R1_IMAGE_BUF_ADDR;
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 2)){
+		dev_err(&info->client->dev, "%s [ERROR] Read buf addr\n", __func__); 
+		goto ERROR;
+	}
+	
+	buf_addr_l = rbuf[0];
+	buf_addr_h = rbuf[1];
+	dev_dbg(&info->client->dev, "%s - buf_addr[0x%02X 0x%02X]\n", __func__, buf_addr_h, buf_addr_l); 
+
+	//print data
+	if(mip_proc_table_data(info, size, data_type_size, data_type_sign, buf_addr_h, buf_addr_l, row_num, col_num, buffer_col_num, rotate, key_num)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_proc_table_data\n", __func__); 
+		goto ERROR;
+	}
+	
+	//clear image type
+	wbuf[0] = MIP_R0_IMAGE;
+	wbuf[1] = MIP_R1_IMAGE_TYPE;
+	wbuf[2] = MIP_IMG_TYPE_NONE;
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] Clear image type\n", __func__); 
+		goto ERROR;
+	}
+
+	//exit
+	mutex_lock(&info->lock);
+	info->test_busy = false;
+	mutex_unlock(&info->lock);
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);	
+	return 0;
+	
+ERROR:
+	mutex_lock(&info->lock);
+	info->test_busy = false;
+	mutex_unlock(&info->lock);
+
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);	
+	return 1;
+}
+
+#endif
+
+#if MIP_USE_SYS
+
+/**
+* Firmware update (section)
+*/
+static ssize_t mip_sys_fw_update_section(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mip_ts_info *info = i2c_get_clientdata(client);
+	int result = 0;
+	u8 data[255];
+	int ret = 0;
+	
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	ret = mip_fw_update_from_storage(info, info->fw_path_ext, false);
+	
+	switch(ret){
+		case fw_err_none:
+			sprintf(data, "F/W update success.\n");
+			break;
+		case fw_err_uptodate:
+			sprintf(data, "F/W is already up-to-date.\n");
+			break;
+		case fw_err_download:
+			sprintf(data, "F/W update failed : Download error\n");
+			break;
+		case fw_err_file_type:
+			sprintf(data, "F/W update failed : File type error\n");
+			break;
+		case fw_err_file_open:			
+			sprintf(data, "F/W update failed : File open error [%s]\n", info->fw_path_ext);
+			break;
+		case fw_err_file_read:
+			sprintf(data, "F/W update failed : File read error\n");
+			break;
+		default:
+			sprintf(data, "F/W update failed.\n");
+			break;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	
+	strcat(info->print_buf, data);
+	result = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return result;
+}
+
+/**
+* Print chip firmware version
+*/
+static ssize_t mip_sys_fw_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	u8 data[255];
+	int ret;
+	u8 rbuf[16];
+
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	if(mip_get_fw_version(info, rbuf)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_get_fw_version\n", __func__);
+
+		sprintf(data, "F/W Version : ERROR\n");	
+		goto ERROR;
+	}
+	
+	dev_info(&info->client->dev, "%s - F/W Version : %02X.%02X_%02X.%02X_%02X.%02X_%02X.%02X\n", __func__, rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4], rbuf[5], rbuf[6], rbuf[7]);	
+	sprintf(data, "melfas_%s,fw_ver:%02X.%02X_%02X.%02X_%02X.%02X_%02X.%02X\n",MIP_DEVICE_NAME, rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4], rbuf[5], rbuf[6], rbuf[7]);
+
+ERROR:	
+	strcat(info->print_buf, data);
+		
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return ret;
+}
+
+/**
+* Set firmware path
+*/
+static ssize_t mip_sys_fw_path_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	char *path;
+	
+	dev_dbg(&info->client->dev, "%s [START] \n", __func__);
+
+	if(count <= 1){
+		dev_err(&info->client->dev, "%s [ERROR] Wrong value [%s]\n", __func__, buf);
+		goto ERROR;
+	}	
+
+	path = kzalloc(count - 1, GFP_KERNEL);
+	memcpy(path, buf, count - 1);
+		
+	info->fw_path_ext = kstrdup(path, GFP_KERNEL);
+	
+	dev_dbg(&info->client->dev, "%s - Path : %s\n", __func__, info->fw_path_ext);
+
+	dev_dbg(&info->client->dev, "%s [DONE] \n", __func__);
+	return count;
+
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR] \n", __func__);
+	return count;
+}
+
+/**
+* Print firmware path
+*/
+static ssize_t mip_sys_fw_path_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	u8 data[255];
+	int ret;
+	
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	dev_dbg(&info->client->dev, "%s [START] \n", __func__);
+
+	sprintf(data, "Path : %s\n", info->fw_path_ext);
+
+	dev_dbg(&info->client->dev, "%s [DONE] \n", __func__);
+
+	strcat(info->print_buf, data);
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return ret;
+}
+
+/**
+* Print channel info
+*/
+static ssize_t mip_sys_info(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	u8 data[255];
+	int ret;
+	u8 rbuf[32];
+	u8 wbuf[8];
+	int res_x, res_y;
+	
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	sprintf(data, "\n");		
+	strcat(info->print_buf, data);
+	
+	mip_get_fw_version(info, rbuf);
+	sprintf(data, "F/W Version : %02X.%02X_%02X.%02X_%02X.%02X_%02X.%02X\n", rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4], rbuf[5], rbuf[6], rbuf[7]);	
+	strcat(info->print_buf, data);
+	
+	wbuf[0] = MIP_R0_INFO;
+	wbuf[1] = MIP_R1_INFO_PRODUCT_NAME;
+	mip_i2c_read(info, wbuf, 2, rbuf, 16);
+	sprintf(data, "Product Name : %s\n", rbuf);		
+	strcat(info->print_buf, data);
+	
+	wbuf[0] = MIP_R0_INFO;
+	wbuf[1] = MIP_R1_INFO_RESOLUTION_X;
+	mip_i2c_read(info, wbuf, 2, rbuf, 7);
+	res_x = (rbuf[0]) | (rbuf[1] << 8);
+	res_y = (rbuf[2]) | (rbuf[3] << 8);
+	sprintf(data, "Resolution : X[%d] Y[%d]\n", res_x, res_y);		
+	strcat(info->print_buf, data);
+
+	sprintf(data, "Node Num : X[%d] Y[%d] Key[%d]\n", rbuf[4], rbuf[5], rbuf[6]);		
+	strcat(info->print_buf, data);
+	
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return ret;
+	
+}
+
+/**
+* Power on
+*/
+static ssize_t mip_sys_power_on(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+	u8 data[255];
+	int ret;
+
+	memset(info->print_buf,0,PAGE_SIZE);
+
+	mip_power_on(info);
+
+	dev_info(&client->dev, "%s", __func__);	
+	
+	sprintf(data, "Power : On\n");	
+	strcat(info->print_buf,data);
+	
+	ret = snprintf(buf,PAGE_SIZE,"%s\n",info->print_buf);
+	return ret;
+	
+}
+
+/**
+* Power off
+*/
+static ssize_t mip_sys_power_off(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+	u8 data[255];
+	int ret;
+
+	memset(info->print_buf,0,PAGE_SIZE);
+
+	mip_power_off(info);
+
+	dev_info(&client->dev, "%s", __func__);	
+	
+	sprintf(data, "Power : Off\n");	
+	strcat(info->print_buf,data);
+	
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return ret;
+	
+}
+
+/**
+* Reboot chip
+*/
+static ssize_t mip_sys_reboot(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+	u8 data[255];
+	int ret;
+
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	dev_info(&client->dev, "%s", __func__); 
+	
+	disable_irq(info->irq);	
+	mip_clear_input(info);	
+	mip_reboot(info);	
+	enable_irq(info->irq);
+	
+	sprintf(data, "Reboot\n");	
+	strcat(info->print_buf,data);
+		
+	ret = snprintf(buf,PAGE_SIZE,"%s\n",info->print_buf);
+	return ret;
+	
+}
+
+/**
+* Set mode
+*/
+static ssize_t mip_sys_mode_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	u8 wbuf[8];
+	u8 value = 0;
+	
+	dev_dbg(&info->client->dev, "%s [START] \n", __func__);
+
+	wbuf[0] = MIP_R0_CTRL;
+
+	if (!strcmp(attr->attr.name, "mode_glove")){		
+		wbuf[1] = MIP_R1_CTRL_GLOVE_MODE;
+	}
+	else if (!strcmp(attr->attr.name, "mode_charger")){
+		wbuf[1] = MIP_R1_CTRL_CHARGER_MODE;
+	}
+	else if (!strcmp(attr->attr.name, "mode_cover_window")){
+		wbuf[1] = MIP_R1_CTRL_WINDOW_MODE;
+	}
+	else if (!strcmp(attr->attr.name, "mode_palm_rejection")){
+		wbuf[1] = MIP_R1_CTRL_PALM_REJECTION;
+	}
+	else {
+		dev_err(&info->client->dev, "%s [ERROR] Unknown mode [%s]\n", __func__, attr->attr.name);		
+		goto ERROR;
+	}
+
+	if(buf[0] == 48){
+		value = 0;
+	}
+	else if(buf[0] == 49){
+		value = 1;
+	}
+	else{
+		dev_err(&info->client->dev, "%s [ERROR] Unknown value [%c]\n", __func__, buf[0]);
+		goto EXIT;
+	}	
+	wbuf[2] = value;
+	
+	if(mip_i2c_write(info, wbuf, 3)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__);
+	}
+	else{
+		dev_info(&info->client->dev, "%s - value[%d]\n", __func__, value);
+	}
+		
+EXIT:
+	dev_dbg(&info->client->dev, "%s [DONE] \n", __func__);
+	return count;
+
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR] \n", __func__);
+	return count;
+}
+
+/**
+* Print mode
+*/
+static ssize_t mip_sys_mode_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	u8 data[255];
+	int ret;
+	u8 wbuf[8];
+	u8 rbuf[4];
+	
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	dev_dbg(&info->client->dev, "%s [START] \n", __func__);
+
+	wbuf[0] = MIP_R0_CTRL;
+	
+	if (!strcmp(attr->attr.name, "mode_glove")){		
+		wbuf[1] = MIP_R1_CTRL_GLOVE_MODE;
+	}
+	else if (!strcmp(attr->attr.name, "mode_charger")){
+		wbuf[1] = MIP_R1_CTRL_CHARGER_MODE;
+	}
+	else if (!strcmp(attr->attr.name, "mode_cover_window")){
+		wbuf[1] = MIP_R1_CTRL_WINDOW_MODE;
+	}
+	else if (!strcmp(attr->attr.name, "mode_palm_rejection")){
+		wbuf[1] = MIP_R1_CTRL_PALM_REJECTION;
+	}
+	else {
+		dev_err(&info->client->dev, "%s [ERROR] Unknown mode [%s]\n", __func__, attr->attr.name);		
+		sprintf(data, "%s : Unknown Mode\n", attr->attr.name);
+		goto EXIT;
+	}
+	
+	if(mip_i2c_read(info, wbuf, 2, rbuf, 1)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_i2c_read\n", __func__);
+		sprintf(data, "%s : ERROR\n", attr->attr.name);
+	}
+	else{
+		dev_info(&info->client->dev, "%s - value[%d]\n", __func__, rbuf[0]);
+		sprintf(data, "%s : %d\n", attr->attr.name, rbuf[0]);
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE] \n", __func__);
+
+EXIT:	
+	strcat(info->print_buf, data);
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return ret;
+}
+
+/**
+* Sysfs print image
+*/
+static ssize_t mip_sys_image(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	int ret;
+	u8 type;
+
+	dev_dbg(&info->client->dev, "%s [START] \n", __func__);
+
+	if (!strcmp(attr->attr.name, "image_intensity")){		
+		type = MIP_IMG_TYPE_INTENSITY;
+	}
+	else if (!strcmp(attr->attr.name, "image_rawdata")){
+		type = MIP_IMG_TYPE_RAWDATA;
+	}
+	else {
+		dev_err(&info->client->dev, "%s [ERROR] Unknown image [%s]\n", __func__, attr->attr.name);		
+		ret = snprintf(buf, PAGE_SIZE, "%s\n", "ERROR : Unknown image type");
+		goto ERROR;
+	}
+
+	if(mip_get_image(info, type)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_get_image\n", __func__);
+		ret = snprintf(buf, PAGE_SIZE, "%s\n", "ERROR");
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s [DONE] \n", __func__);
+	
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return ret;
+	
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return ret;
+}
+
+/**
+* Sysfs run test
+*/
+static ssize_t mip_sys_test(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	int ret;
+	u8 test_type;
+	
+	dev_dbg(&info->client->dev, "%s [START] \n", __func__);
+
+	if (!strcmp(attr->attr.name, "test_cm_delta")){		
+		test_type = MIP_TEST_TYPE_CM_DELTA;
+	}
+	else if (!strcmp(attr->attr.name, "test_cm_jitter")){
+		test_type = MIP_TEST_TYPE_CM_JITTER;
+	}
+	else if (!strcmp(attr->attr.name, "test_short")){
+		test_type = MIP_TEST_TYPE_SHORT;
+	}
+	else {
+		dev_err(&info->client->dev, "%s [ERROR] Unknown test [%s]\n", __func__, attr->attr.name);		
+		ret = snprintf(buf, PAGE_SIZE, "%s\n", "ERROR : Unknown test type");
+		goto ERROR;
+	}
+
+	if(mip_run_test(info, test_type)){
+		dev_err(&info->client->dev, "%s [ERROR] mip_run_test\n", __func__);
+		ret = snprintf(buf, PAGE_SIZE, "%s\n", "ERROR");
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
+	return ret;
+
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return ret;
+}
+
+/**
+* Print wake-up gesture code
+*/
+static ssize_t mip_sys_wakeup_gesture(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mip_ts_info *info = dev_get_drvdata(dev);
+	struct i2c_client *client = info->client;
+	u8 data[255];
+	int ret;
+
+	memset(info->print_buf, 0, PAGE_SIZE);
+
+	dev_info(&client->dev, "%s", __func__); 
+		
+	sprintf(data, "gesture:%d\n", info->wakeup_gesture_code);	
+	strcat(info->print_buf,data);
+	
+	ret = snprintf(buf,PAGE_SIZE,"%s\n",info->print_buf);
+	return ret;
+	
+}
+
+/**
+* Sysfs functions
+*/
+static DEVICE_ATTR(fw_update_section, 0666, mip_sys_fw_update_section, NULL);
+static DEVICE_ATTR(fw_version, 0666, mip_sys_fw_version, NULL);
+static DEVICE_ATTR(fw_path, 0666, mip_sys_fw_path_show, mip_sys_fw_path_store);
+static DEVICE_ATTR(info, 0666, mip_sys_info, NULL);
+static DEVICE_ATTR(power_on, 0666, mip_sys_power_on, NULL);
+static DEVICE_ATTR(power_off, 0666, mip_sys_power_off, NULL);
+static DEVICE_ATTR(reboot, 0666, mip_sys_reboot, NULL);
+static DEVICE_ATTR(mode_glove, 0666, mip_sys_mode_show, mip_sys_mode_store);
+static DEVICE_ATTR(mode_charger, 0666, mip_sys_mode_show, mip_sys_mode_store);
+static DEVICE_ATTR(mode_cover_window, 0666, mip_sys_mode_show, mip_sys_mode_store);
+static DEVICE_ATTR(mode_palm_rejection, 0666, mip_sys_mode_show, mip_sys_mode_store);
+static DEVICE_ATTR(image_intensity, 0666, mip_sys_image, NULL);
+static DEVICE_ATTR(image_rawdata, 0666, mip_sys_image, NULL);
+static DEVICE_ATTR(test_cm_delta, 0600, mip_sys_test, NULL);
+static DEVICE_ATTR(test_cm_jitter, 0666, mip_sys_test, NULL);
+static DEVICE_ATTR(test_short, 0600, mip_sys_test, NULL);
+static DEVICE_ATTR(wakeup_gesture, 0666, mip_sys_wakeup_gesture, NULL);
+
+/**
+* Sysfs attr list info
+*/
+static struct attribute *mip_sys_attr[] = {
+	&dev_attr_fw_update_section.attr,
+	&dev_attr_fw_version.attr,
+	&dev_attr_fw_path.attr,
+	&dev_attr_info.attr,
+	&dev_attr_power_on.attr,
+	&dev_attr_power_off.attr,
+	&dev_attr_reboot.attr,
+	&dev_attr_mode_glove.attr,
+	&dev_attr_mode_charger.attr,
+	&dev_attr_mode_cover_window.attr,
+	&dev_attr_mode_palm_rejection.attr,
+	&dev_attr_image_intensity.attr,
+	&dev_attr_image_rawdata.attr,
+	&dev_attr_test_cm_delta.attr,
+	&dev_attr_test_cm_jitter.attr,
+	&dev_attr_test_short.attr,
+	&dev_attr_wakeup_gesture.attr,
+	NULL,
+};
+
+/**
+* Sysfs attr group info
+*/
+static const struct attribute_group mip_sys_attr_group = {
+	.attrs = mip_sys_attr,
+};
+
+/**
+* Create sysfs test functions
+*/
+int mip_sysfs_create(struct mip_ts_info *info)
+{
+	struct i2c_client *client = info->client;
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	if (sysfs_create_group(&client->dev.kobj, &mip_sys_attr_group)) {
+		dev_err(&client->dev, "%s [ERROR] sysfs_create_group\n", __func__);
+		return -EAGAIN;
+	}
+	
+	info->print_buf = kzalloc(sizeof(u8) * 4096, GFP_KERNEL);
+	info->image_buf = kzalloc(sizeof(int) * ((info->node_x * info->node_y) + info->node_key), GFP_KERNEL);
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+
+	return 0;
+}
+
+/**
+* Remove sysfs test functions
+*/
+void mip_sysfs_remove(struct mip_ts_info *info)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	
+	sysfs_remove_group(&info->client->dev.kobj, &mip_sys_attr_group);
+		
+	kfree(info->print_buf);
+	kfree(info->image_buf);
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	
+	return;
+}
+
+#endif
+
diff --git a/drivers/input/touchscreen/melfas_mip4_testplus/mip4_fw_mms438.c b/drivers/input/touchscreen/melfas_mip4_testplus/mip4_fw_mms438.c
new file mode 100755
index 00000000000..cc39fafbb88
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_testplus/mip4_fw_mms438.c
@@ -0,0 +1,503 @@
+/*
+ * MELFAS MIP4 Touchscreen
+ *
+ * Copyright (C) 2015 MELFAS Inc.
+ *
+ *
+ * mip4_fw_mms438.c : Firmware update functions for MMS438/449/458
+ *
+ */
+
+#include "mip4.h"
+
+//ISC Info
+#define ISC_PAGE_SIZE				128
+
+//ISC Command
+//#define ISC_CMD_ERASE_ALL			{0xFB,0x4A,0x00,0x15,0x00,0x00}
+#define ISC_CMD_ERASE_PAGE		{0xFB,0x4A,0x00,0x8F,0x00,0x00}
+#define ISC_CMD_READ_PAGE			{0xFB,0x4A,0x00,0xC2,0x00,0x00}
+//#define ISC_CMD_WRITE_PAGE		{0xFB,0x4A,0x00,0xA5,0x00,0x00}
+#define ISC_CMD_PROGRAM_PAGE		{0xFB,0x4A,0x00,0x54,0x00,0x00}
+#define ISC_CMD_READ_STATUS		{0xFB,0x4A,0x36,0xC2,0x00,0x00}
+#define ISC_CMD_EXIT				{0xFB,0x4A,0x00,0x66,0x00,0x00}
+
+//ISC Status
+#define ISC_STATUS_BUSY			0x96
+#define ISC_STATUS_DONE			0xAD
+
+/**
+* Read ISC status
+*/
+static int mip_isc_read_status(struct mip_ts_info *info)
+{
+	struct i2c_client *client = info->client;
+	u8 cmd[6] =  ISC_CMD_READ_STATUS;
+	u8 result = 0;
+	int cnt = 100;
+	int ret = 0;
+	struct i2c_msg msg[2] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.buf = cmd,
+			.len = 6,
+		}, {
+			.addr = client->addr,
+			.flags = I2C_M_RD,
+			.buf = &result,
+			.len = 1,
+		},
+	};
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+	
+	do {
+		if(i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg))!=ARRAY_SIZE(msg)){
+			dev_err(&info->client->dev, "%s [ERROR] i2c_transfer\n", __func__);
+			return -1;
+		}
+		
+		if(result == ISC_STATUS_DONE){
+			ret = 0;
+			break;
+		}
+		else if(result == ISC_STATUS_BUSY){
+			ret = -1;
+			msleep(1);
+		}
+		else{
+			dev_err(&info->client->dev, "%s [ERROR] wrong value [0x%02X]\n", __func__, result);
+			ret = -1;
+			msleep(1);
+		}	
+	} while (--cnt);
+
+	if (!cnt) {
+		dev_err(&info->client->dev, "%s [ERROR] count overflow - cnt [%d] status [0x%02X]\n", __func__, cnt, result);
+		goto ERROR;
+	}
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);	
+	
+	return ret;
+
+ERROR:
+	return ret;	
+}
+
+/**
+* Command : Erase Page
+*/
+static int mip_isc_erase_page(struct mip_ts_info *info, int offset)
+{
+	u8 write_buf[6] = ISC_CMD_ERASE_PAGE;
+
+	struct i2c_msg msg[1] = {
+		{
+			.addr = info->client->addr,
+			.flags = 0,
+			.buf = write_buf,
+			.len = 6,
+		}, 
+	};
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+
+	write_buf[4] = (u8)(((offset)>>8)&0xFF );
+	write_buf[5] = (u8)(((offset)>>0)&0xFF );
+	if(i2c_transfer(info->client->adapter, msg, ARRAY_SIZE(msg)) != ARRAY_SIZE(msg)){
+		dev_err(&info->client->dev, "%s [ERROR] i2c_transfer\n", __func__);
+		goto ERROR;
+	}
+	
+	if(mip_isc_read_status(info) != 0){
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE] - Offset [0x%04X]\n", __func__, offset);	
+		
+	return 0;
+
+ERROR:
+	return -1;
+}
+
+/**
+* Command : Read Page
+*/
+static int mip_isc_read_page(struct mip_ts_info *info, int offset, u8 *data)
+{
+	u8 write_buf[6] =ISC_CMD_READ_PAGE;
+
+	struct i2c_msg msg[2] = {
+		{
+			.addr = info->client->addr,
+			.flags = 0,
+			.buf = write_buf,
+			.len = 6,
+		}, {
+			.addr = info->client->addr,
+			.flags = I2C_M_RD,
+			.buf = data,
+			.len = ISC_PAGE_SIZE,
+		},
+	};
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+
+	write_buf[4] = (u8)(((offset)>>8)&0xFF );
+	write_buf[5] = (u8)(((offset)>>0)&0xFF );
+	if(i2c_transfer(info->client->adapter, msg, ARRAY_SIZE(msg)) != ARRAY_SIZE(msg)){
+		dev_err(&info->client->dev, "%s [ERROR] i2c_transfer\n", __func__);
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE] - Offset [0x%04X]\n", __func__, offset);	
+		
+	return 0;
+
+ERROR:
+	return -1;
+}
+
+#if 0
+/**
+* Command : Write Page
+*/
+static int mip_isc_write_page(struct mip_ts_info *info, int offset,const u8 *data, int length)
+{
+	u8 write_buf[134] = ISC_CMD_WRITE_PAGE;
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+
+	if( length > 128 ){
+		dev_err(&info->client->dev, "%s [ERROR] page length overflow\n", __func__);
+		goto ERROR;
+	}
+		
+	write_buf[4] = (u8)(((offset)>>8)&0xFF );
+	write_buf[5] = (u8)(((offset)>>0)&0xFF );
+	
+	memcpy( &write_buf[6], data, length);
+	
+	if(i2c_master_send(info->client, write_buf, length+6 )!=length+6){
+		dev_err(&info->client->dev, "%s [ERROR] i2c_master_send\n", __func__);	
+		goto ERROR;
+	}
+	
+	if(mip_isc_read_status(info) != 0){
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE] - Offset[0x%04X] Length[%d]\n", __func__, offset, length);	
+	
+	return 0;
+
+ERROR:
+	return -1;
+}
+#endif
+
+/**
+* Command : Program Page
+*/
+static int mip_isc_program_page(struct mip_ts_info *info, int offset, const u8 *data, int length)
+{
+	u8 write_buf[134] = ISC_CMD_PROGRAM_PAGE;
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+
+	if(length > ISC_PAGE_SIZE){
+		dev_err(&info->client->dev, "%s [ERROR] page length overflow\n", __func__);
+		goto ERROR;
+	}
+		
+	write_buf[4] = (u8)(((offset)>>8)&0xFF ); 
+	write_buf[5] = (u8)(((offset)>>0)&0xFF );
+	
+	memcpy(&write_buf[6], data, length);
+	
+	if(i2c_master_send(info->client, write_buf, (length + 6)) != (length + 6)){
+		dev_err(&info->client->dev, "%s [ERROR] i2c_master_send\n", __func__);	
+		goto ERROR;
+	}
+	
+	if(mip_isc_read_status(info) != 0){
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE] - Offset[0x%04X] Length[%d]\n", __func__, offset, length);	
+	
+	return 0;
+
+ERROR:
+	return -1;
+}
+
+/**
+* Command : Exit ISC
+*/
+static int mip_isc_exit(struct mip_ts_info *info)
+{
+	u8 write_buf[6] = ISC_CMD_EXIT;
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+
+	if(i2c_master_send(info->client, write_buf, 6 )!=6){
+		dev_err(&info->client->dev, "%s [ERROR] i2c_master_send\n", __func__);	
+		goto ERROR;
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);	
+	
+	return 0;
+
+ERROR:
+	return -1;
+}
+
+/**
+* Flash chip firmware (main function)
+*/
+int mip_flash_fw(struct mip_ts_info *info, const u8 *fw_data, size_t fw_size, bool force, bool section)
+{
+
+	struct mip_bin_hdr *fw_hdr;
+	struct mip_fw_img **img;
+	struct i2c_client *client = info->client;
+	int i;
+	int retires = 3;
+	int nRet;
+	int nStartAddr;
+	int nWriteLength;
+	int nLast;
+	int nOffset;
+	int nTransferLength;
+	int size;
+	u8 *data;
+	u8 *cpydata;
+	
+	int offset = sizeof(struct mip_bin_hdr);
+
+	bool update_flag = false;
+	bool update_flags[MIP_FW_MAX_SECT_NUM] = {false, };
+	
+	u16 ver_chip[MIP_FW_MAX_SECT_NUM];
+	u16 ver_file[MIP_FW_MAX_SECT_NUM];
+
+	int offsetStart = 0;
+	u8 initData[ISC_PAGE_SIZE];
+	memset(initData, 0xFF, sizeof(initData));
+	
+	dev_dbg(&client->dev,"%s [START]\n", __func__);
+
+	//Read firmware file
+	fw_hdr = (struct mip_bin_hdr *)fw_data;
+	img = kzalloc(sizeof(*img) * fw_hdr->section_num, GFP_KERNEL);
+
+	//Check firmware file
+	if(memcmp(CHIP_FW_CODE, &fw_hdr->tag[4], 4)){
+		dev_err(&client->dev, "%s [ERROR] F/W file is not for %s\n", __func__, CHIP_NAME);
+
+		nRet = fw_err_file_type;
+		goto ERROR;
+	}
+	
+	//Reboot chip
+	mip_reboot(info);
+	
+	//Check chip firmware version
+	while (retires--) {
+		if (!mip_get_fw_version_u16(info, ver_chip)){
+			break;
+		}
+		else {
+			mip_reboot(info);
+		}
+	}
+	if (retires < 0) {
+		dev_err(&client->dev, "%s [ERROR] cannot read chip firmware version\n", __func__);
+		
+		memset(ver_chip, 0xFFFF, sizeof(ver_chip));		
+		dev_info(&client->dev, "%s - Chip firmware version is set to [0xFFFF]\n", __func__);
+	} 
+	else {
+		dev_info(&client->dev, "%s - Chip firmware version [0x%04X 0x%04X 0x%04X 0x%04X]\n", __func__, ver_chip[0], ver_chip[1], ver_chip[2], ver_chip[3]);
+	}
+
+	//Set update flag
+	dev_info(&client->dev, "%s - Firmware file info : Sections[%d] Offset[0x%08X] Length[0x%08X]\n", __func__, fw_hdr->section_num, fw_hdr->binary_offset, fw_hdr->binary_length);
+
+	for (i = 0; i < fw_hdr->section_num; i++, offset += sizeof(struct mip_fw_img)) {
+		img[i] = (struct mip_fw_img *)(fw_data + offset);
+		ver_file[i] = img[i]->version;
+		
+		dev_info(&client->dev, "%s - Section info : Section[%d] Version[0x%04X] StartPage[%d] EndPage[%d] Offset[0x%08X] Length[0x%08X]\n", __func__, i, img[i]->version, img[i]->start_page, img[i]->end_page, img[i]->offset, img[i]->length);
+		
+		//Compare section version
+		if (ver_chip[i] != ver_file[i]) {
+			//Set update flag
+			update_flag = true;
+			update_flags[i] = true;
+			
+			dev_info(&client->dev, "%s - Section [%d] is need to be updated. Version : Chip[0x%04X] File[0x%04X]\n", __func__, i, ver_chip[i], ver_file[i]);
+		}
+	}
+
+	//Set force update flag
+	if(force == true){
+		update_flag = true;
+		update_flags[0] = true;
+		update_flags[1] = true;
+		update_flags[2] = true;
+		update_flags[3] = true;
+		
+		dev_info(&client->dev, "%s - Force update\n", __func__);
+	}
+
+	//Exit when up-to-date
+	if(update_flag == false){
+		nRet = fw_err_uptodate;
+		dev_dbg(&client->dev, "%s [DONE] Chip firmware is already up-to-date\n", __func__);
+		goto EXIT;
+	}
+	
+	//Set start addr offset
+	if(section == true){
+		if(update_flags[0] == true){
+			//boot
+			offsetStart = img[0]->start_page;
+		}
+		else if(update_flags[1] == true){
+			//core
+			offsetStart = img[1]->start_page;
+		}
+		else if(update_flags[2] == true){
+			//custom
+			offsetStart = img[2]->start_page;
+		}
+		else if(update_flags[3] == true){
+			//param
+			offsetStart = img[3]->start_page;
+		}
+	}
+	else{
+		offsetStart = 0;
+	}
+	
+	offsetStart = offsetStart * 1024;
+	
+	//Load firmware data
+	data = kzalloc(sizeof(u8) * fw_hdr->binary_length, GFP_KERNEL);
+	size = fw_hdr->binary_length;
+	cpydata = kzalloc(ISC_PAGE_SIZE, GFP_KERNEL);	
+
+	//Check firmware size
+	if(size % ISC_PAGE_SIZE != 0){
+		size += ( ISC_PAGE_SIZE - (size % ISC_PAGE_SIZE) );
+	}
+
+	nStartAddr = 0;	
+	nWriteLength = size;
+	nLast = nStartAddr + nWriteLength;
+
+	if((nLast) % 8 != 0){
+		nRet = fw_err_file_type;
+		dev_err(&client->dev, "%s [ERROR] Firmware size mismatch\n", __func__);
+		goto ERROR;
+	}
+	else{
+		memcpy(data, fw_data + fw_hdr->binary_offset, fw_hdr->binary_length);		
+	}
+
+	//Set address
+	nOffset = nStartAddr + nWriteLength - ISC_PAGE_SIZE;
+	nTransferLength = ISC_PAGE_SIZE;
+
+	//Erase first page
+	dev_info(&client->dev, "%s - Erase first page : Offset[0x%04X]\n", __func__, offsetStart);
+	nRet = mip_isc_erase_page(info, offsetStart);
+	if( nRet != 0 ) {
+		dev_err(&client->dev,"%s [ERROR] clear first page failed\n", __func__);
+		goto ERROR;
+	}
+
+	//Flash firmware
+	dev_info(&client->dev, "%s - Start Download : Offset Start[0x%04X] End[0x%04X]\n", __func__, nOffset, offsetStart);
+	while( nOffset >= offsetStart )
+	{
+		dev_info(&client->dev, "%s - Downloading : Offset[0x%04X]\n", __func__, nOffset);
+		
+		//Program (erase and write) a page
+		nRet = mip_isc_program_page(info, nOffset, &data[nOffset], nTransferLength);
+		if( nRet != 0 ) {
+			dev_err(&client->dev,"%s [ERROR] isc_program_page\n", __func__);
+			goto ERROR;
+		}
+
+		//Verify (read and compare)
+		if (mip_isc_read_page(info, nOffset, cpydata)) {
+			dev_err(&client->dev,"%s [ERROR] mip_isc_read_page\n", __func__);
+			goto ERROR;
+		}
+		
+		if (memcmp(&data[nOffset], cpydata, ISC_PAGE_SIZE)) {
+#if MIP_FW_UPDATE_DEBUG
+			print_hex_dump(KERN_ERR, "Firmware Page Write : ", DUMP_PREFIX_OFFSET, 16, 1, data, ISC_PAGE_SIZE, false);
+			print_hex_dump(KERN_ERR, "Firmware Page Read : ", DUMP_PREFIX_OFFSET, 16, 1, cpydata, ISC_PAGE_SIZE, false);
+#endif
+			dev_err(&client->dev, "%s [ERROR] verify page failed\n", __func__);
+
+			nRet = -1;
+			goto ERROR;
+		}
+		
+		nOffset -= nTransferLength;
+	}
+
+	//Exit ISC
+	nRet = mip_isc_exit(info);
+	if( nRet != 0 ) {
+		dev_err(&client->dev,"%s [ERROR] mip_isc_exit\n", __func__);
+		goto ERROR;
+	}
+	
+	//Reboot chip
+	mip_reboot(info);
+	
+	//Check chip firmware version
+	if (mip_get_fw_version_u16(info, ver_chip)) {
+		dev_err(&client->dev, "%s [ERROR] cannot read chip firmware version after flash\n", __func__);
+
+		nRet = -1;
+		goto ERROR;
+	} 
+	else {
+		for (i = 0; i < fw_hdr->section_num; i++) {
+			if (ver_chip[i] != ver_file[i]) {
+				dev_err(&client->dev, "%s [ERROR] version mismatch after flash. Section[%d] : Chip[0x%04X] != File[0x%04X]\n", __func__, i, ver_chip[i], ver_file[i]);
+
+				nRet = -1;
+				goto ERROR;
+			}
+		}
+	}
+
+	nRet = 0;
+	dev_dbg(&client->dev,"%s [DONE]\n", __func__);
+	dev_info(&client->dev,"Firmware update completed\n");
+ 	goto EXIT;
+
+ERROR:
+	dev_err(&client->dev,"%s [ERROR]\n", __func__);
+	dev_err(&client->dev,"Firmware update failed\n");
+	goto EXIT;
+
+EXIT:
+	kfree(img);
+
+	return nRet;
+	
+}
+
diff --git a/drivers/input/touchscreen/melfas_mip4_testplus/mip4_mod.c b/drivers/input/touchscreen/melfas_mip4_testplus/mip4_mod.c
new file mode 100755
index 00000000000..e606d60196b
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_testplus/mip4_mod.c
@@ -0,0 +1,612 @@
+/*
+ * MELFAS MIP4 Touchscreen
+ *
+ * Copyright (C) 2015 MELFAS Inc.
+ *
+ *
+ * mip4_mod.c : Model dependent functions
+ * 
+ */
+//#define DEBUG 1
+#include "mip4.h"
+
+/**
+* Control regulator
+*/
+int mip_regulator_control(struct mip_ts_info *info, int enable)
+{
+	//int ret = 0;
+
+	//////////////////////////
+	// MODIFY REQUIRED
+	//
+
+#if 0
+	static struct regulator *reg_vd33;
+
+	dev_dbg(&client->dev, "%s [START]\n", __func__);
+
+	if (!reg_vd33) {
+		reg_vd33 = regulator_get(&client->dev, "vd33");
+		//reg_vd33 = regulator_get(NULL, "8941_l22");		
+		if (IS_ERR(reg_vd33)) {
+			dev_err(&client->dev, "%s [ERROR] regulator_get\n", __func__);
+			goto ERROR;
+		}
+		
+		ret = regulator_set_voltage(reg_vd33, 3300000, 3300000);
+		if (ret) {
+			dev_err(&client->dev, "%s [ERROR] regulator_set_voltage\n", __func__);
+			goto ERROR;
+		}
+	}
+
+	if (enable) {
+		ret = regulator_enable(reg_vd33);
+		if (ret) {
+			dev_err(&client->dev, "%s [ERROR] regulator_enable [%d]\n", __func__, ret);
+			goto ERROR;
+		}
+	}
+	else{
+		if (regulator_is_enabled(reg_vd33)){
+			ret = regulator_disable(reg_vd33);
+			if (ret) {
+				dev_err(&client->dev, "%s [ERROR] regulator_disable [%d]\n", __func__, ret);
+				goto ERROR;
+			}
+		}
+	}
+
+	regulator_put(reg_vd33);
+
+#endif
+
+	//
+	//////////////////////////
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+
+/*
+ERROR:
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return -1;
+*/
+}
+
+/**
+* Turn off power supply
+*/
+int mip_power_off(struct mip_ts_info *info)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	//Control regulator
+	//mip_regulator_control(info, 0);
+
+	//Control power switch
+	gpio_direction_output(info->pdata->vdd_supply, 0);
+	mdelay(2);
+	gpio_direction_output(info->pdata->gpio_vdd_en, 0);
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+}
+
+/**
+* Turn on power supply
+*/
+int mip_power_on(struct mip_ts_info *info)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	//Control regulator
+	//mip_regulator_control(info, 1);
+
+	//Control power switch
+	gpio_direction_output(info->pdata->vdd_supply, 1);
+	mdelay(2);
+	gpio_direction_output(info->pdata->gpio_vdd_en, 1);
+	mdelay(20);
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+}
+
+/**
+* Clear touch input status in the set
+*/
+void mip_clear_input(struct mip_ts_info *info)
+{
+	int i;
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	//Screen
+	for(i = 0; i < MAX_FINGER_NUM; i++){
+		/////////////////////////////////
+		// MODIFY REQUIRED
+		//
+		
+		input_mt_slot(info->input_dev, i);
+		input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 0);
+		//input_report_key(info->input_dev, BTN_TOUCH, 0);
+		//input_report_key(info->input_dev, BTN_TOOL_FINGER, 0);
+
+		#if INPUT_SYNC_TYPE
+		input_sync(info->input_dev);
+		#endif
+		
+		//
+		/////////////////////////////////
+	}
+
+	//Key
+	if(info->key_enable == true){
+		for(i = 0; i < info->key_num; i++){
+			input_report_key(info->input_dev, info->key_code[i], 0);
+
+			#if INPUT_SYNC_TYPE
+			input_sync(info->input_dev);
+			#endif
+		}
+	}
+	
+#if !INPUT_SYNC_TYPE
+	input_sync(info->input_dev);
+#endif
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+		
+	return;
+}
+
+/**
+* Input event handler - Report touch input event
+*/
+void mip_input_event_handler(struct mip_ts_info *info, u8 sz, u8 *buf)
+{
+	int i;
+	int id, x, y;
+	int pressure = 0;
+	int size = 0;
+	int touch_major = 0;
+	int touch_minor = 0;
+	int palm = 0;
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	//dev_dbg(&info->client->dev, "%s - sz[%d] buf[0x%02X]\n", __func__, sz, buf[0]);
+	//print_hex_dump(KERN_ERR, "Event Packet : ", DUMP_PREFIX_OFFSET, 16, 1, buf, sz, false);
+
+	for (i = 0; i < sz; i += info->event_size) {
+		u8 *tmp = &buf[i];
+
+		//Report input data
+		if ((tmp[0] & MIP_EVENT_INPUT_SCREEN) == 0) {
+			//Touchkey Event
+			int key = tmp[0] & 0xf;
+			int key_state = (tmp[0] & MIP_EVENT_INPUT_PRESS) ? 1 : 0;
+			int key_code = 0;
+			
+			//Report touchkey event
+			if((key > 0) && (key <= info->key_num)){
+				key_code = info->key_code[key - 1];
+				
+				input_report_key(info->input_dev, key_code, key_state);
+				
+				#if INPUT_SYNC_TYPE
+				input_sync(info->input_dev);
+				#endif
+				
+				dev_dbg(&info->client->dev, "%s - Key : ID[%d] Code[%d] State[%d]\n", __func__, key, key_code, key_state);	
+			}
+			else{
+				dev_err(&info->client->dev, "%s [ERROR] Unknown key id [%d]\n", __func__, key);
+				continue;
+			}
+		}
+		else
+		{
+			//Touchscreen Event
+			
+			//Protocol Type
+			if(info->event_format == 0){
+				id = (tmp[0] & 0xf) - 1;
+				x = tmp[2] | ((tmp[1] & 0xf) << 8);
+				y = tmp[3] | (((tmp[1] >> 4) & 0xf) << 8);
+				pressure = tmp[4];
+				touch_major = tmp[5];								
+				palm = (tmp[0] & MIP_EVENT_INPUT_PALM) >> 4;			
+			}
+			else if(info->event_format == 1){
+				id = (tmp[0] & 0xf) - 1;
+				x = tmp[2] | ((tmp[1] & 0xf) << 8);
+				y = tmp[3] | (((tmp[1] >> 4) & 0xf) << 8);
+				pressure = tmp[4];
+				size = tmp[5];
+				touch_major = tmp[6];
+				touch_minor = tmp[7];							
+				palm = (tmp[0] & MIP_EVENT_INPUT_PALM) >> 4;			
+			}
+			else if(info->event_format == 2){
+				id = (tmp[0] & 0xf) - 1;
+				x = tmp[2] | ((tmp[1] & 0xf) << 8);
+				y = tmp[3] | (((tmp[1] >> 4) & 0xf) << 8);
+				pressure = tmp[4];
+				touch_major = tmp[5];
+				touch_minor = tmp[6];							
+				palm = (tmp[0] & MIP_EVENT_INPUT_PALM) >> 4;			
+			}
+			else{
+				dev_err(&info->client->dev, "%s [ERROR] Unknown event format [%d]\n", __func__, info->event_format);
+				goto ERROR;
+			}
+						
+			/////////////////////////////////
+			// MODIFY REQUIRED
+			//
+
+			//Report touchscreen event
+			if((tmp[0] & MIP_EVENT_INPUT_PRESS) == 0) {
+				//Release
+				input_mt_slot(info->input_dev, id);
+				input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 0);
+				//input_report_key(info->input_dev, BTN_TOUCH, 0);
+				//input_report_key(info->input_dev, BTN_TOOL_FINGER, 0);
+					
+				dev_dbg(&info->client->dev, "%s - Touch : ID[%d] Release\n", __func__, id);
+				
+				#if INPUT_SYNC_TYPE
+				input_sync(info->input_dev);
+				#endif
+				
+				continue;
+			}			
+			
+			//Press or Move
+			input_mt_slot(info->input_dev, id);
+			input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 1);
+			//input_report_key(info->input_dev, BTN_TOUCH, 1);
+			//input_report_key(info->input_dev, BTN_TOOL_FINGER, 1);
+			
+			input_report_abs(info->input_dev, ABS_MT_POSITION_X, x);
+			input_report_abs(info->input_dev, ABS_MT_POSITION_Y, y);
+			input_report_abs(info->input_dev, ABS_MT_PRESSURE, pressure);
+			input_report_abs(info->input_dev, ABS_MT_TOUCH_MAJOR, touch_major);
+			input_report_abs(info->input_dev, ABS_MT_TOUCH_MINOR, touch_minor);			
+			//input_report_abs(info->input_dev, ABS_MT_SUMSIZE, size);
+			//input_report_abs(info->input_dev, ABS_MT_PALM, palm);
+			
+			dev_dbg(&info->client->dev, "%s - Touch : ID[%d] X[%d] Y[%d] Z[%d] Major[%d] Minor[%d] Size[%d] Palm[%d]\n", __func__, id, x, y, pressure, touch_major, touch_minor, size, palm);
+
+			#if INPUT_SYNC_TYPE
+			input_sync(info->input_dev);
+			#endif
+			
+			//
+			/////////////////////////////////
+		}
+	}
+	
+#if !INPUT_SYNC_TYPE
+	input_sync(info->input_dev);
+#endif
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return;
+
+ERROR:	
+	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
+	return;
+}
+
+/**
+* Wake-up event handler
+*/
+int mip_wakeup_event_handler(struct mip_ts_info *info, u8 *rbuf)
+{
+	u8 wbuf[4];
+	//u8 gesture_code = rbuf[2];
+	u8 gesture_code = rbuf[1];
+	
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+	
+	/////////////////////////////////
+	// MODIFY REQUIRED
+	//
+
+	//Report wake-up event
+
+	dev_dbg(&info->client->dev, "%s - gesture[%d]\n", __func__, gesture_code);
+
+	info->wakeup_gesture_code = gesture_code;
+
+	switch(gesture_code){
+		case MIP_EVENT_GESTURE_C:
+		case MIP_EVENT_GESTURE_W:
+		case MIP_EVENT_GESTURE_V:
+		case MIP_EVENT_GESTURE_M:				
+		case MIP_EVENT_GESTURE_S:				
+		case MIP_EVENT_GESTURE_Z:				
+		case MIP_EVENT_GESTURE_O:				
+		case MIP_EVENT_GESTURE_E:				
+		case MIP_EVENT_GESTURE_V_90:
+		case MIP_EVENT_GESTURE_V_180:		
+		case MIP_EVENT_GESTURE_FLICK_RIGHT:	
+		case MIP_EVENT_GESTURE_FLICK_DOWN:	
+		case MIP_EVENT_GESTURE_FLICK_LEFT:	
+		case MIP_EVENT_GESTURE_FLICK_UP:		
+		case MIP_EVENT_GESTURE_DOUBLE_TAP:
+			//Example : emulate power key
+			input_report_key(info->input_dev, KEY_POWER, 1);
+			input_sync(info->input_dev);
+			input_report_key(info->input_dev, KEY_POWER, 0);
+			input_sync(info->input_dev);
+			break;
+			
+		default:
+			//Re-enter nap mode
+			wbuf[0] = MIP_R0_CTRL;
+			wbuf[1] = MIP_R1_CTRL_POWER_STATE;
+			wbuf[2] = MIP_CTRL_POWER_LOW;
+			if(mip_i2c_write(info, wbuf, 3)){
+				dev_err(&info->client->dev, "%s [ERROR] mip_i2c_write\n", __func__);
+				goto ERROR;
+			}	
+				
+			break;
+	}
+
+	//
+	//
+	/////////////////////////////////
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+	return 0;
+	
+ERROR:
+	return 1;
+}
+
+#if MIP_USE_DEVICETREE
+/**
+* Parse device tree
+*/
+int mip_parse_devicetree(struct device *dev, struct mip_ts_info *info)
+{
+	//struct i2c_client *client = to_i2c_client(dev);
+	//struct mip_ts_info *info = i2c_get_clientdata(client);
+	struct device_node *np = dev->of_node;
+	int ret;
+	//u32 val;
+	
+	dev_dbg(dev, "%s [START]\n", __func__);
+	
+	/////////////////////////////////
+	// MODIFY REQUIRED
+	//
+	
+	//Read property
+	/*
+	ret = of_property_read_u32(np, MIP_DEVICE_NAME",max_x", &val);
+	if (ret) {
+		dev_err(dev, "%s [ERROR] max_x\n", __func__);
+		info->pdata->max_x = 1080;
+	} 
+	else {
+		info->pdata->max_x = val;
+	}
+
+	ret = of_property_read_u32(np, MIP_DEVICE_NAME",max_y", &val);
+	if (ret) {
+		dev_err(dev, "%s [ERROR] max_y\n", __func__);
+		info->pdata->max_y = 1920;
+	}
+	else {
+		info->pdata->max_y = val;
+	}
+	*/
+	
+	//Get GPIO 
+	ret = of_get_named_gpio(np, MIP_DEVICE_NAME",irq-gpio", 0);
+	if (!gpio_is_valid(ret)) {
+		dev_err(dev, "%s [ERROR] of_get_named_gpio : irq-gpio\n", __func__);
+		goto ERROR;
+	}
+	else{
+		info->pdata->gpio_intr = ret;
+	}
+
+	/*
+	ret = of_get_named_gpio(np, MIP_DEVICE_NAME",reset-gpio", 0);
+	if (!gpio_is_valid(ret)) {
+		dev_err(dev, "%s [ERROR] of_get_named_gpio : reset-gpio\n", __func__);
+		goto ERROR;
+	}
+	else{
+		info->pdata->gpio_reset = ret;
+	}
+	*/
+	
+	//Config GPIO
+	ret = gpio_request(info->pdata->gpio_intr, "irq-gpio");
+	if (ret < 0) {
+		dev_err(dev, "%s [ERROR] gpio_request : irq-gpio\n", __func__);
+		goto ERROR;
+	}	
+	gpio_direction_input(info->pdata->gpio_intr);
+
+	info->pdata->melfas_pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR_OR_NULL(info->pdata->melfas_pinctrl)) {
+		dev_err(dev, "%s:melfas pinctrl get error!\n", __func__);
+		ret = PTR_ERR(info->pdata->melfas_pinctrl);
+		goto ERROR;
+	}
+
+	info->pdata->pinctrl_default = pinctrl_lookup_state(
+			info->pdata->melfas_pinctrl, "default");
+	if (IS_ERR_OR_NULL(info->pdata->pinctrl_default)) {
+		dev_err(dev, "%s:Can not get ts default state\n", __func__);
+		ret = PTR_ERR(info->pdata->pinctrl_default);
+		goto ERROR;
+	}
+
+	ret = pinctrl_select_state(info->pdata->melfas_pinctrl,
+			info->pdata->pinctrl_default);
+	if (ret) {		
+		dev_err(dev, "%s:pinctrl select error!\n", __func__);
+		goto ERROR;
+	}
+	
+	ret = of_property_read_string(np, "mip4_ts,fw_name", &info->pdata->fw_name);
+        if (ret && (ret != -EINVAL)) {
+               	dev_err(dev, "Unable to read fw name\n");
+               	return ret;
+        }
+
+	/*
+	ret = gpio_request(info->pdata->gpio_reset, "reset-gpio");
+	if (ret < 0) {
+		dev_err(dev, "%s [ERROR] gpio_request : reset-gpio\n", __func__);
+		goto ERROR;
+	}		
+	gpio_direction_output(info->pdata->gpio_reset, 1);
+	*/
+	
+	//Set IRQ
+	//info->client->irq = gpio_to_irq(info->pdata->gpio_intr); 
+	dev_dbg(dev, "%s - gpio_to_irq : irq[%d]\n", __func__, info->client->irq);
+
+	//Get  Reset GPIO 
+	ret = of_get_named_gpio(np, MIP_DEVICE_NAME",reset-gpio", 0);
+	if (!gpio_is_valid(ret)) {
+		dev_err(dev, "%s [ERROR] of_get_named_gpio : irq-gpio\n", __func__);
+		goto ERROR;
+	}
+	else{
+		info->pdata->gpio_vdd_en = ret;
+	}
+
+	ret = gpio_request(info->pdata->gpio_vdd_en, "reset-gpio");
+	if (ret < 0) {
+		dev_err(dev, "%s [ERROR] gpio_request : reset-gpio\n", __func__);
+		goto ERROR;
+	}
+	
+	ret = of_get_named_gpio(np, MIP_DEVICE_NAME",vdd-supply", 0);
+	if (!gpio_is_valid(ret)) {
+		dev_err(dev, "%s [ERROR] of_get_named_gpio : irq-gpio\n", __func__);
+		goto ERROR;
+	}
+	else{
+		info->pdata->vdd_supply = ret;
+	}
+
+	ret = gpio_request(info->pdata->vdd_supply, "vdd-supply");
+	if (ret < 0) {
+		dev_err(dev, "%s [ERROR] gpio_request : reset-gpio\n", __func__);
+		goto ERROR;
+	}
+	//
+	/////////////////////////////////
+	
+	dev_dbg(dev, "%s [DONE]\n", __func__);	
+	return 0;
+
+ERROR:
+	dev_err(dev, "%s [ERROR]\n", __func__);	
+	return 1;
+}
+#endif
+
+/**
+* Config input interface	
+*/
+void mip_config_input(struct mip_ts_info *info)
+{
+	struct input_dev *input_dev = info->input_dev;
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+
+	/////////////////////////////
+	// MODIFY REQUIRED
+	//
+
+	set_bit(EV_SYN, input_dev->evbit);
+	set_bit(EV_ABS, input_dev->evbit);
+	set_bit(EV_KEY, input_dev->evbit);	
+	
+	//Screen
+	set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+	//set_bit(BTN_TOUCH, input_dev->keybit);
+	//set_bit(BTN_TOOL_FINGER, input_dev->keybit);	
+	
+	input_mt_init_slots(input_dev, MAX_FINGER_NUM, 0);
+	//input_mt_init_slots(input_dev, MAX_FINGER_NUM, INPUT_MT_DIRECT);
+	
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, info->max_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, info->max_y, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_PRESSURE, 0, INPUT_PRESSURE_MAX, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, INPUT_TOUCH_MAJOR_MAX, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0, INPUT_TOUCH_MINOR_MAX, 0, 0);	
+	//input_set_abs_params(input_dev, ABS_MT_SUMSIZE, 0, 255, 0, 0);
+	//input_set_abs_params(input_dev, ABS_MT_PALM, 0, 1, 0, 0);
+	
+	//Key
+	set_bit(KEY_BACK, input_dev->keybit);
+	set_bit(KEY_MENU, input_dev->keybit);
+	set_bit(KEY_HOME, input_dev->keybit);
+	
+	info->key_code[0] = KEY_BACK;
+	info->key_code[1] = KEY_HOME;
+	info->key_code[2] = KEY_MENU;
+
+#if MIP_USE_WAKEUP_GESTURE
+	set_bit(KEY_POWER, input_dev->keybit);
+#endif	
+		
+	//
+	/////////////////////////////
+
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);	
+	return;
+}
+
+#if MIP_USE_CALLBACK
+/**
+* Callback - get charger status
+*/
+void mip_callback_charger(struct mip_callbacks *cb, int charger_status)
+{
+	struct mip_ts_info *info = container_of(cb, struct mip_ts_info, callbacks);
+
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
+
+	dev_info(&info->client->dev, "%s - charger_status[%d]\n", __func__, charger_status);
+	
+	//...
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
+}
+
+/**
+* Config callback functions
+*/
+void mip_config_callback(struct mip_ts_info *info)
+{
+	dev_dbg(&info->client->dev, "%s [START]\n", __func__);	
+
+	info->register_callback = info->pdata->register_callback;
+
+	//callback functions
+	info->callbacks.inform_charger = mip_callback_charger;
+	//info->callbacks.inform_display = mip_callback_display;
+	//...
+	
+	if (info->register_callback){
+		info->register_callback(&info->callbacks);
+	}
+	
+	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);	
+	return;
+}
+#endif
+
diff --git a/drivers/input/touchscreen/melfas_mip4_testplus/mip4_reg.h b/drivers/input/touchscreen/melfas_mip4_testplus/mip4_reg.h
new file mode 100755
index 00000000000..bb8572f1560
--- /dev/null
+++ b/drivers/input/touchscreen/melfas_mip4_testplus/mip4_reg.h
@@ -0,0 +1,155 @@
+/*
+ * MELFAS MIP4 Touchscreen
+ *
+ * Copyright (C) 2015 MELFAS Inc.
+ *
+ *
+ * mip4_reg.h : Protocol information
+ * 
+ *
+ * Protocol Version : MIP 4.0 Rev 3.2
+ *
+ */
+
+//Address
+#define MIP_R0_INFO						0x01
+#define MIP_R1_INFO_PRODUCT_NAME			0x00
+#define MIP_R1_INFO_RESOLUTION_X			0x10
+#define MIP_R1_INFO_RESOLUTION_Y			0x12
+#define MIP_R1_INFO_NODE_NUM_X			0x14
+#define MIP_R1_INFO_NODE_NUM_Y			0x15
+#define MIP_R1_INFO_KEY_NUM				0x16
+#define MIP_R1_INFO_VERSION_BOOT			0x20
+#define MIP_R1_INFO_VERSION_CORE			0x22
+#define MIP_R1_INFO_VERSION_CUSTOM		0x24
+#define MIP_R1_INFO_VERSION_PARAM		0x26
+#define MIP_R1_INFO_SECT_BOOT_START		0x30
+#define MIP_R1_INFO_SECT_BOOT_END		0x31
+#define MIP_R1_INFO_SECT_CORE_START		0x32
+#define MIP_R1_INFO_SECT_CORE_END		0x33
+#define MIP_R1_INFO_SECT_CUSTOM_START	0x34
+#define MIP_R1_INFO_SECT_CUSTOM_END		0x35
+#define MIP_R1_INFO_SECT_PARAM_START	0x36
+#define MIP_R1_INFO_SECT_PARAM_END		0x37
+#define MIP_R1_INFO_BUILD_DATE			0x40
+#define MIP_R1_INFO_BUILD_TIME			0x44
+#define MIP_R1_INFO_CHECKSUM_PRECALC	0x48
+#define MIP_R1_INFO_CHECKSUM_REALTIME	0x4A
+#define MIP_R1_INFO_CHECKSUM_CALC		0x4C
+#define MIP_R1_INFO_PROTOCOL_NAME		0x50
+#define MIP_R1_INFO_PROTOCOL_VERSION	0x58
+#define MIP_R1_INFO_IC_ID					0x70
+
+#define MIP_R0_EVENT						0x02
+#define MIP_R1_EVENT_SUPPORTED_FUNC		0x00
+#define MIP_R1_EVENT_FORMAT				0x04
+#define MIP_R1_EVENT_SIZE					0x06
+#define MIP_R1_EVENT_PACKET_INFO			0x10
+#define MIP_R1_EVENT_PACKET_DATA			0x11
+
+#define MIP_R0_CTRL						0x06	
+#define MIP_R1_CTRL_READY_STATUS			0x00
+#define MIP_R1_CTRL_EVENT_READY			0x01
+#define MIP_R1_CTRL_MODE					0x10
+#define MIP_R1_CTRL_EVENT_TRIGGER_TYPE	0x11
+#define MIP_R1_CTRL_RECALIBRATE			0x12
+#define MIP_R1_CTRL_POWER_STATE			0x13
+#define MIP_R1_CTRL_GESTURE_TYPE			0x14
+#define MIP_R1_CTRL_DISABLE_ESD_ALERT	0x18
+#define MIP_R1_CTRL_CHARGER_MODE			0x19
+#define MIP_R1_CTRL_GLOVE_MODE			0x1A
+#define MIP_R1_CTRL_WINDOW_MODE			0x1B
+#define MIP_R1_CTRL_PALM_REJECTION		0x1C
+#define MIP_R1_CTRL_EDGE_EXPAND			0x1D
+
+#define MIP_R0_PARAM						0x08
+#define MIP_R1_PARAM_BUFFER_ADDR			0x00
+#define MIP_R1_PARAM_PROTOCOL			0x04
+#define MIP_R1_PARAM_MODE					0x10
+
+#define MIP_R0_TEST						0x0A
+#define MIP_R1_TEST_BUF_ADDR				0x00
+#define MIP_R1_TEST_PROTOCOL				0x02
+#define MIP_R1_TEST_TYPE					0x10
+#define MIP_R1_TEST_DATA_FORMAT			0x20
+#define MIP_R1_TEST_ROW_NUM				0x20
+#define MIP_R1_TEST_COL_NUM				0x21
+#define MIP_R1_TEST_BUFFER_COL_NUM		0x22
+#define MIP_R1_TEST_COL_AXIS				0x23
+#define MIP_R1_TEST_KEY_NUM				0x24
+#define MIP_R1_TEST_DATA_TYPE			0x25
+
+#define MIP_R0_IMAGE						0x0C
+#define MIP_R1_IMAGE_BUF_ADDR			0x00
+#define MIP_R1_IMAGE_PROTOCOL_ID			0x04
+#define MIP_R1_IMAGE_TYPE					0x10
+#define MIP_R1_IMAGE_DATA_FORMAT			0x20
+#define MIP_R1_IMAGE_ROW_NUM				0x20
+#define MIP_R1_IMAGE_COL_NUM				0x21
+#define MIP_R1_IMAGE_BUFFER_COL_NUM		0x22
+#define MIP_R1_IMAGE_COL_AXIS			0x23
+#define MIP_R1_IMAGE_KEY_NUM				0x24
+#define MIP_R1_IMAGE_DATA_TYPE			0x25
+#define MIP_R1_IMAGE_FINGER_NUM			0x30
+#define MIP_R1_IMAGE_FINGER_AREA			0x31
+
+#define MIP_R0_LOG							0x10
+#define MIP_R1_LOG_TRIGGER				0x14
+
+//Value
+#define MIP_EVENT_INPUT_PRESS			0x80
+#define MIP_EVENT_INPUT_SCREEN			0x40
+#define MIP_EVENT_INPUT_HOVER			0x20
+#define MIP_EVENT_INPUT_PALM				0x10
+#define MIP_EVENT_INPUT_ID				0x0F
+
+#define MIP_EVENT_GESTURE_C				1
+#define MIP_EVENT_GESTURE_W				2
+#define MIP_EVENT_GESTURE_V				3	
+#define MIP_EVENT_GESTURE_M				4
+#define MIP_EVENT_GESTURE_S				5
+#define MIP_EVENT_GESTURE_Z				6
+#define MIP_EVENT_GESTURE_O				7
+#define MIP_EVENT_GESTURE_E				8
+#define MIP_EVENT_GESTURE_V_90			9
+#define MIP_EVENT_GESTURE_V_180			10
+#define MIP_EVENT_GESTURE_FLICK_RIGHT	20			
+#define MIP_EVENT_GESTURE_FLICK_DOWN	21		
+#define MIP_EVENT_GESTURE_FLICK_LEFT	22	
+#define MIP_EVENT_GESTURE_FLICK_UP		23
+#define MIP_EVENT_GESTURE_DOUBLE_TAP	24
+#define MIP_EVENT_GESTURE_ALL			0xFFFFFFFF
+
+#define MIP_ALERT_ESD					1
+#define MIP_ALERT_WAKEUP				2
+#define MIP_ALERT_INPUTTYPE			3
+
+#define MIP_CTRL_STATUS_NONE			0x05
+#define MIP_CTRL_STATUS_READY		0xA0
+#define MIP_CTRL_STATUS_LOG			0x77
+
+#define MIP_CTRL_MODE_NORMAL			0		
+#define MIP_CTRL_MODE_PARAM			1
+#define MIP_CTRL_MODE_TEST_CM		2
+
+#define MIP_CTRL_POWER_ACTIVE		0
+#define MIP_CTRL_POWER_LOW			1
+
+#define MIP_TEST_TYPE_NONE			0
+#define MIP_TEST_TYPE_CM_DELTA		1
+#define MIP_TEST_TYPE_CM_ABS			2
+#define MIP_TEST_TYPE_CM_JITTER		3
+#define MIP_TEST_TYPE_SHORT			4
+
+#define MIP_IMG_TYPE_NONE				0
+#define MIP_IMG_TYPE_INTENSITY		1
+#define MIP_IMG_TYPE_RAWDATA			2
+#define MIP_IMG_TYPE_WAIT				255
+
+#define MIP_TRIGGER_TYPE_NONE		0
+#define MIP_TRIGGER_TYPE_INTR		1
+#define MIP_TRIGGER_TYPE_REG			2
+
+#define MIP_LOG_MODE_NONE				0
+#define MIP_LOG_MODE_TRIG				1
+
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index 9dedfdc4d1a..c208b837f66 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -517,6 +517,13 @@ config LEDS_BLINKM
 	help
 	  This option enables support for the BlinkM RGB LED connected
 	  through I2C. Say Y to enable support for the BlinkM LED.
+config LEDS_aw2013rgb                                                                                               
+	 tristate "LED support for the BlinkM I2C RGB LED"
+     depends on LEDS_CLASS
+     depends on I2C
+     help
+       This option enables support for the BlinkM RGB LED connected
+       through I2C. Say Y to enable support for the BlinkM LED.
 
 config LEDS_AW2013
 	tristate "LED support for AW2013"
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index 201a9097c35..379e3519b4c 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -58,7 +58,7 @@ obj-$(CONFIG_LEDS_LM355x)		+= leds-lm355x.o
 obj-$(CONFIG_LEDS_BLINKM)		+= leds-blinkm.o
 obj-$(CONFIG_LEDS_MSM_GPIO_FLASH)	+= leds-msm-gpio-flash.o
 obj-$(CONFIG_LEDS_AW2013)		+= leds-aw2013.o
-
+obj-$(CONFIG_LEDS_aw2013rgb)    += aw2013_rgb.o
 # LED SPI Drivers
 obj-$(CONFIG_LEDS_DAC124S085)		+= leds-dac124s085.o
 
diff --git a/drivers/leds/aw2013_rgb.c b/drivers/leds/aw2013_rgb.c
new file mode 100755
index 00000000000..70339448297
--- /dev/null
+++ b/drivers/leds/aw2013_rgb.c
@@ -0,0 +1,888 @@
+#include <linux/i2c.h>
+#include <linux/debugfs.h>
+#include <linux/gpio.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/power_supply.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/regulator/machine.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/bitops.h>
+
+#define RSTR   0x00   //can be ID register and RESET register 0x54 or 0x55 
+#define GCR    0x01   
+#define STATUS 0x02
+#define effecREG30 0x30
+#define LED0_CTRL 0x31
+#define LED1_CTRL 0x32
+#define LED2_CTRL 0x33
+#define PWM0_CTRL 0x34
+#define PWM1_CTRL 0x35
+#define PWM2_CTRL 0x36
+#define LED0_T0   0x37
+#define LED0_T1   0x38
+#define LED0_T2   0x39
+#define LED1_T0   0x3A
+#define LED1_T1   0x3B
+#define LED1_T2   0x3C
+#define LED2_T0   0x3D
+#define LED2_T1   0x3E
+#define LED2_T2   0x3F
+#define SELECT_I2C_ADDR   0x77
+
+
+//#define Imax        0x01   //LED ,0x00=omA,0x01=5mA,0x02=10mA,0x03=15mA,
+#define Rise_time   0x02   //LED,0x00=0.13s,0x01=0.26s,0x02=0.52s,0x03=1.04s,0x04=2.08s,0x05=4.16s,0x06=8.32s,0x07=16.64s
+#define Hold_time   0x03   //LED,0x00=0.13s,0x01=0.26s,0x02=0.52s,0x03=1.04s,0x04=2.08s,0x05=4.16s
+#define Fall_time   0x02   //LED,0x00=0.13s,0x01=0.26s,0x02=0.52s,0x03=1.04s,0x04=2.08s,0x05=4.16s,0x06=8.32s,0x07=16.64s
+#define Off_time    0x01   //LED,0x00=0.13s,0x01=0.26s,0x02=0.52s,0x03=1.04s,0x04=2.08s,0x05=4.16s,0x06=8.32s,0x07=16.64s
+#define Delay_time  0x00   //LED,0x00=0s,0x01=0.13s,0x02=0.26s,0x03=0.52s,0x04=1.04s,0x05=2.08s,0x06=4.16s,0x07=8.32s,0x08=16.64s
+#define Period_Num  0x00   //LED,0x00=,0x01=1,0x02=2.....0x0f=15
+
+static u8 MAX_BRIGHTNESS = 200;
+static u8 Imax = 0x01;
+
+struct aw2013_chip {
+    struct i2c_client *client;
+	struct device     *dev;
+	struct led_classdev red;
+	struct led_classdev green;
+	struct led_classdev blue;
+	struct work_struct work_red;
+	struct work_struct work_green;
+	struct work_struct work_blue;
+	struct work_struct work_red_blink;
+	struct work_struct work_green_blink;
+	struct work_struct work_blue_blink;
+	/*brightness*/
+	int    red_brightness;
+	int    green_brightness;
+	int    blue_brightness;
+	/*blink on off time*/
+	unsigned long    red_ontime;
+	unsigned long    red_offtime;
+	unsigned long    green_ontime;
+	unsigned long    green_offtime;
+	unsigned long    blue_ontime;
+	unsigned long    blue_offtime;
+	/*status*/
+	int    enable_status; 
+	int    pwm;
+	int    light;
+	struct dentry	  *debug_root;
+	struct mutex  read_write_lock;
+	struct pinctrl *redledgpio_pinctrl;
+	struct pinctrl_state *gpio_state_active;
+	#if 0
+	struct pinctrl_state *dtv_state_suspend;
+	int    dtv_gpio20;
+	#endif
+	int    red_gpio22;
+};
+enum aw2013_mode{
+    RED_MODE,
+    GREEN_MODE,
+    BLUE_MODE,
+    BREATH_MODE,
+};
+static struct i2c_client *aw_i2c_client;//globle 
+static int aw2013_blink_set(struct led_classdev *led_cdev,
+				     unsigned long *delay_on,
+				     unsigned long *delay_off);
+static void red_led_gpio22_output(struct aw2013_chip *chip);
+static int first_redgpio_output = 0;
+static struct aw2013_chip *the_chip;
+static int __aw2013_read(struct aw2013_chip *chip, int reg,
+				u8 *val)
+{
+	s32 ret;
+
+	ret = i2c_smbus_read_byte_data(chip->client, reg);
+	if (ret < 0) {
+		dev_err(chip->dev,
+			"i2c read fail: can't read from %02x: %d\n", reg, ret);
+		return ret;
+	} else {
+		*val = ret;
+	}
+
+	return 0;
+}
+
+static int __aw2013_write(struct aw2013_chip *chip, int reg,
+						u8 val)
+{
+	s32 ret;
+
+	ret = i2c_smbus_write_byte_data(chip->client, reg, val);
+	if (ret < 0) {
+		dev_err(chip->dev,
+			"i2c write fail: can't write %02x to %02x: %d\n",
+			val, reg, ret);
+		return ret;
+	}
+	pr_debug("Writing 0x%02x=0x%02x\n", reg, val);
+	return 0;
+}
+#if 1
+static int aw2013_write(int reg,u8 val)
+{
+    s32 ret ;
+	ret = i2c_smbus_write_byte_data(aw_i2c_client, reg, val);
+	if (ret < 0) {
+		printk("aw2013_write error\n");
+		return ret;
+	}
+	//pr_debug("wuboadd Writing 0x%02x=0x%02x\n", reg, val);
+	return 0;
+}
+/*
+static int aw2013_read(int reg)
+{
+    s32 ret ;
+	ret = i2c_smbus_read_byte_data(aw_i2c_client, reg);
+	if (ret < 0) {
+		printk("aw2013_write error\n");
+		return ret;
+	}
+	//pr_debug("wuboadd Writing 0x%02x=0x%02x\n", reg, val);
+	return ret;
+}*/
+
+#endif
+static void aw2013_breath_all(int led0,int led1,int led2)  //led on=0x01   ledoff=0x00
+{  
+
+#if 0
+	aw2013_write(0x00, 0x55);				// Reset 
+	aw2013_write(0x01, 0x01);		// enable LED 		
+
+	aw2013_write(0x31, 0x70|Imax);	//config mode, IMAX = 5mA	
+	aw2013_write(0x32, 0x70|Imax);	//config mode, IMAX = 5mA	
+	aw2013_write(0x33, 0x70|Imax);	//config mode, IMAX = 5mA	
+
+	aw2013_write(0x34, 0xff);	// LED0 level,
+	aw2013_write(0x35, 0xff);	// LED1 level,
+	aw2013_write(0x36, 0xff);	// LED2 level,
+											
+	aw2013_write(0x37, Rise_time<<4 | Hold_time);	//led0  							
+	aw2013_write(0x38, Fall_time<<4 | Off_time);	       //led0 
+	aw2013_write(0x39, Delay_time<<4| Period_Num);   //led0  
+
+	aw2013_write(0x3a, Rise_time<<4 | Hold_time);	//led1								
+	aw2013_write(0x3b, Fall_time<<4 | Off_time);	       //led1 
+	aw2013_write(0x3c, Delay_time<<4| Period_Num);   //led1  
+
+	aw2013_write(0x3d, Rise_time<<4 | Hold_time);	//led2  				
+	aw2013_write(0x3e, Fall_time<<4 | Off_time);	       //led2 
+	aw2013_write(0x3f, Delay_time<<4| Period_Num);    //
+
+	aw2013_write(0x30, led2<<2|led1<<1|led0);	       //led on=0x01 ledoff=0x00	
+	mdelay(2);//5us	
+#endif
+}
+
+static int aw2013_control(struct aw2013_chip *chip,
+			  u8 brightness, enum aw2013_mode opmode)
+{
+    
+    //u8 data0x30 =0;
+    //__aw2013_read(chip,0x30,&data0x30);
+	//printk("wubo aw2013_control mode:%d reg0x30:%x\n",opmode,data0x30);
+    __aw2013_write(chip,0x30,0x07);
+	//__aw2013_read(chip,0x30,&data0x30);
+	//printk("wubo aw2013_control after write again reg0x30:%x\n",data0x30);
+	__aw2013_write(chip,GCR,0x01);
+	//__aw2013_read(chip,GCR,&data0x30);
+	//printk("wubo aw2013_control after write again reg0x01:%x\n",data0x30);
+    switch(opmode){
+           case RED_MODE:
+                //__aw2013_write(chip,LED0_CTRL,Imax);
+				__aw2013_write(chip,LED1_CTRL,Imax);
+                //__aw2013_write(chip,LED2_CTRL,Imax);
+                __aw2013_write(chip,PWM1_CTRL,brightness);
+				//udelay(5);
+				//__aw2013_write(chip,0x30, 0x02);
+				//udelay(5);
+			    break;
+		   case GREEN_MODE:
+                //__aw2013_write(chip,LED0_CTRL,Imax);
+				//__aw2013_write(chip,LED1_CTRL,Imax);
+				__aw2013_write(chip,LED2_CTRL,Imax);
+		   	    __aw2013_write(chip,PWM2_CTRL,brightness);
+				//udelay(5);
+				//__aw2013_write(chip,0x30, 0x04);
+				//udelay(5);
+				break;
+		   case BLUE_MODE:
+                __aw2013_write(chip,LED0_CTRL,Imax);
+				//__aw2013_write(chip,LED1_CTRL,Imax);
+				//__aw2013_write(chip,LED2_CTRL,Imax);
+		   	    __aw2013_write(chip,PWM0_CTRL,brightness);
+				//udelay(5);
+				//__aw2013_write(chip,0x30, 0x01);
+				//udelay(5);
+		   	    break;
+		   case BREATH_MODE:
+		   	    break;
+	}
+	return 1;
+}
+static int aw2013_remove(struct i2c_client *client)
+{
+	struct aw2013_chip *chip = i2c_get_clientdata(client);
+
+	mutex_destroy(&chip->read_write_lock);
+	debugfs_remove_recursive(chip->debug_root);
+
+	return 0;
+}
+static void aw2013_deferred_red_brightness_set(struct work_struct *work)
+{
+	struct aw2013_chip *chip =
+	    container_of(work, struct aw2013_chip, work_red);
+    red_led_gpio22_output(chip);
+	mutex_lock(&chip->read_write_lock);
+	aw2013_control(chip, chip->red_brightness, RED_MODE);
+	mutex_unlock(&chip->read_write_lock);
+}
+static void aw2013_deferred_red_blink_set(struct work_struct *work)
+{
+	struct aw2013_chip *chip =
+	    container_of(work, struct aw2013_chip, work_red_blink);
+    red_led_gpio22_output(chip);
+	mutex_lock(&chip->read_write_lock);
+	aw2013_blink_set(&chip->red,&chip->red_ontime,&chip->red_offtime);
+	mutex_unlock(&chip->read_write_lock);
+}
+
+static void aw2013_deferred_green_brightness_set(struct work_struct *work)
+{
+	struct aw2013_chip *chip =
+	    container_of(work, struct aw2013_chip, work_green);
+
+	mutex_lock(&chip->read_write_lock);
+	aw2013_control(chip, chip->green_brightness, GREEN_MODE);
+	mutex_unlock(&chip->read_write_lock);
+}
+
+static void aw2013_deferred_green_blink_set(struct work_struct *work)
+{
+	struct aw2013_chip *chip =
+	    container_of(work, struct aw2013_chip, work_green_blink);
+
+	mutex_lock(&chip->read_write_lock);
+	aw2013_blink_set(&chip->green,&chip->green_ontime,&chip->green_offtime);
+	mutex_unlock(&chip->read_write_lock);
+}
+
+static void aw2013_deferred_blue_brightness_set(struct work_struct *work)
+{
+	struct aw2013_chip *chip =
+	    container_of(work, struct aw2013_chip, work_blue);
+
+	mutex_lock(&chip->read_write_lock);
+	aw2013_control(chip, chip->blue_brightness, BLUE_MODE);
+	mutex_unlock(&chip->read_write_lock);
+}
+
+static void aw2013_deferred_blue_blink_set(struct work_struct *work)
+{
+	struct aw2013_chip *chip =
+	    container_of(work, struct aw2013_chip, work_blue_blink);
+
+	mutex_lock(&chip->read_write_lock);
+	aw2013_blink_set(&chip->blue,&chip->blue_ontime,&chip->blue_offtime);
+	mutex_unlock(&chip->read_write_lock);
+}
+
+static void aw2013_red_brightness_set(struct led_classdev *cdev,
+					enum led_brightness brightness)
+{
+	struct aw2013_chip *chip =
+	    container_of(cdev, struct aw2013_chip, red);
+    chip->red_ontime  = 0;
+	chip->red_offtime = 0;
+	chip->red_brightness = brightness;
+	schedule_work(&chip->work_red);
+}
+
+static void aw2013_green_brightness_set(struct led_classdev *cdev,
+					enum led_brightness brightness)
+{
+	struct aw2013_chip *chip =
+	    container_of(cdev, struct aw2013_chip, green);
+    chip->green_ontime  = 0;
+	chip->green_offtime = 0;
+	chip->green_brightness = brightness;
+	schedule_work(&chip->work_green);
+}
+
+static void aw2013_blue_brightness_set(struct led_classdev *cdev,
+					enum led_brightness brightness)
+{
+	struct aw2013_chip *chip =
+	    container_of(cdev, struct aw2013_chip, blue);
+    chip->blue_ontime  = 0;
+	chip->blue_offtime = 0;
+	chip->blue_brightness = brightness;
+	schedule_work(&chip->work_blue);
+}
+
+static int aw2013_blink_red_set(struct led_classdev *led_cdev,
+				     unsigned long *delay_on,
+				     unsigned long *delay_off)
+{
+	struct aw2013_chip *chip =
+	    container_of(led_cdev, struct aw2013_chip, red);
+    
+	chip->red_ontime  = *delay_on;
+	chip->red_offtime = *delay_off;
+	schedule_work(&chip->work_red_blink);
+	return 1;
+}
+
+static int aw2013_blink_green_set(struct led_classdev *led_cdev,
+				     unsigned long *delay_on,
+				     unsigned long *delay_off)
+{
+	struct aw2013_chip *chip =
+	    container_of(led_cdev, struct aw2013_chip, green);
+	
+	chip->green_ontime  = *delay_on;
+	chip->green_offtime = *delay_off;
+	schedule_work(&chip->work_green_blink);
+	return 1;
+}
+
+static int aw2013_blink_blue_set(struct led_classdev *led_cdev,
+				     unsigned long *delay_on,
+				     unsigned long *delay_off)
+{
+	struct aw2013_chip *chip =
+	    container_of(led_cdev, struct aw2013_chip, blue);
+
+	chip->blue_ontime  = *delay_on;
+	chip->blue_offtime = *delay_off;
+	schedule_work(&chip->work_blue_blink);
+	return 1;
+}
+
+static int aw2013_blink_set(struct led_classdev *led_cdev,
+				     unsigned long *delay_on,
+				     unsigned long *delay_off)
+{
+
+    int delay_on_new = *delay_on;
+	int delay_off_new = *delay_off;
+    unsigned char risetime =0;
+	unsigned char holdtime =0;
+	unsigned char falltime =0;
+	unsigned char offtime =0;
+	//unsigned char delaytime =0;
+	switch(delay_on_new)
+	{
+	 case 500:risetime = 0;holdtime = 2;falltime = 0;break;
+	 case 1000:risetime = 1;holdtime = 3;falltime = 1;break;
+	 case 2000:risetime = 1;holdtime = 4;falltime = 1;break;
+	 default :risetime = 1;holdtime = 3;falltime = 1;break;
+	}
+	
+	switch(delay_off_new)
+	{
+	 case 500:offtime =  2;break;
+	 case 1000:offtime =  3;break;
+	 case 2000:offtime =  4;break;
+	 case 5000:offtime =  5;break;
+	 default :offtime =  5;break;
+	}
+
+    //aw2013_read(0x30);
+	//printk("wuboadd blink blink reg0x30:%x\n",aw2013_read(0x30));
+    aw2013_write(0x30,0x07);
+	//aw2013_read(0x30);
+	//printk("wuboadd blink after write again reg0x30:%x\n",aw2013_read(0x30));
+	aw2013_write(GCR, 0x01);
+	//printk("wuboadd blink after write again reg0x01:%x\n",aw2013_read(0x01));
+	//printk("wuboadd risetime = %d;holdtime = %d;falltime = %d;offtime = %d delaytime =  %d\n",
+	//	risetime,holdtime,falltime,offtime,delaytime);
+     if(!strncmp("red",led_cdev->name,3))
+       {
+
+           aw2013_write(0x32, 0x70|Imax);	//config mode, IMAX = 5mA	
+           aw2013_write(0x35, MAX_BRIGHTNESS);	// LED1 level,
+           //aw2013_write(0x37, Rise_time<<4 | Hold_time);	//led0  							
+	       //aw2013_write(0x38, Fall_time<<4 | Off_time);	       //led0 
+	       //aw2013_write(0x39, Delay_time<<4| Period_Num);   //led0  
+	       aw2013_write(0x3A, risetime<<4 | holdtime);	//led0  							
+	       aw2013_write(0x3B, falltime<<4 | offtime);	       //led0 
+	       aw2013_write(0x3C, Delay_time<<4| Period_Num);   //led0  
+           //aw2013_write(0x30, 0x02);
+ 
+	   return 0; 
+       
+       }
+	 if(!strncmp("green",led_cdev->name,5))
+       {
+           aw2013_write(0x33, 0x70|Imax);	//config mode, IMAX = 5mA	
+           aw2013_write(0x36, MAX_BRIGHTNESS);	// LED2 level,
+	       //aw2013_write(0x3d, Rise_time<<4 | Hold_time);   //led2  			   
+		   //aw2013_write(0x3e, Fall_time<<4 | Off_time); 		  //led2 
+		   //aw2013_write(0x3f, Delay_time<<4| Period_Num);	 //
+           aw2013_write(0x3D, risetime<<4 | holdtime);
+	       aw2013_write(0x3E, falltime<<4 | offtime);
+	       aw2013_write(0x3F, Delay_time<<4| Period_Num);
+		   //aw2013_write(0x30, 0x04);     //led on=0x01 ledoff=0x00
+		   return 0; 
+       }
+	 if(!strncmp("blue",led_cdev->name,4))
+       {
+           aw2013_write(0x31, 0x70|Imax);	//config mode, IMAX = 5mA	
+	       aw2013_write(0x34, MAX_BRIGHTNESS);	// LED0 level,	
+	       aw2013_write(0x37, risetime<<4 | holdtime);
+	       aw2013_write(0x38, falltime<<4 | offtime);
+	       aw2013_write(0x39, Delay_time<<4| Period_Num);
+	       //aw2013_write(0x37, Rise_time<<4 | Hold_time);	//led0  							
+	       //aw2013_write(0x38, Fall_time<<4 | Off_time);	       //led0 
+	       //aw2013_write(0x39, Delay_time<<4| Period_Num);   //led0  
+	       //aw2013_write(0x30, 0x01);     //led on=0x01 ledoff=0x00
+		   return 0; 
+       }
+      return 0; 
+}
+static int show_cnfg_regs(struct seq_file *m, void *data)
+{
+	struct aw2013_chip *chip = m->private;
+	int rc;
+	u8 reg;
+	u8 addr;
+
+
+	for (addr = 0x00; addr <= 0x02; addr++) {
+		rc = __aw2013_read(chip, addr, &reg);
+		if (!rc)
+			seq_printf(m, "0x%02x = 0x%02x\n", addr, reg);
+	}
+
+	for (addr = 0x30; addr <= 0x3F; addr++) {
+		rc = __aw2013_read(chip, addr, &reg);
+		if (!rc)
+			seq_printf(m, "0x%02x = 0x%02x\n", addr, reg);
+	}
+
+	return 0;
+}
+
+static int cnfg_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct aw2013_chip *chip = inode->i_private;
+
+	return single_open(file, show_cnfg_regs, chip);
+}
+
+static const struct file_operations cnfg_debugfs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= cnfg_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int pinctrl_init_regled_gpio22(struct aw2013_chip *chip)
+{
+	int retval;
+	pr_info("entry pinctrl_init_regled_gpio22\n");
+	chip->redledgpio_pinctrl = devm_pinctrl_get(chip->dev);
+	if (IS_ERR_OR_NULL(chip->redledgpio_pinctrl)) {
+		pr_info("wuboadd chip->redledgpio_pinctrl IS_ERR_OR_NULL \n");
+		dev_dbg(chip->dev,
+			"Target does not use pinctrl\n");
+		retval = PTR_ERR(chip->redledgpio_pinctrl);
+		chip->redledgpio_pinctrl = NULL;
+		return retval;
+	}
+	#if 0
+	chip->dtv_state_suspend
+		= pinctrl_lookup_state(chip->redledgpio_pinctrl,
+			"dtv-ldoen-gpio");
+	if (IS_ERR_OR_NULL(chip->dtv_state_suspend)) {
+		pr_info("wuboadd IS_ERR_OR_NULL(chip->dtv_state_suspend) \n");
+		dev_dbg(chip->dev,
+			"Can not get ts default pinstate\n");
+		retval = PTR_ERR(chip->dtv_state_suspend);
+		//chip->redledgpio_pinctrl = NULL;
+		//return retval;
+	}
+	#endif
+	chip->gpio_state_active
+		= pinctrl_lookup_state(chip->redledgpio_pinctrl,
+			"redled_gpio");
+	if (IS_ERR_OR_NULL(chip->gpio_state_active)) {
+		pr_info("wuboadd IS_ERR_OR_NULL(chip->gpio_state_active) \n");
+		dev_dbg(chip->dev,
+			"Can not get ts default pinstate\n");
+		retval = PTR_ERR(chip->gpio_state_active);
+		chip->redledgpio_pinctrl = NULL;
+		return retval;
+	}
+	return 0;
+}
+#if 0
+static int dtv_ldoen_disable(struct aw2013_chip *chip)
+{
+
+	int err =0;
+    
+    chip->dtv_gpio20 = of_get_named_gpio(chip->dev->of_node, "dtvldoen,gpio20", 0);
+	
+	if(gpio_is_valid(chip->dtv_gpio20))
+	{
+	 pr_info("wuboadd chip->dtv_gpio20 :%d \n",chip->dtv_gpio20);
+	}
+	else
+	{
+	 pr_info("wuboadd add invalid chip->dtv_gpio20 \n");
+	 return -1;
+	}
+
+    pr_info("wuboadd pinctrl init successed \n");
+	err = pinctrl_select_state(chip->redledgpio_pinctrl,chip->dtv_state_suspend);
+	   
+    if (err) {
+			dev_err(chip->dev,
+				"can not set dtv_gpio20 low\n");
+		return -1;
+	}else
+	{
+		pr_info("wuboadd pinctrl dtv_gpio20 pinctrl_select_state successed \n");
+	}
+
+	if(gpio_is_valid(chip->dtv_gpio20)){
+			
+        if((err = gpio_request(chip->dtv_gpio20, "dtv-ldoen"))){
+		    pr_info("dtv_gpio20 gpio_request failed\n");
+	    }
+		
+	    if((err = gpio_direction_output(chip->dtv_gpio20, 0))){
+			
+		     gpio_free(chip->red_gpio22);
+		     pr_info("dtv_gpio20 gpio_direction_output failed\n");
+	    }
+	}
+	return 0;
+}
+#endif
+static int red_gpio22_output_init(struct aw2013_chip *chip)
+{
+    int err = 0;
+    chip->red_gpio22 = of_get_named_gpio(chip->dev->of_node, "aw2013,red_gpio20", 0);
+	if(gpio_is_valid(chip->red_gpio22))
+	{
+	 pr_info("wuboadd chip->red_gpio22 :%d \n",chip->red_gpio22);
+	}
+	else
+	{
+	 pr_info("wuboadd add invalid chip->red_gpio22 \n");
+	 return -1;
+	}
+	
+	if(!pinctrl_init_regled_gpio22(chip))
+	{
+	      //	dtv_ldoen_disable(chip);
+	   err = pinctrl_select_state(chip->redledgpio_pinctrl,chip->gpio_state_active);
+	   
+
+		if (err) 
+		{
+			dev_err(chip->dev,
+				"can not set redled_gpio22 high\n");
+		}else
+		{
+		pr_info("wuboadd pinctrl pinctrl_select_state successed \n");
+		}
+
+	    if(gpio_is_valid(chip->red_gpio22))
+		{
+			
+            if ((err = gpio_request(chip->red_gpio22, "led_gpio22"))){
+		    pr_info("led_gpio22 gpio_request failed\n");
+	        }
+
+	    /*if((err = gpio_direction_output(chip->red_gpio22, 1))){
+		     gpio_free(chip->red_gpio22);
+		     pr_info("led_gpio22 gpio_direction_output failed\n");
+	        }*/
+	   }
+	}
+	else		
+	    return -1;
+
+	return 0;
+}
+
+static void red_led_gpio22_output(struct aw2013_chip *chip)
+{
+    //static int first_output = 0;
+	int err =0;
+    if(first_redgpio_output ==0)
+    {
+	    if(gpio_is_valid(chip->red_gpio22)){
+		
+		if((err = gpio_direction_output(chip->red_gpio22, 1))){
+		     gpio_free(chip->red_gpio22);
+		     pr_info("led_gpio22 gpio_direction_output failed\n");
+	       }
+	   }
+		first_redgpio_output = 1;
+    }
+}
+
+	void smb1360_redled_gpio_output(void)
+{
+    int err =0;
+    if(gpio_is_valid(the_chip->red_gpio22)){
+		first_redgpio_output = 1;
+		if((err = gpio_direction_output(the_chip->red_gpio22, 1))){
+		first_redgpio_output = 0;
+		gpio_free(the_chip->red_gpio22);
+		pr_info("led_gpio22 gpio_direction_output failed\n");
+		}
+	}
+}
+EXPORT_SYMBOL(smb1360_redled_gpio_output);
+
+static void parse_dt_data(struct aw2013_chip *chip)
+{
+    u32 max_brightness_tmp =0;
+	u32 imax_tmp = 0;
+	int ret = 0;
+	
+    ret = of_property_read_u32(chip->dev->of_node, "aw2013,maxbrightness",
+						&max_brightness_tmp);
+	if(ret<0)
+	{
+	    pr_info("read aw2013,maxbrightness failed\n");
+	}
+	else
+	{   
+	    MAX_BRIGHTNESS = (u8)max_brightness_tmp;
+	    pr_info("read aw2013,maxbrightness %d\n",max_brightness_tmp);
+	}
+	
+    ret = of_property_read_u32(chip->dev->of_node, "aw2013,Imax",&imax_tmp);
+	
+	if(ret<0)
+	{
+	    pr_info("read aw2013,Imax failed\n");
+	}
+    else
+    {
+        Imax = (u8)imax_tmp;
+        pr_info("read aw2013,Imax %d\n",imax_tmp);
+    }
+}
+
+static int aw2013_hw_init(struct aw2013_chip *chip)
+{
+    u8 chip_id=0;
+	//return 0;
+    if(!__aw2013_read(chip,RSTR,&chip_id))
+	{
+	    pr_info("aw2013_hw_init aw2013 chipid: %02x ",chip_id);
+        //__aw2013_write(chip,RSTR,0x55);
+		//udelay(20);
+		__aw2013_write(chip,GCR, 0x01);
+		__aw2013_write(chip,STATUS,0x00);
+		__aw2013_write(chip,effecREG30,0x07);
+		//__aw2013_write(chip,LED0_CTRL,0x02);
+		//__aw2013_write(chip,LED1_CTRL,0x02);
+		//__aw2013_write(chip,LED2_CTRL,0x02);
+		//__aw2013_write(chip,PWM0_CTRL,0x8f);
+		//__aw2013_write(chip,PWM1_CTRL,0x8f);
+		//__aw2013_write(chip,PWM2_CTRL,0x8f);
+		//mdelay(20);
+		return chip_id;
+	};
+	return 0;
+}
+
+static int aw2013_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+
+	struct aw2013_chip *chip;
+	int err =0;
+	pr_info("wuboadd aw2013 aw2013_probe\n");
+	chip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip) {
+		dev_err(&client->dev, "Unable to allocate memory\n");
+		return -ENOMEM;
+	}
+    aw_i2c_client = client;
+	chip->client = client;
+	chip->dev = &client->dev;
+	err = aw2013_hw_init(chip);
+	if(!err)
+	{
+	pr_err("aw2013_hwinit failed return -1\n");
+	return -1;
+	}
+	parse_dt_data(chip);
+	mutex_init(&chip->read_write_lock);
+	i2c_set_clientdata(client, chip);
+
+	err = red_gpio22_output_init(chip);
+    	if(err){pr_err("red_gpio22_not support\n");}
+
+    INIT_WORK(&chip->work_red, aw2013_deferred_red_brightness_set);
+    INIT_WORK(&chip->work_red_blink, aw2013_deferred_red_blink_set);
+    chip->red.name= "red";
+	chip->red.max_brightness = MAX_BRIGHTNESS;
+	chip->red.brightness_set = aw2013_red_brightness_set;
+	chip->red.blink_set  = aw2013_blink_red_set;
+	
+	err = led_classdev_register((struct device *)
+				    &client->dev, &chip->red);
+    if(err){
+        pr_debug("wubo add red led register error \n");
+	}
+	INIT_WORK(&chip->work_green, aw2013_deferred_green_brightness_set);
+	INIT_WORK(&chip->work_green_blink, aw2013_deferred_green_blink_set);
+	chip->green.name= "green";
+	chip->green.max_brightness = MAX_BRIGHTNESS;
+	chip->green.brightness_set = aw2013_green_brightness_set;
+	chip->green.blink_set  = aw2013_blink_green_set;
+	err = led_classdev_register((struct device *)
+				    &client->dev, &chip->green);
+    if(err){
+        pr_debug("wubo add green led register error \n");
+	}
+	INIT_WORK(&chip->work_blue, aw2013_deferred_blue_brightness_set);
+	INIT_WORK(&chip->work_blue_blink, aw2013_deferred_blue_blink_set);
+	chip->blue.name= "blue";
+	chip->blue.max_brightness = MAX_BRIGHTNESS;
+	chip->blue.brightness_set = aw2013_blue_brightness_set;
+	chip->blue.blink_set  = aw2013_blink_blue_set;
+	err = led_classdev_register((struct device *)
+				    &client->dev, &chip->blue);
+    if(err){
+        pr_debug("wubo add blue led register error \n");
+	}
+	chip->debug_root = debugfs_create_dir("aw2013", NULL);
+	if (!chip->debug_root)
+		dev_err(chip->dev, "Couldn't create debug dir\n");
+	
+    if (chip->debug_root) {
+		struct dentry *ent;
+
+		ent = debugfs_create_file("config_registers", S_IFREG | S_IRUGO,
+					  chip->debug_root, chip,
+					  &cnfg_debugfs_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create cnfg debug file rc = %d\n",
+				err);
+    }
+	chip->enable_status = 0;
+	chip->pwm =0;
+	chip->light =0 ;
+	the_chip = chip;
+/*
+	err = aw2013_hw_init(chip);
+	if(!err)
+	{
+	 pr_info("aw2013_hwinit failed\n");
+	}
+*/
+	aw2013_breath_all(0,1,0);
+	return 0;
+}
+
+
+static int aw2013_suspend(struct device *dev)
+{
+	u8 pwm0_ctrl,pwm1_ctrl,pwm2_ctrl;
+	int err = 0;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct aw2013_chip *chip = i2c_get_clientdata(client);
+	printk("aw2013_suspend enter \n");
+	err |= __aw2013_read(chip,PWM0_CTRL,&pwm0_ctrl);
+	err |= __aw2013_read(chip,PWM1_CTRL,&pwm1_ctrl);
+	err |= __aw2013_read(chip,PWM2_CTRL,&pwm2_ctrl);
+
+	if(err != 0)
+	{
+		pr_err("suspend err !\n");
+		return err;
+	}
+
+	if((pwm0_ctrl == 0)&&(pwm1_ctrl == 0)&&(pwm2_ctrl == 0))
+	{
+		err |=__aw2013_write(chip,effecREG30,0x00);
+		err |=__aw2013_write(chip,GCR, 0x00);
+	}
+
+	if(err != 0)
+	{
+		pr_err("suspend err !\n");
+		return err;
+	}
+
+	return 0;
+	
+}
+
+static int aw2013_suspend_noirq(struct device *dev)
+{
+
+return 0;
+
+}
+
+static int aw2013_resume(struct device *dev)
+{
+
+return 0;
+
+}
+
+static const struct dev_pm_ops aw2013_pm_ops = {
+	.resume		= aw2013_resume,
+	.suspend_noirq	= aw2013_suspend_noirq,
+	.suspend	= aw2013_suspend,
+};
+
+static struct of_device_id aw2013_match_table[] = {
+	{ .compatible = "aw,aw2013-rgb-leds",},
+	{ },
+};
+
+static const struct i2c_device_id aw2013_id[] = {
+	{"aw2013-rgb-leds", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, aw2013_id);
+
+static struct i2c_driver aw2013_driver = {
+	.driver		= {
+		.name		= "aw2013-rgb-leds",
+		.owner		= THIS_MODULE,
+		.of_match_table	= aw2013_match_table,
+		.pm		= &aw2013_pm_ops,
+	},
+	.probe		= aw2013_probe,
+	.remove		= aw2013_remove,
+	.id_table	= aw2013_id,
+};
+
+module_i2c_driver(aw2013_driver);
+
+MODULE_DESCRIPTION("AW2013 RGB LED");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("i2c:AW2013 RGB LED");
+MODULE_AUTHOR("bo.wu@ck-telecom.com");
diff --git a/drivers/leds/led-class.c b/drivers/leds/led-class.c
index 213a3017782..d171af855fd 100644
--- a/drivers/leds/led-class.c
+++ b/drivers/leds/led-class.c
@@ -85,10 +85,42 @@ static ssize_t led_max_brightness_show(struct device *dev,
 	return snprintf(buf, LED_BUFF_SIZE, "%u\n", led_cdev->max_brightness);
 }
 
+static ssize_t led_blink_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+	return 1000;
+}
+static ssize_t led_blink_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	//int state;
+	int ontime;
+	int offtime;
+	int blink_flag;//  1 blink 
+	ssize_t ret = -EINVAL;
+    
+	//printk("wubo add strlenbuf :%d\n",strlen(buf));
+	if(sscanf(buf,"%d %d %d",&blink_flag,&ontime,&offtime))
+	{
+	}
+	else
+	{
+	printk("wubo add read failed \n");
+	return ret;
+	}
+
+
+	__led_set_blink(led_cdev, blink_flag,ontime,offtime);
+
+	return size;
+}
 static struct device_attribute led_class_attrs[] = {
 	__ATTR(brightness, 0644, led_brightness_show, led_brightness_store),
 	__ATTR(max_brightness, 0644, led_max_brightness_show,
 			led_max_brightness_store),
+	__ATTR(blink, 0644, led_blink_show, led_blink_store),
 #ifdef CONFIG_LEDS_TRIGGERS
 	__ATTR(trigger, 0644, led_trigger_show, led_trigger_store),
 #endif
diff --git a/drivers/leds/leds-msm-gpio-flash.c b/drivers/leds/leds-msm-gpio-flash.c
index 1d811beccdc..2fee143bed6 100644
--- a/drivers/leds/leds-msm-gpio-flash.c
+++ b/drivers/leds/leds-msm-gpio-flash.c
@@ -24,12 +24,15 @@
 #include <linux/pinctrl/consumer.h>
 
 /* #define CONFIG_GPIO_FLASH_DEBUG */
+/*
 #undef CDBG
 #ifdef CONFIG_GPIO_FLASH_DEBUG
 #define CDBG(fmt, args...) pr_err(fmt, ##args)
 #else
 #define CDBG(fmt, args...) do { } while (0)
 #endif
+*/
+#define CDBG(fmt, args...) pr_err(fmt, ##args)
 
 #define LED_GPIO_FLASH_DRIVER_NAME	"qcom,leds-gpio-flash"
 #define LED_TRIGGER_DEFAULT		"none"
@@ -37,14 +40,20 @@
 #define GPIO_OUT_LOW          (0 << 1)
 #define GPIO_OUT_HIGH         (1 << 1)
 
+int number_pin=3; //Jelly add for detect whether the forth pin of the gpio is specified for led 
+
+
 enum msm_flash_seq_type_t {
 	FLASH_EN,
 	FLASH_NOW,
+	TORCH_EN,
+	ENABLE_MULTI,
 };
 
 struct msm_flash_ctrl_seq {
 	enum msm_flash_seq_type_t seq_type;
 	uint8_t flash_on_val;
+	uint8_t pre_on_val;
 	uint8_t torch_on_val;
 	uint8_t flash_off_val;
 };
@@ -52,13 +61,19 @@ struct msm_flash_ctrl_seq {
 struct led_gpio_flash_data {
 	int flash_en;
 	int flash_now;
+	int torch_en;
+	int rear_enable;
+	int front_enable;
 	int brightness;
 	struct led_classdev cdev;
 	struct pinctrl *pinctrl;
 	struct pinctrl_state *gpio_state_default;
-	struct msm_flash_ctrl_seq ctrl_seq[2];
+	struct msm_flash_ctrl_seq ctrl_seq[4];
 };
 
+extern uint32_t get_camera_id(void);
+
+
 static struct of_device_id led_gpio_flash_of_match[] = {
 	{.compatible = LED_GPIO_FLASH_DRIVER_NAME,},
 	{},
@@ -72,23 +87,31 @@ static void led_gpio_brightness_set(struct led_classdev *led_cdev,
 	    container_of(led_cdev, struct led_gpio_flash_data, cdev);
 
 	int brightness = value;
-	int flash_en = 0, flash_now = 0;
-
-	if (brightness > LED_HALF) {
-		flash_en =
-			flash_led->ctrl_seq[FLASH_EN].flash_on_val;
-		flash_now =
-			flash_led->ctrl_seq[FLASH_NOW].flash_on_val;
+	int flash_en = 0, flash_now = 0, torch_en = 0, enable_multi = 0;
+    if(brightness > LED_PRE){
+		flash_en  = flash_led->ctrl_seq[FLASH_EN].flash_on_val;
+		flash_now = flash_led->ctrl_seq[FLASH_NOW].flash_on_val;
+		torch_en  = flash_led->ctrl_seq[TORCH_EN].flash_on_val;
+		enable_multi = flash_led->ctrl_seq[ENABLE_MULTI].flash_on_val;
+	}
+	else if (brightness > LED_HALF) {
+		flash_en  = flash_led->ctrl_seq[FLASH_EN].pre_on_val;
+		flash_now = flash_led->ctrl_seq[FLASH_NOW].pre_on_val;
+		torch_en  = flash_led->ctrl_seq[TORCH_EN].pre_on_val;
+		enable_multi = flash_led->ctrl_seq[ENABLE_MULTI].pre_on_val;
 	} else if (brightness > LED_OFF) {
-		flash_en =
-			flash_led->ctrl_seq[FLASH_EN].torch_on_val;
-		flash_now =
-			flash_led->ctrl_seq[FLASH_NOW].torch_on_val;
+		flash_en  = flash_led->ctrl_seq[FLASH_EN].torch_on_val;
+		flash_now = flash_led->ctrl_seq[FLASH_NOW].torch_on_val;
+		torch_en  = flash_led->ctrl_seq[TORCH_EN].torch_on_val;
+		enable_multi = flash_led->ctrl_seq[ENABLE_MULTI].torch_on_val;
 	} else {
 		flash_en = 0;
 		flash_now = 0;
+		torch_en = 0;
+		enable_multi = 0;
 	}
-	CDBG("%s:flash_en=%d, flash_now=%d\n", __func__, flash_en, flash_now);
+	CDBG("%s:flash_en=%d, flash_now=%d, torch_en=%d, enable_multi=%d,brightness = %d\n", __func__,
+		flash_en, flash_now,torch_en,enable_multi,brightness);
 
 	rc = gpio_direction_output(flash_led->flash_en, flash_en);
 	if (rc) {
@@ -102,6 +125,31 @@ static void led_gpio_brightness_set(struct led_classdev *led_cdev,
 		       flash_led->flash_now);
 		goto err;
 	}
+	rc = gpio_direction_output(flash_led->torch_en, torch_en);
+	if (rc) {
+		pr_err("%s: Failed to set gpio %d\n", __func__,
+		       flash_led->torch_en);
+		goto err;
+	}
+
+/*Jelly add for detect whether the forth pin of the gpio is specified 2015/4/18*/
+if (number_pin==4){
+	if(get_camera_id() == 1){
+	    rc = gpio_direction_output(flash_led->front_enable, enable_multi);
+	    if (rc) {
+		    pr_err("%s: Failed to set gpio %d\n", __func__,
+		           flash_led->front_enable);
+		    goto err;
+	    }
+	}else{
+	    rc = gpio_direction_output(flash_led->rear_enable, enable_multi);
+	    if (rc) {
+		    pr_err("%s: Failed to set gpio %d\n", __func__,
+		           flash_led->rear_enable);
+		    goto err;
+	    }
+	}
+}//endif Jelly add for detect whether the forth pin of the gpio is specified 2015/4/18
 	flash_led->brightness = brightness;
 err:
 	return;
@@ -122,9 +170,12 @@ int led_gpio_flash_probe(struct platform_device *pdev)
 	struct led_gpio_flash_data *flash_led = NULL;
 	struct device_node *node = pdev->dev.of_node;
 	const char *seq_name = NULL;
-	uint32_t array_flash_seq[2];
-	uint32_t array_torch_seq[2];
+	uint32_t array_flash_seq[4];
+	uint32_t array_pre_seq[4];
+	uint32_t array_torch_seq[4];
 	int i = 0;
+
+	printk("<1>yulinghan led_gpio_flash_probe !!!!!!!!!11");
 	flash_led = devm_kzalloc(&pdev->dev, sizeof(struct led_gpio_flash_data),
 				 GFP_KERNEL);
 	if (flash_led == NULL) {
@@ -179,6 +230,9 @@ int led_gpio_flash_probe(struct platform_device *pdev)
 			"Looking up %s property in node %s failed. rc =  %d\n",
 			"flash-now", node->full_name, flash_led->flash_now);
 		goto error;
+	/*+++ wangzhihong add for led flash use two gpios 20150420*/
+	}else if(flash_led->flash_en == flash_led->flash_now){
+		dev_err(&pdev->dev,"skip request flash_now gpio.\n");
 	} else {
 		rc = gpio_request(flash_led->flash_now, "FLASH_NOW");
 		if (rc) {
@@ -189,6 +243,65 @@ int led_gpio_flash_probe(struct platform_device *pdev)
 		}
 	}
 
+	flash_led->torch_en = of_get_named_gpio(node, "qcom,torch-en", 0);
+	if (flash_led->torch_en < 0) {
+		dev_err(&pdev->dev,
+			"Looking up %s property in node %s failed. rc =  %d\n",
+			"torch_en", node->full_name, flash_led->torch_en);
+		goto error;
+	} else {
+		rc = gpio_request(flash_led->torch_en, "TORCH_EN");
+		if (rc) {
+			dev_err(&pdev->dev,
+				"%s: Failed to request gpio %d,rc = %d\n",
+				__func__, flash_led->torch_en, rc);
+			goto error;
+		}
+	}
+	/*Jelly add for whether property is  specified 2015/4/18*/
+	if ((of_find_property(node, "qcom,flash-front-enable", NULL))&&(of_find_property(node, "qcom,flash-rear-enable", NULL)))
+	{
+	 number_pin=4;//Jelly add for detect whether the forth pin of the gpio is specified
+	flash_led->front_enable = of_get_named_gpio(node, "qcom,flash-front-enable", 0);
+	if (flash_led->front_enable < 0) {
+		dev_err(&pdev->dev,
+			"Looking up %s property in node %s failed. rc =  %d\n",
+			"front_enable", node->full_name, flash_led->front_enable);
+		goto error;
+	/*+++ wangzhihong add for led flash use two gpios 20150420*/
+	}else if(flash_led->flash_en == flash_led->front_enable){
+		dev_err(&pdev->dev,"skip request front_enable gpio.\n");
+	} else {
+		rc = gpio_request(flash_led->front_enable, "FRONT_ENABLE");
+		if (rc) {
+			dev_err(&pdev->dev,
+				"%s: Failed to request gpio %d,rc = %d\n",
+				__func__, flash_led->front_enable, rc);
+			goto error;
+		}
+	}
+
+	flash_led->rear_enable= of_get_named_gpio(node, "qcom,flash-rear-enable", 0);
+	if (flash_led->rear_enable < 0) {
+		dev_err(&pdev->dev,
+			"Looking up %s property in node %s failed. rc =  %d\n",
+			"rear_enable", node->full_name, flash_led->front_enable);
+		goto error;
+	/* wangzhihong add for led flash use two gpios 20150420*/
+	}else if(flash_led->flash_en == flash_led->rear_enable){
+		dev_err(&pdev->dev,"skip request rear_enable gpio.\n");
+	} else {
+		rc = gpio_request(flash_led->rear_enable, "REAR_ENABLE");
+		if (rc) {
+			dev_err(&pdev->dev,
+				"%s: Failed to request gpio %d,rc = %d\n",
+				__func__, flash_led->rear_enable, rc);
+			goto error;
+		}
+	}
+
+	}/*end if  Jelly add for whether property is  specified2015/4/18*/
+      
 	rc = of_property_read_string(node, "linux,name", &flash_led->cdev.name);
 	if (rc) {
 		dev_err(&pdev->dev, "%s: Failed to read linux name. rc = %d\n",
@@ -197,16 +310,25 @@ int led_gpio_flash_probe(struct platform_device *pdev)
 	}
 
 	rc = of_property_read_u32_array(node, "qcom,flash-seq-val",
-		array_flash_seq, 2);
+		array_flash_seq, number_pin);
 
 	if (rc < 0) {
 		pr_err("%s get flash op seq failed %d\n",
 			__func__, __LINE__);
 		goto error;
 	}
+	
+	rc = of_property_read_u32_array(node, "qcom,pre-seq-val",
+		array_pre_seq, number_pin);
+
+	if (rc < 0) {
+		pr_err("%s get pre op seq failed %d\n", //Jelly modify the debug infro for debuging 2015/4/18
+			__func__, __LINE__);
+		goto error;
+	}
 
 	rc = of_property_read_u32_array(node, "qcom,torch-seq-val",
-		array_torch_seq, 2);
+		array_torch_seq, number_pin);
 
 	if (rc < 0) {
 		pr_err("%s get torch op seq failed %d\n",
@@ -214,7 +336,7 @@ int led_gpio_flash_probe(struct platform_device *pdev)
 		goto error;
 	}
 
-	for (i = 0; i < 2; i++) {
+	for (i = 0; i < number_pin; i++) {
 		rc = of_property_read_string_index(node,
 			"qcom,op-seq", i,
 			&seq_name);
@@ -236,6 +358,13 @@ int led_gpio_flash_probe(struct platform_device *pdev)
 				flash_led->ctrl_seq[FLASH_EN].flash_on_val =
 					GPIO_OUT_HIGH;
 
+            if (array_pre_seq[i] == 0)
+				flash_led->ctrl_seq[FLASH_EN].pre_on_val =
+					GPIO_OUT_LOW;
+			else
+				flash_led->ctrl_seq[FLASH_EN].pre_on_val =
+					GPIO_OUT_HIGH;
+
 			if (array_torch_seq[i] == 0)
 				flash_led->ctrl_seq[FLASH_EN].torch_on_val =
 					GPIO_OUT_LOW;
@@ -253,6 +382,13 @@ int led_gpio_flash_probe(struct platform_device *pdev)
 			else
 				flash_led->ctrl_seq[FLASH_NOW].flash_on_val =
 					GPIO_OUT_HIGH;
+			
+            if (array_pre_seq[i] == 0)
+				flash_led->ctrl_seq[FLASH_NOW].pre_on_val =
+					GPIO_OUT_LOW;
+			else
+				flash_led->ctrl_seq[FLASH_NOW].pre_on_val =
+					GPIO_OUT_HIGH;
 
 			if (array_torch_seq[i] == 0)
 				flash_led->ctrl_seq[FLASH_NOW].torch_on_val =
@@ -260,8 +396,58 @@ int led_gpio_flash_probe(struct platform_device *pdev)
 			 else
 				flash_led->ctrl_seq[FLASH_NOW].torch_on_val =
 					GPIO_OUT_HIGH;
-		}
+		} else if (!strcmp(seq_name, "torch_en")) {
+			flash_led->ctrl_seq[TORCH_EN].seq_type =
+				TORCH_EN;
+			CDBG("%s:%d seq_type[%d] %d\n", __func__, __LINE__,
+				i, flash_led->ctrl_seq[i].seq_type);
+			if (array_flash_seq[i] == 0)
+				flash_led->ctrl_seq[TORCH_EN].flash_on_val =
+					GPIO_OUT_LOW;
+			else
+				flash_led->ctrl_seq[TORCH_EN].flash_on_val =
+					GPIO_OUT_HIGH;
 
+			if (array_pre_seq[i] == 0)
+				flash_led->ctrl_seq[TORCH_EN].pre_on_val =
+					GPIO_OUT_LOW;
+			else
+				flash_led->ctrl_seq[TORCH_EN].pre_on_val =
+					GPIO_OUT_HIGH;
+
+			if (array_torch_seq[i] == 0)
+				flash_led->ctrl_seq[TORCH_EN].torch_on_val =
+					GPIO_OUT_LOW;
+			 else
+				flash_led->ctrl_seq[TORCH_EN].torch_on_val =
+					GPIO_OUT_HIGH;
+		} else if (!strcmp(seq_name, "enable_multi")) {
+			flash_led->ctrl_seq[ENABLE_MULTI].seq_type =
+				ENABLE_MULTI;
+			CDBG("%s:%d seq_type[%d] %d\n", __func__, __LINE__,
+				i, flash_led->ctrl_seq[i].seq_type);
+			if (array_flash_seq[i] == 0)
+				flash_led->ctrl_seq[ENABLE_MULTI].flash_on_val =
+					GPIO_OUT_LOW;
+			else
+				flash_led->ctrl_seq[ENABLE_MULTI].flash_on_val =
+					GPIO_OUT_HIGH;
+
+			if (array_pre_seq[i] == 0)
+				flash_led->ctrl_seq[ENABLE_MULTI].pre_on_val =
+					GPIO_OUT_LOW;
+			else
+				flash_led->ctrl_seq[ENABLE_MULTI].pre_on_val =
+					GPIO_OUT_HIGH;
+
+
+			if (array_torch_seq[i] == 0)
+				flash_led->ctrl_seq[ENABLE_MULTI].torch_on_val =
+					GPIO_OUT_LOW;
+			 else
+				flash_led->ctrl_seq[ENABLE_MULTI].torch_on_val =
+					GPIO_OUT_HIGH;
+		}
 	}
 
 	platform_set_drvdata(pdev, flash_led);
@@ -308,6 +494,7 @@ static struct platform_driver led_gpio_flash_driver = {
 
 static int __init led_gpio_flash_init(void)
 {
+	printk("<1>yulinghan led_gpio_flash_init\n");
 	return platform_driver_register(&led_gpio_flash_driver);
 }
 
diff --git a/drivers/leds/leds.h b/drivers/leds/leds.h
index 4c50365344a..c04ba02c272 100644
--- a/drivers/leds/leds.h
+++ b/drivers/leds/leds.h
@@ -26,7 +26,30 @@ static inline void __led_set_brightness(struct led_classdev *led_cdev,
 	if (!(led_cdev->flags & LED_SUSPENDED))
 		led_cdev->brightness_set(led_cdev, value);
 }
-
+/*wubo add star for led blink 2014-8-1 13:43:33*/
+static inline void __led_set_blink(struct led_classdev *led_cdev,
+					int blink_flag,int ontime,int offtime)
+{
+	//if (value > led_cdev->max_brightness)
+	//	value = led_cdev->max_brightness;
+	//led_cdev->brightness = value;
+	unsigned long blink = (unsigned long)blink_flag;
+	unsigned long on_time = (unsigned long)ontime;
+	unsigned long off_time = (unsigned long)offtime;
+	if(blink){
+	if (!(led_cdev->flags & LED_SUSPENDED))
+		{
+		if(led_cdev->blink_set){
+#ifdef BLINK_BRIGHTNESS
+		if(blink > led_cdev->max_brightness)
+			blink = led_cdev->max_brightness;
+		led_cdev->blink_brightness = blink;
+#endif
+		   led_cdev->blink_set(led_cdev, &on_time,&off_time);
+		   }
+		}
+	}
+}
 static inline int led_get_brightness(struct led_classdev *led_cdev)
 {
 	return led_cdev->brightness;
diff --git a/drivers/media/platform/msm/camera_v2/Kconfig b/drivers/media/platform/msm/camera_v2/Kconfig
index b94e4011b28..4704dd662f0 100644
--- a/drivers/media/platform/msm/camera_v2/Kconfig
+++ b/drivers/media/platform/msm/camera_v2/Kconfig
@@ -181,6 +181,21 @@ config OV7695
 		and snapshot. The preview and snapshot resolution shall be
 		VGA. It does not support auto focus. It supports
 		few special effects like saturation.
+		
+config OV2685
+	bool "Sensor OV2685 (YUV 2MP)"
+	depends on MSMB_CAMERA
+	---help---
+		OV2685 is Omnivision YUV sensor. It supports 2 MP preview
+		and snapshot. The preview and snapshot resolution shall be
+		VGA. It does not support auto focus. It supports
+		few special effects like saturation.
+
+config ALTEK_AF
+	bool "Sensor ALTEK_AF (YUV 2MP)"
+	depends on MSMB_CAMERA
+	---help---
+		ALTEK_AF need to modify kernel af driver in CKT merageplus01a
 
 config SP1628
 	bool "Sensor SP1628 (YUV 720P)"
diff --git a/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c b/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c
index 73aeedebf10..ecd2865d0dc 100644
--- a/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c
+++ b/drivers/media/platform/msm/camera_v2/ispif/msm_ispif.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2015, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -1185,7 +1185,7 @@ static int msm_ispif_set_vfe_info(struct ispif_device *ispif,
 		((uint32_t)(vfe_info->num_vfe) > ispif->hw_num_isps)) {
 		pr_err("Invalid VFE info: %p %d\n", vfe_info,
 			   (vfe_info ? vfe_info->num_vfe:0));
-		return -EINVAL;
+ 		return -EINVAL;
 	}
 
 	memcpy(&ispif->vfe_info, vfe_info, sizeof(struct msm_ispif_vfe_info));
diff --git a/drivers/media/platform/msm/camera_v2/sensor/Makefile b/drivers/media/platform/msm/camera_v2/sensor/Makefile
index 09afb7b66fb..67c964977e8 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/Makefile
+++ b/drivers/media/platform/msm/camera_v2/sensor/Makefile
@@ -5,7 +5,8 @@ ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
 ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/cci
 obj-$(CONFIG_MSMB_CAMERA) += cci/ io/ csiphy/ csid/ actuator/ flash/ eeprom/ ois/
 obj-$(CONFIG_MSM_CAMERA_SENSOR) += msm_sensor_init.o msm_sensor_driver.o msm_sensor.o
-obj-$(CONFIG_MT9M114) += mt9m114.o
-obj-$(CONFIG_OV5645) += ov5645.o
-obj-$(CONFIG_OV5645) += ov7695.o
-obj-$(CONFIG_GC0310) += gc0310.o
+#obj-$(CONFIG_MT9M114) += mt9m114.o
+#obj-$(CONFIG_OV5645) += ov5645.o
+#obj-$(CONFIG_OV5645) += ov7695.o
+#obj-$(CONFIG_GC0310) += gc0310.o
+obj-$(CONFIG_OV2685) += ov2685.o
\ No newline at end of file
diff --git a/drivers/media/platform/msm/camera_v2/sensor/actuator/Makefile b/drivers/media/platform/msm/camera_v2/sensor/actuator/Makefile
index c0d607f731b..f9038c050c7 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/actuator/Makefile
+++ b/drivers/media/platform/msm/camera_v2/sensor/actuator/Makefile
@@ -1,4 +1,8 @@
 ccflags-y += -Idrivers/media/platform/msm/camera_v2
 ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
 ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/cci
+ifeq ($(CONFIG_ALTEK_AF),y)
+obj-$(CONFIG_MSMB_CAMERA) += msm_actuator_altek.o
+else
 obj-$(CONFIG_MSMB_CAMERA) += msm_actuator.o
+endif
\ No newline at end of file
diff --git a/drivers/media/platform/msm/camera_v2/sensor/actuator/lc898212axb_AfDef.h b/drivers/media/platform/msm/camera_v2/sensor/actuator/lc898212axb_AfDef.h
new file mode 100755
index 00000000000..3cb00c7c129
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/actuator/lc898212axb_AfDef.h
@@ -0,0 +1,328 @@
+/*******************************************************************************
+ *  AfDef.h - Header file for LC898211
+ *
+ *  SANYO Semiconductor
+ *
+ *  REVISION:
+ *      2012/05/16 - First Edition, YS.Kim
+ ******************************************************************************/
+// Delay RAM
+#define	ADHXI_211H		0x00
+#define	ADHXI_211L		0x01
+#define	PIDZO_211H		0x02
+#define	PIDZO_211L		0x03
+#define	RZ_211H			0x04
+#define	RZ_211L			0x05
+#define	DZ1_211H		0x06
+#define	DZ1_211L		0x07
+#define	DZ2_211H		0x08
+#define	DZ2_211L		0x09
+#define	UZ1_211H		0x0A
+#define	UZ1_211L		0x0B
+#define	UZ2_211H		0x0C
+#define	UZ2_211L		0x0D
+#define	IZ1_211H		0x0E
+#define	IZ1_211L		0x0F
+#define	IZ2_211H		0x10
+#define	IZ2_211L		0x11
+#define	MS1Z01_211H		0x12
+#define	MS1Z01_211L		0x13
+#define	MS1Z11_211H		0x14
+#define	MS1Z11_211L		0x15
+#define	MS1Z12_211H		0x16
+#define	MS1Z12_211L		0x17
+#define	MS1Z22_211H		0x18
+#define	MS1Z22_211L		0x19
+#define	MS2Z01_211H		0x1A
+#define	MS2Z01_211L		0x1B
+#define	MS2Z11_211H		0x1C
+#define	MS2Z11_211L		0x1D
+#define	MS2Z12_211H		0x1E
+#define	MS2Z12_211L		0x1F
+#define	MS2Z22_211H		0x20
+#define	MS2Z22_211L		0x21
+#define	MS2Z23_211H		0x22
+#define	MS2Z23_211L		0x23
+#define	OZ1_211H		0x24
+#define	OZ1_211L		0x25
+#define	OZ2_211H		0x26
+#define	OZ2_211L		0x27
+#define	DAHLXO_211H		0x28
+#define	DAHLXO_211L		0x29
+#define	OZ3_211H		0x2A
+#define	OZ3_211L		0x2B
+#define	OZ4_211H		0x2C
+#define	OZ4_211L		0x2D
+#define	OZ5_211H		0x2E
+#define	OZ5_211L		0x2F
+#define	oe_211H			0x30
+#define	oe_211L			0x31
+#define	MSR1CMAX_211H	0x32
+#define	MSR1CMAX_211L	0x33
+#define	MSR1CMIN_211H	0x34
+#define	MSR1CMIN_211L	0x35
+#define	MSR2CMAX_211H	0x36
+#define	MSR2CMAX_211L	0x37
+#define	MSR2CMIN_211H	0x38
+#define	MSR2CMIN_211L	0x39
+#define	OFFSET_211H		0x3A
+#define	OFFSET_211L		0x3B
+#define	ADOFFSET_211H	0x3C
+#define	ADOFFSET_211L	0x3D
+#define	EZ_211H			0x3E
+#define	EZ_211L			0x3F
+
+#define    LC898212AXB_REG_ADDR_START 0x80
+
+#define	LC898211_fs	24
+
+//Coefficient
+#define	ag_211H			0x40
+#define	ag_211L			0x41
+#define	da_211H			0x42
+#define	da_211L			0x43
+#define	db_211H			0x44
+#define	db_211L			0x45
+#define	dc_211H			0x46
+#define	dc_211L			0x47
+#define	dg_211H			0x48
+#define	dg_211L			0x49
+#define	pg_211H			0x4A
+#define	pg_211L			0x4B
+#define	gain1_211H		0x4C
+#define	gain1_211L		0x4D
+#define	gain2_211H		0x4E
+#define	gain2_211L		0x4F
+#define	ua_211H			0x50
+#define	ua_211L			0x51
+#define	uc_211H			0x52
+#define	uc_211L			0x53
+#define	ia_211H			0x54
+#define	ia_211L			0x55
+#define	ib_211H			0x56
+#define	ib_211L			0x57
+#define	ic_211H			0x58
+#define	ic_211L			0x59
+#define	ms11a_211H		0x5A
+#define	ms11a_211L		0x5B
+#define	ms11c_211H		0x5C
+#define	ms11c_211L		0x5D
+#define	ms12a_211H		0x5E
+#define	ms12a_211L		0x5F
+#define	ms12c_211H		0x60
+#define	ms12c_211L		0x61
+#define	ms21a_211H		0x62
+#define	ms21a_211L		0x63
+#define	ms21b_211H		0x64
+#define	ms21b_211L		0x65
+#define	ms21c_211H		0x66
+#define	ms21c_211L		0x67
+#define	ms22a_211H		0x68
+#define	ms22a_211L		0x69
+#define	ms22c_211H		0x6A
+#define	ms22c_211L		0x6B
+#define	ms22d_211H		0x6C
+#define	ms22d_211L		0x6D
+#define	ms22e_211H		0x6E
+#define	ms22e_211L		0x6F
+#define	ms23p_211H		0x70
+#define	ms23p_211L		0x71
+#define	oa_211H			0x72
+#define	oa_211L			0x73
+#define	oc_211H			0x74
+#define	oc_211L			0x75
+#define	PX12_211H		0x76
+#define	PX12_211L		0x77
+#define	PX3_211H		0x78
+#define	PX3_211L		0x79
+#define	MS2X_211H		0x7A
+#define	MS2X_211L		0x7B
+#define	CHTGX_211H		0x7C
+#define	CHTGX_211L		0x7D
+#define	CHTGN_211H		0x7E
+#define	CHTGN_211L		0x7F
+
+//Register
+#define	CLKSEL_211		0x80
+#define	ADSET_211		0x81
+#define	PWMSEL_211		0x82
+#define	SWTCH_211		0x83
+#define	STBY_211		0x84
+#define	CLR_211			0x85
+#define	DSSEL_211		0x86
+#define	ENBL_211		0x87
+#define	ANA1_211		0x88
+#define	AFSEND_211		0x8A
+#define	STMVEN_211		0x8A
+#define	STPT_211		0x8B
+#define	SWFC_211		0x8C
+#define	SWEN_211		0x8D
+#define	MSNUM_211		0x8E
+#define	MSSET_211		0x8F
+#define	DLYMON_211		0x90
+#define	MONA_211		0x91
+#define	PWMLIMIT_211	0x92
+#define	PINSEL_211		0x93
+#define	PWMSEL2_211		0x94
+#define	SFTRST_211		0x95
+#define	TEST_211		0x96
+#define	PWMZONE2_211	0x97
+#define	PWMZONE1_211	0x98
+#define	PWMZONE0_211	0x99
+#define	ZONE3_211		0x9A
+#define	ZONE2_211		0x9B
+#define	ZONE1_211		0x9C
+#define	ZONE0_211		0x9D
+#define	GCTIM_211		0x9E
+#define	GCTIM_211NU		0x9F
+#define	STMINT_211		0xA0
+#define	STMVENDH_211	0xA1
+#define	STMVENDL_211	0xA2
+#define	MSNUMR_211		0xA3
+#define 	ANA2_211		0xA4
+// Convergence Judgement
+#define INI_MSSET_211		0x00    // Initialize Value For [8Fh]
+#define CHTGX_THRESHOLD	0x0200  // Convergence Judge Threshold
+#define CHTGOKN_TIME		0x80    // 64 Sampling Time 1.365msec( EQCLK=12MHz )
+#define CHTGOKN_WAIT		3       // CHTGOKN_WAIT(3ms) > CHTGOKN_TIME(2.732msec) ( CHTGOKN_WAIT has to be longer than CHTGOKN_TIME)
+
+// StepMove
+#define STMV_SIZE           0x180   // StepSize(MS1Z12)
+
+#define STMV_INTERVAL       0x08    // Step Interval(STMVINT)
+
+#define STMCHTG_ON          0x08    // STMVEN Register Set
+#define STMSV_ON            0x04
+#define STMLFF_ON           0x02
+#define STMVEN_ON           0x01
+#define STMCHTG_OFF         0x00
+#define STMSV_OFF           0x00
+#define STMLFF_OFF          0x00
+#define STMVEN_OFF          0x00
+
+#define STMCHTG_SET         STMCHTG_ON  // Convergence Judgement On
+#define STMSV_SET           STMSV_ON    // Setting Target Position = End Position
+#define STMLFF_SET          STMLFF_OFF
+
+
+typedef struct STMVPAR {
+	uint16_t    UsSmvSiz ;
+	uint16_t	UcSmvItv ;
+	uint16_t	UcSmvEnb ;
+} stSmvPar;
+
+struct LC898212AXB_INIDATA {
+    uint16_t     addr ;
+    uint16_t     data ;
+} lc898212axb_IniData;
+
+const struct LC898212AXB_INIDATA lc898212axb_Init_Table[] = {
+    //Addr,   Data
+/// ALTEK_actuator >>>
+    /*{CLKSEL_211,   0x34},
+    {ADSET_211,    0x20},
+    {STBY_211,     0xE0},
+    {ENBL_211,     0x05},
+    {ANA2_211,     0x24},
+    {STPT_211,     0x80},
+    {OFFSET_211H,  0x00},
+    {OFFSET_211L,  0x00},
+    {RZ_211H,      0x00},
+    {RZ_211L,      0x00},
+    {PIDZO_211H,   0x00},
+    {PIDZO_211L,   0x00},
+    {MS1Z22_211H,  0x00},
+    {MS1Z22_211L,  0x00},
+    {DAHLXO_211H,  0x80},
+    {DAHLXO_211L,  0x40},
+    {SWTCH_211,    0x2C},
+    {STBY_211 ,    0xE3},
+    {PWMZONE2_211, 0x00},
+    {PWMZONE1_211, 0x42},
+    {PWMZONE0_211, 0x00},
+    {ZONE3_211   , 0x00},
+    {ANA1_211,     0x70},
+    {PWMLIMIT_211, 0x00},
+    {STMINT_211,   0x01},
+    {MS2X_211H,    0x68},
+    {MS2X_211L,    0x00},
+    {CHTGN_211H,   0x78},
+    {CHTGN_211L,   0x00},
+    {CHTGX_211H,   0x03},
+    {CHTGX_211L,   0x00},*/
+/// ALTEK_actuator <<<
+    {PINSEL_211,   0x00},
+    {DSSEL_211,    0x60},
+    {ag_211H,      0x7F},
+    {ag_211L,      0xF0},
+    {da_211H,      0x71},
+    {da_211L,      0x50},
+    {db_211H,      0x8F},
+    {db_211L,      0x90},
+    {dc_211H,      0x61},
+    {dc_211L,      0xB0},
+    {dg_211H,      0x65},
+    {dg_211L,      0xB0},
+    {PX12_211H,    0x0C},
+    {PX12_211L,    0x50},
+    {pg_211H,      0x28},
+    {pg_211L,      0x70},
+    {ua_211H,      0x04},
+    {ua_211L,      0xF0},
+    {uc_211H,      0x76},
+    {uc_211L,      0x10},
+    {ia_211H,      0x16},
+    {ia_211L,      0xC0},
+    {ib_211H,      0x00},
+    {ib_211L,      0x00},
+    {ic_211H,      0x7F},
+    {ic_211L,      0xF0},
+    {gain1_211H,   0x40},
+    {gain1_211L,   0x30},
+    {PX3_211H,     0x40},
+    {PX3_211L,     0x00},
+    {gain2_211H,   0x7F},
+    {gain2_211L,   0xF0},
+    {ms22e_211H,   0x00},
+    {ms22e_211L,   0x00},
+    {oa_211H,      0x18},
+    {oa_211L,      0xE0},
+    {oc_211H,      0x4E},
+    {oc_211L,      0x30},
+    {oe_211H,      0x00},
+    {oe_211L,      0x00},
+    {ms11a_211H,   0x06},
+    {ms11a_211L,   0x80},
+    {ms11c_211H,   0x72},
+    {ms11c_211L,   0xF0},
+    {ms12a_211H,   0x7F},
+    {ms12a_211L,   0x70},
+    {ms12c_211H,   0x7E},
+    {ms12c_211L,   0xD0},
+    {ms21a_211H,   0x7F},
+    {ms21a_211L,   0xF0},
+    {ms21b_211H,   0x00},
+    {ms21b_211L,   0x00},
+    {ms21c_211H,   0x00},
+    {ms21c_211L,   0x00},
+    {ms22a_211H,   0x51},
+    {ms22a_211L,   0x30},
+    {ms22c_211H,   0x72},
+    {ms22c_211L,   0xF0},
+    {ms23p_211H,   0x00},
+    {ms23p_211L,   0x00},
+    {ms22d_211H,   0x80},
+    {ms22d_211L,   0x10},
+    {PX12_211H,    0x0C},
+    {PX12_211L,    0x50},
+    {PX3_211H ,    0x40},
+    {PX3_211L ,    0x00},
+    {oe_211H,      0x00},
+    {oe_211L,      0x00},
+    {CLR_211,      0xC0},
+    {ENBL_211,     0x85},
+    {ms11a_211H,   0x08},
+    {ms11a_211L,   0x00},
+    {SWTCH_211,    0xac},
+    {STMINT_211,   0x01},
+};
diff --git a/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator_altek.c b/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator_altek.c
new file mode 100755
index 00000000000..bdfeb17a4fc
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator_altek.c
@@ -0,0 +1,1734 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "%s:%d " fmt, __func__, __LINE__
+
+#include <linux/module.h>
+#include "msm_sd.h"
+#include "msm_actuator_altek.h"
+#include "msm_cci.h"
+
+DEFINE_MSM_MUTEX(msm_actuator_mutex);
+
+/*#define MSM_ACUTUATOR_DEBUG*/
+#undef CDBG
+#ifdef MSM_ACUTUATOR_DEBUG
+#define CDBG(fmt, args...) pr_err(fmt, ##args)
+#else
+#define CDBG(fmt, args...) pr_debug(fmt, ##args)
+#endif
+
+#define WAIT 0xFF       // Wait command
+/// ALTEK_actuator >>>
+uint16_t otp_13p1bca[6] = {0x68, 0x2B, 0x7F, 0xF0, 0x80, 0x10}; //default
+/// ALTEK_actuator <<<
+
+static struct v4l2_file_operations msm_actuator_v4l2_subdev_fops;
+static int32_t msm_actuator_power_up(struct msm_actuator_ctrl_t *a_ctrl);
+static int32_t msm_actuator_power_down(struct msm_actuator_ctrl_t *a_ctrl);
+
+static struct msm_actuator msm_vcm_actuator_table;
+static struct msm_actuator msm_piezo_actuator_table;
+static struct msm_actuator msm_close_loop_actuator_table;
+
+static struct i2c_driver msm_actuator_i2c_driver;
+static struct msm_actuator *actuators[] = {
+	&msm_vcm_actuator_table,
+	&msm_piezo_actuator_table,
+	&msm_close_loop_actuator_table,
+};
+
+
+void close_loop_RamWriteA(struct msm_actuator_ctrl_t *a_ctrl,
+        uint16_t addr, uint16_t data)
+{
+    int rc;
+	//pr_err("RAM write addr=0x%x, data=0x%x\n", addr, data);
+    rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write(
+        &a_ctrl->i2c_client,
+        addr, data, MSM_CAMERA_I2C_BYTE_DATA);
+    if(rc < 0) pr_err("Actuator I2C Failed");
+}
+
+
+
+void close_loop_RamReadA(struct msm_actuator_ctrl_t *a_ctrl,
+        uint16_t addr, uint16_t *data)
+{
+    int rc;
+    rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_read(
+        &a_ctrl->i2c_client,
+        addr, data, MSM_CAMERA_I2C_BYTE_DATA);
+    if(rc < 0) pr_err("Actuator I2C Failed");
+}
+
+
+
+void close_loop_RegWriteA(struct msm_actuator_ctrl_t *a_ctrl,
+        uint16_t addr, uint16_t data)
+{
+    int rc;
+    //pr_err("Reg write addr=0x%x, data=0x%x\n", addr, data);
+    rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write(
+        &a_ctrl->i2c_client,
+        addr, data, MSM_CAMERA_I2C_BYTE_DATA);
+    if(rc < 0) pr_err("Actuator I2C Failed");
+}
+
+
+
+void close_loop_RegReadA(struct msm_actuator_ctrl_t *a_ctrl,
+        uint16_t addr, uint16_t *data)
+{
+    int rc;
+    rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_read(
+        &a_ctrl->i2c_client,
+        addr, data, MSM_CAMERA_I2C_BYTE_DATA);
+    if(rc < 0) pr_err("Actuator I2C Failed");
+}
+
+
+void close_loop_WaitTime(uint16_t msec)
+{
+    msleep(msec);
+}
+
+void close_loop_ServoOn(struct msm_actuator_ctrl_t *a_ctrl)
+{
+    close_loop_WaitTime(5);
+    close_loop_RegWriteA(a_ctrl, 0x87, 0x85);
+}
+
+uint16_t close_loop_init(struct msm_actuator_ctrl_t *a_ctrl,
+        struct msm_actuator_set_info_t *set_info)
+{
+    #define DataLen sizeof(lc898212axb_Init_Table) / sizeof(lc898212axb_IniData)
+/// ALTEK_actuator >>>
+    //uint16_t hall_bias, hall_off;
+/// ALTEK_actuator <<<
+    uint16_t i;
+    uint16_t pos;
+    stSmvPar StSmvPar;
+        StSmvPar.UsSmvSiz   = STMV_SIZE ;
+        StSmvPar.UcSmvItv   = STMV_INTERVAL ;
+        StSmvPar.UcSmvEnb   = STMCHTG_SET | STMSV_SET | STMLFF_SET ;
+    //pr_err("close_loop_init\n");
+//    for(i=0;i<6;i++) otp_13p1bca[i] = set_info->actuator_params.init_settings[i].reg_data;
+
+    for(i = 0; i < DataLen; i++)
+    {
+        //pr_err("lc898212axb_Init_Table[%d].addr=0x%x, wait=0x%x\n", i, lc898212axb_Init_Table[i].addr, WAIT);
+        if(lc898212axb_Init_Table[i].addr == WAIT)
+        {
+            close_loop_WaitTime(lc898212axb_Init_Table[i].data);
+            continue;
+        }
+
+        if(lc898212axb_Init_Table[i].addr >= LC898212AXB_REG_ADDR_START)
+        {
+            close_loop_RegWriteA(a_ctrl, lc898212axb_Init_Table[i].addr,
+                    (uint16_t)(lc898212axb_Init_Table[i].data & 0x00ff));
+        } else {
+            close_loop_RamWriteA(a_ctrl, lc898212axb_Init_Table[i].addr,
+                    (uint16_t)lc898212axb_Init_Table[i].data);
+        }
+    }
+
+/// ALTEK_actuator >>>
+    //hall_bias = otp_13p1bca[1];
+    //hall_off = otp_13p1bca[0];
+    //close_loop_RegWriteA(a_ctrl, 0x28, hall_off);
+    //close_loop_RegWriteA(a_ctrl, 0x29, hall_bias);
+/// ALTEK_actuator <<<
+    close_loop_RamReadA(a_ctrl, 0x3C, &pos);
+    close_loop_RamWriteA(a_ctrl, 0x04, pos);
+    close_loop_RamWriteA(a_ctrl, 0x18, pos);
+    close_loop_StmvSet(a_ctrl, StSmvPar ) ;
+    close_loop_ServoOn(a_ctrl);
+
+    return 0;
+}
+
+uint16_t close_loop_StmvTo(struct msm_actuator_ctrl_t *a_ctrl, uint16_t SsSmvEnd)
+{
+    int rc=0;
+    uint16_t UsSmvTim;
+    uint16_t UsSmvDpl;
+    uint16_t SsParStt;
+
+    close_loop_RamReadA(a_ctrl, RZ_211H , &SsParStt );
+    UsSmvDpl = abs( SsParStt - SsSmvEnd );
+    if((UsSmvDpl <= StSmvPar.UsSmvSiz) &&
+            ((StSmvPar.UcSmvEnb & STMSV_ON) == STMSV_ON)) {
+        if(StSmvPar.UcSmvEnb & STMCHTG_ON) {
+            close_loop_RegWriteA(a_ctrl, MSSET_211, INI_MSSET_211 | (uint16_t)0x01);
+        }
+	//pr_err("i2c write, addr=0x%x, data=%x0x\n", MS1Z22_211H, SsSmvEnd);
+        rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write(
+            &a_ctrl->i2c_client,
+            MS1Z22_211H,
+            SsSmvEnd, MSM_CAMERA_I2C_WORD_DATA);
+
+        StSmvPar.UcSmvEnb |= STMVEN_ON;
+
+    } else {
+        if(SsParStt < SsSmvEnd) {
+            close_loop_RamWriteA(a_ctrl, MS1Z12_211H, 0x01);
+            close_loop_RamWriteA(a_ctrl, MS1Z12_211L, 0x80);
+        } else if(SsParStt > SsSmvEnd) {
+            close_loop_RamWriteA(a_ctrl, MS1Z12_211H, 0xFE);
+            close_loop_RamWriteA(a_ctrl, MS1Z12_211L, 0x80);
+        }
+	 //pr_err("move lens, addr=0x%x, data=0x%x\n", STMVENDH_211, SsSmvEnd);
+        rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write(
+            &a_ctrl->i2c_client,
+            STMVENDH_211,
+            SsSmvEnd, MSM_CAMERA_I2C_WORD_DATA);
+        StSmvPar.UcSmvEnb |= STMVEN_ON;
+        close_loop_RegWriteA(a_ctrl, STMVEN_211, StSmvPar.UcSmvEnb);
+    }
+
+    UsSmvTim=(uint16_t)((UsSmvDpl*(STMV_INTERVAL+1))/(STMV_SIZE*LC898211_fs));
+    close_loop_WaitTime(1);
+
+    return close_loop_StmvEnd(a_ctrl, StSmvPar.UcSmvEnb);
+}
+
+uint16_t close_loop_StmvEnd(struct msm_actuator_ctrl_t *a_ctrl, uint16_t UcParMod)
+{
+    uint16_t UcChtGst;
+    uint16_t i;
+
+    while(UcParMod & STMVEN_ON)
+    {
+        close_loop_RegReadA(a_ctrl, STMVEN_211 , &UcParMod);
+    }
+
+    if( (UcParMod & 0x08) == STMCHTG_ON ){
+        for(i=0; i<CHTGOKN_WAIT; i++)
+        {
+            close_loop_RegReadA(a_ctrl, MSSET_211, &UcChtGst);
+            if(!(UcChtGst & 0x01))  break;
+            close_loop_WaitTime(1);
+        }
+    }
+
+    if(UcChtGst & 0x01) {
+        UcParMod |= 0x80;
+    } else {
+        UcParMod &= 0x7F;
+    }
+
+    return UcParMod;
+}
+
+void close_loop_StmvSet(struct msm_actuator_ctrl_t *a_ctrl, stSmvPar StSetSmv)
+{
+    uint16_t UcSetEnb;
+    uint16_t UcSetSwt;
+    uint16_t UsParSiz;
+    uint16_t UcParItv;
+    uint16_t SsParStt;
+
+    StSmvPar.UsSmvSiz = StSetSmv.UsSmvSiz;
+    StSmvPar.UcSmvItv = StSetSmv.UcSmvItv;
+    StSmvPar.UcSmvEnb = StSetSmv.UcSmvEnb;
+
+    close_loop_RegWriteA(a_ctrl, AFSEND_211, 0x00);
+
+    close_loop_RegReadA(a_ctrl, ENBL_211, &UcSetEnb);
+    UcSetEnb &= 0xFD;
+    close_loop_RegWriteA(a_ctrl, ENBL_211,  UcSetEnb);
+
+    close_loop_RegReadA(a_ctrl, SWTCH_211,  &UcSetSwt);
+    UcSetSwt &= 0x7F;
+    close_loop_RegWriteA(a_ctrl, SWTCH_211, UcSetSwt);
+
+    close_loop_RamReadA(a_ctrl, RZ_211H, &SsParStt);
+    UsParSiz    = StSetSmv.UsSmvSiz ;
+    UcParItv    = StSetSmv.UcSmvItv ;
+
+    close_loop_RamWriteA(a_ctrl, ms11a_211H, 0x08);
+    close_loop_RamWriteA(a_ctrl, ms11a_211L, 0x00);
+    close_loop_RamWriteA(a_ctrl, MS1Z22_211H, (SsParStt&0xFF00) >> 8);
+    close_loop_RamWriteA(a_ctrl, MS1Z22_211L, SsParStt& 0xFF);
+    close_loop_RamWriteA(a_ctrl, MS1Z12_211H, (UsParSiz&0xFF00) >> 8);
+    close_loop_RamWriteA(a_ctrl, MS1Z12_211L, UsParSiz & 0xFF);
+
+    close_loop_RegWriteA(a_ctrl, STMINT_211, UcParItv);
+    UcSetSwt |= 0x80;
+    close_loop_RegWriteA(a_ctrl, SWTCH_211, UcSetSwt);
+}
+
+uint16_t close_loop_AF_convert(uint16_t position)
+{
+/// ALTEK_actuator >>>
+    uint16_t Min_Pos = 0;
+    uint16_t Max_Pos = 1023;
+/// ALTEK_actuator <<<
+    uint16_t Hall_Min = ((otp_13p1bca[4]<<8) | otp_13p1bca[5]);
+    uint16_t Hall_Max = ((otp_13p1bca[2]<<8) | otp_13p1bca[3]);
+    int HallRange = ((Hall_Max - Hall_Min)&0xFFFF); //hall range
+    int PosRange = Max_Pos - Min_Pos; //1023
+    int HallPos = 0;
+    //Hall_Min = 0xea93 , Hall_Max = 0x3A67
+    CDBG("Hall_Min = 0x%04x , Hall_Max = 0x%04x , Position = %d",Hall_Min,Hall_Max,position);
+
+/*
+    if(position<=100)
+        position=(position*15)/10;
+    else
+        position = (position+50) - 1*((position/20)-5); //(3540+50) - 1*((3540/20) -5) = 3590 - 121 = 3469
+
+    //177 * 1024 / 310 + 1 = 585
+    position = position * (Max_Pos - Min_Pos) / 310 + Min_Pos;
+
+    //(585 - 1) * 20436 / 1023 + 0xea93
+
+
+    HallPos = (position - Min_Pos) * HallRange / PosRange;
+    if(HallPos < (Hall_Min - 0x7fff))
+      HallPos = Hall_Min - HallPos;
+    else
+      HallPos = HallPos - Hall_Min;
+*/
+
+	HallPos =((Hall_Max-((position-Min_Pos) * (HallRange/ PosRange)))& 0xFFFF);
+
+	//pr_err("VCMSTEPK:Target HallPos 0x%04x\n", HallPos);
+    return HallPos;
+}
+
+static int32_t close_loop_move_focus(struct msm_actuator_ctrl_t *a_ctrl,
+        struct msm_actuator_move_params_t *move_params)
+{
+    uint16_t position = move_params->dest_step_pos;
+#if 0
+    // Ringing Test
+    for(position=0;position<50;position+=10) {
+        close_loop_StmvTo(a_ctrl, close_loop_AF_convert(position*20));
+        usleep(66000);
+    }
+    for(position=50;position>0;position-=10) {
+        close_loop_StmvTo(a_ctrl, close_loop_AF_convert(position*20));
+        usleep(66000);
+    }
+#endif
+#if 0
+    // Linearity Test
+    for(position=0;position<50;position++) {
+        close_loop_StmvTo(a_ctrl, close_loop_AF_convert(position*20));
+        usleep(33000);
+    }
+    for(position=50;position>0;position--) {
+        close_loop_StmvTo(a_ctrl, close_loop_AF_convert(position*20));
+        usleep(33000);
+    }
+#endif
+#if 1
+    //pr_err("Dest_pos : %d",position);
+    close_loop_StmvTo(a_ctrl, close_loop_AF_convert(position));
+#endif
+    return 0;
+}
+/// ALTEK_actuator >>>
+static int32_t close_loop_set_position(
+	struct msm_actuator_ctrl_t *a_ctrl,
+	struct msm_actuator_set_position_t *set_pos)
+{
+	int32_t rc = 0;
+	int32_t index;
+	uint16_t next_lens_position;
+	uint16_t delay;
+	CDBG("%s Enter %d\n", __func__, __LINE__);
+	if (set_pos->number_of_steps  == 0)
+		return rc;
+
+	a_ctrl->i2c_tbl_index = 0;
+	for (index = 0; index < set_pos->number_of_steps; index++) {
+		next_lens_position = set_pos->pos[index];
+		delay = set_pos->delay[index];
+		close_loop_StmvTo(a_ctrl, close_loop_AF_convert(set_pos->pos[index]));
+	}
+	CDBG("%s exit %d\n", __func__, __LINE__);
+	return rc;
+}
+
+static int32_t close_loop_set_boundary(
+	struct msm_actuator_ctrl_t *a_ctrl,
+	struct msm_actuator_boundary_t *a_boundary)
+{
+	int32_t rc = 0;
+
+	otp_13p1bca[2] = (a_boundary->hall_max & 0xFF00)>>8;
+	otp_13p1bca[3] = (a_boundary->hall_max & 0xFF);
+	otp_13p1bca[4] = (a_boundary->hall_min & 0xFF00)>>8;
+	otp_13p1bca[5] = (a_boundary->hall_min & 0xFF);
+	return rc;
+}
+/// ALTEK_actuator <<<
+
+static int32_t msm_actuator_piezo_set_default_focus(
+	struct msm_actuator_ctrl_t *a_ctrl,
+	struct msm_actuator_move_params_t *move_params)
+{
+	int32_t rc = 0;
+	struct msm_camera_i2c_reg_setting reg_setting;
+	CDBG("Enter\n");
+
+	if (a_ctrl->curr_step_pos != 0) {
+		a_ctrl->i2c_tbl_index = 0;
+		a_ctrl->func_tbl->actuator_parse_i2c_params(a_ctrl,
+			a_ctrl->initial_code, 0, 0);
+		a_ctrl->func_tbl->actuator_parse_i2c_params(a_ctrl,
+			a_ctrl->initial_code, 0, 0);
+		reg_setting.reg_setting = a_ctrl->i2c_reg_tbl;
+		reg_setting.data_type = a_ctrl->i2c_data_type;
+		reg_setting.size = a_ctrl->i2c_tbl_index;
+		rc = a_ctrl->i2c_client.i2c_func_tbl->
+			i2c_write_table_w_microdelay(
+			&a_ctrl->i2c_client, &reg_setting);
+		if (rc < 0) {
+			pr_err("%s: i2c write error:%d\n",
+				__func__, rc);
+			return rc;
+		}
+		a_ctrl->i2c_tbl_index = 0;
+		a_ctrl->curr_step_pos = 0;
+	}
+	CDBG("Exit\n");
+	return rc;
+}
+
+static void msm_actuator_parse_i2c_params(struct msm_actuator_ctrl_t *a_ctrl,
+	int16_t next_lens_position, uint32_t hw_params, uint16_t delay)
+{
+	struct msm_actuator_reg_params_t *write_arr = a_ctrl->reg_tbl;
+	uint32_t hw_dword = hw_params;
+	uint16_t i2c_byte1 = 0, i2c_byte2 = 0;
+	uint16_t value = 0;
+	uint32_t size = a_ctrl->reg_tbl_size, i = 0;
+	struct msm_camera_i2c_reg_array *i2c_tbl = a_ctrl->i2c_reg_tbl;
+	CDBG("Enter\n");
+	for (i = 0; i < size; i++) {
+		/* check that the index into i2c_tbl cannot grow larger that
+		the allocated size of i2c_tbl */
+		if ((a_ctrl->total_steps + 1) < (a_ctrl->i2c_tbl_index)) {
+			break;
+		}
+		if (write_arr[i].reg_write_type == MSM_ACTUATOR_WRITE_DAC) {
+			value = next_lens_position;
+
+			if (write_arr[i].reg_addr != 0xFFFF) {
+				i2c_byte1 = write_arr[i].reg_addr;
+				i2c_byte2 = value;
+				if (size != (i+1)) {
+					i2c_byte2 = (value & 0xFF00) >> 8;
+					CDBG("byte1:0x%x, byte2:0x%x\n",
+						i2c_byte1, i2c_byte2);
+					i2c_tbl[a_ctrl->i2c_tbl_index].
+						reg_addr = i2c_byte1;
+					i2c_tbl[a_ctrl->i2c_tbl_index].
+						reg_data = i2c_byte2;
+					i2c_tbl[a_ctrl->i2c_tbl_index].
+						delay = 0;
+					a_ctrl->i2c_tbl_index++;
+					i++;
+					i2c_byte1 = write_arr[i].reg_addr;
+					i2c_byte2 = value & 0xFF;
+				}
+			} else {
+				i2c_byte1 = (value & 0xFF00) >> 8;
+				i2c_byte2 = value & 0xFF;
+			}
+		} else {
+			i2c_byte1 = write_arr[i].reg_addr;
+			i2c_byte2 = (hw_dword & write_arr[i].hw_mask) >>
+				write_arr[i].hw_shift;
+		}
+		CDBG("i2c_byte1:0x%x, i2c_byte2:0x%x\n", i2c_byte1, i2c_byte2);
+		i2c_tbl[a_ctrl->i2c_tbl_index].reg_addr = i2c_byte1;
+		i2c_tbl[a_ctrl->i2c_tbl_index].reg_data = i2c_byte2;
+		i2c_tbl[a_ctrl->i2c_tbl_index].delay = delay;
+		a_ctrl->i2c_tbl_index++;
+	}
+	CDBG("Exit\n");
+}
+
+static int32_t msm_actuator_init_focus(struct msm_actuator_ctrl_t *a_ctrl,
+	uint16_t size, struct reg_settings_t *settings)
+{
+	int32_t rc = -EFAULT;
+	int32_t i = 0;
+	enum msm_camera_i2c_reg_addr_type save_addr_type;
+	CDBG("Enter\n");
+
+	save_addr_type = a_ctrl->i2c_client.addr_type;
+	for (i = 0; i < size; i++) {
+
+		switch (settings[i].addr_type) {
+		case MSM_ACTUATOR_BYTE_ADDR:
+			a_ctrl->i2c_client.addr_type = MSM_CAMERA_I2C_BYTE_ADDR;
+			break;
+		case MSM_ACTUATOR_WORD_ADDR:
+			a_ctrl->i2c_client.addr_type = MSM_CAMERA_I2C_WORD_ADDR;
+			break;
+		default:
+			pr_err("Unsupport addr type: %d\n",
+				settings[i].addr_type);
+			break;
+		}
+
+		switch (settings[i].i2c_operation) {
+		case MSM_ACT_WRITE:
+			rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write(
+				&a_ctrl->i2c_client,
+				settings[i].reg_addr,
+				settings[i].reg_data,
+				settings[i].data_type);
+			break;
+		case MSM_ACT_POLL:
+			rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_poll(
+				&a_ctrl->i2c_client,
+				settings[i].reg_addr,
+				settings[i].reg_data,
+				settings[i].data_type);
+			break;
+		default:
+			pr_err("Unsupport i2c_operation: %d\n",
+				settings[i].i2c_operation);
+			break;
+
+		if (0 != settings[i].delay)
+			msleep(settings[i].delay);
+
+		if (rc < 0)
+			break;
+		}
+	}
+
+	a_ctrl->curr_step_pos = 0;
+	/*
+	 * Recover register addr_type after the init
+	 * settings are written.
+	 */
+	a_ctrl->i2c_client.addr_type = save_addr_type;
+	CDBG("Exit\n");
+	return rc;
+}
+
+static void msm_actuator_write_focus(
+	struct msm_actuator_ctrl_t *a_ctrl,
+	uint16_t curr_lens_pos,
+	struct damping_params_t *damping_params,
+	int8_t sign_direction,
+	int16_t code_boundary)
+{
+//	int16_t next_lens_pos = 0;
+	uint16_t damping_code_step = 0;
+	uint16_t wait_time = 0;
+	CDBG("Enter\n");
+
+	damping_code_step = damping_params->damping_step;
+	wait_time = damping_params->damping_delay;
+
+	/* Write code based on damping_code_step in a loop */
+/*	for (next_lens_pos =
+		curr_lens_pos + (sign_direction * damping_code_step);
+		(sign_direction * next_lens_pos) <=
+			(sign_direction * code_boundary);
+		next_lens_pos =
+			(next_lens_pos +
+				(sign_direction * damping_code_step))) {
+		a_ctrl->func_tbl->actuator_parse_i2c_params(a_ctrl,
+			next_lens_pos, damping_params->hw_params, wait_time);
+		curr_lens_pos = next_lens_pos;
+	}
+*/
+	if (curr_lens_pos != code_boundary) {
+		a_ctrl->func_tbl->actuator_parse_i2c_params(a_ctrl,
+			code_boundary, damping_params->hw_params, wait_time);
+	}
+	CDBG("Exit\n");
+}
+
+static int32_t msm_actuator_piezo_move_focus(
+	struct msm_actuator_ctrl_t *a_ctrl,
+	struct msm_actuator_move_params_t *move_params)
+{
+	int32_t dest_step_position = move_params->dest_step_pos;
+	struct damping_params_t ringing_params_kernel;
+	int32_t rc = 0;
+	int32_t num_steps = move_params->num_steps;
+	struct msm_camera_i2c_reg_setting reg_setting;
+	CDBG("Enter\n");
+
+	if (copy_from_user(&ringing_params_kernel,
+		&(move_params->ringing_params[0]),
+		sizeof(struct damping_params_t))) {
+		pr_err("copy_from_user failed\n");
+		return -EFAULT;
+	}
+
+	if (num_steps == 0)
+		return rc;
+
+	a_ctrl->i2c_tbl_index = 0;
+	a_ctrl->func_tbl->actuator_parse_i2c_params(a_ctrl,
+		(num_steps *
+		a_ctrl->region_params[0].code_per_step),
+		ringing_params_kernel.hw_params, 0);
+
+	reg_setting.reg_setting = a_ctrl->i2c_reg_tbl;
+	reg_setting.data_type = a_ctrl->i2c_data_type;
+	reg_setting.size = a_ctrl->i2c_tbl_index;
+	rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write_table_w_microdelay(
+		&a_ctrl->i2c_client, &reg_setting);
+	if (rc < 0) {
+		pr_err("i2c write error:%d\n", rc);
+		return rc;
+	}
+	a_ctrl->i2c_tbl_index = 0;
+	a_ctrl->curr_step_pos = dest_step_position;
+	CDBG("Exit\n");
+	return rc;
+}
+
+static int32_t msm_actuator_move_focus(
+	struct msm_actuator_ctrl_t *a_ctrl,
+	struct msm_actuator_move_params_t *move_params)
+{
+	int32_t rc = 0;
+	struct damping_params_t ringing_params_kernel;
+	int8_t sign_dir = move_params->sign_dir;
+	uint16_t step_boundary = 0;
+	uint16_t target_step_pos = 0;
+	uint16_t target_lens_pos = 0;
+	int16_t dest_step_pos = move_params->dest_step_pos;
+	uint16_t curr_lens_pos = 0;
+	int dir = move_params->dir;
+	int32_t num_steps = move_params->num_steps;
+	struct msm_camera_i2c_reg_setting reg_setting;
+
+	if (copy_from_user(&ringing_params_kernel,
+		&(move_params->ringing_params[a_ctrl->curr_region_index]),
+		sizeof(struct damping_params_t))) {
+		pr_err("copy_from_user failed\n");
+		return -EFAULT;
+	}
+
+
+	CDBG("called, dir %d, num_steps %d\n", dir, num_steps);
+
+	if (dest_step_pos == a_ctrl->curr_step_pos)
+		return rc;
+
+	if ((sign_dir > MSM_ACTUATOR_MOVE_SIGNED_NEAR) ||
+		(sign_dir < MSM_ACTUATOR_MOVE_SIGNED_FAR)) {
+		//pr_err("Invalid sign_dir = %d\n", sign_dir);
+		return -EFAULT;
+	}
+	if ((dir > MOVE_FAR) || (dir < MOVE_NEAR)) {
+		pr_err("Invalid direction = %d\n", dir);
+		return -EFAULT;
+	}
+	if (dest_step_pos > a_ctrl->total_steps) {
+		//pr_err("Step pos greater than total steps = %d\n",
+		//dest_step_pos);
+		return -EFAULT;
+	}
+	curr_lens_pos = a_ctrl->step_position_table[a_ctrl->curr_step_pos];
+	a_ctrl->i2c_tbl_index = 0;
+	CDBG("curr_step_pos =%d dest_step_pos =%d curr_lens_pos=%d\n",
+		a_ctrl->curr_step_pos, dest_step_pos, curr_lens_pos);
+
+	while (a_ctrl->curr_step_pos != dest_step_pos) {
+		step_boundary =
+			a_ctrl->region_params[a_ctrl->curr_region_index].
+			step_bound[dir];
+		if ((dest_step_pos * sign_dir) <=
+			(step_boundary * sign_dir)) {
+
+			target_step_pos = dest_step_pos;
+			target_lens_pos =
+				a_ctrl->step_position_table[target_step_pos];
+			a_ctrl->func_tbl->actuator_write_focus(a_ctrl,
+					curr_lens_pos,
+					&ringing_params_kernel,
+					sign_dir,
+					target_lens_pos);
+			curr_lens_pos = target_lens_pos;
+
+		} else {
+			target_step_pos = step_boundary;
+			target_lens_pos =
+				a_ctrl->step_position_table[target_step_pos];
+			a_ctrl->func_tbl->actuator_write_focus(a_ctrl,
+					curr_lens_pos,
+					&ringing_params_kernel,
+					sign_dir,
+					target_lens_pos);
+			curr_lens_pos = target_lens_pos;
+
+			a_ctrl->curr_region_index += sign_dir;
+		}
+		a_ctrl->curr_step_pos = target_step_pos;
+	}
+
+	move_params->curr_lens_pos = curr_lens_pos;
+	reg_setting.reg_setting = a_ctrl->i2c_reg_tbl;
+	reg_setting.data_type = a_ctrl->i2c_data_type;
+	reg_setting.size = a_ctrl->i2c_tbl_index;
+	rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write_table_w_microdelay(
+		&a_ctrl->i2c_client, &reg_setting);
+	if (rc < 0) {
+		pr_err("i2c write error:%d\n", rc);
+		return rc;
+	}
+	a_ctrl->i2c_tbl_index = 0;
+	CDBG("Exit\n");
+
+	return rc;
+}
+
+
+static int32_t msm_actuator_park_lens(struct msm_actuator_ctrl_t *a_ctrl)
+{
+	int32_t rc = 0;
+	uint16_t next_lens_pos = 0;
+	struct msm_camera_i2c_reg_setting reg_setting;
+
+	a_ctrl->i2c_tbl_index = 0;
+	if ((a_ctrl->curr_step_pos > a_ctrl->total_steps) ||
+		(!a_ctrl->park_lens.max_step) ||
+		(!a_ctrl->step_position_table) ||
+		(!a_ctrl->i2c_reg_tbl) ||
+		(!a_ctrl->func_tbl) ||
+		(!a_ctrl->func_tbl->actuator_parse_i2c_params)) {
+		pr_err("%s:%d Failed to park lens.\n",
+			__func__, __LINE__);
+		return 0;
+	}
+
+	if (a_ctrl->park_lens.max_step > a_ctrl->max_code_size)
+		a_ctrl->park_lens.max_step = a_ctrl->max_code_size;
+
+	next_lens_pos = a_ctrl->step_position_table[a_ctrl->curr_step_pos];
+	while (next_lens_pos) {
+		next_lens_pos = (next_lens_pos > a_ctrl->park_lens.max_step) ?
+			(next_lens_pos - a_ctrl->park_lens.max_step) : 0;
+		a_ctrl->func_tbl->actuator_parse_i2c_params(a_ctrl,
+			next_lens_pos, a_ctrl->park_lens.hw_params,
+			a_ctrl->park_lens.damping_delay);
+
+		reg_setting.reg_setting = a_ctrl->i2c_reg_tbl;
+		reg_setting.size = a_ctrl->i2c_tbl_index;
+		reg_setting.data_type = a_ctrl->i2c_data_type;
+
+		rc = a_ctrl->i2c_client.i2c_func_tbl->
+			i2c_write_table_w_microdelay(
+			&a_ctrl->i2c_client, &reg_setting);
+		if (rc < 0) {
+			pr_err("%s Failed I2C write Line %d\n",
+				__func__, __LINE__);
+			return rc;
+		}
+		a_ctrl->i2c_tbl_index = 0;
+		/* Use typical damping time delay to avoid tick sound */
+		usleep_range(10000, 12000);
+	}
+
+	return 0;
+}
+
+static int32_t msm_actuator_init_step_table(struct msm_actuator_ctrl_t *a_ctrl,
+	struct msm_actuator_set_info_t *set_info)
+{
+	int16_t code_per_step = 0;
+	int16_t cur_code = 0;
+	int16_t step_index = 0, region_index = 0;
+	uint16_t step_boundary = 0;
+	uint32_t max_code_size = 1;
+	uint16_t data_size = set_info->actuator_params.data_size;
+	CDBG("Enter\n");
+
+	for (; data_size > 0; data_size--)
+		max_code_size *= 2;
+
+	a_ctrl->max_code_size = max_code_size;
+CDBG("data_size=%d, max_code_size=%d\n", data_size, max_code_size);
+	kfree(a_ctrl->step_position_table);
+	a_ctrl->step_position_table = NULL;
+
+	if (set_info->af_tuning_params.total_steps
+		>  MAX_ACTUATOR_AF_TOTAL_STEPS) {
+		pr_err("Max actuator totalsteps exceeded = %d\n",
+		set_info->af_tuning_params.total_steps);
+		return -EFAULT;
+	}
+	/* Fill step position table */
+	a_ctrl->step_position_table =
+		kmalloc(sizeof(uint16_t) *
+		(set_info->af_tuning_params.total_steps + 1), GFP_KERNEL);
+
+	if (a_ctrl->step_position_table == NULL)
+		return -ENOMEM;
+
+	cur_code = set_info->af_tuning_params.initial_code;
+	a_ctrl->step_position_table[step_index++] = cur_code;
+	for (region_index = 0;
+		region_index < a_ctrl->region_size;
+		region_index++) {
+		code_per_step =
+			a_ctrl->region_params[region_index].code_per_step;
+		step_boundary =
+			a_ctrl->region_params[region_index].
+			step_bound[MOVE_NEAR];
+		for (; step_index <= step_boundary;
+			step_index++) {
+			cur_code += code_per_step;
+//			if (cur_code < max_code_size)
+				a_ctrl->step_position_table[step_index] =
+					cur_code;
+//			else {
+//				for (; step_index <
+//					set_info->af_tuning_params.total_steps;
+//					step_index++)
+//					a_ctrl->
+//						step_position_table[
+//						step_index] =
+//						max_code_size;
+//			}
+		}
+	}
+	CDBG("Exit\n");
+	return 0;
+}
+
+static int32_t msm_actuator_set_default_focus(
+	struct msm_actuator_ctrl_t *a_ctrl,
+	struct msm_actuator_move_params_t *move_params)
+{
+	int32_t rc = 0;
+	CDBG("Enter\n");
+
+	if (a_ctrl->curr_step_pos != 0)
+		rc = a_ctrl->func_tbl->actuator_move_focus(a_ctrl, move_params);
+	CDBG("Exit\n");
+	return rc;
+}
+
+
+static int32_t close_loop_set_default_focus(
+    struct msm_actuator_ctrl_t *a_ctrl,
+    struct msm_actuator_move_params_t *move_params)
+{
+    return 0;
+}
+
+static int32_t msm_actuator_vreg_control(struct msm_actuator_ctrl_t *a_ctrl,
+							int config)
+{
+	int rc = 0, i, cnt;
+	struct msm_actuator_vreg *vreg_cfg;
+
+	vreg_cfg = &a_ctrl->vreg_cfg;
+	cnt = vreg_cfg->num_vreg;
+	if (!cnt)
+		return 0;
+
+	if (cnt >= MSM_ACTUATOT_MAX_VREGS) {
+		pr_err("%s failed %d cnt %d\n", __func__, __LINE__, cnt);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < cnt; i++) {
+		rc = msm_camera_config_single_vreg(&(a_ctrl->pdev->dev),
+			&vreg_cfg->cam_vreg[i],
+			(struct regulator **)&vreg_cfg->data[i],
+			config);
+	}
+	return rc;
+}
+
+static int32_t msm_actuator_power_down(struct msm_actuator_ctrl_t *a_ctrl)
+{
+	int32_t rc = 0;
+	CDBG("Enter\n");
+	if (a_ctrl->actuator_state != ACTUATOR_POWER_DOWN) {
+
+		if (a_ctrl->func_tbl && a_ctrl->func_tbl->actuator_park_lens) {
+			rc = a_ctrl->func_tbl->actuator_park_lens(a_ctrl);
+			if (rc < 0)
+				pr_err("%s:%d Lens park failed.\n",
+					__func__, __LINE__);
+		}
+
+		rc = msm_actuator_vreg_control(a_ctrl, 0);
+		if (rc < 0) {
+			pr_err("%s failed %d\n", __func__, __LINE__);
+			return rc;
+		}
+
+		kfree(a_ctrl->step_position_table);
+		a_ctrl->step_position_table = NULL;
+		kfree(a_ctrl->i2c_reg_tbl);
+		a_ctrl->i2c_reg_tbl = NULL;
+		a_ctrl->i2c_tbl_index = 0;
+		a_ctrl->actuator_state = ACTUATOR_POWER_DOWN;
+	}
+	CDBG("Exit\n");
+	return rc;
+}
+
+static int32_t msm_actuator_set_position(
+	struct msm_actuator_ctrl_t *a_ctrl,
+	struct msm_actuator_set_position_t *set_pos)
+{
+	int32_t rc = 0;
+	int32_t index;
+	uint16_t next_lens_position;
+	uint16_t delay;
+	uint32_t hw_params = 0;
+	struct msm_camera_i2c_reg_setting reg_setting;
+	CDBG("%s Enter %d\n", __func__, __LINE__);
+	if (set_pos->number_of_steps  == 0)
+		return rc;
+
+	a_ctrl->i2c_tbl_index = 0;
+	for (index = 0; index < set_pos->number_of_steps; index++) {
+		next_lens_position = set_pos->pos[index];
+		delay = set_pos->delay[index];
+		a_ctrl->func_tbl->actuator_parse_i2c_params(a_ctrl,
+		next_lens_position, hw_params, delay);
+
+		reg_setting.reg_setting = a_ctrl->i2c_reg_tbl;
+		reg_setting.size = a_ctrl->i2c_tbl_index;
+		reg_setting.data_type = a_ctrl->i2c_data_type;
+
+		rc = a_ctrl->i2c_client.i2c_func_tbl->
+			i2c_write_table_w_microdelay(
+			&a_ctrl->i2c_client, &reg_setting);
+		if (rc < 0) {
+			pr_err("%s Failed I2C write Line %d\n",
+				__func__, __LINE__);
+			return rc;
+		}
+		a_ctrl->i2c_tbl_index = 0;
+	}
+	CDBG("%s exit %d\n", __func__, __LINE__);
+	return rc;
+}
+
+static int32_t msm_actuator_set_param(struct msm_actuator_ctrl_t *a_ctrl,
+	struct msm_actuator_set_info_t *set_info) {
+	struct reg_settings_t *init_settings = NULL;
+	int32_t rc = -EFAULT;
+	uint16_t i = 0;
+	struct msm_camera_cci_client *cci_client = NULL;
+	CDBG("Enter\n");
+
+	for (i = 0; i < ARRAY_SIZE(actuators); i++) {
+		if (set_info->actuator_params.act_type ==
+			actuators[i]->act_type) {
+			a_ctrl->func_tbl = &actuators[i]->func_tbl;
+			rc = 0;
+		}
+	}
+
+	if (rc < 0) {
+		pr_err("Actuator function table not found\n");
+		return rc;
+	}
+	if (set_info->af_tuning_params.total_steps
+		>  MAX_ACTUATOR_AF_TOTAL_STEPS) {
+		pr_err("Max actuator totalsteps exceeded = %d\n",
+		set_info->af_tuning_params.total_steps);
+		return -EFAULT;
+	}
+	if (set_info->af_tuning_params.region_size
+		> MAX_ACTUATOR_REGION) {
+		pr_err("MAX_ACTUATOR_REGION is exceeded.\n");
+		return -EFAULT;
+	}
+
+	a_ctrl->region_size = set_info->af_tuning_params.region_size;
+	a_ctrl->pwd_step = set_info->af_tuning_params.pwd_step;
+	a_ctrl->total_steps = set_info->af_tuning_params.total_steps;
+
+	if (copy_from_user(&a_ctrl->region_params,
+		(void *)set_info->af_tuning_params.region_params,
+		a_ctrl->region_size * sizeof(struct region_params_t)))
+		return -EFAULT;
+
+	if (a_ctrl->act_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		cci_client = a_ctrl->i2c_client.cci_client;
+		cci_client->sid =
+			set_info->actuator_params.i2c_addr >> 1;
+		cci_client->retries = 3;
+		cci_client->id_map = 0;
+		cci_client->cci_i2c_master = a_ctrl->cci_master;
+	} else {
+		a_ctrl->i2c_client.client->addr =
+			set_info->actuator_params.i2c_addr;
+	}
+
+	a_ctrl->i2c_data_type = set_info->actuator_params.i2c_data_type;
+	a_ctrl->i2c_client.addr_type = set_info->actuator_params.i2c_addr_type;
+	if (set_info->actuator_params.reg_tbl_size <=
+		MAX_ACTUATOR_REG_TBL_SIZE) {
+		a_ctrl->reg_tbl_size = set_info->actuator_params.reg_tbl_size;
+	} else {
+		a_ctrl->reg_tbl_size = 0;
+		pr_err("MAX_ACTUATOR_REG_TBL_SIZE is exceeded.\n");
+		return -EFAULT;
+	}
+
+	kfree(a_ctrl->i2c_reg_tbl);
+	a_ctrl->i2c_reg_tbl = NULL;
+	a_ctrl->i2c_reg_tbl =
+		kmalloc(sizeof(struct msm_camera_i2c_reg_array) *
+		(set_info->af_tuning_params.total_steps + 1), GFP_KERNEL);
+	if (!a_ctrl->i2c_reg_tbl) {
+		pr_err("kmalloc fail\n");
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(&a_ctrl->reg_tbl,
+		(void *)set_info->actuator_params.reg_tbl_params,
+		a_ctrl->reg_tbl_size *
+		sizeof(struct msm_actuator_reg_params_t))) {
+		kfree(a_ctrl->i2c_reg_tbl);
+		a_ctrl->i2c_reg_tbl = NULL;
+		return -EFAULT;
+	}
+//pr_err("[Mark]init_setting_size=%d", set_info->actuator_params.init_setting_size);
+	if (set_info->actuator_params.init_setting_size &&
+		set_info->actuator_params.init_setting_size
+		<= MAX_ACTUATOR_INIT_SET) {
+		//pr_err("[Mark]before actuator_init_focus\n");
+		if (a_ctrl->func_tbl->actuator_init_focus) {
+			init_settings = kmalloc(sizeof(struct reg_settings_t) *
+				(set_info->actuator_params.init_setting_size),
+				GFP_KERNEL);
+			if (init_settings == NULL) {
+				kfree(a_ctrl->i2c_reg_tbl);
+				a_ctrl->i2c_reg_tbl = NULL;
+				pr_err("Error allocating memory for init_settings\n");
+				return -EFAULT;
+			}
+			if (copy_from_user(init_settings,
+				(void *)set_info->actuator_params.init_settings,
+				set_info->actuator_params.init_setting_size *
+				sizeof(struct reg_settings_t))) {
+				kfree(init_settings);
+				kfree(a_ctrl->i2c_reg_tbl);
+				a_ctrl->i2c_reg_tbl = NULL;
+				pr_err("Error copying init_settings\n");
+				return -EFAULT;
+			}
+			//pr_err("[Mark]before msm_actuator_init_focus\n");
+			rc = a_ctrl->func_tbl->actuator_init_focus(a_ctrl,
+				set_info->actuator_params.init_setting_size,
+				init_settings);
+			kfree(init_settings);
+			if (rc < 0) {
+				kfree(a_ctrl->i2c_reg_tbl);
+				a_ctrl->i2c_reg_tbl = NULL;
+				pr_err("Error actuator_init_focus\n");
+				return -EFAULT;
+			}
+		}
+	}
+
+	/* Park lens data */
+	a_ctrl->park_lens = set_info->actuator_params.park_lens;
+	a_ctrl->initial_code = set_info->af_tuning_params.initial_code;
+	if (a_ctrl->func_tbl->actuator_init_step_table)
+		rc = a_ctrl->func_tbl->
+			actuator_init_step_table(a_ctrl, set_info);
+
+	a_ctrl->curr_step_pos = 0;
+	a_ctrl->curr_region_index = 0;
+	CDBG("Exit\n");
+
+	return rc;
+}
+
+static int msm_actuator_init(struct msm_actuator_ctrl_t *a_ctrl)
+{
+	int rc = 0;
+	CDBG("Enter\n");
+	if (!a_ctrl) {
+		pr_err("failed\n");
+		return -EINVAL;
+	}
+	if (a_ctrl->act_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_util(
+			&a_ctrl->i2c_client, MSM_CCI_INIT);
+		if (rc < 0)
+			pr_err("cci_init failed\n");
+	}
+	CDBG("Exit\n");
+	return rc;
+}
+
+static int32_t msm_actuator_config(struct msm_actuator_ctrl_t *a_ctrl,
+	void __user *argp)
+{
+	struct msm_actuator_cfg_data *cdata =
+		(struct msm_actuator_cfg_data *)argp;
+	int32_t rc = 0;
+	mutex_lock(a_ctrl->actuator_mutex);
+	CDBG("Enter\n");
+	CDBG("%s type %d\n", __func__, cdata->cfgtype);
+	switch (cdata->cfgtype) {
+	case CFG_ACTUATOR_INIT:
+		rc = msm_actuator_init(a_ctrl);
+		if (rc < 0)
+			pr_err("msm_actuator_init failed %d\n", rc);
+		break;
+	case CFG_GET_ACTUATOR_INFO:
+		cdata->is_af_supported = 1;
+		cdata->cfg.cam_name = a_ctrl->cam_name;
+		break;
+
+	case CFG_SET_ACTUATOR_INFO:
+		rc = msm_actuator_set_param(a_ctrl, &cdata->cfg.set_info);
+		rc = close_loop_init(a_ctrl, &cdata->cfg.set_info);
+		if (rc < 0)
+			pr_err("init table failed %d\n", rc);
+		break;
+
+	case CFG_SET_DEFAULT_FOCUS:
+		if(a_ctrl&&a_ctrl->func_tbl){
+            rc = a_ctrl->func_tbl->actuator_set_default_focus(a_ctrl,
+              &cdata->cfg.move);
+            if (rc < 0)
+                pr_err("move focus failed %d\n", rc);
+         }else
+             pr_err("%s:CFG_SET_DEFAULT_FOCUS failed!\n",__func__);
+		break;
+
+	case CFG_MOVE_FOCUS:
+		if(a_ctrl&&a_ctrl->func_tbl){
+			rc = a_ctrl->func_tbl->actuator_move_focus(a_ctrl,
+				&cdata->cfg.move);
+			if (rc < 0)
+				pr_err("move focus failed %d\n", rc);
+		}else
+			pr_err("%s:CFG_MOVE_FOCUS failed!\n",__func__);
+		break;
+	case CFG_ACTUATOR_POWERDOWN:
+		rc = msm_actuator_power_down(a_ctrl);
+		if (rc < 0)
+			pr_err("msm_actuator_power_down failed %d\n", rc);
+		break;
+
+	case CFG_SET_POSITION:
+		if(a_ctrl&&a_ctrl->func_tbl){
+			rc = a_ctrl->func_tbl->actuator_set_position(a_ctrl,
+				&cdata->cfg.setpos);
+			if (rc < 0)
+				pr_err("actuator_set_position failed %d\n", rc);
+		}else
+			pr_err("%s:CFG_SET_POSITION failed!\n",__func__);
+
+		break;
+
+	case CFG_ACTUATOR_POWERUP:
+		rc = msm_actuator_power_up(a_ctrl);
+		if (rc < 0)
+			pr_err("Failed actuator power up%d\n", rc);
+		break;
+/// ALTEK_actuator >>>
+	case CFG_ACTUATOR_SET_BOUNDARY:
+	    rc = close_loop_set_boundary(a_ctrl, &(cdata->cfg.set_boundary));
+		if (rc < 0)
+			pr_err("Failed actuator set boundary %d\n", rc);
+		break;
+/// ALTEK_actuator <<<
+	default:
+		break;
+	}
+	mutex_unlock(a_ctrl->actuator_mutex);
+	CDBG("Exit\n");
+	return rc;
+}
+
+static int32_t msm_actuator_get_subdev_id(struct msm_actuator_ctrl_t *a_ctrl,
+	void *arg)
+{
+	uint32_t *subdev_id = (uint32_t *)arg;
+	CDBG("Enter\n");
+	if (!subdev_id) {
+		pr_err("failed\n");
+		return -EINVAL;
+	}
+	if (a_ctrl->act_device_type == MSM_CAMERA_PLATFORM_DEVICE)
+		*subdev_id = a_ctrl->pdev->id;
+	else
+		*subdev_id = a_ctrl->subdev_id;
+
+	CDBG("subdev_id %d\n", *subdev_id);
+	CDBG("Exit\n");
+	return 0;
+}
+
+static struct msm_camera_i2c_fn_t msm_sensor_cci_func_tbl = {
+	.i2c_read = msm_camera_cci_i2c_read,
+	.i2c_read_seq = msm_camera_cci_i2c_read_seq,
+	.i2c_write = msm_camera_cci_i2c_write,
+	.i2c_write_table = msm_camera_cci_i2c_write_table,
+	.i2c_write_seq_table = msm_camera_cci_i2c_write_seq_table,
+	.i2c_write_table_w_microdelay =
+		msm_camera_cci_i2c_write_table_w_microdelay,
+	.i2c_util = msm_sensor_cci_i2c_util,
+	.i2c_poll =  msm_camera_cci_i2c_poll,
+};
+
+static struct msm_camera_i2c_fn_t msm_sensor_qup_func_tbl = {
+	.i2c_read = msm_camera_qup_i2c_read,
+	.i2c_read_seq = msm_camera_qup_i2c_read_seq,
+	.i2c_write = msm_camera_qup_i2c_write,
+	.i2c_write_table = msm_camera_qup_i2c_write_table,
+	.i2c_write_seq_table = msm_camera_qup_i2c_write_seq_table,
+	.i2c_write_table_w_microdelay =
+		msm_camera_qup_i2c_write_table_w_microdelay,
+	.i2c_poll = msm_camera_qup_i2c_poll,
+};
+
+static int msm_actuator_close(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh) {
+	int rc = 0;
+	struct msm_actuator_ctrl_t *a_ctrl =  v4l2_get_subdevdata(sd);
+	CDBG("Enter\n");
+	if (!a_ctrl) {
+		pr_err("failed\n");
+		return -EINVAL;
+	}
+	if (a_ctrl->act_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_util(
+			&a_ctrl->i2c_client, MSM_CCI_RELEASE);
+		if (rc < 0)
+			pr_err("cci_init failed\n");
+	}
+	kfree(a_ctrl->i2c_reg_tbl);
+	a_ctrl->i2c_reg_tbl = NULL;
+
+	CDBG("Exit\n");
+	return rc;
+}
+
+static const struct v4l2_subdev_internal_ops msm_actuator_internal_ops = {
+	.close = msm_actuator_close,
+};
+
+static long msm_actuator_subdev_ioctl(struct v4l2_subdev *sd,
+			unsigned int cmd, void *arg)
+{
+	struct msm_actuator_ctrl_t *a_ctrl = v4l2_get_subdevdata(sd);
+	void __user *argp = (void __user *)arg;
+	CDBG("Enter\n");
+	CDBG("%s:%d a_ctrl %p argp %p\n", __func__, __LINE__, a_ctrl, argp);
+	switch (cmd) {
+	case VIDIOC_MSM_SENSOR_GET_SUBDEV_ID:
+		return msm_actuator_get_subdev_id(a_ctrl, argp);
+	case VIDIOC_MSM_ACTUATOR_CFG:
+		return msm_actuator_config(a_ctrl, argp);
+	case MSM_SD_SHUTDOWN:
+		msm_actuator_close(sd, NULL);
+		return 0;
+	default:
+		return -ENOIOCTLCMD;
+	}
+}
+
+#ifdef CONFIG_COMPAT
+static long msm_actuator_subdev_do_ioctl(
+	struct file *file, unsigned int cmd, void *arg)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct v4l2_subdev *sd = vdev_to_v4l2_subdev(vdev);
+	struct msm_actuator_cfg_data32 *u32 =
+		(struct msm_actuator_cfg_data32 *)arg;
+	struct msm_actuator_cfg_data actuator_data;
+	void *parg = arg;
+	long rc;
+
+	switch (cmd) {
+	case VIDIOC_MSM_ACTUATOR_CFG32:
+		cmd = VIDIOC_MSM_ACTUATOR_CFG;
+		switch (u32->cfgtype) {
+		case CFG_SET_ACTUATOR_INFO:
+			actuator_data.cfgtype = u32->cfgtype;
+			actuator_data.is_af_supported = u32->is_af_supported;
+			actuator_data.cfg.set_info.actuator_params.act_type =
+				u32->cfg.set_info.actuator_params.act_type;
+
+			actuator_data.cfg.set_info.actuator_params
+				.reg_tbl_size =
+				u32->cfg.set_info.actuator_params.reg_tbl_size;
+
+			actuator_data.cfg.set_info.actuator_params.data_size =
+				u32->cfg.set_info.actuator_params.data_size;
+
+			actuator_data.cfg.set_info.actuator_params
+				.init_setting_size =
+				u32->cfg.set_info.actuator_params
+				.init_setting_size;
+
+			actuator_data.cfg.set_info.actuator_params.i2c_addr =
+				u32->cfg.set_info.actuator_params.i2c_addr;
+
+			actuator_data.cfg.set_info.actuator_params
+				.i2c_addr_type =
+				u32->cfg.set_info.actuator_params.i2c_addr_type;
+
+			actuator_data.cfg.set_info.actuator_params
+				.i2c_data_type =
+				u32->cfg.set_info.actuator_params.i2c_data_type;
+
+			actuator_data.cfg.set_info.actuator_params
+				.reg_tbl_params =
+				compat_ptr(
+				u32->cfg.set_info.actuator_params
+				.reg_tbl_params);
+
+			actuator_data.cfg.set_info.actuator_params
+				.init_settings =
+				compat_ptr(
+				u32->cfg.set_info.actuator_params
+				.init_settings);
+
+			actuator_data.cfg.set_info.af_tuning_params
+				.initial_code =
+				u32->cfg.set_info.af_tuning_params.initial_code;
+
+			actuator_data.cfg.set_info.af_tuning_params.pwd_step =
+				u32->cfg.set_info.af_tuning_params.pwd_step;
+
+			actuator_data.cfg.set_info.af_tuning_params
+				.region_size =
+				u32->cfg.set_info.af_tuning_params.region_size;
+
+			actuator_data.cfg.set_info.af_tuning_params
+				.total_steps =
+				u32->cfg.set_info.af_tuning_params.total_steps;
+
+			actuator_data.cfg.set_info.af_tuning_params
+				.region_params = compat_ptr(
+				u32->cfg.set_info.af_tuning_params
+				.region_params);
+
+			actuator_data.cfg.set_info.actuator_params.park_lens =
+				u32->cfg.set_info.actuator_params.park_lens;
+
+			parg = &actuator_data;
+			break;
+		case CFG_SET_DEFAULT_FOCUS:
+		case CFG_MOVE_FOCUS:
+			actuator_data.cfgtype = u32->cfgtype;
+			actuator_data.is_af_supported = u32->is_af_supported;
+			actuator_data.cfg.move.dir = u32->cfg.move.dir;
+
+			actuator_data.cfg.move.sign_dir =
+				u32->cfg.move.sign_dir;
+
+			actuator_data.cfg.move.dest_step_pos =
+				u32->cfg.move.dest_step_pos;
+
+			actuator_data.cfg.move.num_steps =
+				u32->cfg.move.num_steps;
+
+			actuator_data.cfg.move.curr_lens_pos =
+				u32->cfg.move.curr_lens_pos;
+
+			actuator_data.cfg.move.ringing_params =
+				compat_ptr(u32->cfg.move.ringing_params);
+			parg = &actuator_data;
+			break;
+		case CFG_SET_POSITION:
+			actuator_data.cfgtype = u32->cfgtype;
+			actuator_data.is_af_supported = u32->is_af_supported;
+			memcpy(&actuator_data.cfg.setpos, &(u32->cfg.setpos),
+				sizeof(struct msm_actuator_set_position_t));
+			break;
+/// ALTEK_actuator >>>
+	    case CFG_ACTUATOR_SET_BOUNDARY:
+			actuator_data.cfgtype = u32->cfgtype;
+			actuator_data.is_af_supported = u32->is_af_supported;
+			memcpy(&actuator_data.cfg.set_boundary, &(u32->cfg.set_boundary),
+				sizeof(struct msm_actuator_boundary_t));
+			break;
+/// ALTEK_actuator <<<
+		default:
+			actuator_data.cfgtype = u32->cfgtype;
+			parg = &actuator_data;
+			break;
+		}
+	}
+
+	rc = msm_actuator_subdev_ioctl(sd, cmd, parg);
+
+	switch (cmd) {
+
+	case VIDIOC_MSM_ACTUATOR_CFG:
+
+		switch (u32->cfgtype) {
+
+		case CFG_SET_DEFAULT_FOCUS:
+		case CFG_MOVE_FOCUS:
+			u32->cfg.move.curr_lens_pos =
+				actuator_data.cfg.move.curr_lens_pos;
+			break;
+		default:
+			break;
+		}
+	}
+
+	return rc;
+}
+
+static long msm_actuator_subdev_fops_ioctl(struct file *file, unsigned int cmd,
+	unsigned long arg)
+{
+	return video_usercopy(file, cmd, arg, msm_actuator_subdev_do_ioctl);
+}
+#endif
+
+static int32_t msm_actuator_power_up(struct msm_actuator_ctrl_t *a_ctrl)
+{
+	int rc = 0;
+	CDBG("%s called\n", __func__);
+
+	rc = msm_actuator_vreg_control(a_ctrl, 1);
+	if (rc < 0) {
+		pr_err("%s failed %d\n", __func__, __LINE__);
+		return rc;
+	}
+
+	a_ctrl->actuator_state = ACTUATOR_POWER_UP;
+
+	CDBG("Exit\n");
+	return rc;
+}
+
+static int32_t msm_actuator_power(struct v4l2_subdev *sd, int on)
+{
+	int rc = 0;
+	struct msm_actuator_ctrl_t *a_ctrl = v4l2_get_subdevdata(sd);
+	CDBG("Enter\n");
+	mutex_lock(a_ctrl->actuator_mutex);
+	if (on)
+		rc = msm_actuator_power_up(a_ctrl);
+	else
+		rc = msm_actuator_power_down(a_ctrl);
+	mutex_unlock(a_ctrl->actuator_mutex);
+	CDBG("Exit\n");
+	return rc;
+}
+
+static struct v4l2_subdev_core_ops msm_actuator_subdev_core_ops = {
+	.ioctl = msm_actuator_subdev_ioctl,
+	.s_power = msm_actuator_power,
+};
+
+static struct v4l2_subdev_ops msm_actuator_subdev_ops = {
+	.core = &msm_actuator_subdev_core_ops,
+};
+
+static const struct i2c_device_id msm_actuator_i2c_id[] = {
+	{"qcom,actuator", (kernel_ulong_t)NULL},
+	{ }
+};
+
+static int32_t msm_actuator_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int rc = 0;
+	struct msm_actuator_ctrl_t *act_ctrl_t = NULL;
+	struct msm_actuator_vreg *vreg_cfg = NULL;
+	CDBG("Enter\n");
+
+	if (client == NULL) {
+		pr_err("msm_actuator_i2c_probe: client is null\n");
+		return -EINVAL;
+	}
+
+	act_ctrl_t = kzalloc(sizeof(struct msm_actuator_ctrl_t),
+		GFP_KERNEL);
+	if (!act_ctrl_t) {
+		pr_err("%s:%d failed no memory\n", __func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		pr_err("i2c_check_functionality failed\n");
+		goto probe_failure;
+	}
+
+	CDBG("client = 0x%p\n",  client);
+
+	rc = of_property_read_u32(client->dev.of_node, "cell-index",
+		&act_ctrl_t->subdev_id);
+	CDBG("cell-index %d, rc %d\n", act_ctrl_t->subdev_id, rc);
+	if (rc < 0) {
+		pr_err("failed rc %d\n", rc);
+		goto probe_failure;
+	}
+
+	if (of_find_property(client->dev.of_node,
+		"qcom,cam-vreg-name", NULL)) {
+		vreg_cfg = &act_ctrl_t->vreg_cfg;
+		rc = msm_camera_get_dt_vreg_data(client->dev.of_node,
+			&vreg_cfg->cam_vreg, &vreg_cfg->num_vreg);
+		if (rc < 0) {
+			pr_err("failed rc %d\n", rc);
+			goto probe_failure;
+		}
+	}
+
+	act_ctrl_t->i2c_driver = &msm_actuator_i2c_driver;
+	act_ctrl_t->i2c_client.client = client;
+	act_ctrl_t->curr_step_pos = 0,
+	act_ctrl_t->curr_region_index = 0,
+	act_ctrl_t->actuator_state = ACTUATOR_POWER_DOWN;
+	/* Set device type as I2C */
+	act_ctrl_t->act_device_type = MSM_CAMERA_I2C_DEVICE;
+	act_ctrl_t->i2c_client.i2c_func_tbl = &msm_sensor_qup_func_tbl;
+	act_ctrl_t->act_v4l2_subdev_ops = &msm_actuator_subdev_ops;
+	act_ctrl_t->actuator_mutex = &msm_actuator_mutex;
+	act_ctrl_t->cam_name = act_ctrl_t->subdev_id;
+	CDBG("act_ctrl_t->cam_name: %d", act_ctrl_t->cam_name);
+	/* Assign name for sub device */
+	snprintf(act_ctrl_t->msm_sd.sd.name, sizeof(act_ctrl_t->msm_sd.sd.name),
+		"%s", act_ctrl_t->i2c_driver->driver.name);
+
+	/* Initialize sub device */
+	v4l2_i2c_subdev_init(&act_ctrl_t->msm_sd.sd,
+		act_ctrl_t->i2c_client.client,
+		act_ctrl_t->act_v4l2_subdev_ops);
+	v4l2_set_subdevdata(&act_ctrl_t->msm_sd.sd, act_ctrl_t);
+	act_ctrl_t->msm_sd.sd.internal_ops = &msm_actuator_internal_ops;
+	act_ctrl_t->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	media_entity_init(&act_ctrl_t->msm_sd.sd.entity, 0, NULL, 0);
+	act_ctrl_t->msm_sd.sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV;
+	act_ctrl_t->msm_sd.sd.entity.group_id = MSM_CAMERA_SUBDEV_ACTUATOR;
+	act_ctrl_t->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x2;
+	msm_sd_register(&act_ctrl_t->msm_sd);
+	msm_actuator_v4l2_subdev_fops = v4l2_subdev_fops;
+
+#ifdef CONFIG_COMPAT
+	msm_actuator_v4l2_subdev_fops.compat_ioctl32 =
+		msm_actuator_subdev_fops_ioctl;
+#endif
+	act_ctrl_t->msm_sd.sd.devnode->fops =
+		&msm_actuator_v4l2_subdev_fops;
+
+	pr_info("msm_actuator_i2c_probe: succeeded\n");
+	CDBG("Exit\n");
+
+	return 0;
+
+probe_failure:
+	kfree(act_ctrl_t);
+	return rc;
+}
+
+static int32_t msm_actuator_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	struct msm_camera_cci_client *cci_client = NULL;
+	struct msm_actuator_ctrl_t *msm_actuator_t = NULL;
+	struct msm_actuator_vreg *vreg_cfg;
+	CDBG("Enter\n");
+
+	if (!pdev->dev.of_node) {
+		pr_err("of_node NULL\n");
+		return -EINVAL;
+	}
+
+	msm_actuator_t = kzalloc(sizeof(struct msm_actuator_ctrl_t),
+		GFP_KERNEL);
+	if (!msm_actuator_t) {
+		pr_err("%s:%d failed no memory\n", __func__, __LINE__);
+		return -ENOMEM;
+	}
+	rc = of_property_read_u32((&pdev->dev)->of_node, "cell-index",
+		&pdev->id);
+	CDBG("cell-index %d, rc %d\n", pdev->id, rc);
+	if (rc < 0) {
+		kfree(msm_actuator_t);
+		pr_err("failed rc %d\n", rc);
+		return rc;
+	}
+
+	rc = of_property_read_u32((&pdev->dev)->of_node, "qcom,cci-master",
+		&msm_actuator_t->cci_master);
+	CDBG("qcom,cci-master %d, rc %d\n", msm_actuator_t->cci_master, rc);
+	if (rc < 0) {
+		kfree(msm_actuator_t);
+		pr_err("failed rc %d\n", rc);
+		return rc;
+	}
+
+	if (of_find_property((&pdev->dev)->of_node,
+			"qcom,cam-vreg-name", NULL)) {
+		vreg_cfg = &msm_actuator_t->vreg_cfg;
+		rc = msm_camera_get_dt_vreg_data((&pdev->dev)->of_node,
+			&vreg_cfg->cam_vreg, &vreg_cfg->num_vreg);
+		if (rc < 0) {
+			kfree(msm_actuator_t);
+			pr_err("failed rc %d\n", rc);
+			return rc;
+		}
+	}
+
+	msm_actuator_t->act_v4l2_subdev_ops = &msm_actuator_subdev_ops;
+	msm_actuator_t->actuator_mutex = &msm_actuator_mutex;
+	msm_actuator_t->cam_name = pdev->id;
+
+	/* Set platform device handle */
+	msm_actuator_t->pdev = pdev;
+	/* Set device type as platform device */
+	msm_actuator_t->act_device_type = MSM_CAMERA_PLATFORM_DEVICE;
+	msm_actuator_t->i2c_client.i2c_func_tbl = &msm_sensor_cci_func_tbl;
+	msm_actuator_t->i2c_client.cci_client = kzalloc(sizeof(
+		struct msm_camera_cci_client), GFP_KERNEL);
+	if (!msm_actuator_t->i2c_client.cci_client) {
+		kfree(msm_actuator_t->vreg_cfg.cam_vreg);
+		kfree(msm_actuator_t);
+		pr_err("failed no memory\n");
+		return -ENOMEM;
+	}
+
+	cci_client = msm_actuator_t->i2c_client.cci_client;
+	cci_client->cci_subdev = msm_cci_get_subdev();
+	cci_client->cci_i2c_master = MASTER_MAX;
+	v4l2_subdev_init(&msm_actuator_t->msm_sd.sd,
+		msm_actuator_t->act_v4l2_subdev_ops);
+	v4l2_set_subdevdata(&msm_actuator_t->msm_sd.sd, msm_actuator_t);
+	msm_actuator_t->msm_sd.sd.internal_ops = &msm_actuator_internal_ops;
+	msm_actuator_t->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	snprintf(msm_actuator_t->msm_sd.sd.name,
+		ARRAY_SIZE(msm_actuator_t->msm_sd.sd.name), "msm_actuator");
+	media_entity_init(&msm_actuator_t->msm_sd.sd.entity, 0, NULL, 0);
+	msm_actuator_t->msm_sd.sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV;
+	msm_actuator_t->msm_sd.sd.entity.group_id = MSM_CAMERA_SUBDEV_ACTUATOR;
+	msm_actuator_t->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x2;
+	msm_sd_register(&msm_actuator_t->msm_sd);
+	msm_actuator_t->actuator_state = ACTUATOR_POWER_DOWN;
+	msm_actuator_v4l2_subdev_fops = v4l2_subdev_fops;
+#ifdef CONFIG_COMPAT
+	msm_actuator_v4l2_subdev_fops.compat_ioctl32 =
+		msm_actuator_subdev_fops_ioctl;
+#endif
+	msm_actuator_t->msm_sd.sd.devnode->fops =
+		&msm_actuator_v4l2_subdev_fops;
+
+	CDBG("Exit\n");
+	return rc;
+}
+
+static const struct of_device_id msm_actuator_i2c_dt_match[] = {
+	{.compatible = "qcom,actuator"},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, msm_actuator_i2c_dt_match);
+
+static struct i2c_driver msm_actuator_i2c_driver = {
+	.id_table = msm_actuator_i2c_id,
+	.probe  = msm_actuator_i2c_probe,
+	.remove = __exit_p(msm_actuator_i2c_remove),
+	.driver = {
+		.name = "qcom,actuator",
+		.owner = THIS_MODULE,
+		.of_match_table = msm_actuator_i2c_dt_match,
+	},
+};
+
+static const struct of_device_id msm_actuator_dt_match[] = {
+	{.compatible = "qcom,actuator", .data = NULL},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, msm_actuator_dt_match);
+
+static struct platform_driver msm_actuator_platform_driver = {
+	.driver = {
+		.name = "qcom,actuator",
+		.owner = THIS_MODULE,
+		.of_match_table = msm_actuator_dt_match,
+	},
+};
+
+static int __init msm_actuator_init_module(void)
+{
+	int32_t rc = 0;
+	CDBG("Enter\n");
+	rc = platform_driver_probe(&msm_actuator_platform_driver,
+		msm_actuator_platform_probe);
+	if (!rc)
+		return rc;
+
+	CDBG("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&msm_actuator_i2c_driver);
+}
+
+static struct msm_actuator msm_vcm_actuator_table = {
+	.act_type = ACTUATOR_VCM,
+	.func_tbl = {
+		.actuator_init_step_table = msm_actuator_init_step_table,
+		.actuator_move_focus = msm_actuator_move_focus,
+		.actuator_write_focus = msm_actuator_write_focus,
+		.actuator_set_default_focus = msm_actuator_set_default_focus,
+		.actuator_init_focus = msm_actuator_init_focus,
+		.actuator_parse_i2c_params = msm_actuator_parse_i2c_params,
+		.actuator_set_position = msm_actuator_set_position,
+		.actuator_park_lens = msm_actuator_park_lens,
+	},
+};
+
+static struct msm_actuator msm_piezo_actuator_table = {
+	.act_type = ACTUATOR_PIEZO,
+	.func_tbl = {
+		.actuator_init_step_table = NULL,
+		.actuator_move_focus = msm_actuator_piezo_move_focus,
+		.actuator_write_focus = NULL,
+		.actuator_set_default_focus =
+			msm_actuator_piezo_set_default_focus,
+		.actuator_init_focus = msm_actuator_init_focus,
+		.actuator_parse_i2c_params = msm_actuator_parse_i2c_params,
+		.actuator_park_lens = NULL,
+	},
+};
+
+static struct msm_actuator msm_close_loop_actuator_table = {
+			    .act_type = ACTUATOR_CLOSE_LOOP,
+			    .func_tbl = {
+			        .actuator_init_step_table = msm_actuator_init_step_table,
+			        .actuator_move_focus = close_loop_move_focus,
+			        .actuator_write_focus = msm_actuator_write_focus,
+			        .actuator_set_default_focus = close_loop_set_default_focus,
+			        .actuator_init_focus = msm_actuator_init_focus,
+			        .actuator_parse_i2c_params = msm_actuator_parse_i2c_params,
+/// ALTEK_actuator >>>
+			        .actuator_set_position = close_loop_set_position,
+/// ALTEK_actuator <<<
+      },
+};
+
+module_init(msm_actuator_init_module);
+MODULE_DESCRIPTION("MSM ACTUATOR");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator_altek.h b/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator_altek.h
new file mode 100755
index 00000000000..ddb6d095994
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/actuator/msm_actuator_altek.h
@@ -0,0 +1,133 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef MSM_ACTUATOR_H
+#define MSM_ACTUATOR_H
+
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <soc/qcom/camera2.h>
+#include <media/v4l2-subdev.h>
+#include <media/msmb_camera.h>
+#include "msm_camera_i2c.h"
+#include "msm_camera_dt_util.h"
+#include "msm_camera_io_util.h"
+#include "lc898212axb_AfDef.h"
+
+
+#define DEFINE_MSM_MUTEX(mutexname) \
+	static struct mutex mutexname = __MUTEX_INITIALIZER(mutexname)
+
+#define	MSM_ACTUATOT_MAX_VREGS (10)
+
+struct msm_actuator_ctrl_t;
+static  stSmvPar StSmvPar;
+
+enum msm_actuator_state_t {
+	ACTUATOR_POWER_UP,
+	ACTUATOR_POWER_DOWN,
+};
+
+struct msm_actuator_func_tbl {
+	int32_t (*actuator_i2c_write_b_af)(struct msm_actuator_ctrl_t *,
+			uint8_t,
+			uint8_t);
+	int32_t (*actuator_init_step_table)(struct msm_actuator_ctrl_t *,
+		struct msm_actuator_set_info_t *);
+	int32_t (*actuator_init_focus)(struct msm_actuator_ctrl_t *,
+		uint16_t, struct reg_settings_t *);
+	int32_t (*actuator_set_default_focus) (struct msm_actuator_ctrl_t *,
+			struct msm_actuator_move_params_t *);
+	int32_t (*actuator_move_focus) (struct msm_actuator_ctrl_t *,
+			struct msm_actuator_move_params_t *);
+	void (*actuator_parse_i2c_params)(struct msm_actuator_ctrl_t *,
+			int16_t, uint32_t, uint16_t);
+	void (*actuator_write_focus)(struct msm_actuator_ctrl_t *,
+			uint16_t,
+			struct damping_params_t *,
+			int8_t,
+			int16_t);
+	int32_t (*actuator_set_position)(struct msm_actuator_ctrl_t *,
+		struct msm_actuator_set_position_t *);
+	int32_t (*actuator_park_lens)(struct msm_actuator_ctrl_t *);
+/// ALTEK_actuator >>>
+	int32_t (*actuator_set_boundary)(struct msm_actuator_ctrl_t *,
+									 struct msm_actuator_boundary_t *);
+/// ALTEK_actuator <<<
+};
+
+struct msm_actuator {
+	enum actuator_type act_type;
+	struct msm_actuator_func_tbl func_tbl;
+};
+
+struct msm_actuator_vreg {
+	struct camera_vreg_t *cam_vreg;
+	void *data[MSM_ACTUATOT_MAX_VREGS];
+	int num_vreg;
+};
+
+struct msm_actuator_ctrl_t {
+	struct i2c_driver *i2c_driver;
+	struct platform_driver *pdriver;
+	struct platform_device *pdev;
+	struct msm_camera_i2c_client i2c_client;
+	enum msm_camera_device_type_t act_device_type;
+	struct msm_sd_subdev msm_sd;
+	enum af_camera_name cam_name;
+	struct mutex *actuator_mutex;
+	struct msm_actuator_func_tbl *func_tbl;
+	enum msm_actuator_data_type i2c_data_type;
+	struct v4l2_subdev sdev;
+	struct v4l2_subdev_ops *act_v4l2_subdev_ops;
+
+	int16_t curr_step_pos;
+	uint16_t curr_region_index;
+	uint16_t *step_position_table;
+	struct region_params_t region_params[MAX_ACTUATOR_REGION];
+	uint16_t reg_tbl_size;
+	struct msm_actuator_reg_params_t reg_tbl[MAX_ACTUATOR_REG_TBL_SIZE];
+	uint16_t region_size;
+	void *user_data;
+	uint32_t total_steps;
+	uint16_t pwd_step;
+	uint16_t initial_code;
+	struct msm_camera_i2c_reg_array *i2c_reg_tbl;
+	uint16_t i2c_tbl_index;
+	enum cci_i2c_master_t cci_master;
+	uint32_t subdev_id;
+	enum msm_actuator_state_t actuator_state;
+	struct msm_actuator_vreg vreg_cfg;
+	struct park_lens_data_t park_lens;
+	uint32_t max_code_size;
+};
+
+void close_loop_StmvSet(struct msm_actuator_ctrl_t *a_ctrl, stSmvPar StSetSmv);
+			void close_loop_ServoOn(struct msm_actuator_ctrl_t *a_ctrl);
+			void close_loop_WaitTime(uint16_t msec);
+			void close_loop_RegReadA(struct msm_actuator_ctrl_t *a_ctrl,
+			        uint16_t addr, uint16_t *data);
+			void close_loop_RegWriteA(struct msm_actuator_ctrl_t *a_ctrl,
+			        uint16_t addr, uint16_t data);
+			void close_loop_RamReadA(struct msm_actuator_ctrl_t *a_ctrl,
+			        uint16_t addr, uint16_t *data);
+			void close_loop_RamWriteA(struct msm_actuator_ctrl_t *a_ctrl,
+			        uint16_t addr, uint16_t data);
+			uint16_t close_loop_StmvEnd(struct msm_actuator_ctrl_t *a_ctrl,
+			        uint16_t UcParMod);
+			uint16_t close_loop_StmvTo(struct msm_actuator_ctrl_t *a_ctrl, uint16_t SsSmvEnd);
+			uint16_t close_loop_init(struct msm_actuator_ctrl_t *a_ctrl,
+			        struct msm_actuator_set_info_t *set_info);
+			static int32_t close_loop_move_focus(struct msm_actuator_ctrl_t *a_ctrl,
+			        struct msm_actuator_move_params_t *move_params);
+			uint16_t close_loop_AF_convert(uint16_t position);
+
+#endif
diff --git a/drivers/media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c b/drivers/media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c
index fc6fc5a252d..cd2f8498544 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c
@@ -855,6 +855,16 @@ static int eeprom_config_read_cal_data32(struct msm_eeprom_ctrl_t *e_ctrl,
 	rc = copy_to_user(ptr_dest, e_ctrl->cal_data.mapdata,
 		cdata.cfg.read_data.num_bytes);
 
+	/* should only be called once.  free kernel resource */
+//remove it. when mm-qcamera-daemon crash,we can open camera apk again. by pengliu 20150514
+/*
+	if (!rc) {
+		kfree(e_ctrl->cal_data.mapdata);
+		kfree(e_ctrl->cal_data.map);
+		memset(&e_ctrl->cal_data, 0, sizeof(e_ctrl->cal_data));
+	}
+*/
+//remove end
 	return rc;
 }
 
diff --git a/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_flash.h b/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_flash.h
index 9edc6b02103..a960d64a0a4 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_flash.h
+++ b/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_flash.h
@@ -61,6 +61,7 @@ struct msm_led_flash_ctrl_t {
 	struct led_trigger *torch_trigger[MAX_LED_TRIGGERS];
 	uint32_t torch_num_sources;
 	uint32_t torch_op_current[MAX_LED_TRIGGERS];
+	uint32_t pre_op_current[MAX_LED_TRIGGERS];
 	uint32_t torch_max_current[MAX_LED_TRIGGERS];
 
 	void *data;
diff --git a/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_trigger.c b/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_trigger.c
index ee4e6543bf5..0a2c66f7d9d 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_trigger.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_trigger.c
@@ -82,6 +82,15 @@ static int32_t msm_led_trigger_config(struct msm_led_flash_ctrl_t *fctrl,
 						curr_l);
 			}
 		break;
+    case MSM_CAMERA_LED_PRE:
+		for (i = 0; i < fctrl->torch_num_sources; i++)
+			if (fctrl->torch_trigger[i]) {
+				max_curr_l = fctrl->torch_max_current[i];
+				curr_l = fctrl->pre_op_current[i];
+				pr_debug("LED pre %d clamped %d\n",i, curr_l);
+				led_trigger_event(fctrl->torch_trigger[i],curr_l);
+			}
+		break;
 
 	case MSM_CAMERA_LED_HIGH:
 		/* Torch off */
@@ -274,6 +283,7 @@ static int32_t msm_led_trigger_probe(struct platform_device *pdev)
 			if (flashtype == GPIO_FLASH) {
 				/* use fake current */
 				fctrl.torch_op_current[i] = LED_HALF;
+				fctrl.pre_op_current[i] = LED_PRE;
 			} else {
 				rc = of_property_read_u32(flash_src_node,
 					"qcom,current",
diff --git a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c
index a6dd834da83..3b2bd562d8e 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor.c
@@ -21,6 +21,14 @@
 #undef CDBG
 #define CDBG(fmt, args...) pr_debug(fmt, ##args)
 
+
+static uint32_t g_camera_id = 0;   /*main 0 sub 1*/
+
+uint32_t get_camera_id(void)
+{
+    return g_camera_id;
+}
+
 static struct v4l2_file_operations msm_sensor_v4l2_subdev_fops;
 static void msm_sensor_adjust_mclk(struct msm_camera_power_ctrl_t *ctrl)
 {
@@ -455,6 +463,14 @@ int msm_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl)
 	slave_info = s_ctrl->sensordata->slave_info;
 	sensor_name = s_ctrl->sensordata->sensor_name;
 
+	if(!strcmp(sensor_name, "imx214_br")){
+		if(!strcmp(power_info->cam_vreg->reg_name, "cam_vdig")){
+			power_info->cam_vreg->min_voltage = 1000000;
+			power_info->cam_vreg->max_voltage = 1000000;
+			pr_err("msm_sensor_power_up:set imx214_br->cam_vdig to 1000000\n");
+		}
+	}
+
 	if (!power_info || !sensor_i2c_client || !slave_info ||
 		!sensor_name) {
 		pr_err("%s:%d failed: %p %p %p %p\n",
@@ -492,7 +508,12 @@ int msm_sensor_match_id(struct msm_sensor_ctrl_t *s_ctrl)
 	struct msm_camera_i2c_client *sensor_i2c_client;
 	struct msm_camera_slave_info *slave_info;
 	const char *sensor_name;
-
+    //Jelly add for s5k5e2 compatibale
+    #ifdef CONFIG_TEST_ONLY
+	uint16_t i=0,eepromMid = 0, eepromRmid = 0, eepromData;
+	uint32_t eepromAddr;
+    #endif
+    //endif
 	if (!s_ctrl) {
 		pr_err("%s:%d failed: %p\n",
 			__func__, __LINE__, s_ctrl);
@@ -519,10 +540,118 @@ int msm_sensor_match_id(struct msm_sensor_ctrl_t *s_ctrl)
 
 	CDBG("%s: read id: 0x%x expected id 0x%x:\n", __func__, chipid,
 		slave_info->sensor_id);
+	
+	
 	if (chipid != slave_info->sensor_id) {
 		pr_err("msm_sensor_match_id chip id doesnot match\n");
+		//Jelly  added for FFBM test failed workaround 
+		pr_err("%s: read id: 0x%x expected id 0x%x:\n", __func__, chipid,
+		slave_info->sensor_id);
+		pr_err("%s: sensor_id_reg_addr: 0x%x sensor_slave_addr 0x%x:\n", __func__,
+		slave_info->sensor_id_reg_addr,slave_info->sensor_slave_addr);
+		if(s_ctrl->is_probe_succeed == 1)
+		{
+		  pr_err("Skip the match error!!Already probe succees !!!!!!!!!!\n");
+		}else
+		//end
 		return -ENODEV;
 	}
+    //Jelly add for s5k5e2 compatibale
+    #ifdef CONFIG_TEST_ONLY
+	if(!strcmp(sensor_name, "s5k5e2_SFS5C7597") || !strcmp(sensor_name, "s5k5e2_F5E2YAU")){
+		eepromMid = s_ctrl->sensordata->eeprom_mid;
+
+		for(i=0; i<s_ctrl->sensordata->eeprom_mid_addr_cnt;){
+			/* make initial state */
+			eepromAddr = 0x0A00;
+			eepromData = 0x04;
+			rc = sensor_i2c_client->i2c_func_tbl->i2c_write(
+					sensor_i2c_client, eepromAddr,
+					eepromData, MSM_CAMERA_I2C_BYTE_DATA);
+			if (rc < 0) {
+				pr_err("%s: %s: read mid failed\n", __func__, sensor_name);
+				return rc;
+			}
+			mdelay(1);
+
+			/* set the PAGE number of OTP(0 = the number of PAGE = 15) */
+			eepromAddr = 0x0A02;
+			eepromData = s_ctrl->sensordata->eeprom_mid_addr[i++];
+			rc = sensor_i2c_client->i2c_func_tbl->i2c_write(
+					sensor_i2c_client, eepromAddr,
+					eepromData, MSM_CAMERA_I2C_BYTE_DATA);
+			if (rc < 0) {
+				pr_err("%s: %s: read mid failed\n", __func__, sensor_name);
+				return rc;
+			}
+			mdelay(1);
+
+			/* set read mode of NVM controller Interface1 */
+			eepromAddr = 0x0A00;
+			eepromData = 0x01;
+			rc = sensor_i2c_client->i2c_func_tbl->i2c_write(
+					sensor_i2c_client, eepromAddr,
+					eepromData, MSM_CAMERA_I2C_BYTE_DATA);
+			if (rc < 0) {
+				pr_err("%s: %s: read mid failed\n", __func__, sensor_name);
+				return rc;
+			}
+			mdelay(1);
+
+			/* read eeprom module id */
+			rc = sensor_i2c_client->i2c_func_tbl->i2c_read(
+					sensor_i2c_client, s_ctrl->sensordata->eeprom_mid_addr[i++],
+					&eepromRmid, MSM_CAMERA_I2C_BYTE_DATA);
+			if (rc < 0) {
+				pr_err("%s: %s: read mid failed\n", __func__, sensor_name);
+				return rc;
+			}
+
+			pr_err("<eeprom_mid_match> eepromRmid:0x%02x, eepromPage:%d, eepromAddr:0x%04x\n",
+				eepromRmid,
+				s_ctrl->sensordata->eeprom_mid_addr[i-2],
+				s_ctrl->sensordata->eeprom_mid_addr[i-1]);
+
+			/* if match, stop loop */
+			if(eepromRmid == eepromMid){
+				break;
+			}
+		}
+
+		/* make initial state */
+		eepromAddr = 0x0A00;
+		eepromData = 0x04;
+		rc = sensor_i2c_client->i2c_func_tbl->i2c_write(
+				sensor_i2c_client, eepromAddr,
+				eepromData, MSM_CAMERA_I2C_BYTE_DATA);
+		if (rc < 0) {
+			pr_err("%s: %s: read mid failed\n", __func__, sensor_name);
+			return rc;
+		}
+		mdelay(1);
+
+		/* disable NVM controller */
+		eepromAddr = 0x0A00;
+		eepromData = 0x00;
+		rc = sensor_i2c_client->i2c_func_tbl->i2c_write(
+				sensor_i2c_client, eepromAddr,
+				eepromData, MSM_CAMERA_I2C_BYTE_DATA);
+		if (rc < 0) {
+			pr_err("%s: %s: read mid failed\n", __func__, sensor_name);
+			return rc;
+		}
+		mdelay(1);
+
+		if(eepromRmid == eepromMid){
+			pr_err("<eeprom_mid_match> sensor %s match expected eeprom mid:0x%02x success\n", sensor_name, eepromMid);
+			return 0;
+		} else {
+			pr_err("<eeprom_mid_match> sensor %s match expected eeprom mid:0x%02x failed\n", sensor_name, eepromMid);
+			return -ENODEV;
+		}
+	}
+	#endif
+	//end
 	return rc;
 }
 
@@ -613,8 +742,8 @@ static int msm_sensor_config32(struct msm_sensor_ctrl_t *s_ctrl,
 	int32_t rc = 0;
 	int32_t i = 0;
 	mutex_lock(s_ctrl->msm_sensor_mutex);
-	CDBG("%s:%d %s cfgtype = %d\n", __func__, __LINE__,
-		s_ctrl->sensordata->sensor_name, cdata->cfgtype);
+	CDBG("%s:%d %s cfgtype = %d,session_id = %d\n", __func__, __LINE__,
+		s_ctrl->sensordata->sensor_name, cdata->cfgtype,s_ctrl->sensordata->sensor_info->session_id);
 	switch (cdata->cfgtype) {
 	case CFG_GET_SENSOR_INFO:
 		memcpy(cdata->cfg.sensor_info.sensor_name,
@@ -831,6 +960,10 @@ static int msm_sensor_config32(struct msm_sensor_ctrl_t *s_ctrl,
 	}
 
 	case CFG_POWER_UP:
+		g_camera_id = s_ctrl->sensordata->cam_slave_info->camera_id;
+			//CDBG("pengliu g_camaera_id = %d\n",g_camera_id);
+			pr_err("pengliu g_camaera_id = %d\n",g_camera_id);//jelly added for debug
+
 		if (s_ctrl->sensor_state != MSM_SENSOR_POWER_DOWN) {
 			pr_err("%s:%d failed: invalid state %d\n", __func__,
 				__LINE__, s_ctrl->sensor_state);
diff --git a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_driver.c b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_driver.c
index c93e165a0ec..ab21ae2d0b9 100755
--- a/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_driver.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/msm_sensor_driver.c
@@ -165,6 +165,12 @@ static int32_t msm_sensor_fill_eeprom_subdevid_by_name(
 	struct  msm_sensor_info_t *sensor_info;
 	struct device_node *of_node = s_ctrl->of_node;
 	const void *p;
+    //Jelly add for s5k5e2 compatibale
+	#ifdef CONFIG_TEST_ONLY
+	int32_t eeprom_mid=0;
+	uint32_t cnt = 0;
+	#endif
+	//end
 
 	if (!s_ctrl->sensordata->eeprom_name || !of_node)
 		return -EINVAL;
@@ -193,6 +199,12 @@ static int32_t msm_sensor_fill_eeprom_subdevid_by_name(
 	count /= sizeof(uint32_t);
 	for (i = 0; i < count; i++) {
 		eeprom_name = NULL;
+        //Jelly add for s5k5e2 compatibale
+	    #ifdef CONFIG_TEST_ONLY
+		eeprom_mid=0;
+		cnt = 0;
+	    #endif
+		//end
 		src_node = of_parse_phandle(of_node, "qcom,eeprom-src", i);
 		if (!src_node) {
 			pr_err("eeprom src node NULL\n");
@@ -217,6 +229,29 @@ static int32_t msm_sensor_fill_eeprom_subdevid_by_name(
 			of_node_put(src_node);
 			continue;
 		}
+         //Jelly add for s5k5e2 compatibale
+	    #ifdef CONFIG_TEST_ONLY
+		if(of_get_property(src_node, "qcom,mid-addr", &cnt)){
+			cnt /= sizeof(uint32_t);
+			s_ctrl->sensordata->eeprom_mid_addr_cnt = cnt;
+			rc = of_property_read_u32_array(src_node, "qcom,mid-addr", s_ctrl->sensordata->eeprom_mid_addr, cnt);
+			if (rc < 0) {
+				pr_err("<eeprom_mid_match> get addr is error\n");
+			}
+			pr_err("<eeprom_mid_match> eeprom mid page and addr pair in dts:\nPage\tAddr\n");
+			for(i=0; i<cnt; i+=2){
+				pr_err("%d\t0x%04x\n", s_ctrl->sensordata->eeprom_mid_addr[i], s_ctrl->sensordata->eeprom_mid_addr[i+1]);
+			}
+
+			rc = of_property_read_u32(src_node, "qcom,mid", &eeprom_mid);
+			if(rc < 0){
+				pr_err("<eeprom_mid_match> get mid is error\n");
+			}
+			s_ctrl->sensordata->eeprom_mid = eeprom_mid;
+			pr_err("<eeprom_mid_match> eeprom mid in dts:0x%02x\n", s_ctrl->sensordata->eeprom_mid);
+		}
+		#endif
+		//end
 
 		*eeprom_subdev_id = val;
 		CDBG("Done. Eeprom subdevice id is %d\n", val);
@@ -626,6 +661,30 @@ static void msm_sensor_fill_sensor_info(struct msm_sensor_ctrl_t *s_ctrl,
 	strlcpy(entity_name, s_ctrl->msm_sd.sd.entity.name, MAX_SENSOR_NAME);
 }
 
+//hongjie.zhao add for camera info sysfile
+static struct class *camera_class = NULL;
+char *main_camera_info = NULL;
+char *sub_camera_info = NULL;
+
+static ssize_t main_camera_info_show(struct class *class,
+				     struct class_attribute *attr, char *buf)
+{
+    if (main_camera_info != NULL)
+	return snprintf(buf, 32, "%s\n", main_camera_info);
+    return 0;
+}
+
+static ssize_t sub_camera_info_show(struct class *class,
+				     struct class_attribute *attr, char *buf)
+{
+    if (sub_camera_info != NULL)
+	return snprintf(buf, 32, "%s\n", sub_camera_info);
+    return 0;
+}
+static CLASS_ATTR(main_camera_info, 0644, main_camera_info_show, NULL);
+static CLASS_ATTR(sub_camera_info, 0644, sub_camera_info_show, NULL);
+//hongjie.zhao add end
+
 /* static function definition */
 int32_t msm_sensor_driver_is_special_support(
 	struct msm_sensor_ctrl_t *s_ctrl,
@@ -905,6 +964,21 @@ int32_t msm_sensor_driver_probe(void *setting,
 
 	pr_err("%s probe succeeded", slave_info->sensor_name);
 
+	/*
+	  Set probe succeeded flag to 1 so that no other camera shall
+	 * probed on this slot
+	 */
+	s_ctrl->is_probe_succeed = 1;
+        //hongjie.zhao add for camera info sysfile
+        if (slave_info->camera_id == 0)
+        {
+            main_camera_info = slave_info->sensor_name;
+        }
+        if (slave_info->camera_id == 1)
+        {
+            sub_camera_info = slave_info->sensor_name;
+        }
+        //hongjie.zhao add end
 	/*
 	 * Update the subdevice id of flash-src based on availability in kernel.
 	 */
@@ -1370,6 +1444,13 @@ static int __init msm_sensor_driver_init(void)
 {
 	int32_t rc = 0;
 
+        //hongjie.zhao add for camera info sysfile
+        int sys_ret = 0;
+	camera_class = class_create(THIS_MODULE, "camera");
+	if (IS_ERR(camera_class))
+		return PTR_ERR(camera_class);
+        sys_ret = class_create_file(camera_class, &class_attr_main_camera_info);
+        sys_ret = class_create_file(camera_class, &class_attr_sub_camera_info);
 	CDBG("Enter");
 	rc = platform_driver_probe(&msm_sensor_platform_driver,
 		msm_sensor_driver_platform_probe);
@@ -1390,6 +1471,9 @@ static void __exit msm_sensor_driver_exit(void)
 	CDBG("Enter");
 	platform_driver_unregister(&msm_sensor_platform_driver);
 	i2c_del_driver(&msm_sensor_driver_i2c);
+        class_remove_file(camera_class, &class_attr_main_camera_info);
+        class_remove_file(camera_class, &class_attr_sub_camera_info);
+        class_destroy(camera_class);
 	return;
 }
 
diff --git a/drivers/media/platform/msm/camera_v2/sensor/ov2685.c b/drivers/media/platform/msm/camera_v2/sensor/ov2685.c
new file mode 100755
index 00000000000..351b1db81c6
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/ov2685.c
@@ -0,0 +1,2171 @@
+/* Copyritht (C) 2013 Intrinsyc Software International Inc.
+ * Copyright (c) 2011-2013, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "msm_sensor.h"
+#include "msm_cci.h"
+#include "msm_camera_io_util.h"
+#include "msm.h"
+#define OV2685_SENSOR_NAME "ov2685"
+#define PLATFORM_DRIVER_NAME "msm_camera_ov2685"
+#define ov2685_obj ov2685_##obj
+#define CONFIG_MSMB_CAMERA_DEBUG
+#undef CDBG
+#ifdef CONFIG_MSMB_CAMERA_DEBUG
+#define CDBG(fmt, args...) pr_debug(fmt, ##args)
+#else
+#define CDBG(fmt, args...) do { } while (0)
+#endif
+
+extern char* saved_command_line;
+static u8 ov2685_ffbm_mode = 0;
+
+DEFINE_MUTEX(ov2685_mut);
+static struct msm_sensor_ctrl_t ov2685_s_ctrl;
+static struct class *camera_class = NULL;
+char slave_camera_info[7] = OV2685_SENSOR_NAME;
+
+static ssize_t slave_camera_info_show(struct class *class,
+                     struct class_attribute *attr, char *buf){
+	if (slave_camera_info != NULL)
+		return snprintf(buf, 32, "%s\n", slave_camera_info);
+	return 0;
+}
+static CLASS_ATTR(slave_camera_info, 0644, slave_camera_info_show, NULL);
+
+static struct msm_sensor_power_setting ov2685_power_setting[] = {
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 1,
+	},
+
+    {
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VANA,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VANA,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 1,
+	},
+
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 1,
+	},
+
+
+/*
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VANA,
+		.config_val = 0,
+		.delay = 1,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VDIG,
+		.config_val = 0,
+		.delay = 1,
+	},
+*/
+	/*{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VAF,
+		.config_val = 0,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_VDIG,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 5,
+	},*/
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_STANDBY,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 10,
+	},
+/*
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 10,
+	},
+*/
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 10,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct msm_camera_i2c_reg_conf ov2685_start_settings[] = {
+	{0x0100, 0x01},
+};
+
+static struct msm_camera_i2c_reg_conf ov2685_stop_settings[] = {
+	{0x0100, 0x00},
+};
+
+/// ALTEK_IQM >>>
+static struct msm_camera_i2c_reg_conf ov2685_hw_frame_sync_settings[] = {
+    {0x3826, 0x05}, // r, calibrated by Altek, 11us, n=0x0610-0x05d4=60
+    {0x3827, 0xd4},
+
+};
+/// ALTEK_IQM <<<
+
+static struct msm_camera_i2c_reg_conf ov2685_1600x1200p30_ffbm_settings[] = {
+	{0x0103 , 0x01},
+	{0x3002 , 0x00},
+	{0x3016 , 0x1c},
+	{0x3018 , 0x84},
+	{0x301d , 0xf0},
+	{0x3020 , 0x00},
+	{0x3082 , 0x2c},
+	{0x3083 , 0x03},
+	{0x3084 , 0x07},
+	{0x3085 , 0x03},
+	{0x3086 , 0x00},
+	{0x3087 , 0x00},
+	{0x3501 , 0x4e},
+	{0x3502 , 0xe0},
+	{0x3503 , 0x03},
+	{0x350b , 0x36},
+	{0x3600 , 0xb4},
+	{0x3603 , 0x35},
+	{0x3604 , 0x24},
+	{0x3605 , 0x00},
+	{0x3620 , 0x24},
+	{0x3621 , 0x34},
+	{0x3622 , 0x03},
+	{0x3628 , 0x10},
+	{0x3705 , 0x3c},
+	{0x370a , 0x21},
+	{0x370c , 0x50},
+	{0x370d , 0xc0},
+	{0x3717 , 0x58},
+	{0x3718 , 0x80},
+	{0x3720 , 0x00},
+	{0x3721 , 0x09},
+	{0x3722 , 0x06},
+	{0x3723 , 0x59},
+	{0x3738 , 0x99},
+	{0x3781 , 0x80},
+	{0x3784 , 0x0c},
+	{0x3789 , 0x60},
+	{0x3800 , 0x00},
+	{0x3801 , 0x00},
+	{0x3802 , 0x00},
+	{0x3803 , 0x00},
+	{0x3804 , 0x06},
+	{0x3805 , 0x4f},
+	{0x3806 , 0x04},
+	{0x3807 , 0xbf},
+	{0x3808 , 0x06},
+	{0x3809 , 0x40},
+	{0x380a , 0x04},
+	{0x380b , 0xb0},
+	{0x380c , 0x06},
+	{0x380d , 0xa4},
+	{0x380e , 0x05},
+	{0x380f , 0x0e},
+	{0x3810 , 0x00},
+	{0x3811 , 0x08},
+	{0x3812 , 0x00},
+	{0x3813 , 0x08},
+	{0x3814 , 0x11},
+	{0x3815 , 0x11},
+	{0x3819 , 0x04},
+	{0x3820 , 0xc0},
+	{0x3821 , 0x00},
+	{0x3a06 , 0x01},
+	{0x3a07 , 0x84},
+	{0x3a08 , 0x01},
+	{0x3a09 , 0x43},
+	{0x3a0a , 0x24},
+	{0x3a0b , 0x60},
+	{0x3a0c , 0x28},
+	{0x3a0d , 0x60},
+	{0x3a0e , 0x04},
+	{0x3a0f , 0x8c},
+	{0x3a10 , 0x05},
+	{0x3a11 , 0x0c},
+	{0x4000 , 0x81},
+	{0x4001 , 0x40},
+	{0x4008 , 0x02},
+	{0x4009 , 0x09},
+	{0x4300 , 0x30},
+	{0x430e , 0x00},
+	{0x4602 , 0x02},
+	{0x481b , 0x40},
+	{0x481f , 0x40},
+	{0x4837 , 0x1e},
+	{0x5000 , 0xff},
+	{0x5001 , 0x05},
+	{0x5002 , 0x32},
+	{0x5003 , 0x04},
+	{0x5004 , 0xfd},
+	{0x5005 , 0x12},
+	{0x0100 , 0x00},
+	{0x5180 , 0xf4},
+	{0x5181 , 0x11},
+	{0x5182 , 0x41},
+	{0x5183 , 0x42},
+	{0x5184 , 0x75},
+	{0x5185 , 0x55},
+	{0x5186 , 0xa5},
+	{0x5187 , 0xa0},
+	{0x5188 , 0x0a},
+	{0x5189 , 0x0e},
+	{0x518a , 0x0c},
+	{0x518b , 0x40},
+	{0x518c , 0x2c},
+	{0x518d , 0xf8},
+	{0x518e , 0x04},
+	{0x518f , 0x7f},
+	{0x5190 , 0x40},
+	{0x5191 , 0x5f},
+	{0x5192 , 0x40},
+	{0x5193 , 0xff},
+	{0x5194 , 0x40},
+	{0x5195 , 0x06},
+	{0x5196 , 0x43},
+	{0x5197 , 0x04},
+	{0x5198 , 0x00},
+	{0x5199 , 0x05},
+	{0x519a , 0xd3},
+	{0x519b , 0x04},
+	{0x5200 , 0x09},
+	{0x5201 , 0x00},
+	{0x5202 , 0x06},
+	{0x5203 , 0x20},
+	{0x5204 , 0x41},
+	{0x5205 , 0x16},
+	{0x5206 , 0x00},
+	{0x5207 , 0x05},
+	{0x520b , 0x30},
+	{0x520c , 0x75},
+	{0x520d , 0x00},
+	{0x520e , 0x30},
+	{0x520f , 0x75},
+	{0x5210 , 0x00},
+	{0x5280 , 0x14},
+	{0x5281 , 0x02},
+	{0x5282 , 0x02},
+	{0x5283 , 0x04},
+	{0x5284 , 0x06},
+	{0x5285 , 0x08},
+	{0x5286 , 0x0c},
+	{0x5287 , 0x10},
+	{0x5300 , 0xc5},
+	{0x5301 , 0xa0},
+	{0x5302 , 0x06},
+	{0x5303 , 0x08},
+	{0x5304 , 0x18},
+	{0x5305 , 0x30},
+	{0x5306 , 0x60},
+	{0x5307 , 0xc0},
+	{0x5308 , 0x82},
+	{0x5309 , 0x00},
+	{0x530a , 0x0c},
+	{0x530b , 0x02},
+	{0x530c , 0x02},
+	{0x530d , 0x00},
+	{0x530e , 0x0c},
+	{0x530f , 0x14},
+	{0x5310 , 0x1a},
+	{0x5311 , 0x20},
+	{0x5312 , 0x80},
+	{0x5313 , 0x4b},
+	{0x5380 , 0x01},
+	{0x5381 , 0x6e},
+	{0x5382 , 0x00},
+	{0x5383 , 0x6d},
+	{0x5384 , 0x00},
+	{0x5385 , 0x72},
+	{0x5386 , 0x00},
+	{0x5387 , 0x5f},
+	{0x5388 , 0x00},
+	{0x5389 , 0x4f},
+	{0x538a , 0x01},
+	{0x538b , 0x89},
+	{0x538c , 0x00},
+	{0x5400 , 0x05},
+	{0x5401 , 0x0e},
+	{0x5402 , 0x25},
+	{0x5403 , 0x4e},
+	{0x5404 , 0x60},
+	{0x5405 , 0x6e},
+	{0x5406 , 0x7b},
+	{0x5407 , 0x86},
+	{0x5408 , 0x90},
+	{0x5409 , 0x99},
+	{0x540a , 0xa7},
+	{0x540b , 0xb3},
+	{0x540c , 0xc8},
+	{0x540d , 0xdb},
+	{0x540e , 0xeb},
+	{0x540f , 0xa0},
+	{0x5410 , 0x6e},
+	{0x5411 , 0x06},
+	{0x5480 , 0x19},
+	{0x5481 , 0x00},
+	{0x5482 , 0x09},
+	{0x5483 , 0x12},
+	{0x5484 , 0x04},
+	{0x5485 , 0x06},
+	{0x5486 , 0x08},
+	{0x5487 , 0x0c},
+	{0x5488 , 0x10},
+	{0x5489 , 0x18},
+	{0x5500 , 0x02},
+	{0x5501 , 0x03},
+	{0x5502 , 0x04},
+	{0x5503 , 0x05},
+	{0x5504 , 0x06},
+	{0x5505 , 0x08},
+	{0x5506 , 0x00},
+	{0x5600 , 0x02},
+	{0x5603 , 0x40},
+	{0x5604 , 0x28},
+	{0x5609 , 0x20},
+	{0x560a , 0x60},
+	{0x5780 , 0x3e},
+	{0x5781 , 0x0f},
+	{0x5782 , 0x04},
+	{0x5783 , 0x02},
+	{0x5784 , 0x01},
+	{0x5785 , 0x01},
+	{0x5786 , 0x00},
+	{0x5787 , 0x04},
+	{0x5788 , 0x02},
+	{0x5789 , 0x00},
+	{0x578a , 0x01},
+	{0x578b , 0x02},
+	{0x578c , 0x03},
+	{0x578d , 0x03},
+	{0x578e , 0x08},
+	{0x578f , 0x0c},
+	{0x5790 , 0x08},
+	{0x5791 , 0x04},
+	{0x5792 , 0x00},
+	{0x5793 , 0x00},
+	{0x5794 , 0x03},
+	{0x5800 , 0x03},
+	{0x5801 , 0x1d},
+	{0x5802 , 0x02},
+	{0x5803 , 0x49},
+	{0x5804 , 0x4b},
+	{0x5805 , 0x05},
+	{0x5806 , 0x97},
+	{0x5807 , 0x05},
+	{0x5808 , 0x03},
+	{0x5809 , 0x25},
+	{0x580a , 0x02},
+	{0x580b , 0x4b},
+	{0x580c , 0x3d},
+	{0x580d , 0x05},
+	{0x580e , 0x92},
+	{0x580f , 0x05},
+	{0x5810 , 0x03},
+	{0x5811 , 0x14},
+	{0x5812 , 0x02},
+	{0x5813 , 0x48},
+	{0x5814 , 0x38},
+	{0x5815 , 0x05},
+	{0x5816 , 0x99},
+	{0x5817 , 0x05},
+	{0x5818 , 0x0d},
+	{0x5819 , 0x40},
+	{0x581a , 0x04},
+	{0x581b , 0x0c},
+	{0x3a03 , 0x42},
+	{0x3a04 , 0x36},
+	{0x3503 , 0x00},
+	{0x3080 , 0x00},
+	{0x3018 , 0x44},
+	{0x3084 , 0x0f},
+	{0x3085 , 0x07},
+	{0x4837 , 0x0f},
+	{0x380e , 0x06},
+	{0x380f , 0x10},
+	//;;;; ke,0x s},ettings for MIPI_ser_CLK=888Mbps/lane, sysclk=55.5Mhz, 25.027 FPS
+	{0x3082,0x25},
+	{0x3085,0x06},
+	{0x380e,0x06},
+	{0x380f,0xa2},
+	{0x380e,0x05},
+	{0x380f,0x1a},
+	{0x4837,0x12},
+};
+
+
+static struct msm_camera_i2c_reg_conf ov2685_1600x1200p30_settings[] = {
+	{0x0103 , 0x01},
+	{0x3002 , 0x00},
+	{0x3016 , 0x1c},
+	{0x3018 , 0x84},
+	{0x301d , 0xf0},
+	{0x3020 , 0x00},
+	{0x3082 , 0x2c},
+	{0x3083 , 0x03},
+	{0x3084 , 0x07},
+	{0x3085 , 0x03},
+	{0x3086 , 0x00},
+	{0x3087 , 0x00},
+	{0x3501 , 0x4e},
+	{0x3502 , 0xe0},
+	{0x3503 , 0x03},
+	{0x350b , 0x36},
+	{0x3600 , 0xb4},
+	{0x3603 , 0x35},
+	{0x3604 , 0x24},
+	{0x3605 , 0x00},
+	{0x3620 , 0x24},
+	{0x3621 , 0x34},
+	{0x3622 , 0x03},
+	{0x3628 , 0x10},
+	{0x3705 , 0x3c},
+	{0x370a , 0x21},
+	{0x370c , 0x50},
+	{0x370d , 0xc0},
+	{0x3717 , 0x58},
+	{0x3718 , 0x80},
+	{0x3720 , 0x00},
+	{0x3721 , 0x09},
+	{0x3722 , 0x06},
+	{0x3723 , 0x59},
+	{0x3738 , 0x99},
+	{0x3781 , 0x80},
+	{0x3784 , 0x0c},
+	{0x3789 , 0x60},
+	{0x3800 , 0x00},
+	{0x3801 , 0x00},
+	{0x3802 , 0x00},
+	{0x3803 , 0x00},
+	{0x3804 , 0x06},
+	{0x3805 , 0x4f},
+	{0x3806 , 0x04},
+	{0x3807 , 0xbf},
+	{0x3808 , 0x06},
+	{0x3809 , 0x40},
+	{0x380a , 0x04},
+	{0x380b , 0xb0},
+	{0x380c , 0x06},
+	{0x380d , 0xa4},
+	{0x380e , 0x05},
+	{0x380f , 0x0e},
+	{0x3810 , 0x00},
+	{0x3811 , 0x08},
+	{0x3812 , 0x00},
+	{0x3813 , 0x08},
+	{0x3814 , 0x11},
+	{0x3815 , 0x11},
+	{0x3819 , 0x04},
+	{0x3820 , 0xc0},
+	{0x3821 , 0x00},
+	{0x3a06 , 0x01},
+	{0x3a07 , 0x84},
+	{0x3a08 , 0x01},
+	{0x3a09 , 0x43},
+	{0x3a0a , 0x24},
+	{0x3a0b , 0x60},
+	{0x3a0c , 0x28},
+	{0x3a0d , 0x60},
+	{0x3a0e , 0x04},
+	{0x3a0f , 0x8c},
+	{0x3a10 , 0x05},
+	{0x3a11 , 0x0c},
+	{0x4000 , 0x81},
+	{0x4001 , 0x40},
+	{0x4008 , 0x02},
+	{0x4009 , 0x09},
+	{0x4300 , 0x30},
+	{0x430e , 0x00},
+	{0x4602 , 0x02},
+	{0x481b , 0x40},
+	{0x481f , 0x40},
+	{0x4837 , 0x1e},
+	{0x5000 , 0xff},
+	{0x5001 , 0x05},
+	{0x5002 , 0x32},
+	{0x5003 , 0x04},
+	{0x5004 , 0xfd},
+	{0x5005 , 0x12},
+	{0x0100 , 0x00},
+	{0x5180 , 0xf4},
+	{0x5181 , 0x11},
+	{0x5182 , 0x41},
+	{0x5183 , 0x42},
+	{0x5184 , 0x75},
+	{0x5185 , 0x55},
+	{0x5186 , 0xa5},
+	{0x5187 , 0xa0},
+	{0x5188 , 0x0a},
+	{0x5189 , 0x0e},
+	{0x518a , 0x0c},
+	{0x518b , 0x40},
+	{0x518c , 0x2c},
+	{0x518d , 0xf8},
+	{0x518e , 0x04},
+	{0x518f , 0x7f},
+	{0x5190 , 0x40},
+	{0x5191 , 0x5f},
+	{0x5192 , 0x40},
+	{0x5193 , 0xff},
+	{0x5194 , 0x40},
+	{0x5195 , 0x06},
+	{0x5196 , 0x43},
+	{0x5197 , 0x04},
+	{0x5198 , 0x00},
+	{0x5199 , 0x05},
+	{0x519a , 0xd3},
+	{0x519b , 0x04},
+	{0x5200 , 0x09},
+	{0x5201 , 0x00},
+	{0x5202 , 0x06},
+	{0x5203 , 0x20},
+	{0x5204 , 0x41},
+	{0x5205 , 0x16},
+	{0x5206 , 0x00},
+	{0x5207 , 0x05},
+	{0x520b , 0x30},
+	{0x520c , 0x75},
+	{0x520d , 0x00},
+	{0x520e , 0x30},
+	{0x520f , 0x75},
+	{0x5210 , 0x00},
+	{0x5280 , 0x14},
+	{0x5281 , 0x02},
+	{0x5282 , 0x02},
+	{0x5283 , 0x04},
+	{0x5284 , 0x06},
+	{0x5285 , 0x08},
+	{0x5286 , 0x0c},
+	{0x5287 , 0x10},
+	{0x5300 , 0xc5},
+	{0x5301 , 0xa0},
+	{0x5302 , 0x06},
+	{0x5303 , 0x08},
+	{0x5304 , 0x18},
+	{0x5305 , 0x30},
+	{0x5306 , 0x60},
+	{0x5307 , 0xc0},
+	{0x5308 , 0x82},
+	{0x5309 , 0x00},
+	{0x530a , 0x0c},
+	{0x530b , 0x02},
+	{0x530c , 0x02},
+	{0x530d , 0x00},
+	{0x530e , 0x0c},
+	{0x530f , 0x14},
+	{0x5310 , 0x1a},
+	{0x5311 , 0x20},
+	{0x5312 , 0x80},
+	{0x5313 , 0x4b},
+	{0x5380 , 0x01},
+	{0x5381 , 0x6e},
+	{0x5382 , 0x00},
+	{0x5383 , 0x6d},
+	{0x5384 , 0x00},
+	{0x5385 , 0x72},
+	{0x5386 , 0x00},
+	{0x5387 , 0x5f},
+	{0x5388 , 0x00},
+	{0x5389 , 0x4f},
+	{0x538a , 0x01},
+	{0x538b , 0x89},
+	{0x538c , 0x00},
+	{0x5400 , 0x05},
+	{0x5401 , 0x0e},
+	{0x5402 , 0x25},
+	{0x5403 , 0x4e},
+	{0x5404 , 0x60},
+	{0x5405 , 0x6e},
+	{0x5406 , 0x7b},
+	{0x5407 , 0x86},
+	{0x5408 , 0x90},
+	{0x5409 , 0x99},
+	{0x540a , 0xa7},
+	{0x540b , 0xb3},
+	{0x540c , 0xc8},
+	{0x540d , 0xdb},
+	{0x540e , 0xeb},
+	{0x540f , 0xa0},
+	{0x5410 , 0x6e},
+	{0x5411 , 0x06},
+	{0x5480 , 0x19},
+	{0x5481 , 0x00},
+	{0x5482 , 0x09},
+	{0x5483 , 0x12},
+	{0x5484 , 0x04},
+	{0x5485 , 0x06},
+	{0x5486 , 0x08},
+	{0x5487 , 0x0c},
+	{0x5488 , 0x10},
+	{0x5489 , 0x18},
+	{0x5500 , 0x02},
+	{0x5501 , 0x03},
+	{0x5502 , 0x04},
+	{0x5503 , 0x05},
+	{0x5504 , 0x06},
+	{0x5505 , 0x08},
+	{0x5506 , 0x00},
+	{0x5600 , 0x02},
+	{0x5603 , 0x40},
+	{0x5604 , 0x28},
+	{0x5609 , 0x20},
+	{0x560a , 0x60},
+	{0x5780 , 0x3e},
+	{0x5781 , 0x0f},
+	{0x5782 , 0x04},
+	{0x5783 , 0x02},
+	{0x5784 , 0x01},
+	{0x5785 , 0x01},
+	{0x5786 , 0x00},
+	{0x5787 , 0x04},
+	{0x5788 , 0x02},
+	{0x5789 , 0x00},
+	{0x578a , 0x01},
+	{0x578b , 0x02},
+	{0x578c , 0x03},
+	{0x578d , 0x03},
+	{0x578e , 0x08},
+	{0x578f , 0x0c},
+	{0x5790 , 0x08},
+	{0x5791 , 0x04},
+	{0x5792 , 0x00},
+	{0x5793 , 0x00},
+	{0x5794 , 0x03},
+	{0x5800 , 0x03},
+	{0x5801 , 0x1d},
+	{0x5802 , 0x02},
+	{0x5803 , 0x49},
+	{0x5804 , 0x4b},
+	{0x5805 , 0x05},
+	{0x5806 , 0x97},
+	{0x5807 , 0x05},
+	{0x5808 , 0x03},
+	{0x5809 , 0x25},
+	{0x580a , 0x02},
+	{0x580b , 0x4b},
+	{0x580c , 0x3d},
+	{0x580d , 0x05},
+	{0x580e , 0x92},
+	{0x580f , 0x05},
+	{0x5810 , 0x03},
+	{0x5811 , 0x14},
+	{0x5812 , 0x02},
+	{0x5813 , 0x48},
+	{0x5814 , 0x38},
+	{0x5815 , 0x05},
+	{0x5816 , 0x99},
+	{0x5817 , 0x05},
+	{0x5818 , 0x0d},
+	{0x5819 , 0x40},
+	{0x581a , 0x04},
+	{0x581b , 0x0c},
+	{0x3a03 , 0x42},
+	{0x3a04 , 0x36},
+	{0x3503 , 0x00},
+	{0x3080 , 0x00},
+	{0x3018 , 0x44},
+	{0x3084 , 0x0f},
+	{0x3085 , 0x07},
+	{0x4837 , 0x0f},
+	{0x380e , 0x06},
+	{0x380f , 0x10},
+	//;;;; ke,0x s},ettings for MIPI_ser_CLK=888Mbps/lane, sysclk=55.5Mhz, 25.027 FPS
+	{0x3082,0x25},
+	{0x3085,0x06},
+	{0x380e,0x06},
+	{0x380f,0xa2},
+	{0x380e,0x05},
+	{0x380f,0x1a},
+	{0x4837,0x12},
+
+/// ALTEK_IQM >>>
+    // HW frame sync, OV2685 slave setting
+	{0x3002, 0x00},
+	{0x3823, 0x30},
+
+	{0x3824, 0x00}, // cs
+	{0x3825, 0x20},
+
+	{0x3826, 0x00}, // r
+	{0x3827, 0x06},
+
+	{0x3503, 0x03}, // AE manual
+	{0x5180, 0x03}, // MWB
+	/// ALTEK_IQM <<<
+};
+
+static struct msm_camera_i2c_reg_conf ov2685_720p60_ffbm_settings[] = {
+	{0x0103, 0x01},
+	{0x3002, 0x00},
+	{0x3016, 0x1c},
+	{0x3018, 0x84},
+	{0x301d, 0xf0},
+	{0x3020, 0x00},
+	{0x3082, 0x2c},
+	{0x3083, 0x03},
+	{0x3084, 0x07},
+	{0x3085, 0x03},
+	{0x3086, 0x00},
+	{0x3087, 0x00},
+	{0x3501, 0x2d},
+	{0x3502, 0x80},
+	{0x3503, 0x03},
+	{0x350b, 0x36},
+	{0x3600, 0xb4},
+	{0x3603, 0x35},
+	{0x3604, 0x24},
+	{0x3605, 0x00},
+	{0x3620, 0x26},
+	{0x3621, 0x37},
+	{0x3622, 0x04},
+	{0x3628, 0x10},
+	{0x3705, 0x3c},
+	{0x370a, 0x21},
+	{0x370c, 0x50},
+	{0x370d, 0xc0},
+	{0x3717, 0x58},
+	{0x3718, 0x88},
+	{0x3720, 0x00},
+	{0x3721, 0x00},
+	{0x3722, 0x00},
+	{0x3723, 0x00},
+	{0x3738, 0x00},
+	{0x3781, 0x80},
+	{0x3784, 0x0c},
+	{0x3789, 0x60},
+	{0x3800, 0x00},
+	{0x3801, 0xa0},
+	{0x3802, 0x00},
+	{0x3803, 0xf2},
+	{0x3804, 0x05},
+	{0x3805, 0xaf},
+	{0x3806, 0x03},
+	{0x3807, 0xcd},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380c, 0x05},
+	{0x380d, 0xa6},
+	{0x380e, 0x02},
+	{0x380f, 0xf8},
+	{0x3810, 0x00},
+	{0x3811, 0x08},
+	{0x3812, 0x00},
+	{0x3813, 0x06},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3819, 0x04},
+	{0x3820, 0xc0},
+	{0x3821, 0x00},
+	{0x3a06, 0x01},
+	{0x3a07, 0xc8},
+	{0x3a08, 0x01},
+	{0x3a09, 0x7c},
+	{0x3a0a, 0x0e},
+	{0x3a0b, 0x40},
+	{0x3a0c, 0x17},
+	{0x3a0d, 0xc0},
+	{0x3a0e, 0x01},
+	{0x3a0f, 0xc8},
+	{0x3a10, 0x02},
+	{0x3a11, 0xf8},
+	{0x4000, 0x81},
+	{0x4001, 0x40},
+	{0x4008, 0x02},
+	{0x4009, 0x09},
+	{0x4300, 0x30},
+	{0x430e, 0x00},
+	{0x4602, 0x02},
+	{0x481b, 0x40},
+	{0x481f, 0x40},
+	{0x4837, 0x1e},
+	{0x5000, 0xff},
+	{0x5001, 0x05},
+	{0x5002, 0x32},
+	{0x5003, 0x04},
+	{0x5004, 0xfd},
+	{0x5005, 0x12},
+	{0x5180, 0xf4},
+	{0x5181, 0x11},
+	{0x5182, 0x41},
+	{0x5183, 0x42},
+	{0x5184, 0x75},
+	{0x5185, 0x55},
+	{0x5186, 0xa5},
+	{0x5187, 0xa0},
+	{0x5188, 0x0a},
+	{0x5189, 0x0e},
+	{0x518a, 0x0c},
+	{0x518b, 0x40},
+	{0x518c, 0x2c},
+	{0x518d, 0xf8},
+	{0x518e, 0x04},
+	{0x518f, 0x7f},
+	{0x5190, 0x40},
+	{0x5191, 0x5f},
+	{0x5192, 0x40},
+	{0x5193, 0xff},
+	{0x5194, 0x40},
+	{0x5195, 0x06},
+	{0x5196, 0x43},
+	{0x5197, 0x04},
+	{0x5198, 0x00},
+	{0x5199, 0x05},
+	{0x519a, 0xd3},
+	{0x519b, 0x04},
+	{0x5200, 0x09},
+	{0x5201, 0x00},
+	{0x5202, 0x06},
+	{0x5203, 0x20},
+	{0x5204, 0x41},
+	{0x5205, 0x16},
+	{0x5206, 0x00},
+	{0x5207, 0x05},
+	{0x520b, 0x30},
+	{0x520c, 0x75},
+	{0x520d, 0x00},
+	{0x520e, 0x30},
+	{0x520f, 0x75},
+	{0x5210, 0x00},
+	{0x5280, 0x14},
+	{0x5281, 0x02},
+	{0x5282, 0x02},
+	{0x5283, 0x04},
+	{0x5284, 0x06},
+	{0x5285, 0x08},
+	{0x5286, 0x0c},
+	{0x5287, 0x10},
+	{0x5300, 0xc5},
+	{0x5301, 0xa0},
+	{0x5302, 0x06},
+	{0x5303, 0x08},
+	{0x5304, 0x18},
+	{0x5305, 0x30},
+	{0x5306, 0x60},
+	{0x5307, 0xc0},
+	{0x5308, 0x82},
+	{0x5309, 0x00},
+	{0x530a, 0x0c},
+	{0x530b, 0x02},
+	{0x530c, 0x02},
+	{0x530d, 0x00},
+	{0x530e, 0x0c},
+	{0x530f, 0x14},
+	{0x5310, 0x1a},
+	{0x5311, 0x20},
+	{0x5312, 0x80},
+	{0x5313, 0x4b},
+	{0x5380, 0x01},
+	{0x5381, 0x6e},
+	{0x5382, 0x00},
+	{0x5383, 0x6d},
+	{0x5384, 0x00},
+	{0x5385, 0x72},
+	{0x5386, 0x00},
+	{0x5387, 0x5f},
+	{0x5388, 0x00},
+	{0x5389, 0x4f},
+	{0x538a, 0x01},
+	{0x538b, 0x89},
+	{0x538c, 0x00},
+	{0x5400, 0x05},
+	{0x5401, 0x0e},
+	{0x5402, 0x25},
+	{0x5403, 0x4e},
+	{0x5404, 0x60},
+	{0x5405, 0x6e},
+	{0x5406, 0x7b},
+	{0x5407, 0x86},
+	{0x5408, 0x90},
+	{0x5409, 0x99},
+	{0x540a, 0xa7},
+	{0x540b, 0xb3},
+	{0x540c, 0xc8},
+	{0x540d, 0xdb},
+	{0x540e, 0xeb},
+	{0x540f, 0xa0},
+	{0x5410, 0x6e},
+	{0x5411, 0x06},
+	{0x5480, 0x19},
+	{0x5481, 0x00},
+	{0x5482, 0x09},
+	{0x5483, 0x12},
+	{0x5484, 0x04},
+	{0x5485, 0x06},
+	{0x5486, 0x08},
+	{0x5487, 0x0c},
+	{0x5488, 0x10},
+	{0x5489, 0x18},
+	{0x5500, 0x02},
+	{0x5501, 0x03},
+	{0x5502, 0x04},
+	{0x5503, 0x05},
+	{0x5504, 0x06},
+	{0x5505, 0x08},
+	{0x5506, 0x00},
+	{0x5600, 0x02},
+	{0x5603, 0x40},
+	{0x5604, 0x28},
+	{0x5609, 0x20},
+	{0x560a, 0x60},
+	{0x5780, 0x3e},
+	{0x5781, 0x0f},
+	{0x5782, 0x04},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x00},
+	{0x578a, 0x01},
+	{0x578b, 0x02},
+	{0x578c, 0x03},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x04},
+	{0x5792, 0x00},
+	{0x5793, 0x00},
+	{0x5794, 0x03},
+	{0x5800, 0x03},
+	{0x5801, 0x1d},
+	{0x5802, 0x02},
+	{0x5803, 0x49},
+	{0x5804, 0x4b},
+	{0x5805, 0x05},
+	{0x5806, 0x97},
+	{0x5807, 0x05},
+	{0x5808, 0x03},
+	{0x5809, 0x25},
+	{0x580a, 0x02},
+	{0x580b, 0x4b},
+	{0x580c, 0x3d},
+	{0x580d, 0x05},
+	{0x580e, 0x92},
+	{0x580f, 0x05},
+	{0x5810, 0x03},
+	{0x5811, 0x14},
+	{0x5812, 0x02},
+	{0x5813, 0x48},
+	{0x5814, 0x38},
+	{0x5815, 0x05},
+	{0x5816, 0x99},
+	{0x5817, 0x05},
+	{0x5818, 0x0d},
+	{0x5819, 0x40},
+	{0x581a, 0x04},
+	{0x581b, 0x0c},
+	{0x3a03, 0x42},
+	{0x3a04, 0x36},
+	{0x3503, 0x00},
+};
+
+
+static struct msm_camera_i2c_reg_conf ov2685_720p60_settings[] = {
+	{0x0103, 0x01},
+	{0x3002, 0x00},
+	{0x3016, 0x1c},
+	{0x3018, 0x84},
+	{0x301d, 0xf0},
+	{0x3020, 0x00},
+	{0x3082, 0x2c},
+	{0x3083, 0x03},
+	{0x3084, 0x07},
+	{0x3085, 0x03},
+	{0x3086, 0x00},
+	{0x3087, 0x00},
+	{0x3501, 0x2d},
+	{0x3502, 0x80},
+	{0x3503, 0x03},
+	{0x350b, 0x36},
+	{0x3600, 0xb4},
+	{0x3603, 0x35},
+	{0x3604, 0x24},
+	{0x3605, 0x00},
+	{0x3620, 0x26},
+	{0x3621, 0x37},
+	{0x3622, 0x04},
+	{0x3628, 0x10},
+	{0x3705, 0x3c},
+	{0x370a, 0x21},
+	{0x370c, 0x50},
+	{0x370d, 0xc0},
+	{0x3717, 0x58},
+	{0x3718, 0x88},
+	{0x3720, 0x00},
+	{0x3721, 0x00},
+	{0x3722, 0x00},
+	{0x3723, 0x00},
+	{0x3738, 0x00},
+	{0x3781, 0x80},
+	{0x3784, 0x0c},
+	{0x3789, 0x60},
+	{0x3800, 0x00},
+	{0x3801, 0xa0},
+	{0x3802, 0x00},
+	{0x3803, 0xf2},
+	{0x3804, 0x05},
+	{0x3805, 0xaf},
+	{0x3806, 0x03},
+	{0x3807, 0xcd},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380c, 0x05},
+	{0x380d, 0xa6},
+	{0x380e, 0x02},
+	{0x380f, 0xf8},
+	{0x3810, 0x00},
+	{0x3811, 0x08},
+	{0x3812, 0x00},
+	{0x3813, 0x06},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3819, 0x04},
+	{0x3820, 0xc0},
+	{0x3821, 0x00},
+	{0x3a06, 0x01},
+	{0x3a07, 0xc8},
+	{0x3a08, 0x01},
+	{0x3a09, 0x7c},
+	{0x3a0a, 0x0e},
+	{0x3a0b, 0x40},
+	{0x3a0c, 0x17},
+	{0x3a0d, 0xc0},
+	{0x3a0e, 0x01},
+	{0x3a0f, 0xc8},
+	{0x3a10, 0x02},
+	{0x3a11, 0xf8},
+	{0x4000, 0x81},
+	{0x4001, 0x40},
+	{0x4008, 0x02},
+	{0x4009, 0x09},
+	{0x4300, 0x30},
+	{0x430e, 0x00},
+	{0x4602, 0x02},
+	{0x481b, 0x40},
+	{0x481f, 0x40},
+	{0x4837, 0x1e},
+	{0x5000, 0xff},
+	{0x5001, 0x05},
+	{0x5002, 0x32},
+	{0x5003, 0x04},
+	{0x5004, 0xfd},
+	{0x5005, 0x12},
+	{0x5180, 0xf4},
+	{0x5181, 0x11},
+	{0x5182, 0x41},
+	{0x5183, 0x42},
+	{0x5184, 0x75},
+	{0x5185, 0x55},
+	{0x5186, 0xa5},
+	{0x5187, 0xa0},
+	{0x5188, 0x0a},
+	{0x5189, 0x0e},
+	{0x518a, 0x0c},
+	{0x518b, 0x40},
+	{0x518c, 0x2c},
+	{0x518d, 0xf8},
+	{0x518e, 0x04},
+	{0x518f, 0x7f},
+	{0x5190, 0x40},
+	{0x5191, 0x5f},
+	{0x5192, 0x40},
+	{0x5193, 0xff},
+	{0x5194, 0x40},
+	{0x5195, 0x06},
+	{0x5196, 0x43},
+	{0x5197, 0x04},
+	{0x5198, 0x00},
+	{0x5199, 0x05},
+	{0x519a, 0xd3},
+	{0x519b, 0x04},
+	{0x5200, 0x09},
+	{0x5201, 0x00},
+	{0x5202, 0x06},
+	{0x5203, 0x20},
+	{0x5204, 0x41},
+	{0x5205, 0x16},
+	{0x5206, 0x00},
+	{0x5207, 0x05},
+	{0x520b, 0x30},
+	{0x520c, 0x75},
+	{0x520d, 0x00},
+	{0x520e, 0x30},
+	{0x520f, 0x75},
+	{0x5210, 0x00},
+	{0x5280, 0x14},
+	{0x5281, 0x02},
+	{0x5282, 0x02},
+	{0x5283, 0x04},
+	{0x5284, 0x06},
+	{0x5285, 0x08},
+	{0x5286, 0x0c},
+	{0x5287, 0x10},
+	{0x5300, 0xc5},
+	{0x5301, 0xa0},
+	{0x5302, 0x06},
+	{0x5303, 0x08},
+	{0x5304, 0x18},
+	{0x5305, 0x30},
+	{0x5306, 0x60},
+	{0x5307, 0xc0},
+	{0x5308, 0x82},
+	{0x5309, 0x00},
+	{0x530a, 0x0c},
+	{0x530b, 0x02},
+	{0x530c, 0x02},
+	{0x530d, 0x00},
+	{0x530e, 0x0c},
+	{0x530f, 0x14},
+	{0x5310, 0x1a},
+	{0x5311, 0x20},
+	{0x5312, 0x80},
+	{0x5313, 0x4b},
+	{0x5380, 0x01},
+	{0x5381, 0x6e},
+	{0x5382, 0x00},
+	{0x5383, 0x6d},
+	{0x5384, 0x00},
+	{0x5385, 0x72},
+	{0x5386, 0x00},
+	{0x5387, 0x5f},
+	{0x5388, 0x00},
+	{0x5389, 0x4f},
+	{0x538a, 0x01},
+	{0x538b, 0x89},
+	{0x538c, 0x00},
+	{0x5400, 0x05},
+	{0x5401, 0x0e},
+	{0x5402, 0x25},
+	{0x5403, 0x4e},
+	{0x5404, 0x60},
+	{0x5405, 0x6e},
+	{0x5406, 0x7b},
+	{0x5407, 0x86},
+	{0x5408, 0x90},
+	{0x5409, 0x99},
+	{0x540a, 0xa7},
+	{0x540b, 0xb3},
+	{0x540c, 0xc8},
+	{0x540d, 0xdb},
+	{0x540e, 0xeb},
+	{0x540f, 0xa0},
+	{0x5410, 0x6e},
+	{0x5411, 0x06},
+	{0x5480, 0x19},
+	{0x5481, 0x00},
+	{0x5482, 0x09},
+	{0x5483, 0x12},
+	{0x5484, 0x04},
+	{0x5485, 0x06},
+	{0x5486, 0x08},
+	{0x5487, 0x0c},
+	{0x5488, 0x10},
+	{0x5489, 0x18},
+	{0x5500, 0x02},
+	{0x5501, 0x03},
+	{0x5502, 0x04},
+	{0x5503, 0x05},
+	{0x5504, 0x06},
+	{0x5505, 0x08},
+	{0x5506, 0x00},
+	{0x5600, 0x02},
+	{0x5603, 0x40},
+	{0x5604, 0x28},
+	{0x5609, 0x20},
+	{0x560a, 0x60},
+	{0x5780, 0x3e},
+	{0x5781, 0x0f},
+	{0x5782, 0x04},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x00},
+	{0x578a, 0x01},
+	{0x578b, 0x02},
+	{0x578c, 0x03},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x04},
+	{0x5792, 0x00},
+	{0x5793, 0x00},
+	{0x5794, 0x03},
+	{0x5800, 0x03},
+	{0x5801, 0x1d},
+	{0x5802, 0x02},
+	{0x5803, 0x49},
+	{0x5804, 0x4b},
+	{0x5805, 0x05},
+	{0x5806, 0x97},
+	{0x5807, 0x05},
+	{0x5808, 0x03},
+	{0x5809, 0x25},
+	{0x580a, 0x02},
+	{0x580b, 0x4b},
+	{0x580c, 0x3d},
+	{0x580d, 0x05},
+	{0x580e, 0x92},
+	{0x580f, 0x05},
+	{0x5810, 0x03},
+	{0x5811, 0x14},
+	{0x5812, 0x02},
+	{0x5813, 0x48},
+	{0x5814, 0x38},
+	{0x5815, 0x05},
+	{0x5816, 0x99},
+	{0x5817, 0x05},
+	{0x5818, 0x0d},
+	{0x5819, 0x40},
+	{0x581a, 0x04},
+	{0x581b, 0x0c},
+	{0x3a03, 0x42},
+	{0x3a04, 0x36},
+	{0x3503, 0x00},
+
+	/// ALTEK_IQM >>>
+	{0x3503, 0x03}, // AE manual
+	{0x5180, 0x03}, // MWB
+	/// ALTEK_IQM <<<
+};
+
+struct ov2685_resolution_table_t {
+	char *name;
+	struct msm_camera_i2c_reg_conf *settings;
+	unsigned int size; /* ARRAY_SIZE(settings) */
+};
+/* This table has to be in the same order as they are in the sensor lib */
+static struct ov2685_resolution_table_t ov2685_resolutions[] = {
+	{"2MP 30fps", ov2685_1600x1200p30_settings, ARRAY_SIZE(ov2685_1600x1200p30_settings)},
+	{"720p 60fps",  ov2685_720p60_settings,  ARRAY_SIZE(ov2685_720p60_settings)},
+};
+
+static struct ov2685_resolution_table_t ov2685_ffbm_resolutions[] = {
+	{"2MP 30fps", ov2685_1600x1200p30_ffbm_settings, ARRAY_SIZE(ov2685_1600x1200p30_ffbm_settings)},
+	{"720p 60fps",  ov2685_720p60_ffbm_settings,  ARRAY_SIZE(ov2685_720p60_ffbm_settings)},
+};
+
+
+int32_t ov2685_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl)
+{
+	int32_t rc = -EINVAL;
+	CDBG("Power Up");
+
+	msleep(20);
+
+	rc = msm_sensor_power_up(s_ctrl);
+	if (rc < 0) {
+		pr_err("%s: msm_sensor_power_up failed\n", __func__);
+		return rc;
+	}
+
+	return rc;
+}
+
+/* FIXME: Stop stream null for now, use VFE stop */
+/* static void ov2685_stop_stream(struct msm_sensor_ctrl_t *s_ctrl) {} */
+
+int32_t ov2685_sensor_power_down(struct msm_sensor_ctrl_t *s_ctrl)
+{
+	CDBG("Power Down");
+
+	msleep(20);
+	msm_sensor_power_down(s_ctrl);
+
+	return 0;
+}
+
+static struct v4l2_subdev_info ov2685_subdev_info[] = {
+	{
+		.code   = V4L2_MBUS_FMT_YUYV8_2X8,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt    = 1,
+		.order  = 0,
+	},
+	/* more can be supported, to be added later */
+};
+
+static const struct i2c_device_id ov2685_i2c_id[] = {
+	{OV2685_SENSOR_NAME, (kernel_ulong_t)&ov2685_s_ctrl},
+	{ }
+};
+
+static int32_t msm_ov2685_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &ov2685_s_ctrl);
+}
+
+static struct i2c_driver ov2685_i2c_driver = {
+	.id_table = ov2685_i2c_id,
+	.probe  = msm_ov2685_i2c_probe,
+	.driver = {
+		.name = OV2685_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client ov2685_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id ov2685_dt_match[] = {
+	{.compatible = "ovti,ov2685", .data = &ov2685_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, ov2685_dt_match);
+
+static struct platform_driver ov2685_platform_driver = {
+	.driver = {
+		.name = "ovti,ov2685",
+		.owner = THIS_MODULE,
+		.of_match_table = ov2685_dt_match,
+	},
+};
+
+static int32_t ov2685_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc;
+	const struct of_device_id *match;
+	match = of_match_device(ov2685_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init ov2685_init_module(void)
+{
+	int32_t rc;
+	int sys_ret = 0;
+	char* ov2685_ffbm_mode_string = NULL;
+
+	pr_info("jerry-%s:%d\n", __func__, __LINE__);
+	CDBG("jerry-afasfadfsdsdfs");
+	rc = platform_driver_probe(&ov2685_platform_driver,
+		ov2685_platform_probe);
+	if (!rc){
+		camera_class = class_create(THIS_MODULE, "yuv_camera");
+		sys_ret = class_create_file(camera_class, &class_attr_slave_camera_info);
+
+		ov2685_ffbm_mode_string = strstr(saved_command_line,"androidboot.mode=ffbm-01");
+		if(!ov2685_ffbm_mode_string){
+			ov2685_ffbm_mode = 0; //not ffbm mode
+		}else{
+			ov2685_ffbm_mode = 1; //ffmb mode
+		}
+
+		return rc;
+	}
+
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&ov2685_i2c_driver);
+}
+
+static void __exit ov2685_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (ov2685_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&ov2685_s_ctrl);
+		platform_driver_unregister(&ov2685_platform_driver);
+	} else
+		i2c_del_driver(&ov2685_i2c_driver);
+	return;
+}
+
+int32_t ov2685_sensor_config(struct msm_sensor_ctrl_t *s_ctrl,
+	void __user *argp)
+{
+	long rc = 0;
+	struct sensorb_cfg_data *cdata = (struct sensorb_cfg_data *)argp;
+	int32_t i = 0;
+	enum msm_sensor_resolution_t res;
+	mutex_lock(s_ctrl->msm_sensor_mutex);
+	CDBG("%s:%d %s cfgtype = %d\n", __func__, __LINE__,
+		s_ctrl->sensordata->sensor_name, cdata->cfgtype);
+	switch (cdata->cfgtype) {
+	case CFG_GET_SENSOR_INFO:
+		memcpy(cdata->cfg.sensor_info.sensor_name,
+			s_ctrl->sensordata->sensor_name,
+			sizeof(cdata->cfg.sensor_info.sensor_name));
+		cdata->cfg.sensor_info.session_id =
+			s_ctrl->sensordata->sensor_info->session_id;
+		for (i = 0; i < SUB_MODULE_MAX; i++)
+			cdata->cfg.sensor_info.subdev_id[i] =
+				s_ctrl->sensordata->sensor_info->subdev_id[i];
+		cdata->cfg.sensor_info.is_mount_angle_valid =
+			s_ctrl->sensordata->sensor_info->is_mount_angle_valid;
+		cdata->cfg.sensor_info.sensor_mount_angle =
+			s_ctrl->sensordata->sensor_info->sensor_mount_angle;
+		CDBG("%s:%d sensor name %s\n", __func__, __LINE__,
+			cdata->cfg.sensor_info.sensor_name);
+		CDBG("%s:%d session id %d\n", __func__, __LINE__,
+			cdata->cfg.sensor_info.session_id);
+		for (i = 0; i < SUB_MODULE_MAX; i++)
+			CDBG("%s:%d subdev_id[%d] %d\n", __func__, __LINE__, i,
+				cdata->cfg.sensor_info.subdev_id[i]);
+		CDBG("%s:%d mount angle valid %d value %d\n", __func__,
+			__LINE__, cdata->cfg.sensor_info.is_mount_angle_valid,
+			cdata->cfg.sensor_info.sensor_mount_angle);
+
+		break;
+	case CFG_SET_INIT_SETTING:
+		/* 1. Write Recommend settings */
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			i2c_write_conf_tbl(
+			s_ctrl->sensor_i2c_client,
+			ov2685_1600x1200p30_settings,
+			ARRAY_SIZE(ov2685_1600x1200p30_settings),
+			MSM_CAMERA_I2C_BYTE_DATA);
+		/* 2. Write change settings */
+		CDBG("%s:%d:CFG_SET_INIT_SETTING %ld\n", __func__, __LINE__, rc);
+		break;
+	case CFG_SET_RESOLUTION:
+		{ int val = 0;
+		CDBG(">>%s:%d<<\n",__func__, __LINE__);
+		if (copy_from_user(&val,
+			(void *)cdata->cfg.setting, sizeof(int))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+		res = val;
+		CDBG(">>%s:%d<<\n", __func__, __LINE__);
+		if ( val > 1) { // TODO
+			rc = -EFAULT;
+			CDBG(">>%s:%d<<\n", __func__, __LINE__);
+			CDBG(">>No Good Resolution<<\n");
+			break;
+		}
+		}
+        if(1 == ov2685_ffbm_mode){
+			CDBG("CFG_SET_RESOLUTION FFBM - picking %s\n", ov2685_ffbm_resolutions[res].name);
+			CDBG(">>%s:%d<<\n", __func__, __LINE__);
+			rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+				i2c_write_conf_tbl(
+				s_ctrl->sensor_i2c_client,
+				ov2685_ffbm_resolutions[res].settings,
+				ov2685_ffbm_resolutions[res].size,
+				MSM_CAMERA_I2C_BYTE_DATA);
+			CDBG("%s:%d:CFG_SET_RESOLUTION FFBM res=%d, rc=%ld", __func__, __LINE__, res, rc);
+
+		}else{
+		    CDBG("CFG_SET_RESOLUTION - picking %s\n", ov2685_resolutions[res].name);
+		    CDBG(">>%s:%d<<\n", __func__, __LINE__);
+		    rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			    i2c_write_conf_tbl(
+			    s_ctrl->sensor_i2c_client,
+			    ov2685_resolutions[res].settings,
+			    ov2685_resolutions[res].size,
+			    MSM_CAMERA_I2C_BYTE_DATA);
+		    CDBG("%s:%d:CFG_SET_RESOLUTION res=%d, rc=%ld", __func__, __LINE__, res, rc);
+		}
+		break;
+	case CFG_SET_STOP_STREAM:
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			i2c_write_conf_tbl(
+			s_ctrl->sensor_i2c_client,
+			ov2685_stop_settings,
+			ARRAY_SIZE(ov2685_stop_settings),
+			MSM_CAMERA_I2C_BYTE_DATA);
+		CDBG("%s:%d:CFG_SET_STOP_STREAM %ld\n", __func__, __LINE__, rc);
+		break;
+	case CFG_SET_START_STREAM:
+/// ALTEK_IQM >>>
+        msleep(50); // make sure sub camera stream on after main camera
+/// ALTEK_IQM <<<
+
+        rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			i2c_write_conf_tbl(
+			s_ctrl->sensor_i2c_client,
+			ov2685_start_settings,
+			ARRAY_SIZE(ov2685_start_settings),
+			MSM_CAMERA_I2C_BYTE_DATA);
+	CDBG("%s:%d:CFG_SET_START_STREAM %ld\n", __func__, __LINE__, rc);
+	/// ALTEK_IQM >>>
+	if(1 != ov2685_ffbm_mode){
+		msleep(20);
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			i2c_write_conf_tbl(
+					s_ctrl->sensor_i2c_client,
+					ov2685_hw_frame_sync_settings,
+					ARRAY_SIZE(ov2685_hw_frame_sync_settings),
+					MSM_CAMERA_I2C_BYTE_DATA);
+	}
+/// ALTEK_IQM <<<        
+		break;
+	case CFG_GET_SENSOR_INIT_PARAMS:
+		cdata->cfg.sensor_init_params.modes_supported =
+			s_ctrl->sensordata->sensor_info->modes_supported;
+		cdata->cfg.sensor_init_params.position =
+			s_ctrl->sensordata->sensor_info->position;
+		cdata->cfg.sensor_init_params.sensor_mount_angle =
+			s_ctrl->sensordata->sensor_info->sensor_mount_angle;
+		CDBG("%s:%d init params mode %d pos %d mount %d\n", __func__,
+			__LINE__,
+			cdata->cfg.sensor_init_params.modes_supported,
+			cdata->cfg.sensor_init_params.position,
+			cdata->cfg.sensor_init_params.sensor_mount_angle);
+		break;
+	case CFG_SET_SLAVE_INFO: {
+		static struct msm_camera_sensor_slave_info sensor_slave_info;
+		struct msm_camera_power_ctrl_t *p_ctrl;
+		uint16_t size;
+		int slave_index = 0;
+		if (copy_from_user(&sensor_slave_info,
+			(void *)cdata->cfg.setting,
+			sizeof(struct msm_camera_sensor_slave_info))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+		/* Update sensor slave address */
+		if (sensor_slave_info.slave_addr) {
+			s_ctrl->sensor_i2c_client->cci_client->sid =
+				sensor_slave_info.slave_addr >> 1;
+		}
+
+		/* Update sensor address type */
+		s_ctrl->sensor_i2c_client->addr_type =
+			sensor_slave_info.addr_type;
+
+		/* Update power up / down sequence */
+		p_ctrl = &s_ctrl->sensordata->power_info;
+		size = sensor_slave_info.power_setting_array.size;
+		if (p_ctrl->power_setting_size < size) {
+			struct msm_sensor_power_setting *tmp;
+			tmp = kmalloc(sizeof(struct msm_sensor_power_setting)
+				      * size, GFP_KERNEL);
+			if (!tmp) {
+				pr_err("%s: failed to alloc mem\n", __func__);
+				rc = -ENOMEM;
+				break;
+			}
+			kfree(p_ctrl->power_setting);
+			p_ctrl->power_setting = tmp;
+		}
+		p_ctrl->power_setting_size = size;
+
+		rc = copy_from_user(p_ctrl->power_setting, (void *)
+			sensor_slave_info.power_setting_array.power_setting,
+			size * sizeof(struct msm_sensor_power_setting));
+		if (rc) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+		CDBG("%s sensor id %x\n", __func__,
+			sensor_slave_info.slave_addr);
+		CDBG("%s sensor addr type %d\n", __func__,
+			sensor_slave_info.addr_type);
+		CDBG("%s sensor reg %x\n", __func__,
+			sensor_slave_info.sensor_id_info.sensor_id_reg_addr);
+		CDBG("%s sensor id %x\n", __func__,
+			sensor_slave_info.sensor_id_info.sensor_id);
+		for (slave_index = 0; slave_index <
+			p_ctrl->power_setting_size; slave_index++) {
+			CDBG("%s i %d power setting %d %d %ld %d\n", __func__,
+				slave_index,
+				p_ctrl->power_setting[slave_index].seq_type,
+				p_ctrl->power_setting[slave_index].seq_val,
+				p_ctrl->power_setting[slave_index].config_val,
+				p_ctrl->power_setting[slave_index].delay);
+		}
+		break;
+	}
+	case CFG_WRITE_I2C_ARRAY: {
+		struct msm_camera_i2c_reg_setting conf_array;
+                struct msm_camera_i2c_reg_setting32 conf_array32;
+		struct msm_camera_i2c_reg_array *reg_setting = NULL;
+
+		if (copy_from_user(&conf_array,
+			(void *)cdata->cfg.setting,
+			sizeof(struct msm_camera_i2c_reg_setting))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+
+		conf_array.addr_type = conf_array32.addr_type;
+		conf_array.data_type = conf_array32.data_type;
+		conf_array.delay = conf_array32.delay;
+		conf_array.size = conf_array32.size;
+		conf_array.reg_setting = compat_ptr(conf_array32.reg_setting);
+
+		reg_setting = kzalloc(conf_array.size *
+			(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
+		if (!reg_setting) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -ENOMEM;
+			break;
+		}
+		if (copy_from_user(reg_setting, (void *)conf_array.reg_setting,
+			conf_array.size *
+			sizeof(struct msm_camera_i2c_reg_array))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			kfree(reg_setting);
+			rc = -EFAULT;
+			break;
+		}
+
+		conf_array.reg_setting = reg_setting;
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write_table(
+			s_ctrl->sensor_i2c_client, &conf_array);
+		kfree(reg_setting);
+		break;
+	}
+	case CFG_WRITE_I2C_SEQ_ARRAY: {
+		struct msm_camera_i2c_seq_reg_setting conf_array;
+		struct msm_camera_i2c_seq_reg_array *reg_setting = NULL;
+
+		if (copy_from_user(&conf_array,
+			(void *)cdata->cfg.setting,
+			sizeof(struct msm_camera_i2c_seq_reg_setting))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+
+		reg_setting = kzalloc(conf_array.size *
+			(sizeof(struct msm_camera_i2c_seq_reg_array)),
+			GFP_KERNEL);
+		if (!reg_setting) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -ENOMEM;
+			break;
+		}
+		if (copy_from_user(reg_setting, (void *)conf_array.reg_setting,
+			conf_array.size *
+			sizeof(struct msm_camera_i2c_seq_reg_array))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			kfree(reg_setting);
+			rc = -EFAULT;
+			break;
+		}
+
+		conf_array.reg_setting = reg_setting;
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			i2c_write_seq_table(s_ctrl->sensor_i2c_client,
+			&conf_array);
+		kfree(reg_setting);
+		break;
+	}
+
+	case CFG_POWER_UP:
+		if (s_ctrl->func_tbl->sensor_power_up)
+			rc = s_ctrl->func_tbl->sensor_power_up(s_ctrl);
+		else
+			rc = -EFAULT;
+		break;
+
+	case CFG_POWER_DOWN:
+		if (s_ctrl->func_tbl->sensor_power_down)
+			rc = s_ctrl->func_tbl->sensor_power_down(
+				s_ctrl);
+		else
+			rc = -EFAULT;
+		break;
+
+	case CFG_SET_STOP_STREAM_SETTING: {
+		struct msm_camera_i2c_reg_setting *stop_setting =
+			&s_ctrl->stop_setting;
+		struct msm_camera_i2c_reg_array *reg_setting = NULL;
+		if (copy_from_user(stop_setting, (void *)cdata->cfg.setting,
+		    sizeof(struct msm_camera_i2c_reg_setting))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+
+		reg_setting = stop_setting->reg_setting;
+		stop_setting->reg_setting = kzalloc(stop_setting->size *
+			(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
+		if (!stop_setting->reg_setting) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -ENOMEM;
+			break;
+		}
+		if (copy_from_user(stop_setting->reg_setting,
+		    (void *)reg_setting, stop_setting->size *
+		    sizeof(struct msm_camera_i2c_reg_array))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			kfree(stop_setting->reg_setting);
+			stop_setting->reg_setting = NULL;
+			stop_setting->size = 0;
+			rc = -EFAULT;
+			break;
+		}
+		break;
+	}
+	default:
+		rc = -EFAULT;
+		break;
+	}
+
+	mutex_unlock(s_ctrl->msm_sensor_mutex);
+
+	return rc;
+}
+
+#ifdef CONFIG_COMPAT
+	int32_t ov2685_sensor_config32(struct msm_sensor_ctrl_t *s_ctrl,
+	void __user *argp)
+{
+	long rc = 0;
+	struct sensorb_cfg_data32 *cdata = (struct sensorb_cfg_data32 *)argp;
+	int32_t i = 0;
+	enum msm_sensor_resolution_t res;
+	mutex_lock(s_ctrl->msm_sensor_mutex);
+	CDBG("%s:%d %s cfgtype = %d\n", __func__, __LINE__,
+		s_ctrl->sensordata->sensor_name, cdata->cfgtype);
+	switch (cdata->cfgtype) {
+	case CFG_GET_SENSOR_INFO:
+		memcpy(cdata->cfg.sensor_info.sensor_name,
+			s_ctrl->sensordata->sensor_name,
+			sizeof(cdata->cfg.sensor_info.sensor_name));
+		cdata->cfg.sensor_info.session_id =
+			s_ctrl->sensordata->sensor_info->session_id;
+		for (i = 0; i < SUB_MODULE_MAX; i++)
+			cdata->cfg.sensor_info.subdev_id[i] =
+				s_ctrl->sensordata->sensor_info->subdev_id[i];
+		cdata->cfg.sensor_info.is_mount_angle_valid =
+			s_ctrl->sensordata->sensor_info->is_mount_angle_valid;
+		cdata->cfg.sensor_info.sensor_mount_angle =
+			s_ctrl->sensordata->sensor_info->sensor_mount_angle;
+		CDBG("%s:%d sensor name %s\n", __func__, __LINE__,
+			cdata->cfg.sensor_info.sensor_name);
+		CDBG("%s:%d session id %d\n", __func__, __LINE__,
+			cdata->cfg.sensor_info.session_id);
+		for (i = 0; i < SUB_MODULE_MAX; i++)
+			CDBG("%s:%d subdev_id[%d] %d\n", __func__, __LINE__, i,
+				cdata->cfg.sensor_info.subdev_id[i]);
+		CDBG("%s:%d mount angle valid %d value %d\n", __func__,
+			__LINE__, cdata->cfg.sensor_info.is_mount_angle_valid,
+			cdata->cfg.sensor_info.sensor_mount_angle);
+
+		break;
+	case CFG_SET_INIT_SETTING:
+		/* 1. Write Recommend settings */
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			i2c_write_conf_tbl(
+			s_ctrl->sensor_i2c_client,
+			ov2685_1600x1200p30_settings,
+			ARRAY_SIZE(ov2685_1600x1200p30_settings),
+			MSM_CAMERA_I2C_BYTE_DATA);
+		/* 2. Write change settings */
+		CDBG("%s:%d:CFG_SET_INIT_SETTING %ld\n", __func__, __LINE__, rc);
+		break;
+	case CFG_SET_RESOLUTION:
+		{ int val = 0;
+		CDBG(">>%s:%d<<\n",__func__, __LINE__);
+		if (copy_from_user(&val,
+			(void *)compat_ptr(cdata->cfg.setting), sizeof(int))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+		res = val;
+		CDBG(">>%s:%d<<\n", __func__, __LINE__);
+		if ( val > 1) { // TODO
+			rc = -EFAULT;
+			CDBG(">>%s:%d<<\n", __func__, __LINE__);
+			CDBG(">>No Good Resolution<<\n");
+			break;
+		}
+		}
+
+		if(1 == ov2685_ffbm_mode){
+			CDBG("CFG_SET_RESOLUTION FFBM - picking %s\n", ov2685_ffbm_resolutions[res].name);
+			CDBG(">>%s:%d<<\n", __func__, __LINE__);
+			rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+				i2c_write_conf_tbl(
+						s_ctrl->sensor_i2c_client,
+						ov2685_ffbm_resolutions[res].settings,
+						ov2685_ffbm_resolutions[res].size,
+						MSM_CAMERA_I2C_BYTE_DATA);
+			CDBG("%s:%d:CFG_SET_RESOLUTION FFBM res=%d, rc=%ld", __func__, __LINE__, res, rc);
+		}else{
+			CDBG("CFG_SET_RESOLUTION - picking %s\n", ov2685_resolutions[res].name);
+			CDBG(">>%s:%d<<\n", __func__, __LINE__);
+			rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+				i2c_write_conf_tbl(
+						s_ctrl->sensor_i2c_client,
+						ov2685_resolutions[res].settings,
+						ov2685_resolutions[res].size,
+						MSM_CAMERA_I2C_BYTE_DATA);
+			CDBG("%s:%d:CFG_SET_RESOLUTION res=%d, rc=%ld", __func__, __LINE__, res, rc);
+		}
+		break;
+	case CFG_SET_STOP_STREAM:
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			i2c_write_conf_tbl(
+			s_ctrl->sensor_i2c_client,
+			ov2685_stop_settings,
+			ARRAY_SIZE(ov2685_stop_settings),
+			MSM_CAMERA_I2C_BYTE_DATA);
+		CDBG("%s:%d:CFG_SET_STOP_STREAM %ld\n", __func__, __LINE__, rc);
+		break;
+	case CFG_SET_START_STREAM:
+		/// ALTEK_IQM >>>
+		msleep(50); // make sure sub camera stream on after main camera
+		/// ALTEK_IQM <<<
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			i2c_write_conf_tbl(
+			s_ctrl->sensor_i2c_client,
+			ov2685_start_settings,
+			ARRAY_SIZE(ov2685_start_settings),
+			MSM_CAMERA_I2C_BYTE_DATA);
+		CDBG("%s:%d:CFG_SET_START_STREAM %ld\n", __func__, __LINE__, rc);
+		/// ALTEK_IQM >>>
+		if(1 != ov2685_ffbm_mode){
+			msleep(20);
+			rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+				i2c_write_conf_tbl(
+						s_ctrl->sensor_i2c_client,
+						ov2685_hw_frame_sync_settings,
+						ARRAY_SIZE(ov2685_hw_frame_sync_settings),
+						MSM_CAMERA_I2C_BYTE_DATA);
+		}
+/// ALTEK_IQM <<<        
+		break;
+	case CFG_GET_SENSOR_INIT_PARAMS:
+		cdata->cfg.sensor_init_params.modes_supported =
+			s_ctrl->sensordata->sensor_info->modes_supported;
+		cdata->cfg.sensor_init_params.position =
+			s_ctrl->sensordata->sensor_info->position;
+		cdata->cfg.sensor_init_params.sensor_mount_angle =
+			s_ctrl->sensordata->sensor_info->sensor_mount_angle;
+		CDBG("%s:%d init params mode %d pos %d mount %d\n", __func__,
+			__LINE__,
+			cdata->cfg.sensor_init_params.modes_supported,
+			cdata->cfg.sensor_init_params.position,
+			cdata->cfg.sensor_init_params.sensor_mount_angle);
+		break;
+	case CFG_SET_SLAVE_INFO: {
+		static struct msm_camera_sensor_slave_info sensor_slave_info;
+		struct msm_camera_power_ctrl_t *p_ctrl;
+		uint16_t size;
+		int slave_index = 0;
+		if (copy_from_user(&sensor_slave_info,
+			(void *)compat_ptr(cdata->cfg.setting),
+			sizeof(struct msm_camera_sensor_slave_info))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+		/* Update sensor slave address */
+		if (sensor_slave_info.slave_addr) {
+			s_ctrl->sensor_i2c_client->cci_client->sid =
+				sensor_slave_info.slave_addr >> 1;
+		}
+
+		/* Update sensor address type */
+		s_ctrl->sensor_i2c_client->addr_type =
+			sensor_slave_info.addr_type;
+
+		/* Update power up / down sequence */
+		p_ctrl = &s_ctrl->sensordata->power_info;
+		size = sensor_slave_info.power_setting_array.size;
+		if (p_ctrl->power_setting_size < size) {
+			struct msm_sensor_power_setting *tmp;
+			tmp = kmalloc(sizeof(struct msm_sensor_power_setting)
+				      * size, GFP_KERNEL);
+			if (!tmp) {
+				pr_err("%s: failed to alloc mem\n", __func__);
+				rc = -ENOMEM;
+				break;
+			}
+			kfree(p_ctrl->power_setting);
+			p_ctrl->power_setting = tmp;
+		}
+		p_ctrl->power_setting_size = size;
+
+		rc = copy_from_user(p_ctrl->power_setting, (void *)
+			sensor_slave_info.power_setting_array.power_setting,
+			size * sizeof(struct msm_sensor_power_setting));
+		if (rc) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+		CDBG("%s sensor id %x\n", __func__,
+			sensor_slave_info.slave_addr);
+		CDBG("%s sensor addr type %d\n", __func__,
+			sensor_slave_info.addr_type);
+		CDBG("%s sensor reg %x\n", __func__,
+			sensor_slave_info.sensor_id_info.sensor_id_reg_addr);
+		CDBG("%s sensor id %x\n", __func__,
+			sensor_slave_info.sensor_id_info.sensor_id);
+		for (slave_index = 0; slave_index <
+			p_ctrl->power_setting_size; slave_index++) {
+			CDBG("%s i %d power setting %d %d %ld %d\n", __func__,
+				slave_index,
+				p_ctrl->power_setting[slave_index].seq_type,
+				p_ctrl->power_setting[slave_index].seq_val,
+				p_ctrl->power_setting[slave_index].config_val,
+				p_ctrl->power_setting[slave_index].delay);
+		}
+		break;
+	}
+	case CFG_WRITE_I2C_ARRAY: {
+/// ALTEK_IQM >>>
+#if 1 // To fix copy data wrong bug
+        struct msm_camera_i2c_reg_setting32 conf_array32;
+        struct msm_camera_i2c_reg_setting conf_array;
+        struct msm_camera_i2c_reg_array *reg_setting = NULL;
+
+		if (copy_from_user(&conf_array32,
+			(void *)compat_ptr(cdata->cfg.setting),
+			sizeof(struct msm_camera_i2c_reg_setting32))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+
+        conf_array.addr_type = conf_array32.addr_type;
+		conf_array.data_type = conf_array32.data_type;
+		conf_array.delay = conf_array32.delay;
+		conf_array.size = conf_array32.size;
+		conf_array.reg_setting = compat_ptr(conf_array32.reg_setting);
+
+/*
+        CDBG("%s:%d kernel CFG_WRITE_I2C_ARRAY size [%d] reg [0x%x=0x%x] [0x%x=0x%x] [0x%x=0x%x] [0x%x=0x%x] [0x%x=0x%x] [0x%x=0x%x] [0x%x=0x%x] [0x%x=0x%x] [0x%x=0x%x] [0x%x=0x%x] [0x%x=0x%x] [0x%x=0x%x]\n", __func__,
+			__LINE__, conf_array.size, 
+            conf_array.reg_setting[0].reg_addr, conf_array.reg_setting[0].reg_data, 
+            conf_array.reg_setting[1].reg_addr, conf_array.reg_setting[1].reg_data,
+            conf_array.reg_setting[2].reg_addr, conf_array.reg_setting[2].reg_data,
+            conf_array.reg_setting[3].reg_addr, conf_array.reg_setting[3].reg_data,
+            conf_array.reg_setting[4].reg_addr, conf_array.reg_setting[4].reg_data,
+            conf_array.reg_setting[5].reg_addr, conf_array.reg_setting[5].reg_data,
+            conf_array.reg_setting[6].reg_addr, conf_array.reg_setting[6].reg_data,
+            conf_array.reg_setting[7].reg_addr, conf_array.reg_setting[7].reg_data,
+            conf_array.reg_setting[8].reg_addr, conf_array.reg_setting[8].reg_data,
+            conf_array.reg_setting[9].reg_addr, conf_array.reg_setting[9].reg_data,
+            conf_array.reg_setting[10].reg_addr, conf_array.reg_setting[10].reg_data,
+            conf_array.reg_setting[11].reg_addr, conf_array.reg_setting[11].reg_data);
+*/
+		if (!conf_array.size) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+#else
+		struct msm_camera_i2c_reg_setting conf_array;
+		struct msm_camera_i2c_reg_array *reg_setting = NULL;
+
+		if (copy_from_user(&conf_array,
+			(void *)compat_ptr(cdata->cfg.setting),
+			sizeof(struct msm_camera_i2c_reg_setting))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+#endif
+/// ALTEK_IQM <<<
+
+		reg_setting = kzalloc(conf_array.size *
+			(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
+		if (!reg_setting) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -ENOMEM;
+			break;
+		}
+		if (copy_from_user(reg_setting, (void *)conf_array.reg_setting,
+			conf_array.size *
+			sizeof(struct msm_camera_i2c_reg_array))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			kfree(reg_setting);
+			rc = -EFAULT;
+			break;
+		}
+
+		conf_array.reg_setting = reg_setting;
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_write_table(
+			s_ctrl->sensor_i2c_client, &conf_array);
+		kfree(reg_setting);
+		break;
+	}
+	case CFG_WRITE_I2C_SEQ_ARRAY: {
+		struct msm_camera_i2c_seq_reg_setting conf_array;
+		struct msm_camera_i2c_seq_reg_array *reg_setting = NULL;
+
+		if (copy_from_user(&conf_array,
+			(void *)compat_ptr(cdata->cfg.setting),
+			sizeof(struct msm_camera_i2c_seq_reg_setting))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+
+		reg_setting = kzalloc(conf_array.size *
+			(sizeof(struct msm_camera_i2c_seq_reg_array)),
+			GFP_KERNEL);
+		if (!reg_setting) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -ENOMEM;
+			break;
+		}
+		if (copy_from_user(reg_setting, (void *)conf_array.reg_setting,
+			conf_array.size *
+			sizeof(struct msm_camera_i2c_seq_reg_array))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			kfree(reg_setting);
+			rc = -EFAULT;
+			break;
+		}
+
+		conf_array.reg_setting = reg_setting;
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->
+			i2c_write_seq_table(s_ctrl->sensor_i2c_client,
+			&conf_array);
+		kfree(reg_setting);
+		break;
+	}
+
+	case CFG_POWER_UP:
+		if (s_ctrl->func_tbl->sensor_power_up)
+			rc = s_ctrl->func_tbl->sensor_power_up(s_ctrl);
+		else
+			rc = -EFAULT;
+		break;
+
+	case CFG_POWER_DOWN:
+		if (s_ctrl->func_tbl->sensor_power_down)
+			rc = s_ctrl->func_tbl->sensor_power_down(
+				s_ctrl);
+		else
+			rc = -EFAULT;
+		break;
+
+	case CFG_SET_STOP_STREAM_SETTING: {
+		struct msm_camera_i2c_reg_setting *stop_setting =
+			&s_ctrl->stop_setting;
+		struct msm_camera_i2c_reg_array *reg_setting = NULL;
+		if (copy_from_user(stop_setting, (void *)compat_ptr(cdata->cfg.setting),
+		    sizeof(struct msm_camera_i2c_reg_setting))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -EFAULT;
+			break;
+		}
+
+		reg_setting = stop_setting->reg_setting;
+		stop_setting->reg_setting = kzalloc(stop_setting->size *
+			(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
+		if (!stop_setting->reg_setting) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			rc = -ENOMEM;
+			break;
+		}
+		if (copy_from_user(stop_setting->reg_setting,
+					(void *)reg_setting, stop_setting->size *
+					sizeof(struct msm_camera_i2c_reg_array))) {
+			pr_err("%s:%d failed\n", __func__, __LINE__);
+			kfree(stop_setting->reg_setting);
+			stop_setting->reg_setting = NULL;
+			stop_setting->size = 0;
+			rc = -EFAULT;
+			break;
+		}
+		break;
+	}
+	default:
+		rc = -EFAULT;
+		break;
+	}
+
+	mutex_unlock(s_ctrl->msm_sensor_mutex);
+
+	return rc;
+}
+#endif
+
+static struct msm_sensor_fn_t ov2685_func_tbl = {
+	.sensor_config = ov2685_sensor_config,
+#ifdef CONFIG_COMPAT
+	.sensor_config32 = ov2685_sensor_config32,
+#endif
+	.sensor_power_up = msm_sensor_power_up,
+	.sensor_power_down = msm_sensor_power_down,
+	.sensor_match_id = msm_sensor_match_id,
+};
+
+static struct msm_sensor_ctrl_t ov2685_s_ctrl = {
+	.sensor_i2c_client = &ov2685_sensor_i2c_client,
+	.power_setting_array.power_setting = ov2685_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(ov2685_power_setting),
+	.msm_sensor_mutex = &ov2685_mut,
+	.sensor_v4l2_subdev_info = ov2685_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(ov2685_subdev_info),
+	.func_tbl = &ov2685_func_tbl,
+};
+
+module_init(ov2685_init_module);
+module_exit(ov2685_exit_module);
+MODULE_AUTHOR("Jerry Yuan <jerry.yuan@ovt.com>");
+MODULE_DESCRIPTION("Omnivision OV2685 2MP YUV driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 15a3738e744..dcd31ca4f79 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -80,6 +80,8 @@ static const struct mmc_fixup mmc_fixups[] = {
 		  MMC_QUIRK_CACHE_DISABLE),
 	MMC_FIXUP(CID_NAME_ANY, CID_MANFID_NUMONYX_MICRON, CID_OEMID_ANY,
 		add_quirk_mmc, MMC_QUIRK_CACHE_DISABLE),
+        MMC_FIXUP(CID_NAME_ANY, CID_MANFID_SAMSUNG, CID_OEMID_ANY,
+                add_quirk_mmc, MMC_QUIRK_CACHE_DISABLE),
 	MMC_FIXUP("MMC16G", CID_MANFID_KINGSTON, CID_OEMID_ANY, add_quirk_mmc,
 		  MMC_QUIRK_CACHE_DISABLE),
 
diff --git a/drivers/net/wireless/wcnss/wcnss_wlan.c b/drivers/net/wireless/wcnss/wcnss_wlan.c
index 3f0d9d6390f..f416cab8cf0 100644
--- a/drivers/net/wireless/wcnss/wcnss_wlan.c
+++ b/drivers/net/wireless/wcnss/wcnss_wlan.c
@@ -58,6 +58,8 @@
 #define IS_CAL_DATA_PRESENT     0
 #define WAIT_FOR_CBC_IND	2
 
+const char *chip_name = NULL;
+
 /* module params */
 #define WCNSS_CONFIG_UNSPECIFIED (-1)
 #define UINT32_MAX (0xFFFFFFFFU)
@@ -539,6 +541,17 @@ static ssize_t wcnss_version_show(struct device *dev,
 static DEVICE_ATTR(wcnss_version, S_IRUSR,
 		wcnss_version_show, NULL);
 
+static ssize_t wcnss_name_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	if (!penv)
+		return -ENODEV;
+	return scnprintf(buf, PAGE_SIZE, "%s", chip_name);
+}
+
+static DEVICE_ATTR(wcnss_name, S_IRUSR,
+		wcnss_name_show, NULL);
+        
 void wcnss_riva_dump_pmic_regs(void)
 {
 	int i, rc;
@@ -1159,6 +1172,10 @@ static int wcnss_create_sysfs(struct device *dev)
 	if (ret)
 		goto remove_thermal;
 
+	ret = device_create_file(dev, &dev_attr_wcnss_name);
+	if (ret)
+		goto remove_thermal;
+    
 	ret = device_create_file(dev, &dev_attr_wcnss_mac_addr);
 	if (ret)
 		goto remove_version;
@@ -3054,6 +3071,14 @@ wcnss_trigger_config(struct platform_device *pdev)
 		"qcom,wlan-indication-enabled"))
 		wcnss_en_wlan_led_trigger();
 
+   chip_name = kmalloc(PAGE_SIZE, GFP_KERNEL);
+   if (!chip_name)
+     printk("[%s]:Failed to alloc chip_name.\n", __func__);
+     rc = of_property_read_string(pdev->dev.of_node, "qcom,chip_name",&chip_name);
+   if (rc) {
+     printk("Error reading qcom,chip_name rc=%d\n", rc);
+     chip_name = NULL;
+   }
 	return 0;
 
 fail_ioremap2:
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index 9e1d73dbb14..0c32cd38f05 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -383,6 +383,39 @@ config SMB135X_CHARGER
 	  The driver reports the charger status via the power supply framework.
 	  A charger status change triggers an IRQ via the device STAT pin.
 
+config SMB1360_CHARGER_FG_TEST
+	tristate "TEST SMB1360 Charger and Fuel Guage"
+	depends on I2C
+	help
+	  Say Y to include support for SMB1360 Charger and Fuel Guage.
+	  SMB1360 is a single path switching mode charger capable of charging
+	  the battery with 1.5Amps of current. It supports a fuel gauge which
+	  uses voltage and coloumb counting for state of charge reporting.
+	  The driver reports the status via the power supply framework
+	  A status change triggers an IRQ via the device STAT pin.
+
+config SMB1360_CHARGER_FG_TESTPLUS
+	tristate "TESTPLUS SMB1360 Charger and Fuel Guage"
+	depends on I2C
+	help
+	  Say Y to include support for SMB1360 Charger and Fuel Guage.
+	  SMB1360 is a single path switching mode charger capable of charging
+	  the battery with 1.5Amps of current. It supports a fuel gauge which
+	  uses voltage and coloumb counting for state of charge reporting.
+	  The driver reports the status via the power supply framework
+	  A status change triggers an IRQ via the device STAT pin.
+
+config SMB1360_CHARGER_FG_MIRAGE
+	tristate "MIRAGE SMB1360 Charger and Fuel Guage"
+	depends on I2C
+	help
+	  Say Y to include support for SMB1360 Charger and Fuel Guage.
+	  SMB1360 is a single path switching mode charger capable of charging
+	  the battery with 1.5Amps of current. It supports a fuel gauge which
+	  uses voltage and coloumb counting for state of charge reporting.
+	  The driver reports the status via the power supply framework
+	  A status change triggers an IRQ via the device STAT pin.
+
 config SMB1360_CHARGER_FG
 	tristate "SMB1360 Charger and Fuel Guage"
 	depends on I2C
@@ -543,6 +576,17 @@ config MSM_BCL_PERIPHERAL_CTL
 	  provides routines to configure and monitor the BCL
 	  PMIC peripheral.
 
+
+config TEST_ONLY
+        bool "test driver different flag"
+		help
+		    make macro CONFIG_TEST_ONLY WORKED
+
+config TESTPLUS_ONLY
+        bool "testplus driver different flag "
+		help
+		    make macro CONFIG_TESTPLUS_ONLY WORKED
+
 source "drivers/power/reset/Kconfig"
 
 endif # POWER_SUPPLY
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index 1355701f5b9..8082fdc55ba 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -55,6 +55,8 @@ obj-$(CONFIG_SMB349_USB_CHARGER)   += smb349-charger.o
 obj-$(CONFIG_SMB350_CHARGER)   += smb350_charger.o
 obj-$(CONFIG_SMB135X_CHARGER)   += smb135x-charger.o
 obj-$(CONFIG_SMB1360_CHARGER_FG) += smb1360-charger-fg.o
+obj-$(CONFIG_SMB1360_CHARGER_FG_TESTPLUS) += smb1360-charger-fg-testplus.o
+obj-$(CONFIG_SMB1360_CHARGER_FG_TEST) += smb1360-charger-fg-test.o
 obj-$(CONFIG_SMB358_CHARGER)	+= smb358-charger.o
 obj-$(CONFIG_BATTERY_BQ28400)	+= bq28400_battery.o
 obj-$(CONFIG_SMB137C_CHARGER)	+= smb137c-charger.o
diff --git a/drivers/power/reset/msm-poweroff.c b/drivers/power/reset/msm-poweroff.c
index 9bb1f5e208f..6d85233aad7 100644
--- a/drivers/power/reset/msm-poweroff.c
+++ b/drivers/power/reset/msm-poweroff.c
@@ -63,7 +63,7 @@ static void *emergency_dload_mode_addr;
 static bool scm_dload_supported;
 
 static int dload_set(const char *val, struct kernel_param *kp);
-static int download_mode = 1;
+static int download_mode = 0;
 module_param_call(download_mode, dload_set, param_get_int,
 			&download_mode, 0644);
 static int panic_prep_restart(struct notifier_block *this,
diff --git a/drivers/power/smb1360-charger-fg-test.c b/drivers/power/smb1360-charger-fg-test.c
new file mode 100755
index 00000000000..1694b3e7fd4
--- /dev/null
+++ b/drivers/power/smb1360-charger-fg-test.c
@@ -0,0 +1,5502 @@
+/* Copyright (c) 2013-2015 The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "SMB:%s: " fmt, __func__
+
+#include <linux/i2c.h>
+#include <linux/debugfs.h>
+#include <linux/gpio.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/math64.h>
+#include <linux/slab.h>
+#include <linux/power_supply.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/regulator/machine.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/bitops.h>
+#include <linux/qpnp/qpnp-adc.h>
+#include <linux/completion.h>
+#include <linux/kthread.h> 
+#include <linux/wakelock.h> // wubo add
+//add start 2015-01-06
+#include <linux/leds.h>    
+static int get_usbcharger_type(void);
+extern long get_msm_thermal_cpu_temperature(uint32_t id);
+static struct wake_lock    ac_charger_wakelock;
+static int g_ac_charger_wakelock_count = 0;
+static int android_disable_charging = 0;
+static int first_AC_in = 1;
+struct smb1360_chip *smb1360_chip_global;
+int first_mic = 0;
+EXPORT_SYMBOL(first_mic);
+
+extern void smb1360_redled_gpio_output(void);
+#define MAX_CHARGING_TEMPERATURE 450  //45 degree
+#define MIDDLE_CHARGING_TEMPERATURE 100 //10 degree
+#define MIN_CHARGING_TEMPERATURE 0
+#define OVER_CHARGING_TEMPERATURE 550
+
+#define CURRENT_AC_BETWEEN_45_55 1305
+#define CURRENT_AC_BETWEEN_10_45 1305
+#define CURRENT_AC_BETWEEN_00_10 522
+
+//add end 2015-01-06
+static struct smb1360_chip *the_chip; //patch add
+
+#define _SMB1360_MASK(BITS, POS) \
+	((unsigned char)(((1 << (BITS)) - 1) << (POS)))
+#define SMB1360_MASK(LEFT_BIT_POS, RIGHT_BIT_POS) \
+		_SMB1360_MASK((LEFT_BIT_POS) - (RIGHT_BIT_POS) + 1, \
+				(RIGHT_BIT_POS))
+
+/* Charger Registers */
+#define CFG_BATT_CHG_REG		0x00
+#define CHG_ITERM_MASK			SMB1360_MASK(2, 0)
+#define CHG_ITERM_25MA			0x0
+#define CHG_ITERM_200MA			0x7
+#define RECHG_MV_MASK			SMB1360_MASK(6, 5)
+#define RECHG_MV_SHIFT			5
+#define OTG_CURRENT_MASK		SMB1360_MASK(4, 3)
+#define OTG_CURRENT_SHIFT		3
+
+#define CFG_BATT_CHG_FREQ_REG          0x03
+#define SWITCH_FREQ_BIT                BIT(7)
+
+#define CFG_BATT_CHG_ICL_REG		0x05
+#define AC_INPUT_ICL_PIN_BIT		BIT(7)
+#define AC_INPUT_PIN_HIGH_BIT		BIT(6)
+#define RESET_STATE_USB_500		BIT(5)
+#define INPUT_CURR_LIM_MASK		SMB1360_MASK(3, 0)
+#define INPUT_CURR_LIM_300MA		0x0
+
+#define CFG_GLITCH_FLT_REG		0x06
+#define AICL_ENABLED_BIT		BIT(0)
+#define INPUT_UV_GLITCH_FLT_20MS_BIT	BIT(7)
+
+#define CFG_CHG_MISC_REG		0x7
+#define CHG_EN_BY_PIN_BIT		BIT(7)
+#define CHG_EN_ACTIVE_LOW_BIT		BIT(6)
+#define PRE_TO_FAST_REQ_CMD_BIT		BIT(5)
+#define CHG_CURR_TERM_DIS_BIT		BIT(3)
+#define CFG_AUTO_RECHG_DIS_BIT		BIT(2)
+#define CFG_CHG_INHIBIT_EN_BIT		BIT(0)
+
+#define CFG_CHG_FUNC_CTRL_REG		0x08
+#define CHG_RECHG_THRESH_FG_SRC_BIT	BIT(1)
+
+#define CFG_STAT_CTRL_REG		0x09
+#define CHG_STAT_IRQ_ONLY_BIT		BIT(4)
+#define CHG_TEMP_CHG_ERR_BLINK_BIT	BIT(3)
+#define CHG_STAT_ACTIVE_HIGH_BIT	BIT(1)
+#define CHG_STAT_DISABLE_BIT		BIT(0)
+
+#define CFG_SFY_TIMER_CTRL_REG		0x0A
+#define SAFETY_TIME_DISABLE_BIT		BIT(5)
+#define SAFETY_TIME_MINUTES_SHIFT	2
+#define SAFETY_TIME_MINUTES_MASK	SMB1360_MASK(3, 2)
+
+#define CFG_BATT_MISSING_REG		0x0D
+#define BATT_MISSING_SRC_THERM_BIT	BIT(1)
+
+#define CFG_FG_BATT_CTRL_REG		0x0E
+#define CFG_FG_OTP_BACK_UP_ENABLE	BIT(7)
+#define BATT_ID_ENABLED_BIT		BIT(5)
+#define CHG_BATT_ID_FAIL		BIT(4)
+#define BATT_ID_FAIL_SELECT_PROFILE	BIT(3)
+#define BATT_PROFILE_SELECT_MASK	SMB1360_MASK(3, 0)
+#define BATT_PROFILEA_MASK		0x0
+#define BATT_PROFILEB_MASK		0xF
+
+#define IRQ_CFG_REG			0x0F
+#define IRQ_BAT_HOT_COLD_HARD_BIT	BIT(7)
+#define IRQ_BAT_HOT_COLD_SOFT_BIT	BIT(6)
+#define IRQ_DCIN_UV_BIT			BIT(2)
+#define IRQ_AICL_DONE_BIT		BIT(1)
+#define IRQ_INTERNAL_TEMPERATURE_BIT	BIT(0)
+
+#define IRQ2_CFG_REG			0x10
+#define IRQ2_SAFETY_TIMER_BIT		BIT(7)
+#define IRQ2_CHG_ERR_BIT		BIT(6)
+#define IRQ2_CHG_PHASE_CHANGE_BIT	BIT(4)
+#define IRQ2_POWER_OK_BIT		BIT(2)
+#define IRQ2_BATT_MISSING_BIT		BIT(1)
+#define IRQ2_VBAT_LOW_BIT		BIT(0)
+
+#define IRQ3_CFG_REG			0x11
+#define IRQ3_FG_ACCESS_OK_BIT           BIT(6)
+#define IRQ3_SOC_CHANGE_BIT		BIT(4)
+#define IRQ3_SOC_MIN_BIT		BIT(3)
+#define IRQ3_SOC_MAX_BIT		BIT(2)
+#define IRQ3_SOC_EMPTY_BIT		BIT(1)
+#define IRQ3_SOC_FULL_BIT		BIT(0)
+//add start 2015-01-06
+#define OTG_UVLO_REG			0x12
+#define OTG_UVLO_MASK		SMB1360_MASK(4, 2)
+#define OTG_UVLO_DATA		2
+#define OTG_UVLO_SHIFT		2
+
+#define PRE_TO_FAST_MASK		SMB1360_MASK(7, 5)
+#define PRE_TO_FAST_DATA		7
+#define PRE_TO_FAST_SHIFT		5
+
+#define PRE_CHARGE_CURRENT_MASK		SMB1360_MASK(1, 0)
+#define PRE_CHARGE_CURRENT_SHIFT		0
+#define PRE_CHARGE_CURRENT_DATA    1
+//add end 2015-01-06
+#define CHG_CURRENT_REG			0x13
+#define FASTCHG_CURR_MASK		SMB1360_MASK(4, 2)
+#define FASTCHG_CURR_SHIFT		2
+
+#define CHG_CMP_CFG			0x14
+#define JEITA_COMP_CURR_MASK		SMB1360_MASK(3, 0)
+#define JEITA_COMP_EN_MASK		SMB1360_MASK(7, 4)
+#define JEITA_COMP_EN_SHIFT		4
+#define JEITA_COMP_EN_BIT		SMB1360_MASK(7, 4)
+#define BATT_CHG_FLT_VTG_REG		0x15
+#define VFLOAT_MASK			SMB1360_MASK(6, 0)
+#define CFG_FVC_REG			0x16
+#define FLT_VTG_COMP_MASK		SMB1360_MASK(6, 0)
+
+#define SHDN_CTRL_REG			0x1A
+#define SHDN_CMD_USE_BIT		BIT(1)
+#define SHDN_CMD_POLARITY_BIT		BIT(2)
+
+#define CURRENT_GAIN_LSB_REG		0x1D
+#define CURRENT_GAIN_MSB_REG		0x1E
+
+/* Command Registers */
+#define CMD_I2C_REG			0x40
+#define ALLOW_VOLATILE_BIT		BIT(6)
+#define FG_ACCESS_ENABLED_BIT		BIT(5)
+#define FG_RESET_BIT			BIT(4)
+#define CYCLE_STRETCH_CLEAR_BIT		BIT(3)
+
+#define CMD_IL_REG			0x41
+#define USB_CTRL_MASK			SMB1360_MASK(1 , 0)
+#define USB_100_BIT			0x01
+#define USB_500_BIT			0x00
+#define USB_AC_BIT			0x02
+#define SHDN_CMD_BIT			BIT(7)
+
+#define CMD_CHG_REG			0x42
+#define CMD_CHG_EN			BIT(1)
+#define CMD_OTG_EN_BIT			BIT(0)
+
+/* Status Registers */
+#define STATUS_1_REG			0x48
+#define AICL_CURRENT_STATUS_MASK	SMB1360_MASK(6, 0)
+#define AICL_LIMIT_1500MA		0xF
+
+#define STATUS_3_REG			0x4B
+#define CHG_HOLD_OFF_BIT		BIT(3)
+#define CHG_TYPE_MASK			SMB1360_MASK(2, 1)
+#define CHG_TYPE_SHIFT			1
+#define BATT_NOT_CHG_VAL		0x0
+#define BATT_PRE_CHG_VAL		0x1
+#define BATT_FAST_CHG_VAL		0x2
+#define BATT_TAPER_CHG_VAL		0x3
+#define CHG_EN_BIT			BIT(0)
+
+#define STATUS_4_REG			0x4C
+#define CYCLE_STRETCH_ACTIVE_BIT	BIT(5)
+
+#define REVISION_CTRL_REG		0x4F
+#define DEVICE_REV_MASK			SMB1360_MASK(3, 0)
+
+/* IRQ Status Registers */
+#define IRQ_A_REG			0x50
+#define IRQ_A_HOT_HARD_BIT		BIT(6)
+#define IRQ_A_COLD_HARD_BIT		BIT(4)
+#define IRQ_A_HOT_SOFT_BIT		BIT(2)
+#define IRQ_A_COLD_SOFT_BIT		BIT(0)
+
+#define IRQ_B_REG			0x51
+#define IRQ_B_BATT_TERMINAL_BIT		BIT(6)
+#define IRQ_B_BATT_MISSING_BIT		BIT(4)
+
+#define IRQ_C_REG			0x52
+#define IRQ_C_CHG_TERM			BIT(0)
+
+#define IRQ_D_REG			0x53
+#define IRQ_E_REG			0x54
+#define IRQ_E_USBIN_UV_BIT		BIT(0)
+
+#define IRQ_F_REG			0x55
+
+#define IRQ_G_REG			0x56
+
+#define IRQ_H_REG			0x57
+#define IRQ_I_REG			0x58
+#define FG_ACCESS_ALLOWED_BIT		BIT(0)
+#define BATT_ID_RESULT_BIT		SMB1360_MASK(6, 4)
+#define BATT_ID_SHIFT			4
+
+/* FG registers - IRQ config register */
+#define SOC_MAX_REG			0x24
+#define SOC_MIN_REG			0x25
+#define VTG_EMPTY_REG			0x26
+#define SOC_DELTA_REG			0x28
+#define JEITA_SOFT_COLD_REG		0x29
+#define JEITA_SOFT_HOT_REG		0x2A
+#define VTG_MIN_REG			0x2B
+
+/* FG SHADOW registers */
+#define SHDW_FG_ESR_ACTUAL		0x20
+#define SHDW_FG_BATT_STATUS		0x60
+#define BATTERY_PROFILE_BIT		BIT(0)
+
+#define SHDW_FG_MSYS_SOC		0x61
+#define SHDW_FG_CAPACITY		0x62
+#define SHDW_FG_VTG_NOW			0x69
+#define SHDW_FG_CURR_NOW		0x6B
+#define SHDW_FG_BATT_TEMP		0x6D
+
+#define VOLTAGE_PREDICTED_REG		0x80
+#define CC_TO_SOC_COEFF			0xBA
+#define NOMINAL_CAPACITY_REG		0xBC
+#define ACTUAL_CAPACITY_REG		0xBE
+#define FG_AUTO_RECHARGE_SOC		0xD2
+#define FG_SYS_CUTOFF_V_REG		0xD3
+#define FG_CC_TO_CV_V_REG		0xD5
+#define FG_ITERM_REG			0xD9
+#define FG_THERM_C1_COEFF_REG		0xDB
+#define FG_IBATT_STANDBY_REG		0xCF
+
+#define FG_I2C_CFG_MASK			SMB1360_MASK(2, 1)
+#define FG_CFG_I2C_ADDR			0x2
+#define FG_PROFILE_A_ADDR		0x4
+#define FG_PROFILE_B_ADDR		0x6
+
+/* Constants */
+#define CURRENT_100_MA			100
+#define CURRENT_500_MA			500
+#define MAX_8_BITS			255
+#define JEITA_WORK_MS			3000
+
+#define FG_RESET_THRESHOLD_MV		50
+#define SMB1360_REV_1			0x01
+
+#define SMB1360_POWERON_DELAY_MS       2000
+#define SMB1360_FG_RESET_DELAY_MS      1500
+
+/*****************************************************************************
+ *  Log
+ ****************************************************************************/
+#define SMB1360_LOG_ENABLE 0
+
+#define smb1360_log_printk(fmt, ...) \
+    do { \
+        if (0 < SMB1360_LOG_ENABLE) { \
+            printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__); \
+        } \
+    } while(0)
+
+enum {
+	WRKRND_FG_CONFIG_FAIL = BIT(0),
+	WRKRND_BATT_DET_FAIL = BIT(1),
+	WRKRND_USB100_FAIL = BIT(2),
+	WRKRND_HARD_JEITA = BIT(3),
+};
+
+enum {
+	USER	= BIT(0),
+};
+
+enum {
+	PARALLEL_USER = BIT(0),
+	PARALLEL_CURRENT = BIT(1),
+	PARALLEL_JEITA_SOFT = BIT(2),
+	PARALLEL_JEITA_HARD = BIT(3),
+	PARALLEL_EOC = BIT(4),
+};
+
+enum fg_i2c_access_type {
+	FG_ACCESS_CFG = 0x1,
+	FG_ACCESS_PROFILE_A = 0x2,
+	FG_ACCESS_PROFILE_B = 0x3
+};
+
+enum {
+	BATTERY_PROFILE_A,
+	BATTERY_PROFILE_B,
+	BATTERY_PROFILE_MAX,
+};
+
+static int otg_curr_ma[] = {350, 550, 950, 1500};
+
+struct smb1360_otg_regulator {
+	struct regulator_desc	rdesc;
+	struct regulator_dev	*rdev;
+};
+
+void acquire_AC_charger_wakelock(void)
+{
+    if(g_ac_charger_wakelock_count==0)
+    {
+    pr_info("AC_charger wake_lock\n");
+    g_ac_charger_wakelock_count = 1;
+    wake_lock(&ac_charger_wakelock);
+    }
+}
+EXPORT_SYMBOL(acquire_AC_charger_wakelock);
+void release_AC_charger_wakelock(void)
+{
+	if(g_ac_charger_wakelock_count==1)
+	{
+	    pr_info("AC_charger wake_unlock\n");
+		g_ac_charger_wakelock_count = 0;
+		wake_unlock(&ac_charger_wakelock);
+	}
+}
+EXPORT_SYMBOL(release_AC_charger_wakelock);
+void set_android_charging_enable(void)
+{
+    android_disable_charging = 0;
+	pr_info("android_disable_charging = 0\n");
+}
+EXPORT_SYMBOL(set_android_charging_enable);
+struct smb1360_chip {
+	struct i2c_client		*client;
+	struct device			*dev;
+	u8				revision;
+	u8				soft_hot_rt_stat;
+	u8				soft_cold_rt_stat;
+	struct delayed_work		jeita_work;
+        struct delayed_work             delayed_init_work;
+	unsigned short			default_i2c_addr;
+	unsigned short			fg_i2c_addr;
+	bool				pulsed_irq;
+        struct completion               fg_mem_access_granted;
+	/* configuration data - charger */
+	int				fake_battery_soc;
+	bool				batt_id_disabled;
+	bool				charging_disabled;
+	bool				recharge_disabled;
+	bool				chg_inhibit_disabled;
+	bool				iterm_disabled;
+	bool				shdn_after_pwroff;
+	bool				config_hard_thresholds;
+	bool				soft_jeita_supported;
+	int				iterm_ma;
+	int				vfloat_mv;
+	int				safety_time;
+	int				resume_delta_mv;
+	u32				default_batt_profile;
+	unsigned int			thermal_levels;
+	unsigned int			therm_lvl_sel;
+	unsigned int			*thermal_mitigation;
+	int				otg_batt_curr_limit;
+	bool				min_icl_usb100;
+	int				cold_bat_decidegc;
+	int				hot_bat_decidegc;
+	int				suspend_voltage_empty_mv;
+	int				cool_bat_decidegc;
+	int				warm_bat_decidegc;
+	int				cool_bat_mv;
+	int				warm_bat_mv;
+	int                             hot_bat_mv;
+	int				cool_bat_ma;
+	int				warm_bat_ma;
+	int				soft_cold_thresh;
+	int				soft_hot_thresh;
+
+	/* parallel-chg params */
+	int				fastchg_current;
+	int				parallel_chg_disable_status;
+	int				max_parallel_chg_current;
+	bool				parallel_charging;
+
+	/* configuration data - fg */
+	int				soc_max;
+	int				soc_min;
+	int				delta_soc;
+	int				voltage_min_mv;
+	int				voltage_empty_mv;
+	int				batt_capacity_mah;
+	int				cc_soc_coeff;
+	int				v_cutoff_mv;
+	int				fg_iterm_ma;
+	int				fg_ibatt_standby_ma;
+	int				fg_thermistor_c1_coeff;
+	int				fg_cc_to_cv_mv;
+	int				fg_auto_recharge_soc;
+	bool				empty_soc_disabled;
+	int				fg_reset_threshold_mv;
+	bool				fg_reset_at_pon;
+	bool				rsense_10mohm;
+	bool				otg_fet_present;
+	bool				fet_gain_enabled;
+	int				otg_fet_enable_gpio;
+
+	/* status tracking */
+	int				voltage_now;
+	int				current_now;
+	int				resistance_now;
+	int				temp_now;
+	int				soc_now;
+	int				fcc_mah;
+	bool				usb_present;
+	bool				batt_present;
+	bool				batt_hot;
+	bool				batt_cold;
+	bool				batt_warm;
+	bool				batt_cool;
+	bool				batt_full;
+	bool				resume_completed;
+	bool				irq_waiting;
+	bool				empty_soc;
+	bool				awake_min_soc;
+	int				workaround_flags;
+	u8				irq_cfg_mask[3];
+	int				usb_psy_ma;
+	int				charging_disabled_status;
+	u32				connected_rid;
+	u32				profile_rid[BATTERY_PROFILE_MAX];
+
+	u32				peek_poke_address;
+	u32				fg_access_type;
+	u32				fg_peek_poke_address;
+	int				skip_writes;
+	int				skip_reads;
+	struct dentry			*debug_root;
+
+	struct qpnp_vadc_chip		*vadc_dev;
+	struct power_supply		*parallel_psy;
+	struct power_supply		*usb_psy;
+	struct power_supply		batt_psy;
+	struct smb1360_otg_regulator	otg_vreg;
+	struct mutex			irq_complete;
+	struct mutex			charging_disable_lock;
+	struct mutex			current_change_lock;
+	struct mutex			read_write_lock;
+	struct mutex			parallel_chg_lock;
+	struct work_struct		parallel_work;
+        struct mutex                    otp_gain_lock;
+        struct mutex                    fg_access_request_lock;
+	struct delayed_work abnormal_detect;//add 2015-01-06 wendu
+	struct delayed_work one_shot_delay;//mask add 2015-03-30
+};
+
+static int chg_time[] = {
+	192,
+	384,
+	768,
+	1536,
+};
+//add 
+void setAcInstat(void)
+{
+    first_AC_in = 1;
+	smb1360_log_printk("wuboadd setting first_AC_in = 1\n");
+};
+EXPORT_SYMBOL(setAcInstat);
+
+//add end
+static int input_current_limit[] = {
+	300, 400, 450, 500, 600, 700, 800, 850, 900,
+	950, 1000, 1100, 1200, 1300, 1400, 1500,
+};
+
+static int fastchg_current[] = {
+	450, 600, 750, 900, 1050, 1200, 1350, 1500,
+};
+
+static int is_between(int value, int left, int right)
+{
+	if (left >= right && left >= value && value >= right)
+		return 1;
+	if (left <= right && left <= value && value <= right)
+		return 1;
+
+	return 0;
+}
+
+static int bound(int val, int min, int max)
+{
+	if (val < min)
+		return min;
+	if (val > max)
+		return max;
+
+	return val;
+}
+
+static int __smb1360_read(struct smb1360_chip *chip, int reg,
+				u8 *val)
+{
+	s32 ret;
+
+	ret = i2c_smbus_read_byte_data(chip->client, reg);
+	if (ret < 0) {
+		dev_err(chip->dev,
+			"i2c read fail: can't read from %02x: %d\n", reg, ret);
+		return ret;
+	} else {
+		*val = ret;
+	}
+	pr_debug("Reading 0x%02x=0x%02x\n", reg, *val);
+
+	return 0;
+}
+
+static int __smb1360_write(struct smb1360_chip *chip, int reg,
+						u8 val)
+{
+	s32 ret;
+
+	ret = i2c_smbus_write_byte_data(chip->client, reg, val);
+	if (ret < 0) {
+		dev_err(chip->dev,
+			"i2c write fail: can't write %02x to %02x: %d\n",
+			val, reg, ret);
+		return ret;
+	}
+	pr_debug("Writing 0x%02x=0x%02x\n", reg, val);
+	return 0;
+}
+
+static int smb1360_read(struct smb1360_chip *chip, int reg,
+				u8 *val)
+{
+	int rc;
+
+	if (chip->skip_reads) {
+		*val = 0;
+		return 0;
+	}
+	mutex_lock(&chip->read_write_lock);
+	rc = __smb1360_read(chip, reg, val);
+	mutex_unlock(&chip->read_write_lock);
+
+	return rc;
+}
+
+static int smb1360_write(struct smb1360_chip *chip, int reg,
+						u8 val)
+{
+	int rc;
+
+	if (chip->skip_writes)
+		return 0;
+
+	mutex_lock(&chip->read_write_lock);
+	rc = __smb1360_write(chip, reg, val);
+	mutex_unlock(&chip->read_write_lock);
+
+	return rc;
+}
+
+static int smb1360_fg_read(struct smb1360_chip *chip, int reg,
+				u8 *val)
+{
+	int rc;
+
+	if (chip->skip_reads) {
+		*val = 0;
+		return 0;
+	}
+
+	mutex_lock(&chip->read_write_lock);
+	chip->client->addr = chip->fg_i2c_addr;
+	rc = __smb1360_read(chip, reg, val);
+	chip->client->addr = chip->default_i2c_addr;
+	mutex_unlock(&chip->read_write_lock);
+
+	return rc;
+}
+
+static int smb1360_fg_write(struct smb1360_chip *chip, int reg,
+						u8 val)
+{
+	int rc;
+
+	if (chip->skip_writes)
+		return 0;
+
+	mutex_lock(&chip->read_write_lock);
+	chip->client->addr = chip->fg_i2c_addr;
+	rc = __smb1360_write(chip, reg, val);
+	chip->client->addr = chip->default_i2c_addr;
+	mutex_unlock(&chip->read_write_lock);
+
+	return rc;
+}
+
+static int smb1360_read_bytes(struct smb1360_chip *chip, int reg,
+						u8 *val, u8 bytes)
+{
+	s32 rc;
+
+	if (chip->skip_reads) {
+		*val = 0;
+		return 0;
+	}
+
+	mutex_lock(&chip->read_write_lock);
+	rc = i2c_smbus_read_i2c_block_data(chip->client, reg, bytes, val);
+	if (rc < 0)
+		dev_err(chip->dev,
+			"i2c read fail: can't read %d bytes from %02x: %d\n",
+							bytes, reg, rc);
+	mutex_unlock(&chip->read_write_lock);
+
+	return (rc < 0) ? rc : 0;
+}
+//add start 2015-01-06 ic_version
+static ssize_t smb1360_icinfo_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+	struct smb1360_chip *chip = i2c_get_clientdata(client);	
+	
+	return snprintf(buf, 30,"%s %d \n","SMB1360",chip->revision);
+}
+
+DEVICE_ATTR(smb1360_icinfo, 0444, smb1360_icinfo_show, NULL);
+//add end
+
+static int smb1360_write_bytes(struct smb1360_chip *chip, int reg,
+						u8 *val, u8 bytes)
+{
+	s32 rc;
+
+	if (chip->skip_writes) {
+		*val = 0;
+		return 0;
+	}
+
+	mutex_lock(&chip->read_write_lock);
+	rc = i2c_smbus_write_i2c_block_data(chip->client, reg, bytes, val);
+	if (rc < 0)
+		dev_err(chip->dev,
+			"i2c write fail: can't read %d bytes from %02x: %d\n",
+							bytes, reg, rc);
+	mutex_unlock(&chip->read_write_lock);
+
+	return (rc < 0) ? rc : 0;
+}
+
+static int smb1360_masked_write(struct smb1360_chip *chip, int reg,
+						u8 mask, u8 val)
+{
+	s32 rc;
+	u8 temp;
+
+	if (chip->skip_writes || chip->skip_reads)
+		return 0;
+
+	mutex_lock(&chip->read_write_lock);
+	rc = __smb1360_read(chip, reg, &temp);
+	if (rc < 0) {
+		dev_err(chip->dev, "read failed: reg=%03X, rc=%d\n", reg, rc);
+		goto out;
+	}
+	temp &= ~mask;
+	temp |= val & mask;
+	rc = __smb1360_write(chip, reg, temp);
+	if (rc < 0) {
+		dev_err(chip->dev,
+			"write failed: reg=%03X, rc=%d\n", reg, rc);
+	}
+out:
+	mutex_unlock(&chip->read_write_lock);
+	return rc;
+}
+
+#define EXPONENT_MASK		0xF800
+#define MANTISSA_MASK		0x3FF
+#define SIGN_MASK		0x400
+#define EXPONENT_SHIFT		11
+#define SIGN_SHIFT		10
+#define MICRO_UNIT		1000000ULL
+static int64_t float_decode(u16 reg)
+{
+	int64_t final_val, exponent_val, mantissa_val;
+	int exponent, mantissa, n;
+	bool sign;
+
+	exponent = (reg & EXPONENT_MASK) >> EXPONENT_SHIFT;
+	mantissa = (reg & MANTISSA_MASK);
+	sign = !!(reg & SIGN_MASK);
+
+	pr_debug("exponent=%d mantissa=%d sign=%d\n", exponent, mantissa, sign);
+
+	mantissa_val = mantissa * MICRO_UNIT;
+
+	n = exponent - 15;
+	if (n < 0)
+		exponent_val = MICRO_UNIT >> -n;
+	else
+		exponent_val = MICRO_UNIT << n;
+
+	n = n - 10;
+	if (n < 0)
+		mantissa_val >>= -n;
+	else
+		mantissa_val <<= n;
+
+	final_val = exponent_val + mantissa_val;
+
+	if (sign)
+		final_val *= -1;
+
+	return final_val;
+}
+
+#define MAX_MANTISSA    (1023 * 1000000ULL)
+unsigned int float_encode(int64_t float_val)
+{
+	int exponent = 0, sign = 0;
+	unsigned int final_val = 0;
+
+	if (float_val == 0)
+		return 0;
+
+	if (float_val < 0) {
+		sign = 1;
+		float_val = -float_val;
+	}
+
+	/* Reduce large mantissa until it fits into 10 bit */
+	while (float_val >= MAX_MANTISSA) {
+		exponent++;
+		float_val >>= 1;
+	}
+
+	/* Increase small mantissa to improve precision */
+	while (float_val < MAX_MANTISSA && exponent > -25) {
+		exponent--;
+		float_val <<= 1;
+	}
+
+	exponent = exponent + 25;
+
+	/* Convert mantissa from micro-units to units */
+	float_val = div_s64((float_val + MICRO_UNIT), (int)MICRO_UNIT);
+
+	if (float_val == 1024) {
+		exponent--;
+		float_val <<= 1;
+	}
+
+	float_val -= 1024;
+
+	/* Ensure that resulting number is within range */
+	if (float_val > MANTISSA_MASK)
+		float_val = MANTISSA_MASK;
+
+	/* Convert to 5 bit exponent, 11 bit mantissa */
+	final_val = (float_val & MANTISSA_MASK) | (sign << SIGN_SHIFT) |
+		((exponent << EXPONENT_SHIFT) & EXPONENT_MASK);
+
+	return final_val;
+}
+/*
+static int smb1360_enable_fg_access(struct smb1360_chip *chip)
+{
+	int rc;
+	u8 reg = 0, timeout = 50;
+
+	rc = smb1360_masked_write(chip, CMD_I2C_REG, FG_ACCESS_ENABLED_BIT,
+							FG_ACCESS_ENABLED_BIT);
+	if (rc) {
+		pr_err("Couldn't enable FG access rc=%d\n", rc);
+		return rc;
+	}
+
+	while (timeout) {
+		// delay for FG access to be granted
+		msleep(200);
+		rc = smb1360_read(chip, IRQ_I_REG, &reg);
+		if (rc)
+			pr_err("Could't read IRQ_I_REG rc=%d\n", rc);
+		else if (reg & FG_ACCESS_ALLOWED_BIT)
+			break;
+		timeout--;
+	}
+
+	pr_debug("timeout=%d\n", timeout);
+
+	if (!timeout)
+		return -EBUSY;
+
+	return 0;
+}*/
+/*
+ * Requesting FG access relys on the FG_ACCESS_ALLOWED IRQ.
+ * This function can only be called after interrupt handler
+ * being installed successfully.
+ */
+
+/* FG reset could only be done after FG access being granted */
+static int smb1360_force_fg_reset(struct smb1360_chip *chip)
+{
+ 	int rc;
+ 
+	rc = smb1360_masked_write(chip, CMD_I2C_REG, FG_RESET_BIT,
+						FG_RESET_BIT);
+	if (rc) {
+		pr_err("Couldn't reset FG rc=%d\n", rc);
+		return rc;
+	}
+
+	msleep(SMB1360_FG_RESET_DELAY_MS);
+
+	rc = smb1360_masked_write(chip, CMD_I2C_REG, FG_RESET_BIT, 0);
+	if (rc)
+		pr_err("Couldn't un-reset FG rc=%d\n", rc);
+
+	return rc;
+}
+
+#define SMB1360_FG_ACCESS_TIMEOUT_MS	5000
+#define SMB1360_FG_ACCESS_RETRY_COUNT	3
+static int smb1360_enable_fg_access(struct smb1360_chip *chip)
+{
+	int rc = 0;
+	u8 reg, retry = SMB1360_FG_ACCESS_RETRY_COUNT;
+
+	pr_debug("request FG memory access\n");
+	/*
+	 * read the ACCESS_ALLOW status bit firstly to
+	 * check if the access was granted before
+	 */
+	mutex_lock(&chip->fg_access_request_lock);
+	pm_stay_awake(chip->dev);
+	rc = smb1360_read(chip, IRQ_I_REG, &reg);
+	if (rc) {
+		pr_err("Couldn't read IRQ_I_REG, rc=%d\n", rc);
+		goto bail_i2c;
+	} else if (reg & FG_ACCESS_ALLOWED_BIT) {
+		pr_debug("FG access was granted\n");
+		goto bail_i2c;
+	}
+
+	/* request FG access */
+	rc = smb1360_masked_write(chip, CMD_I2C_REG, FG_ACCESS_ENABLED_BIT,
+							FG_ACCESS_ENABLED_BIT);
+	if (rc) {
+		pr_err("Couldn't enable FG access rc=%d\n", rc);
+		goto bail_i2c;
+ 	}
+	while (retry--) {
+    	rc = wait_for_completion_interruptible_timeout(
+    		&chip->fg_mem_access_granted,
+    		msecs_to_jiffies(SMB1360_FG_ACCESS_TIMEOUT_MS));
+    	if (rc <= 0)
+    		pr_debug("FG access timeout, retry: %d\n", retry);
+    	else
+    		break;
+	}
+	if (rc == 0) /* timed out */
+    		rc = -ETIMEDOUT;
+    else if (rc > 0) /* completed */
+    		rc = 0;
+	/* Clear the FG access bit if request failed */		
+    if (rc < 0) {
+    	rc = smb1360_masked_write(chip, CMD_I2C_REG,
+    			FG_ACCESS_ENABLED_BIT, 0);
+    	if (rc)
+    		pr_err("Couldn't disable FG access rc=%d\n", rc);
+    }
+bail_i2c:
+    	pm_relax(chip->dev);
+    	mutex_unlock(&chip->fg_access_request_lock);
+        return rc;
+}
+
+static inline bool is_device_suspended(struct smb1360_chip *chip)
+{
+	return !chip->resume_completed;
+}
+
+static int smb1360_disable_fg_access(struct smb1360_chip *chip)
+{
+	int rc;
+
+	rc = smb1360_masked_write(chip, CMD_I2C_REG, FG_ACCESS_ENABLED_BIT, 0);
+	if (rc)
+		pr_err("Couldn't disable FG access rc=%d\n", rc);
+    INIT_COMPLETION(chip->fg_mem_access_granted);
+	return rc;
+}
+
+static int smb1360_enable_volatile_writes(struct smb1360_chip *chip)
+{
+	int rc;
+
+	rc = smb1360_masked_write(chip, CMD_I2C_REG,
+		ALLOW_VOLATILE_BIT, ALLOW_VOLATILE_BIT);
+	if (rc < 0)
+		dev_err(chip->dev,
+			"Couldn't set VOLATILE_W_PERM_BIT rc=%d\n", rc);
+
+	return rc;
+}
+
+/*patch add start*/
+int smb1360_fg_reset(void)
+{
+	int rc;
+
+	if (!the_chip) {
+		pr_err("chip not initialized\n");
+		return 0;
+	}
+
+	rc = smb1360_enable_fg_access(the_chip);
+	if (rc)
+		pr_err("Unable to enable FG access\n");
+
+	msleep(1500);
+
+	/* reset FG */
+	rc = smb1360_masked_write(the_chip, CMD_I2C_REG, FG_RESET_BIT,
+						FG_RESET_BIT);
+	if (rc) {
+		pr_err("Couldn't reset FG rc=%d\n", rc);
+		goto disable_access;
+	}
+
+	/* un-reset FG */
+	rc = smb1360_masked_write(the_chip, CMD_I2C_REG, FG_RESET_BIT, 0);
+	if (rc) {
+		pr_err("Couldn't un-reset FG rc=%d\n", rc);
+		goto disable_access;
+	}
+
+disable_access:
+	smb1360_disable_fg_access(the_chip);
+
+	msleep(1500);
+
+	return rc;
+}
+EXPORT_SYMBOL(smb1360_fg_reset);
+/*patch add end*/
+
+
+
+#define TRIM_1C_REG		0x1C
+#define CHECK_USB100_GOOD_BIT	BIT(6)
+static bool is_usb100_broken(struct smb1360_chip *chip)
+{
+	int rc;
+	u8 reg;
+
+	rc = smb1360_read(chip, TRIM_1C_REG, &reg);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't read trim 1C reg rc = %d\n", rc);
+		return rc;
+	}
+	return !!(reg & CHECK_USB100_GOOD_BIT);
+}
+
+static int read_revision(struct smb1360_chip *chip, u8 *revision)
+{
+	int rc;
+
+	*revision = 0;
+	rc = smb1360_read(chip, REVISION_CTRL_REG, revision);
+	if (rc)
+		dev_err(chip->dev, "Couldn't read REVISION_CTRL_REG rc=%d", rc);
+
+	*revision &= DEVICE_REV_MASK;
+
+	return rc;
+}
+
+#define MIN_FLOAT_MV		3460
+#define MAX_FLOAT_MV		4730
+#define VFLOAT_STEP_MV		10
+static int smb1360_float_voltage_set(struct smb1360_chip *chip, int vfloat_mv)
+{
+	u8 temp;
+
+	if ((vfloat_mv < MIN_FLOAT_MV) || (vfloat_mv > MAX_FLOAT_MV)) {
+		dev_err(chip->dev, "bad float voltage mv =%d asked to set\n",
+					vfloat_mv);
+		return -EINVAL;
+	}
+	pr_debug(" zms bad float voltage mv =%d asked to set\n", vfloat_mv);
+	temp = (vfloat_mv - MIN_FLOAT_MV) / VFLOAT_STEP_MV;
+
+	return smb1360_masked_write(chip, BATT_CHG_FLT_VTG_REG,
+				VFLOAT_MASK, temp);
+}
+
+#define MIN_RECHG_MV		50
+#define MAX_RECHG_MV		300
+static int smb1360_recharge_threshold_set(struct smb1360_chip *chip,
+							int resume_mv)
+{
+	u8 temp;
+
+	if ((resume_mv < MIN_RECHG_MV) || (resume_mv > MAX_RECHG_MV)) {
+		dev_err(chip->dev, "bad rechg_thrsh =%d asked to set\n",
+							resume_mv);
+		return -EINVAL;
+	}
+
+	temp = resume_mv / 100;
+
+	return smb1360_masked_write(chip, CFG_BATT_CHG_REG,
+		RECHG_MV_MASK, temp << RECHG_MV_SHIFT);
+}
+
+static int __smb1360_charging_disable(struct smb1360_chip *chip, bool disable)
+{
+	int rc;
+
+	rc = smb1360_masked_write(chip, CMD_CHG_REG,
+			CMD_CHG_EN, disable ? 0 : CMD_CHG_EN);
+	if (rc < 0)
+		pr_err("Couldn't set CHG_ENABLE_BIT disable=%d rc = %d\n",
+							disable, rc);
+	else
+		pr_debug("CHG_EN status=%d\n", !disable);
+
+	return rc;
+}
+
+static int smb1360_set_batt_empty_voltage(struct smb1360_chip *chip, int empty_voltage)
+{
+	int rc = 0;
+	int temp;
+	u8 reg;
+
+	if (empty_voltage != -EINVAL)
+	{
+		temp = (empty_voltage - 2500) * MAX_8_BITS;
+		reg = DIV_ROUND_UP(temp, 2500);
+		pr_debug("voltage_empty=%d reg=%x\n",
+				chip->voltage_empty_mv, reg);
+		rc = smb1360_write(chip, VTG_EMPTY_REG, reg);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't write to VTG_EMPTY_REG rc=%d\n",
+						rc);
+			return rc;
+		}
+	}
+
+	return rc;
+}
+static int smb1360_charging_disable(struct smb1360_chip *chip, int reason,
+								int disable)
+{
+	int rc = 0;
+	int disabled;
+
+	mutex_lock(&chip->charging_disable_lock);
+
+	disabled = chip->charging_disabled_status;
+
+	pr_debug("reason=%d requested_disable=%d disabled_status=%d\n",
+					reason, disable, disabled);
+
+	if (disable == true)
+		disabled |= reason;
+	else
+		disabled &= ~reason;
+
+	if (disabled)
+		rc = __smb1360_charging_disable(chip, true);
+	else
+		rc = __smb1360_charging_disable(chip, false);
+
+	if (rc)
+		pr_err("Couldn't disable charging for reason=%d rc=%d\n",
+							rc, reason);
+	else
+		chip->charging_disabled_status = disabled;
+
+	mutex_unlock(&chip->charging_disable_lock);
+
+	return rc;
+}
+
+static int smb1360_soft_jeita_comp_enable(struct smb1360_chip *chip,
+								bool enable)
+{
+	int rc = 0;
+
+	rc = smb1360_masked_write(chip, CHG_CMP_CFG, JEITA_COMP_EN_MASK,
+					enable ? JEITA_COMP_EN_BIT : 0);
+	if (rc)
+		pr_err("Couldn't %s JEITA compensation\n", enable ?
+						"enable" : "disable");
+
+	return rc;
+}
+
+static enum power_supply_property smb1360_battery_properties[] = {
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_CHARGING_ENABLED,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_RESISTANCE,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL,
+};
+
+static int smb1360_get_prop_batt_present(struct smb1360_chip *chip)
+{
+	return chip->batt_present;
+}
+
+static int smb1360_get_prop_batt_status(struct smb1360_chip *chip)
+{
+	int rc;
+	u8 reg = 0, chg_type;
+
+	if (is_device_suspended(chip))
+		return POWER_SUPPLY_STATUS_UNKNOWN;
+
+	//if (chip->batt_full)
+		//return POWER_SUPPLY_STATUS_FULL;
+
+	rc = smb1360_read(chip, STATUS_3_REG, &reg);
+	if (rc) {
+		pr_err("Couldn't read STATUS_3_REG rc=%d\n", rc);
+		return POWER_SUPPLY_STATUS_UNKNOWN;
+	}
+
+	pr_debug("STATUS_3_REG = %x\n", reg);
+
+	if (reg & CHG_HOLD_OFF_BIT)
+		return POWER_SUPPLY_STATUS_NOT_CHARGING;
+
+	chg_type = (reg & CHG_TYPE_MASK) >> CHG_TYPE_SHIFT;
+
+	if (chg_type == BATT_NOT_CHG_VAL)
+		return POWER_SUPPLY_STATUS_DISCHARGING;
+	else
+		return POWER_SUPPLY_STATUS_CHARGING;
+}
+
+static int smb1360_get_prop_charging_status(struct smb1360_chip *chip)
+{
+	int rc;
+	u8 reg = 0;
+
+	rc = smb1360_read(chip, STATUS_3_REG, &reg);
+	if (rc) {
+		pr_err("Couldn't read STATUS_3_REG rc=%d\n", rc);
+		return 0;
+	}
+
+	return (reg & CHG_EN_BIT) ? 1 : 0;
+}
+
+static int smb1360_get_prop_charge_type(struct smb1360_chip *chip)
+{
+	int rc;
+	u8 reg = 0;
+	u8 chg_type;
+
+	if (is_device_suspended(chip))
+		return POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+
+	rc = smb1360_read(chip, STATUS_3_REG, &reg);
+	if (rc) {
+		pr_err("Couldn't read STATUS_3_REG rc=%d\n", rc);
+		return POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+	}
+
+	chg_type = (reg & CHG_TYPE_MASK) >> CHG_TYPE_SHIFT;
+	if (chg_type == BATT_NOT_CHG_VAL)
+		return POWER_SUPPLY_CHARGE_TYPE_NONE;
+	else if ((chg_type == BATT_FAST_CHG_VAL) ||
+			(chg_type == BATT_TAPER_CHG_VAL))
+		return POWER_SUPPLY_CHARGE_TYPE_FAST;
+	else if (chg_type == BATT_PRE_CHG_VAL)
+		return POWER_SUPPLY_CHARGE_TYPE_TRICKLE;
+
+	return POWER_SUPPLY_CHARGE_TYPE_NONE;
+}
+
+static int smb1360_get_prop_batt_health(struct smb1360_chip *chip)
+{
+	union power_supply_propval ret = {0, };
+
+	if (chip->batt_hot)
+		ret.intval = POWER_SUPPLY_HEALTH_OVERHEAT;
+	else if (chip->batt_cold)
+		ret.intval = POWER_SUPPLY_HEALTH_COLD;
+	else if (chip->batt_warm)
+		ret.intval = POWER_SUPPLY_HEALTH_WARM;
+	else if (chip->batt_cool)
+		ret.intval = POWER_SUPPLY_HEALTH_COOL;
+	else
+		ret.intval = POWER_SUPPLY_HEALTH_GOOD;
+
+	return ret.intval;
+}
+
+static int smb1360_get_prop_batt_capacity(struct smb1360_chip *chip)
+{
+	u8 reg;
+	u32 temp = 0;
+	int rc, soc = 0;
+
+	if (chip->fake_battery_soc >= 0)
+		return chip->fake_battery_soc;
+
+	if (chip->empty_soc) {
+		pr_debug("empty_soc\n");
+		return 0;
+	}
+
+	if (is_device_suspended(chip))
+		return chip->soc_now;
+
+	rc = smb1360_read(chip, SHDW_FG_MSYS_SOC, &reg);
+	if (rc) {
+		pr_err("Failed to read FG_MSYS_SOC rc=%d\n", rc);
+		return chip->soc_now;
+	}
+	soc = (100 * reg) / MAX_8_BITS;
+
+	temp = (100 * reg) % MAX_8_BITS;
+	if (temp > (MAX_8_BITS / 2))
+		soc += 1;
+
+	pr_debug("msys_soc_reg=0x%02x, fg_soc=%d batt_full = %d\n", reg,
+						soc, chip->batt_full);
+	chip->soc_now = soc;
+	return  bound(soc, 0, 100);
+}
+
+static int smb1360_get_prop_chg_full_design(struct smb1360_chip *chip)
+{
+	u8 reg[2];
+	int rc, fcc_mah = 0;
+
+	if (is_device_suspended(chip))
+		return chip->fcc_mah;
+
+	rc = smb1360_read_bytes(chip, SHDW_FG_CAPACITY, reg, 2);
+	if (rc) {
+		pr_err("Failed to read SHDW_FG_CAPACITY rc=%d\n", rc);
+		return rc;
+	}
+	fcc_mah = (reg[1] << 8) | reg[0];
+
+	pr_debug("reg[0]=0x%02x reg[1]=0x%02x fcc_mah=%d\n",
+				reg[0], reg[1], fcc_mah);
+
+	chip->fcc_mah = fcc_mah * 1000;
+
+	return chip->fcc_mah;
+}
+
+static int smb1360_get_prop_batt_temp(struct smb1360_chip *chip)
+{
+	u8 reg[2];
+	int rc, temp = 0;
+
+	if (is_device_suspended(chip))
+		return chip->temp_now;
+
+	rc = smb1360_read_bytes(chip, SHDW_FG_BATT_TEMP, reg, 2);
+	if (rc) {
+		pr_err("Failed to read SHDW_FG_BATT_TEMP rc=%d\n", rc);
+		return rc;
+	}
+
+	temp = (reg[1] << 8) | reg[0];
+	temp = div_u64(temp * 625, 10000UL);	/* temperature in kelvin */
+	temp = (temp - 273) * 10;		/* temperature in decideg */
+
+	pr_debug("reg[0]=0x%02x reg[1]=0x%02x temperature=%d\n",
+					reg[0], reg[1], temp);
+
+	chip->temp_now = temp;
+
+	return chip->temp_now;
+}
+
+static int smb1360_get_prop_voltage_now(struct smb1360_chip *chip)
+{
+	u8 reg[2];
+	int rc, temp = 0;
+
+	if (is_device_suspended(chip))
+		return chip->voltage_now;
+
+	rc = smb1360_read_bytes(chip, SHDW_FG_VTG_NOW, reg, 2);
+	if (rc) {
+		pr_err("Failed to read SHDW_FG_VTG_NOW rc=%d\n", rc);
+		return chip->voltage_now;
+	}
+
+	temp = (reg[1] << 8) | reg[0];
+	temp = div_u64(temp * 5000, 0x7FFF);
+
+	pr_debug("reg[0]=0x%02x reg[1]=0x%02x voltage=%d\n",
+				reg[0], reg[1], temp * 1000);
+
+	chip->voltage_now = temp * 1000;
+
+	return chip->voltage_now;
+}
+
+static int smb1360_get_prop_batt_resistance(struct smb1360_chip *chip)
+{
+	u8 reg[2];
+	u16 temp;
+	int rc;
+	int64_t resistance;
+
+	if (is_device_suspended(chip))
+		return chip->resistance_now;
+
+	rc = smb1360_read_bytes(chip, SHDW_FG_ESR_ACTUAL, reg, 2);
+	if (rc) {
+		pr_err("Failed to read FG_ESR_ACTUAL rc=%d\n", rc);
+		return rc;
+	}
+	temp = (reg[1] << 8) | reg[0];
+
+	resistance = float_decode(temp) * 2;
+
+	pr_debug("reg=0x%02x resistance=%lld\n", temp, resistance);
+
+	/* resistance in uohms */
+	chip->resistance_now = resistance;
+
+	return chip->resistance_now;
+}
+
+static int smb1360_get_prop_current_now(struct smb1360_chip *chip)
+{
+	u8 reg[2];
+	int rc, temp = 0;
+
+	if (is_device_suspended(chip))
+		return chip->current_now;
+
+	rc = smb1360_read_bytes(chip, SHDW_FG_CURR_NOW, reg, 2);
+	if (rc) {
+		pr_err("Failed to read SHDW_FG_CURR_NOW rc=%d\n", rc);
+		return rc;
+	}
+
+	temp = ((s8)reg[1] << 8) | reg[0];
+	temp = div_s64(temp * 2500, 0x7FFF);
+
+	pr_debug("reg[0]=0x%02x reg[1]=0x%02x current=%d\n",
+				reg[0], reg[1], temp * 1000);
+
+	chip->current_now = temp * 1000;
+
+	return chip->current_now;
+}
+
+static int smb1360_set_minimum_usb_current(struct smb1360_chip *chip)
+{
+	int rc = 0;
+
+	if (chip->min_icl_usb100) {
+		pr_debug("USB min current set to 100mA\n");
+		/* set input current limit to minimum (300mA) */
+		rc = smb1360_masked_write(chip, CFG_BATT_CHG_ICL_REG,
+						INPUT_CURR_LIM_MASK,
+						INPUT_CURR_LIM_300MA);
+		if (rc)
+			pr_err("Couldn't set ICL mA rc=%d\n", rc);
+
+		if (!(chip->workaround_flags & WRKRND_USB100_FAIL))
+			rc = smb1360_masked_write(chip, CMD_IL_REG,
+					USB_CTRL_MASK, USB_100_BIT);
+			if (rc)
+				pr_err("Couldn't configure for USB100 rc=%d\n",
+								rc);
+	} else {
+		pr_debug("USB min current set to 500mA\n");
+		rc = smb1360_masked_write(chip, CMD_IL_REG,
+				USB_CTRL_MASK, USB_500_BIT);
+		if (rc)
+			pr_err("Couldn't configure for USB100 rc=%d\n",
+							rc);
+	}
+
+	return rc;
+}
+
+static struct power_supply *get_parallel_psy(struct smb1360_chip *chip)
+{
+	if (chip->parallel_psy)
+		return chip->parallel_psy;
+	chip->parallel_psy = power_supply_get_by_name("usb-parallel");
+	if (!chip->parallel_psy)
+		pr_debug("parallel charger not found\n");
+	return chip->parallel_psy;
+}
+
+static int __smb1360_parallel_charger_enable(struct smb1360_chip *chip,
+							bool enable)
+{
+	struct power_supply *parallel_psy = get_parallel_psy(chip);
+	union power_supply_propval pval = {0, };
+
+	if (!parallel_psy)
+		return 0;
+
+	pval.intval = (enable ? (chip->max_parallel_chg_current * 1000) : 0);
+	parallel_psy->set_property(parallel_psy,
+		POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX, &pval);
+	pval.intval = (enable ? 1 : 0);
+	parallel_psy->set_property(parallel_psy,
+		POWER_SUPPLY_PROP_CHARGING_ENABLED, &pval);
+
+	pr_debug("Parallel-charger %s max_chg_current=%d\n",
+		enable ? "enabled" : "disabled",
+		enable ? (chip->max_parallel_chg_current * 1000) : 0);
+
+	return 0;
+}
+
+static int smb1360_parallel_charger_enable(struct smb1360_chip *chip,
+						int reason, bool enable)
+{
+	int disabled, *disabled_status;
+
+	mutex_lock(&chip->parallel_chg_lock);
+
+	disabled = chip->parallel_chg_disable_status;
+	disabled_status = &chip->parallel_chg_disable_status;
+
+	pr_debug("reason=0x%x requested=%s disabled_status=0x%x\n",
+			reason, enable ? "enable" : "disable", disabled);
+
+	if (enable == true)
+		disabled &= ~reason;
+	else
+		disabled |= reason;
+
+	if (*disabled_status && !disabled)
+		__smb1360_parallel_charger_enable(chip, true);
+
+	if (!(*disabled_status) && disabled)
+		__smb1360_parallel_charger_enable(chip, false);
+
+	*disabled_status = disabled;
+
+	pr_debug("disabled_status = %x\n", *disabled_status);
+
+	mutex_unlock(&chip->parallel_chg_lock);
+
+	return 0;
+}
+
+static void smb1360_parallel_work(struct work_struct *work)
+{
+	u8 reg;
+	int rc, i;
+	struct smb1360_chip *chip = container_of(work,
+				struct smb1360_chip, parallel_work);
+
+	/* check the AICL settled value */
+	rc = smb1360_read(chip, STATUS_1_REG, &reg);
+	if (rc) {
+		pr_debug("Unable to read AICL status rc=%d\n", rc);
+		goto exit_work;
+	}
+	pr_debug("STATUS_1 (aicl status)=0x%x\n", reg);
+	if ((reg & AICL_CURRENT_STATUS_MASK) == AICL_LIMIT_1500MA) {
+		/* Strong Charger - Enable parallel path */
+		/* find the new fastchg current */
+		chip->fastchg_current += (chip->max_parallel_chg_current / 2);
+		for (i = 0; i < ARRAY_SIZE(fastchg_current) - 1;  i++) {
+			if (fastchg_current[i] >= chip->fastchg_current)
+				break;
+		}
+		if (i == ARRAY_SIZE(fastchg_current))
+			i--;
+
+		rc = smb1360_masked_write(chip, CHG_CURRENT_REG,
+			FASTCHG_CURR_MASK, i << FASTCHG_CURR_SHIFT);
+		if (rc)
+			pr_err("Couldn't set fastchg mA rc=%d\n", rc);
+
+		pr_debug("fast-chg (parallel-mode) current set to = %d\n",
+							fastchg_current[i]);
+
+		smb1360_parallel_charger_enable(chip, PARALLEL_CURRENT, true);
+	} else {
+		/* Weak-charger - Disable parallel path */
+		smb1360_parallel_charger_enable(chip, PARALLEL_CURRENT, false);
+	}
+
+exit_work:
+	pm_relax(chip->dev);
+}
+static int smb1360_change_float_voltage(struct smb1360_chip *chip){
+	int rc;
+	u8 value= 0;
+	rc = smb1360_read(chip,BATT_CHG_FLT_VTG_REG,&value);
+	if(rc){
+		pr_debug("can't read the BATT_CHG_FLT_VTG_REG\n");
+	}
+	if(value*10 + MIN_FLOAT_MV == chip->hot_bat_mv){
+		pr_debug("zms change float voltage= %d",value);
+		return rc;
+	}
+	else {
+		rc = smb1360_float_voltage_set(chip, chip->hot_bat_mv);
+		if (rc < 0) {
+			pr_debug("Couldn't set float voltage rc = %d\n", rc);
+			return rc;
+		}
+	}
+	return rc;
+}
+
+static int smb1360_change_normal_voltage(struct smb1360_chip *chip){
+	int rc;
+	u8 value= 0;
+	rc = smb1360_read(chip,BATT_CHG_FLT_VTG_REG,&value);
+	if(rc){
+		pr_debug("can't read the BATT_CHG_FLT_VTG_REG\n");
+	}
+	if(value*10 + MIN_FLOAT_MV == chip->vfloat_mv){
+		pr_debug("zms normalfloat voltage= %d",value);
+		return rc;
+	}
+	else {
+		rc = smb1360_float_voltage_set(chip, chip->vfloat_mv);
+		if (rc < 0) {
+			pr_debug("Couldn't set float voltage rc = %d\n", rc);
+			return rc;
+		}
+	}
+	return rc;
+}
+static int smb1360_set_appropriate_usb_current(struct smb1360_chip *chip)
+{
+	int rc = 0, i, therm_ma, current_ma;
+	int path_current = chip->usb_psy_ma;
+	int temperature =-1000;
+	u8  temp_data =0;
+	int current_changed = 0, fg_capacity = 0;
+	static int pre_charging_current =1;
+
+	/*
+	 * If battery is absent do not modify the current at all, these
+	 * would be some appropriate values set by the bootloader or default
+	 * configuration and since it is the only source of power we should
+	 * not change it
+	 */
+	if (!chip->batt_present) {
+		pr_debug("ignoring current request since battery is absent\n");
+		return 0;
+	}
+
+	if (chip->therm_lvl_sel > 0
+			&& chip->therm_lvl_sel < (chip->thermal_levels - 1))
+		/*
+		 * consider thermal limit only when it is active and not at
+		 * the highest level
+		 */
+		therm_ma = chip->thermal_mitigation[chip->therm_lvl_sel];
+	else
+		therm_ma = path_current;
+
+	current_ma = min(therm_ma, path_current);
+
+	if (chip->workaround_flags & WRKRND_HARD_JEITA) {
+		if (chip->batt_warm)
+			current_ma = min(current_ma, chip->warm_bat_ma);
+		else if (chip->batt_cool)
+			current_ma = min(current_ma, chip->cool_bat_ma);
+	}
+	
+	if (current_ma <= 2) {
+		/*
+		 * SMB1360 does not support USB suspend -
+		 * so set the current-limit to minimum in suspend.
+		 */
+		pr_debug("current_ma=%d <= 2 set USB current to minimum\n",
+								current_ma);
+		rc = smb1360_set_minimum_usb_current(chip);
+		if (rc < 0)
+			pr_err("Couldn't to set minimum USB current rc = %d\n",
+								rc);
+		/* disable parallel charger */
+		if (chip->parallel_charging)
+			smb1360_parallel_charger_enable(chip,
+					PARALLEL_CURRENT, false);
+
+		return rc;
+	}
+
+	for (i = ARRAY_SIZE(input_current_limit) - 1; i >= 0; i--) {
+		if (input_current_limit[i] <= current_ma)
+			break;
+	}
+	if (i < 0) {
+		pr_debug("Couldn't find ICL mA rc=%d\n", rc);
+		i = 0;
+	}
+	rc = smb1360_read(chip,CFG_BATT_CHG_ICL_REG,&temp_data);//add start
+		if (rc)
+		pr_err("read CFG_BATT_CHG_ICL_REG failed %d\n", rc);
+	/* set input current limit */
+	if(get_usbcharger_type()==4)//usb
+	{
+	     temp_data=(temp_data&0x0f) - 2;
+		if(temp_data== i)
+		{
+		}
+		else
+		{
+		rc = smb1360_masked_write(chip, CFG_BATT_CHG_ICL_REG,
+					INPUT_CURR_LIM_MASK, i + 2);
+		
+		if (rc)		
+			pr_err("Couldn't set USB ICL mA rc=%d\n", rc);
+		}
+	}
+	else if(get_usbcharger_type()==5)
+	{
+	    if((temp_data&0x0f) == i)
+		{
+		}
+		else
+		{
+	    	rc = smb1360_masked_write(chip, CFG_BATT_CHG_ICL_REG,
+					INPUT_CURR_LIM_MASK, i);
+			if (rc)
+			pr_err("Couldn't set AC ICL mA rc=%d\n", rc);
+		}
+	}
+
+	pr_debug("ICL set to = %d\n", input_current_limit[i]);
+
+	if ((current_ma <= CURRENT_100_MA) &&
+		((chip->workaround_flags & WRKRND_USB100_FAIL) ||
+				!chip->min_icl_usb100)) {
+		pr_debug("usb100 not supported: usb100_wrkrnd=%d min_icl_100=%d\n",
+			!!(chip->workaround_flags & WRKRND_USB100_FAIL),
+						chip->min_icl_usb100);
+		current_ma = CURRENT_500_MA;
+	}
+
+	fg_capacity = smb1360_get_prop_batt_capacity(chip);
+	if ((current_ma <= CURRENT_100_MA) || ((1 == first_mic) && (99 <= fg_capacity))) {
+		/* USB 100 */
+		first_AC_in = 1;
+		rc = smb1360_masked_write(chip, CMD_IL_REG,
+				USB_CTRL_MASK, USB_100_BIT);
+		if (rc)
+			pr_err("Couldn't configure for USB100 rc=%d\n", rc);
+		pr_debug("Setting USB 100\n");
+	} else if (current_ma <= CURRENT_500_MA)  {
+		/* USB 500 */
+		first_AC_in = 1;
+		rc = smb1360_masked_write(chip, CMD_IL_REG,
+				USB_CTRL_MASK, USB_500_BIT);
+		if (rc)
+			pr_err("Couldn't configure for USB500 rc=%d\n", rc);
+		pr_debug("Setting USB 500\n");
+	} else {
+		/* USB AC */
+		temperature = smb1360_get_prop_batt_temp(chip);
+		if((temperature > MIN_CHARGING_TEMPERATURE)&&(temperature <= MIDDLE_CHARGING_TEMPERATURE))
+		{
+			rc = smb1360_change_normal_voltage(chip);
+			if (rc < 0) {
+				pr_debug("Couldn't configure change foloat volatile rc = %d\n",rc);
+				return rc;
+			}
+			current_ma = CURRENT_AC_BETWEEN_00_10;
+		}
+		else if((temperature > MIDDLE_CHARGING_TEMPERATURE)&&(temperature <=MAX_CHARGING_TEMPERATURE))
+		{
+			rc = smb1360_change_normal_voltage(chip);
+			if (rc < 0) {
+				pr_debug("Couldn't configure change foloat volatile rc = %d\n",rc);
+				return rc;
+			}
+			current_ma = CURRENT_AC_BETWEEN_10_45;
+		}
+		else if (temperature>MAX_CHARGING_TEMPERATURE && temperature <OVER_CHARGING_TEMPERATURE) {
+			rc = smb1360_change_float_voltage(chip);
+			if (rc < 0) {
+				pr_debug("Couldn't configure change foloat volatile rc = %d\n",rc);
+				return rc;
+			}
+			current_ma = CURRENT_AC_BETWEEN_45_55;
+		}
+		else
+		{
+			smb1360_log_printk("wuboadd current_ma : %d temperature:%d\n",current_ma,temperature);
+		}
+
+		if(pre_charging_current!=current_ma)
+		{
+			pre_charging_current = current_ma;
+			smb1360_log_printk("charging current changed\n");
+			current_changed = 1;
+		}
+		else
+		{
+		    current_changed = 0;
+		}
+
+		smb1360_log_printk("wuboadd current_ma : %d \n",current_ma);
+		//add end zms 2015-01-06
+		if (chip->rsense_10mohm)
+			current_ma /= 2;
+
+		for (i = ARRAY_SIZE(fastchg_current) - 1; i >= 0; i--) {
+			if (fastchg_current[i] <= current_ma)
+				break;
+		}
+		if (i < 0) {
+			pr_debug("Couldn't find fastchg mA rc=%d\n", rc);
+			i = 0;
+		}
+
+		chip->fastchg_current = fastchg_current[i];
+
+		/* set fastchg limit */
+		rc = smb1360_masked_write(chip, CHG_CURRENT_REG,
+			FASTCHG_CURR_MASK, i << FASTCHG_CURR_SHIFT);
+		if (rc)
+			pr_err("Couldn't set fastchg mA rc=%d\n", rc);
+
+		/*
+		 * To move to a new (higher) input-current setting,
+		 * first set USB500 and then USBAC. This makes sure
+		 * that the new ICL setting takes affect.
+		 */
+		 if(first_AC_in == 1 || current_changed==1)
+		{
+			first_AC_in=2;
+			rc = smb1360_masked_write(chip, CMD_IL_REG,
+					USB_CTRL_MASK, USB_500_BIT);
+			if (rc)
+				pr_err("Couldn't configure for USB500 rc=%d\n", rc);
+
+			rc = smb1360_masked_write(chip, CMD_IL_REG,
+					USB_CTRL_MASK, USB_AC_BIT);
+			if (rc)
+				pr_err("Couldn't configure for USB AC rc=%d\n", rc);
+
+			pr_debug("fast-chg current set to = %d\n", fastchg_current[i]);
+		}
+	}
+	return rc;
+	
+}
+
+void smb1360_set_usb_current_call(int current_limit_enable)
+{
+
+    struct smb1360_chip *chip = smb1360_chip_global;
+    int charger_type = 0;
+    int rc = 0, fg_capacity = 0;
+    u8 temp_data = 0;
+
+    first_mic = current_limit_enable;
+    charger_type = get_usbcharger_type();
+    pr_debug("current_limit_enable=%d\n", current_limit_enable);
+    fg_capacity = smb1360_get_prop_batt_capacity(chip);
+    if (((5 == charger_type) || (4 == charger_type)) && (99 <= fg_capacity)) {
+        rc = smb1360_read(chip,CMD_IL_REG,&temp_data);
+        if (rc)
+            pr_err("read CMD_IL_REG failed %d\n", rc);
+        temp_data = temp_data & 0x03;
+        pr_debug("read CMD_IL_REG 0x41=%d\n", temp_data);
+
+        if ((1 == current_limit_enable) && (0x01 != temp_data)){
+            rc = smb1360_masked_write(chip, CMD_IL_REG,
+                    USB_CTRL_MASK, USB_100_BIT);
+            if (rc)
+                pr_err("Call Couldn't configure for USB100 rc=%d\n", rc);
+            pr_debug("Call config for USB100\n");
+        } else if (0 == current_limit_enable){
+            if (4 == charger_type) {
+                rc = smb1360_masked_write(chip, CMD_IL_REG,
+                        USB_CTRL_MASK, USB_500_BIT);
+                if (rc)
+                    pr_err("Call Couldn't configure for USB 500 rc=%d\n", rc);
+                pr_debug("Call config for USB 500\n");
+             }
+               else if (5 == charger_type) {
+                 rc = smb1360_masked_write(chip, CMD_IL_REG,
+                        USB_CTRL_MASK, USB_AC_BIT);
+                if (rc)
+                    pr_err("Call Couldn't configure for USB AC rc=%d\n", rc);
+                pr_debug("Call config for USB AC\n");
+               }
+        }
+    }
+
+    return ;
+}
+EXPORT_SYMBOL(smb1360_set_usb_current_call);
+
+static int smb1360_set_jeita_comp_curr(struct smb1360_chip *chip,
+							int current_ma)
+{
+	int i;
+	int rc = 0;
+
+	for (i = ARRAY_SIZE(fastchg_current) - 1; i >= 0; i--) {
+		if (fastchg_current[i] <= current_ma)
+			break;
+	}
+	if (i < 0) {
+		pr_debug("Couldn't find fastchg_current %dmA\n", current_ma);
+		i = 0;
+	}
+
+	rc = smb1360_masked_write(chip, CHG_CMP_CFG,
+			JEITA_COMP_CURR_MASK, i);
+	if (rc)
+		pr_err("Couldn't configure for Icomp, rc = %d\n", rc);
+
+	return rc;
+}
+
+#define TEMP_THRE_SET(x) ((x + 300) / 10)
+static int smb1360_set_soft_jeita_threshold(struct smb1360_chip *chip,
+					int cold_threshold, int hot_threshold)
+{
+	int rc = 0;
+
+	rc = smb1360_write(chip, JEITA_SOFT_COLD_REG,
+				TEMP_THRE_SET(cold_threshold));
+	if (rc) {
+		pr_err("Couldn't set cold threshold, rc = %d\n", rc);
+		return rc;
+	} else {
+		chip->soft_cold_thresh = cold_threshold;
+	}
+
+	rc = smb1360_write(chip, JEITA_SOFT_HOT_REG,
+				TEMP_THRE_SET(hot_threshold));
+	if (rc) {
+		pr_err("Couldn't set hot threshold, rc = %d\n", rc);
+		return rc;
+	} else {
+		chip->soft_hot_thresh = hot_threshold;
+	}
+
+	return rc;
+}
+
+static int smb1360_system_temp_level_set(struct smb1360_chip *chip,
+							int lvl_sel)
+{
+	int rc = 0;
+	int prev_therm_lvl;
+
+	if (!chip->thermal_mitigation) {
+		pr_err("Thermal mitigation not supported\n");
+		return -EINVAL;
+	}
+
+	if (lvl_sel < 0) {
+		pr_err("Unsupported level selected %d\n", lvl_sel);
+		return -EINVAL;
+	}
+
+	if (lvl_sel >= chip->thermal_levels) {
+		pr_err("Unsupported level selected %d forcing %d\n", lvl_sel,
+				chip->thermal_levels - 1);
+		lvl_sel = chip->thermal_levels - 1;
+	}
+
+	if (lvl_sel == chip->therm_lvl_sel)
+		return 0;
+
+	mutex_lock(&chip->current_change_lock);
+	prev_therm_lvl = chip->therm_lvl_sel;
+	chip->therm_lvl_sel = lvl_sel;
+
+	if (chip->therm_lvl_sel == (chip->thermal_levels - 1)) {
+		rc = smb1360_set_minimum_usb_current(chip);
+		if (rc)
+			pr_err("Couldn't set USB current to minimum rc = %d\n",
+							rc);
+	} else {
+		rc = smb1360_set_appropriate_usb_current(chip);
+		if (rc)
+			pr_err("Couldn't set USB current rc = %d\n", rc);
+	}
+
+	mutex_unlock(&chip->current_change_lock);
+	return rc;
+}
+
+static int smb1360_battery_set_property(struct power_supply *psy,
+				       enum power_supply_property prop,
+				       const union power_supply_propval *val)
+{
+	struct smb1360_chip *chip = container_of(psy,
+				struct smb1360_chip, batt_psy);
+
+	switch (prop) {
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		smb1360_charging_disable(chip, USER, !val->intval);
+		android_disable_charging = !val->intval;
+		if (chip->parallel_charging)
+			smb1360_parallel_charger_enable(chip,
+				PARALLEL_USER, val->intval);
+		power_supply_changed(&chip->batt_psy);
+		power_supply_changed(chip->usb_psy);
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		chip->fake_battery_soc = val->intval;
+		pr_info("fake_soc set to %d\n", chip->fake_battery_soc);
+		power_supply_changed(&chip->batt_psy);
+		break;
+	case POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL:
+		smb1360_system_temp_level_set(chip, val->intval);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int smb1360_battery_is_writeable(struct power_supply *psy,
+				       enum power_supply_property prop)
+{
+	int rc;
+
+	switch (prop) {
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+	case POWER_SUPPLY_PROP_CAPACITY:
+	case POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL:
+		rc = 1;
+		break;
+	default:
+		rc = 0;
+		break;
+	}
+	return rc;
+}
+
+static int smb1360_battery_get_property(struct power_supply *psy,
+				       enum power_supply_property prop,
+				       union power_supply_propval *val)
+{
+	struct smb1360_chip *chip = container_of(psy,
+				struct smb1360_chip, batt_psy);
+
+	switch (prop) {
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = smb1360_get_prop_batt_health(chip);
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = smb1360_get_prop_batt_present(chip);
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = smb1360_get_prop_batt_status(chip);
+		break;
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		val->intval = smb1360_get_prop_charging_status(chip);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		val->intval = smb1360_get_prop_charge_type(chip);
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = smb1360_get_prop_batt_capacity(chip);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		val->intval = smb1360_get_prop_chg_full_design(chip);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = smb1360_get_prop_voltage_now(chip);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = smb1360_get_prop_current_now(chip);
+		break;
+	case POWER_SUPPLY_PROP_RESISTANCE:
+		val->intval = smb1360_get_prop_batt_resistance(chip);
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = smb1360_get_prop_batt_temp(chip);
+		break;
+	case POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL:
+		val->intval = chip->therm_lvl_sel;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void smb1360_external_power_changed(struct power_supply *psy)
+{
+	struct smb1360_chip *chip = container_of(psy,struct smb1360_chip, batt_psy);
+	union power_supply_propval prop = {0,};
+	int rc, current_limit = 0;
+
+	rc = chip->usb_psy->get_property(chip->usb_psy,	POWER_SUPPLY_PROP_CURRENT_MAX, &prop);
+	if (rc < 0)
+		dev_err(chip->dev,
+			"could not read USB current_max property, rc=%d\n", rc);
+	else
+		current_limit = prop.intval / 1000;
+	pr_debug("current_limit = %d\n", current_limit);
+	if (chip->usb_psy_ma != current_limit) {
+		mutex_lock(&chip->current_change_lock);
+		chip->usb_psy_ma = current_limit;
+		rc = smb1360_set_appropriate_usb_current(chip);
+		if (rc < 0)
+			pr_err("Couldn't set usb current rc = %d\n", rc);
+		mutex_unlock(&chip->current_change_lock);
+	}
+
+	rc = chip->usb_psy->get_property(chip->usb_psy,
+				POWER_SUPPLY_PROP_ONLINE, &prop);
+	if (rc < 0)
+		pr_err("could not read USB ONLINE property, rc=%d\n", rc);
+
+	/* update online property */
+	rc = 0;
+	if (chip->usb_present && !chip->charging_disabled_status
+					&& chip->usb_psy_ma != 0) {
+		if (prop.intval == 0)
+			rc = power_supply_set_online(chip->usb_psy, true);
+	} else {
+		if (prop.intval == 1)
+			rc = power_supply_set_online(chip->usb_psy, false);
+	}
+	if (rc < 0)
+		pr_err("could not set usb online, rc=%d\n", rc);
+}
+
+static int hot_hard_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+	chip->batt_hot = !!rt_stat;
+
+	if (chip->parallel_charging) {
+		pr_debug("%s parallel-charging\n", chip->batt_hot ?
+					"Disable" : "Enable");
+		smb1360_parallel_charger_enable(chip,
+				PARALLEL_JEITA_HARD, !chip->batt_hot);
+	}
+
+	return 0;
+}
+
+static int cold_hard_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+	chip->batt_cold = !!rt_stat;
+
+	if (chip->parallel_charging) {
+		pr_debug("%s parallel-charging\n", chip->batt_cold ?
+					"Disable" : "Enable");
+		smb1360_parallel_charger_enable(chip,
+				PARALLEL_JEITA_HARD, !chip->batt_cold);
+	}
+
+	return 0;
+}
+
+/*
+ * This worker thread should only be called when WRKRND_HARD_JEITA
+ * is set.
+ * It is needed to re-program JEITA soft thresholds, compensate
+ * target voltage and charging current manually.
+ * The function is required as JEITA hard thresholds can't be programmed.
+*/
+static void smb1360_jeita_work_fn(struct work_struct *work)
+{
+	int temp;
+	int rc = 0;
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct smb1360_chip *chip = container_of(dwork, struct smb1360_chip,
+							jeita_work);
+	temp = smb1360_get_prop_batt_temp(chip);
+
+	if (temp > chip->hot_bat_decidegc) {
+		/* battery status is hot, only config thresholds */
+		rc = smb1360_set_soft_jeita_threshold(chip,
+			chip->warm_bat_decidegc, chip->hot_bat_decidegc);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set jeita threshold\n");
+			goto end;
+		}
+	} else if (temp > chip->warm_bat_decidegc ||
+		(temp == chip->warm_bat_decidegc && !!chip->soft_hot_rt_stat)) {
+		/* battery status is warm, do compensation manually */
+		chip->batt_warm = true;
+		chip->batt_cool = false;
+		rc = smb1360_float_voltage_set(chip, chip->warm_bat_mv);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set float voltage\n");
+			goto end;
+		}
+		rc = smb1360_set_appropriate_usb_current(chip);
+		if (rc)
+			pr_err("Couldn't set USB current\n");
+		rc = smb1360_set_soft_jeita_threshold(chip,
+			chip->warm_bat_decidegc, chip->hot_bat_decidegc);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set jeita threshold\n");
+			goto end;
+		}
+	} else if (temp > chip->cool_bat_decidegc ||
+		(temp == chip->cool_bat_decidegc && !chip->soft_cold_rt_stat)) {
+		/* battery status is good, do the normal charging */
+		chip->batt_warm = false;
+		chip->batt_cool = false;
+		rc = smb1360_float_voltage_set(chip, chip->vfloat_mv);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set float voltage\n");
+			goto end;
+		}
+		rc = smb1360_set_appropriate_usb_current(chip);
+		if (rc)
+			pr_err("Couldn't set USB current\n");
+		rc = smb1360_set_soft_jeita_threshold(chip,
+			chip->cool_bat_decidegc, chip->warm_bat_decidegc);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set jeita threshold\n");
+			goto end;
+		}
+	} else if (temp > chip->cold_bat_decidegc) {
+		/* battery status is cool, do compensation manually */
+		chip->batt_cool = true;
+		chip->batt_warm = false;
+		rc = smb1360_float_voltage_set(chip, chip->cool_bat_mv);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set float voltage\n");
+			goto end;
+		}
+		rc = smb1360_set_soft_jeita_threshold(chip,
+			chip->cold_bat_decidegc, chip->cool_bat_decidegc);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set jeita threshold\n");
+			goto end;
+		}
+	} else {
+		/* battery status is cold, only config thresholds */
+		rc = smb1360_set_soft_jeita_threshold(chip,
+			chip->cold_bat_decidegc, chip->cool_bat_decidegc);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set jeita threshold\n");
+			goto end;
+		}
+	}
+
+	pr_debug("warm %d, cool %d, soft_cold_rt_sts %d, soft_hot_rt_sts %d, jeita supported %d, threshold_now %d %d\n",
+		chip->batt_warm, chip->batt_cool, !!chip->soft_cold_rt_stat,
+		!!chip->soft_hot_rt_stat, chip->soft_jeita_supported,
+		chip->soft_cold_thresh, chip->soft_hot_thresh);
+end:
+	pm_relax(chip->dev);
+}
+
+static int hot_soft_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	chip->soft_hot_rt_stat = rt_stat;
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+	if (!chip->config_hard_thresholds)
+		chip->batt_warm = !!rt_stat;
+
+	if (chip->workaround_flags & WRKRND_HARD_JEITA) {
+		cancel_delayed_work_sync(&chip->jeita_work);
+		schedule_delayed_work(&chip->jeita_work,
+					msecs_to_jiffies(JEITA_WORK_MS));
+		pm_stay_awake(chip->dev);
+	}
+
+	if (chip->parallel_charging) {
+		pr_debug("%s parallel-charging\n", chip->batt_warm ?
+					"Disable" : "Enable");
+		smb1360_parallel_charger_enable(chip,
+				PARALLEL_JEITA_SOFT, !chip->batt_warm);
+	}
+	return 0;
+}
+
+static int cold_soft_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	chip->soft_cold_rt_stat = rt_stat;
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+	if (!chip->config_hard_thresholds)
+		chip->batt_cool = !!rt_stat;
+
+	if (chip->workaround_flags & WRKRND_HARD_JEITA) {
+		cancel_delayed_work_sync(&chip->jeita_work);
+		schedule_delayed_work(&chip->jeita_work,
+					msecs_to_jiffies(JEITA_WORK_MS));
+		pm_stay_awake(chip->dev);
+	}
+
+	if (chip->parallel_charging) {
+		pr_debug("%s parallel-charging\n", chip->batt_cool ?
+					"Disable" : "Enable");
+		smb1360_parallel_charger_enable(chip,
+				PARALLEL_JEITA_SOFT, !chip->batt_cool);
+	}
+
+	return 0;
+}
+
+static int battery_missing_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+	chip->batt_present = !rt_stat;
+	return 0;
+}
+
+static int vbat_low_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("vbat low\n");
+
+	return 0;
+}
+
+static int chg_hot_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_warn_ratelimited("chg hot\n");
+	return 0;
+}
+
+static int chg_term_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+	chip->batt_full = !!rt_stat;
+
+	if (chip->parallel_charging) {
+		pr_debug("%s parallel-charging\n", chip->batt_full ?
+					"Disable" : "Enable");
+		smb1360_parallel_charger_enable(chip,
+				PARALLEL_EOC, !chip->batt_full);
+	}
+
+	return 0;
+}
+
+static int chg_fastchg_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+
+	return 0;
+}
+
+static int usbin_uv_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	bool usb_present = !rt_stat;
+
+	pr_debug("chip->usb_present = %d usb_present = %d\n",
+				chip->usb_present, usb_present);
+	if (chip->usb_present && !usb_present) {
+		/* USB removed */
+		chip->usb_present = usb_present;
+		power_supply_set_present(chip->usb_psy, usb_present);
+	}
+
+	if (!chip->usb_present && usb_present) {
+		/* USB inserted */
+		chip->usb_present = usb_present;
+		power_supply_set_present(chip->usb_psy, usb_present);
+	}
+
+	return 0;
+}
+
+static int aicl_done_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	bool aicl_done = !!rt_stat;
+
+	pr_debug("AICL done=%d\n", aicl_done);
+
+	if (chip->parallel_charging && aicl_done) {
+		cancel_work_sync(&chip->parallel_work);
+		pm_stay_awake(chip->dev);
+		schedule_work(&chip->parallel_work);
+	}
+
+	return 0;
+}
+
+static int chg_inhibit_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	/*
+	 * charger is inserted when the battery voltage is high
+	 * so h/w won't start charging just yet. Treat this as
+	 * battery full
+	 */
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+	chip->batt_full = !!rt_stat;
+	return 0;
+}
+
+static int delta_soc_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("SOC changed! - rt_stat = 0x%02x\n", rt_stat);
+
+	return 0;
+}
+
+static int min_soc_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("SOC dropped below min SOC, rt_stat = 0x%02x\n", rt_stat);
+
+	if (chip->awake_min_soc)
+		rt_stat ? pm_stay_awake(chip->dev) : pm_relax(chip->dev);
+
+	return 0;
+}
+
+static int empty_soc_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("SOC empty! rt_stat = 0x%02x\n", rt_stat);
+
+	if (!chip->empty_soc_disabled) {
+		if (rt_stat) {
+			chip->empty_soc = true;
+			pm_stay_awake(chip->dev);
+			pr_warn_ratelimited("SOC is 0\n");
+		} else {
+			chip->empty_soc = false;
+			pm_relax(chip->dev);
+		}
+	}
+
+	return 0;
+}
+
+static int full_soc_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	if (rt_stat)
+		pr_debug("SOC is 100\n");
+
+	return 0;
+}
+
+static int fg_access_allowed_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("stat=%d\n", !!rt_stat);
+
+        if (rt_stat & FG_ACCESS_ALLOWED_BIT) {
+            pr_debug("FG access granted\n");
+            complete_all(&chip->fg_mem_access_granted);
+       }
+	return 0;
+}
+
+static int batt_id_complete_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("batt_id = %x\n", (rt_stat & BATT_ID_RESULT_BIT)
+						>> BATT_ID_SHIFT);
+
+	return 0;
+}
+
+static int smb1360_select_fg_i2c_address(struct smb1360_chip *chip)
+{
+	unsigned short addr = chip->default_i2c_addr << 0x1;
+
+	switch (chip->fg_access_type) {
+	case FG_ACCESS_CFG:
+		addr = (addr & ~FG_I2C_CFG_MASK) | FG_CFG_I2C_ADDR;
+		break;
+	case FG_ACCESS_PROFILE_A:
+		addr = (addr & ~FG_I2C_CFG_MASK) | FG_PROFILE_A_ADDR;
+		break;
+	case FG_ACCESS_PROFILE_B:
+		addr = (addr & ~FG_I2C_CFG_MASK) | FG_PROFILE_B_ADDR;
+		break;
+	default:
+		pr_err("Invalid FG access type=%d\n", chip->fg_access_type);
+		return -EINVAL;
+	}
+
+	chip->fg_i2c_addr = addr >> 0x1;
+	pr_debug("FG_access_type=%d fg_i2c_addr=%x\n", chip->fg_access_type,
+							chip->fg_i2c_addr);
+
+	return 0;
+}
+
+static int smb1360_adjust_current_gain(struct smb1360_chip *chip,
+							int gain_factor)
+{
+	int i, rc;
+	int64_t current_gain, new_current_gain;
+	u8 reg[2];
+	u16 reg_value1 = 0, reg_value2 = 0;
+	u8 reg_val_mapping[][2] = {
+			{0xE0, 0x1D},
+			{0xE1, 0x00},
+			{0xE2, 0x1E},
+			{0xE3, 0x00},
+			{0xE4, 0x00},
+			{0xE5, 0x00},
+			{0xE6, 0x00},
+			{0xE7, 0x00},
+			{0xE8, 0x00},
+			{0xE9, 0x00},
+			{0xEA, 0x00},
+			{0xEB, 0x00},
+			{0xEC, 0x00},
+			{0xED, 0x00},
+			{0xEF, 0x00},
+			{0xF0, 0x50},
+			{0xF1, 0x00},
+	};
+
+	if (gain_factor) {
+		rc = smb1360_fg_read(chip, CURRENT_GAIN_LSB_REG, &reg[0]);
+		if (rc) {
+			pr_err("Unable to set FG access I2C address rc=%d\n",
+									rc);
+			return rc;
+		}
+
+		rc = smb1360_fg_read(chip, CURRENT_GAIN_MSB_REG, &reg[1]);
+		if (rc) {
+			pr_err("Unable to set FG access I2C address rc=%d\n",
+									rc);
+			return rc;
+		}
+
+		reg_value1 = (reg[1] << 8) | reg[0];
+		current_gain = float_decode(reg_value1);
+		new_current_gain = MICRO_UNIT  + (gain_factor * current_gain);
+		reg_value2 = float_encode(new_current_gain);
+		reg[0] = reg_value2 & 0xFF;
+		reg[1] = (reg_value2 & 0xFF00) >> 8;
+		pr_debug("current_gain_reg=0x%x current_gain_decoded=%lld new_current_gain_decoded=%lld new_current_gain_reg=0x%x\n",
+			reg_value1, current_gain, new_current_gain, reg_value2);
+
+		for (i = 0; i < ARRAY_SIZE(reg_val_mapping); i++) {
+			if (reg_val_mapping[i][0] == 0xE1)
+				reg_val_mapping[i][1] = reg[0];
+			if (reg_val_mapping[i][0] == 0xE3)
+				reg_val_mapping[i][1] = reg[1];
+
+			pr_debug("Writing reg_add=%x value=%x\n",
+				reg_val_mapping[i][0], reg_val_mapping[i][1]);
+
+			rc = smb1360_fg_write(chip, reg_val_mapping[i][0],
+					reg_val_mapping[i][1]);
+			if (rc) {
+				pr_err("Write fg address 0x%x failed, rc = %d\n",
+						reg_val_mapping[i][0], rc);
+				return rc;
+			}
+		}
+	} else {
+		pr_debug("Disabling gain correction\n");
+		rc = smb1360_fg_write(chip, 0xF0, 0x00);
+		if (rc) {
+			pr_err("Write fg address 0x%x failed, rc = %d\n",
+								0xF0, rc);
+			return rc;
+		}
+	}
+
+	return 0;
+}
+
+static int smb1360_otp_gain_config(struct smb1360_chip *chip, int gain_factor)
+{
+	int rc = 0;
+
+	rc = smb1360_enable_fg_access(chip);
+	if (rc) {
+		pr_err("Couldn't request FG access rc = %d\n", rc);
+		return rc;
+	}
+	chip->fg_access_type = FG_ACCESS_CFG;
+
+	rc = smb1360_select_fg_i2c_address(chip);
+	if (rc) {
+		pr_err("Unable to set FG access I2C address\n");
+		goto restore_fg;
+	}
+
+	rc = smb1360_adjust_current_gain(chip, gain_factor);
+	if (rc) {
+		pr_err("Unable to modify current gain rc=%d\n", rc);
+		goto restore_fg;
+	}
+
+	rc = smb1360_masked_write(chip, CFG_FG_BATT_CTRL_REG,
+			CFG_FG_OTP_BACK_UP_ENABLE, CFG_FG_OTP_BACK_UP_ENABLE);
+	if (rc) {
+		pr_err("Write reg 0x0E failed, rc = %d\n", rc);
+		goto restore_fg;
+	}
+
+restore_fg:
+	rc = smb1360_disable_fg_access(chip);
+	if (rc) {
+		pr_err("Couldn't disable FG access rc = %d\n", rc);
+		return rc;
+	}
+
+	return rc;
+}
+
+static int smb1360_otg_disable(struct smb1360_chip *chip)
+{
+	int rc;
+
+	rc = smb1360_masked_write(chip, CMD_CHG_REG, CMD_OTG_EN_BIT, 0);
+	if (rc) {
+		pr_err("Couldn't disable OTG mode rc=%d\n", rc);
+		return rc;
+	}
+        mutex_lock(&chip->otp_gain_lock);
+	/* Disable current gain configuration */
+	if (chip->otg_fet_present && chip->fet_gain_enabled) {
+		/* Disable FET */
+		gpio_set_value(chip->otg_fet_enable_gpio, 1);
+		rc = smb1360_otp_gain_config(chip, 0);
+		if (rc < 0)
+			pr_err("Couldn't config OTP gain config rc=%d\n", rc);
+		else
+			chip->fet_gain_enabled = false;
+	}
+        mutex_unlock(&chip->otp_gain_lock);
+	return rc;
+}
+
+static int otg_fail_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	int rc;
+
+	pr_debug("OTG Failed stat=%d\n", rt_stat);
+	rc = smb1360_otg_disable(chip);
+	if (rc)
+		pr_err("Couldn't disable OTG mode rc=%d\n", rc);
+
+	return 0;
+}
+
+static int otg_oc_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	int rc;
+
+	pr_debug("OTG over-current stat=%d\n", rt_stat);
+	rc = smb1360_otg_disable(chip);
+	if (rc)
+		pr_err("Couldn't disable OTG mode rc=%d\n", rc);
+
+	return 0;
+}
+
+struct smb_irq_info {
+	const char		*name;
+	int			(*smb_irq)(struct smb1360_chip *chip,
+							u8 rt_stat);
+	int			high;
+	int			low;
+};
+
+struct irq_handler_info {
+	u8			stat_reg;
+	u8			val;
+	u8			prev_val;
+	struct smb_irq_info	irq_info[4];
+};
+
+static struct irq_handler_info handlers[] = {
+	{IRQ_A_REG, 0, 0,
+		{
+			{
+				.name		= "cold_soft",
+				.smb_irq	= cold_soft_handler,
+			},
+			{
+				.name		= "hot_soft",
+				.smb_irq	= hot_soft_handler,
+			},
+			{
+				.name		= "cold_hard",
+				.smb_irq	= cold_hard_handler,
+			},
+			{
+				.name		= "hot_hard",
+				.smb_irq	= hot_hard_handler,
+			},
+		},
+	},
+	{IRQ_B_REG, 0, 0,
+		{
+			{
+				.name		= "chg_hot",
+				.smb_irq	= chg_hot_handler,
+			},
+			{
+				.name		= "vbat_low",
+				.smb_irq	= vbat_low_handler,
+			},
+			{
+				.name		= "battery_missing",
+				.smb_irq	= battery_missing_handler,
+			},
+			{
+				.name		= "battery_missing",
+				.smb_irq	= battery_missing_handler,
+			},
+		},
+	},
+	{IRQ_C_REG, 0, 0,
+		{
+			{
+				.name		= "chg_term",
+				.smb_irq	= chg_term_handler,
+			},
+			{
+				.name		= "taper",
+			},
+			{
+				.name		= "recharge",
+			},
+			{
+				.name		= "fast_chg",
+				.smb_irq	= chg_fastchg_handler,
+			},
+		},
+	},
+	{IRQ_D_REG, 0, 0,
+		{
+			{
+				.name		= "prechg_timeout",
+			},
+			{
+				.name		= "safety_timeout",
+			},
+			{
+				.name		= "aicl_done",
+				.smb_irq	= aicl_done_handler,
+			},
+			{
+				.name		= "battery_ov",
+			},
+		},
+	},
+	{IRQ_E_REG, 0, 0,
+		{
+			{
+				.name		= "usbin_uv",
+				.smb_irq	= usbin_uv_handler,
+			},
+			{
+				.name		= "usbin_ov",
+			},
+			{
+				.name		= "unused",
+			},
+			{
+				.name		= "chg_inhibit",
+				.smb_irq	= chg_inhibit_handler,
+			},
+		},
+	},
+	{IRQ_F_REG, 0, 0,
+		{
+			{
+				.name		= "power_ok",
+			},
+			{
+				.name		= "unused",
+			},
+			{
+				.name		= "otg_fail",
+				.smb_irq	= otg_fail_handler,
+			},
+			{
+				.name		= "otg_oc",
+				.smb_irq	= otg_oc_handler,
+			},
+		},
+	},
+	{IRQ_G_REG, 0, 0,
+		{
+			{
+				.name		= "delta_soc",
+				.smb_irq	= delta_soc_handler,
+			},
+			{
+				.name		= "chg_error",
+			},
+			{
+				.name		= "wd_timeout",
+			},
+			{
+				.name		= "unused",
+			},
+		},
+	},
+	{IRQ_H_REG, 0, 0,
+		{
+			{
+				.name		= "min_soc",
+				.smb_irq	= min_soc_handler,
+			},
+			{
+				.name		= "max_soc",
+			},
+			{
+				.name		= "empty_soc",
+				.smb_irq	= empty_soc_handler,
+			},
+			{
+				.name		= "full_soc",
+				.smb_irq	= full_soc_handler,
+			},
+		},
+	},
+	{IRQ_I_REG, 0, 0,
+		{
+			{
+				.name		= "fg_access_allowed",
+				.smb_irq	= fg_access_allowed_handler,
+			},
+			{
+				.name		= "fg_data_recovery",
+			},
+			{
+				.name		= "batt_id_complete",
+				.smb_irq	= batt_id_complete_handler,
+			},
+		},
+	},
+};
+
+#define IRQ_LATCHED_MASK	0x02
+#define IRQ_STATUS_MASK		0x01
+#define BATT_ID_LATCHED_MASK	0x08
+#define BATT_ID_STATUS_MASK	0x07
+#define BITS_PER_IRQ		2
+static irqreturn_t smb1360_stat_handler(int irq, void *dev_id)
+{
+	struct smb1360_chip *chip = dev_id;
+	int i, j;
+	u8 triggered;
+	u8 changed;
+	u8 rt_stat, prev_rt_stat, irq_latched_mask, irq_status_mask;
+	int rc;
+	int handler_count = 0;
+
+	mutex_lock(&chip->irq_complete);
+	chip->irq_waiting = true;
+	if (!chip->resume_completed) {
+		dev_dbg(chip->dev, "IRQ triggered before device-resume\n");
+		disable_irq_nosync(irq);
+		mutex_unlock(&chip->irq_complete);
+		return IRQ_HANDLED;
+	}
+	chip->irq_waiting = false;
+
+	for (i = 0; i < ARRAY_SIZE(handlers); i++) {
+		rc = smb1360_read(chip, handlers[i].stat_reg,
+					&handlers[i].val);
+		if (rc < 0) {
+			dev_err(chip->dev, "Couldn't read %d rc = %d\n",
+					handlers[i].stat_reg, rc);
+			continue;
+		}
+
+		for (j = 0; j < ARRAY_SIZE(handlers[i].irq_info); j++) {
+			if (handlers[i].stat_reg == IRQ_I_REG && j == 2) {
+				irq_latched_mask = BATT_ID_LATCHED_MASK;
+				irq_status_mask = BATT_ID_STATUS_MASK;
+			} else {
+				irq_latched_mask = IRQ_LATCHED_MASK;
+				irq_status_mask = IRQ_STATUS_MASK;
+			}
+			triggered = handlers[i].val
+			       & (irq_latched_mask << (j * BITS_PER_IRQ));
+			rt_stat = handlers[i].val
+				& (irq_status_mask << (j * BITS_PER_IRQ));
+			prev_rt_stat = handlers[i].prev_val
+				& (irq_status_mask << (j * BITS_PER_IRQ));
+			changed = prev_rt_stat ^ rt_stat;
+
+			if (triggered || changed)
+				rt_stat ? handlers[i].irq_info[j].high++ :
+						handlers[i].irq_info[j].low++;
+
+			if ((triggered || changed)
+				&& handlers[i].irq_info[j].smb_irq != NULL) {
+				handler_count++;
+				rc = handlers[i].irq_info[j].smb_irq(chip,
+								rt_stat);
+				if (rc < 0)
+					dev_err(chip->dev,
+						"Couldn't handle %d irq for reg 0x%02x rc = %d\n",
+						j, handlers[i].stat_reg, rc);
+			}
+		}
+		handlers[i].prev_val = handlers[i].val;
+	}
+
+	pr_debug("handler count = %d\n", handler_count);
+	if (handler_count)
+		power_supply_changed(&chip->batt_psy);
+
+	mutex_unlock(&chip->irq_complete);
+
+	return IRQ_HANDLED;
+}
+
+static int show_irq_count(struct seq_file *m, void *data)
+{
+	int i, j, total = 0;
+
+	for (i = 0; i < ARRAY_SIZE(handlers); i++)
+		for (j = 0; j < 4; j++) {
+			if (!handlers[i].irq_info[j].name)
+				continue;
+			seq_printf(m, "%s=%d\t(high=%d low=%d)\n",
+						handlers[i].irq_info[j].name,
+						handlers[i].irq_info[j].high
+						+ handlers[i].irq_info[j].low,
+						handlers[i].irq_info[j].high,
+						handlers[i].irq_info[j].low);
+			total += (handlers[i].irq_info[j].high
+					+ handlers[i].irq_info[j].low);
+		}
+
+	seq_printf(m, "\n\tTotal = %d\n", total);
+
+	return 0;
+}
+
+static int irq_count_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct smb1360_chip *chip = inode->i_private;
+
+	return single_open(file, show_irq_count, chip);
+}
+
+static const struct file_operations irq_count_debugfs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= irq_count_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int get_reg(void *data, u64 *val)
+{
+	struct smb1360_chip *chip = data;
+	int rc;
+	u8 temp;
+
+	rc = smb1360_read(chip, chip->peek_poke_address, &temp);
+	if (rc < 0) {
+		dev_err(chip->dev,
+			"Couldn't read reg %x rc = %d\n",
+			chip->peek_poke_address, rc);
+		return -EAGAIN;
+	}
+	*val = temp;
+	return 0;
+}
+
+static int set_reg(void *data, u64 val)
+{
+	struct smb1360_chip *chip = data;
+	int rc;
+	u8 temp;
+
+	temp = (u8) val;
+	rc = smb1360_write(chip, chip->peek_poke_address, temp);
+	if (rc < 0) {
+		dev_err(chip->dev,
+			"Couldn't write 0x%02x to 0x%02x rc= %d\n",
+			chip->peek_poke_address, temp, rc);
+		return -EAGAIN;
+	}
+	return 0;
+}
+DEFINE_SIMPLE_ATTRIBUTE(poke_poke_debug_ops, get_reg, set_reg, "0x%02llx\n");
+
+static int fg_get_reg(void *data, u64 *val)
+{
+	struct smb1360_chip *chip = data;
+	int rc;
+	u8 temp;
+
+	rc = smb1360_select_fg_i2c_address(chip);
+	if (rc) {
+		pr_err("Unable to set FG access I2C address\n");
+		return -EINVAL;
+	}
+
+	rc = smb1360_fg_read(chip, chip->fg_peek_poke_address, &temp);
+	if (rc < 0) {
+		dev_err(chip->dev,
+			"Couldn't read reg %x rc = %d\n",
+			chip->fg_peek_poke_address, rc);
+		return -EAGAIN;
+	}
+	*val = temp;
+	return 0;
+}
+
+static int fg_set_reg(void *data, u64 val)
+{
+	struct smb1360_chip *chip = data;
+	int rc;
+	u8 temp;
+
+	rc = smb1360_select_fg_i2c_address(chip);
+	if (rc) {
+		pr_err("Unable to set FG access I2C address\n");
+		return -EINVAL;
+	}
+
+	temp = (u8) val;
+	rc = smb1360_fg_write(chip, chip->fg_peek_poke_address, temp);
+	if (rc < 0) {
+		dev_err(chip->dev,
+			"Couldn't write 0x%02x to 0x%02x rc= %d\n",
+			chip->fg_peek_poke_address, temp, rc);
+		return -EAGAIN;
+	}
+	return 0;
+}
+DEFINE_SIMPLE_ATTRIBUTE(fg_poke_poke_debug_ops, fg_get_reg,
+				fg_set_reg, "0x%02llx\n");
+
+#define LAST_CNFG_REG	0x17
+static int show_cnfg_regs(struct seq_file *m, void *data)
+{
+	struct smb1360_chip *chip = m->private;
+	int rc;
+	u8 reg;
+	u8 addr;
+
+	for (addr = 0; addr <= LAST_CNFG_REG; addr++) {
+		rc = smb1360_read(chip, addr, &reg);
+		if (!rc)
+			seq_printf(m, "0x%02x = 0x%02x\n", addr, reg);
+	}
+
+	return 0;
+}
+
+static int cnfg_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct smb1360_chip *chip = inode->i_private;
+
+	return single_open(file, show_cnfg_regs, chip);
+}
+
+static const struct file_operations cnfg_debugfs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= cnfg_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+#define FIRST_CMD_REG	0x40
+#define LAST_CMD_REG	0x42
+static int show_cmd_regs(struct seq_file *m, void *data)
+{
+	struct smb1360_chip *chip = m->private;
+	int rc;
+	u8 reg;
+	u8 addr;
+
+	for (addr = FIRST_CMD_REG; addr <= LAST_CMD_REG; addr++) {
+		rc = smb1360_read(chip, addr, &reg);
+		if (!rc)
+			seq_printf(m, "0x%02x = 0x%02x\n", addr, reg);
+	}
+
+	return 0;
+}
+
+static int cmd_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct smb1360_chip *chip = inode->i_private;
+
+	return single_open(file, show_cmd_regs, chip);
+}
+
+static const struct file_operations cmd_debugfs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= cmd_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+#define FIRST_STATUS_REG	0x48
+#define LAST_STATUS_REG		0x4B
+static int show_status_regs(struct seq_file *m, void *data)
+{
+	struct smb1360_chip *chip = m->private;
+	int rc;
+	u8 reg;
+	u8 addr;
+
+	for (addr = FIRST_STATUS_REG; addr <= LAST_STATUS_REG; addr++) {
+		rc = smb1360_read(chip, addr, &reg);
+		if (!rc)
+			seq_printf(m, "0x%02x = 0x%02x\n", addr, reg);
+	}
+
+	return 0;
+}
+
+static int status_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct smb1360_chip *chip = inode->i_private;
+
+	return single_open(file, show_status_regs, chip);
+}
+
+static const struct file_operations status_debugfs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= status_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+#define FIRST_IRQ_REG		0x50
+#define LAST_IRQ_REG		0x58
+static int show_irq_stat_regs(struct seq_file *m, void *data)
+{
+	struct smb1360_chip *chip = m->private;
+	int rc;
+	u8 reg;
+	u8 addr;
+
+	for (addr = FIRST_IRQ_REG; addr <= LAST_IRQ_REG; addr++) {
+		rc = smb1360_read(chip, addr, &reg);
+		if (!rc)
+			seq_printf(m, "0x%02x = 0x%02x\n", addr, reg);
+	}
+
+	return 0;
+}
+
+static int irq_stat_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct smb1360_chip *chip = inode->i_private;
+
+	return single_open(file, show_irq_stat_regs, chip);
+}
+
+static const struct file_operations irq_stat_debugfs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= irq_stat_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int data_8(u8 *reg)
+{
+	return reg[0];
+}
+static int data_16(u8 *reg)
+{
+	return (reg[1] << 8) | reg[0];
+}
+static int data_24(u8 *reg)
+{
+	return  (reg[2] << 16) | (reg[1] << 8) | reg[0];
+}
+static int data_28(u8 *reg)
+{
+	return  ((reg[3] & 0xF) << 24) | (reg[2] << 16) |
+					(reg[1] << 8) | reg[0];
+}
+static int data_32(u8 *reg)
+{
+	return  (reg[3]  << 24) | (reg[2] << 16) |
+				(reg[1] << 8) | reg[0];
+}
+
+struct fg_regs {
+	int index;
+	int length;
+	char *param_name;
+	int (*calc_func) (u8 *);
+};
+
+static struct fg_regs fg_scratch_pad[] = {
+	{0, 2, "v_current_predicted", data_16},
+	{2, 2, "v_cutoff_predicted", data_16},
+	{4, 2, "v_full_predicted", data_16},
+	{6, 2, "ocv_estimate", data_16},
+	{8, 2, "rslow_drop", data_16},
+	{10, 2, "voltage_old", data_16},
+	{12, 2, "current_old", data_16},
+	{14, 4, "current_average_full", data_32},
+	{18, 2, "temperature", data_16},
+	{20, 2, "temp_last_track", data_16},
+	{22, 2, "ESR_nominal", data_16},
+	{26, 2, "Rslow", data_16},
+	{28, 2, "counter_imptr", data_16},
+	{30, 2, "counter_pulse", data_16},
+	{32, 1, "IRQ_delta_prev", data_8},
+	{33, 1, "cap_learning_counter", data_8},
+	{34, 4, "Vact_int_error", data_32},
+	{38, 3, "SOC_cutoff", data_24},
+	{41, 3, "SOC_full", data_24},
+	{44, 3, "SOC_auto_rechrge_temp", data_24},
+	{47, 3, "Battery_SOC", data_24},
+	{50, 4, "CC_SOC", data_28},
+	{54, 2, "SOC_filtered", data_16},
+	{56, 2, "SOC_Monotonic", data_16},
+	{58, 2, "CC_SOC_coeff", data_16},
+	{60, 2, "nominal_capacity", data_16},
+	{62, 2, "actual_capacity", data_16},
+	{68, 1, "temperature_counter", data_8},
+	{69, 3, "Vbatt_filtered", data_24},
+	{72, 3, "Ibatt_filtered", data_24},
+	{75, 2, "Current_CC_shadow", data_16},
+	{79, 2, "Ibatt_standby", data_16},
+	{82, 1, "Auto_recharge_SOC_threshold", data_8},
+	{83, 2, "System_cutoff_voltage", data_16},
+	{85, 2, "System_CC_to_CV_voltage", data_16},
+	{87, 2, "System_term_current", data_16},
+	{89, 2, "System_fake_term_current", data_16},
+	{91, 2, "thermistor_c1_coeff", data_16},
+};
+
+static struct fg_regs fg_cfg[] = {
+	{0, 2, "ESR_actual", data_16},
+	{4, 1, "IRQ_SOC_max", data_8},
+	{5, 1, "IRQ_SOC_min", data_8},
+	{6, 1, "IRQ_volt_empty", data_8},
+	{7, 1, "Temp_external", data_8},
+	{8, 1, "IRQ_delta_threshold", data_8},
+	{9, 1, "JIETA_soft_cold", data_8},
+	{10, 1, "JIETA_soft_hot", data_8},
+	{11, 1, "IRQ_volt_min", data_8},
+	{14, 2, "ESR_sys_replace", data_16},
+};
+
+static struct fg_regs fg_shdw[] = {
+	{0, 1, "Latest_battery_info", data_8},
+	{1, 1, "Latest_Msys_SOC", data_8},
+	{2, 2, "Battery_capacity", data_16},
+	{4, 2, "Rslow_drop", data_16},
+	{6, 1, "Latest_SOC", data_8},
+	{7, 1, "Latest_Cutoff_SOC", data_8},
+	{8, 1, "Latest_full_SOC", data_8},
+	{9, 2, "Voltage_shadow", data_16},
+	{11, 2, "Current_shadow", data_16},
+	{13, 2, "Latest_temperature", data_16},
+	{15, 1, "Latest_system_sbits", data_8},
+};
+
+#define FIRST_FG_CFG_REG		0x20
+#define LAST_FG_CFG_REG			0x2F
+#define FIRST_FG_SHDW_REG		0x60
+#define LAST_FG_SHDW_REG		0x6F
+#define FG_SCRATCH_PAD_MAX		93
+#define FG_SCRATCH_PAD_BASE_REG		0x80
+#define SMB1360_I2C_READ_LENGTH		32
+
+static int smb1360_check_cycle_stretch(struct smb1360_chip *chip)
+{
+	int rc = 0;
+	u8 reg;
+
+	rc = smb1360_read(chip, STATUS_4_REG, &reg);
+	if (rc) {
+		pr_err("Unable to read status regiseter\n");
+	} else if (reg & CYCLE_STRETCH_ACTIVE_BIT) {
+		/* clear cycle stretch */
+		rc = smb1360_masked_write(chip, CMD_I2C_REG,
+			CYCLE_STRETCH_CLEAR_BIT, CYCLE_STRETCH_CLEAR_BIT);
+		if (rc)
+			pr_err("Unable to clear cycle stretch\n");
+	}
+
+	return rc;
+}
+
+static int show_fg_regs(struct seq_file *m, void *data)
+{
+	struct smb1360_chip *chip = m->private;
+	int rc, i , j, rem_length;
+	u8 reg[FG_SCRATCH_PAD_MAX];
+
+	rc = smb1360_check_cycle_stretch(chip);
+	if (rc)
+		pr_err("Unable to check cycle-stretch\n");
+
+	rc = smb1360_enable_fg_access(chip);
+	if (rc) {
+		pr_err("Couldn't request FG access rc=%d\n", rc);
+		return rc;
+	}
+
+	for (i = 0; i < (FG_SCRATCH_PAD_MAX / SMB1360_I2C_READ_LENGTH); i++) {
+		j = i * SMB1360_I2C_READ_LENGTH;
+		rc = smb1360_read_bytes(chip, FG_SCRATCH_PAD_BASE_REG + j,
+					&reg[j], SMB1360_I2C_READ_LENGTH);
+		if (rc) {
+			pr_err("Couldn't read scratch registers rc=%d\n", rc);
+			break;
+		}
+	}
+
+	j = i * SMB1360_I2C_READ_LENGTH;
+	rem_length = (FG_SCRATCH_PAD_MAX % SMB1360_I2C_READ_LENGTH);
+	if (rem_length) {
+		rc = smb1360_read_bytes(chip, FG_SCRATCH_PAD_BASE_REG + j,
+						&reg[j], rem_length);
+		if (rc)
+			pr_err("Couldn't read scratch registers rc=%d\n", rc);
+	}
+
+	rc = smb1360_disable_fg_access(chip);
+	if (rc) {
+		pr_err("Couldn't disable FG access rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = smb1360_check_cycle_stretch(chip);
+	if (rc)
+		pr_err("Unable to check cycle-stretch\n");
+
+
+	seq_puts(m, "FG scratch-pad registers\n");
+	for (i = 0; i < ARRAY_SIZE(fg_scratch_pad); i++)
+		seq_printf(m, "\t%s = %x\n", fg_scratch_pad[i].param_name,
+		fg_scratch_pad[i].calc_func(&reg[fg_scratch_pad[i].index]));
+
+	rem_length = LAST_FG_CFG_REG - FIRST_FG_CFG_REG + 1;
+	rc = smb1360_read_bytes(chip, FIRST_FG_CFG_REG,
+					&reg[0], rem_length);
+	if (rc)
+		pr_err("Couldn't read config registers rc=%d\n", rc);
+
+	seq_puts(m, "FG config registers\n");
+	for (i = 0; i < ARRAY_SIZE(fg_cfg); i++)
+		seq_printf(m, "\t%s = %x\n", fg_cfg[i].param_name,
+				fg_cfg[i].calc_func(&reg[fg_cfg[i].index]));
+
+	rem_length = LAST_FG_SHDW_REG - FIRST_FG_SHDW_REG + 1;
+	rc = smb1360_read_bytes(chip, FIRST_FG_SHDW_REG,
+					&reg[0], rem_length);
+	if (rc)
+		pr_err("Couldn't read shadow registers rc=%d\n", rc);
+
+	seq_puts(m, "FG shadow registers\n");
+	for (i = 0; i < ARRAY_SIZE(fg_shdw); i++)
+		seq_printf(m, "\t%s = %x\n", fg_shdw[i].param_name,
+				fg_shdw[i].calc_func(&reg[fg_shdw[i].index]));
+
+	return rc;
+}
+
+static int fg_regs_open(struct inode *inode, struct file *file)
+{
+	struct smb1360_chip *chip = inode->i_private;
+
+	return single_open(file, show_fg_regs, chip);
+}
+
+static const struct file_operations fg_regs_debugfs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= fg_regs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int smb1360_otg_regulator_enable(struct regulator_dev *rdev)
+{
+	int rc = 0;
+	struct smb1360_chip *chip = rdev_get_drvdata(rdev);
+
+	//if ( !chip->usb_present ) smb1360_redled_gpio_output();
+	rc = smb1360_masked_write(chip, CMD_CHG_REG, CMD_OTG_EN_BIT,
+						CMD_OTG_EN_BIT);
+	if (rc) {
+		pr_err("Couldn't enable  OTG mode rc=%d\n", rc);
+		return rc;
+	}
+
+	pr_debug("OTG mode enabled\n");
+	/* Enable current gain configuration */
+       	mutex_lock(&chip->otp_gain_lock);
+        if (chip->otg_fet_present) {
+		/* Enable FET */
+		gpio_set_value(chip->otg_fet_enable_gpio, 0);
+		rc = smb1360_otp_gain_config(chip, 3);
+		if (rc < 0)
+			pr_err("Couldn't config OTP gain config rc=%d\n", rc);
+		else
+			chip->fet_gain_enabled = true;
+	    }
+	    mutex_unlock(&chip->otp_gain_lock);
+
+	if (!chip->usb_present)
+		smb1360_redled_gpio_output();
+
+	return rc;
+}
+
+static int smb1360_otg_regulator_disable(struct regulator_dev *rdev)
+{
+	int rc = 0;
+	struct smb1360_chip *chip = rdev_get_drvdata(rdev);
+
+	rc = smb1360_otg_disable(chip);
+	if (rc)
+		pr_err("Couldn't disable OTG regulator rc=%d\n", rc);
+
+	pr_debug("OTG mode disabled\n");
+	return rc;
+}
+
+static int smb1360_otg_regulator_is_enable(struct regulator_dev *rdev)
+{
+	u8 reg = 0;
+	int rc = 0;
+	struct smb1360_chip *chip = rdev_get_drvdata(rdev);
+
+	rc = smb1360_read(chip, CMD_CHG_REG, &reg);
+	if (rc) {
+		pr_err("Couldn't read OTG enable bit rc=%d\n", rc);
+		return rc;
+	}
+
+	return  (reg & CMD_OTG_EN_BIT) ? 1 : 0;
+}
+
+struct regulator_ops smb1360_otg_reg_ops = {
+	.enable		= smb1360_otg_regulator_enable,
+	.disable	= smb1360_otg_regulator_disable,
+	.is_enabled	= smb1360_otg_regulator_is_enable,
+};
+
+static int smb1360_regulator_init(struct smb1360_chip *chip)
+{
+	int rc = 0;
+	struct regulator_init_data *init_data;
+	struct regulator_config cfg = {};
+
+	init_data = of_get_regulator_init_data(chip->dev, chip->dev->of_node);
+	if (!init_data) {
+		dev_err(chip->dev, "Unable to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	if (init_data->constraints.name) {
+		chip->otg_vreg.rdesc.owner = THIS_MODULE;
+		chip->otg_vreg.rdesc.type = REGULATOR_VOLTAGE;
+		chip->otg_vreg.rdesc.ops = &smb1360_otg_reg_ops;
+		chip->otg_vreg.rdesc.name = init_data->constraints.name;
+
+		cfg.dev = chip->dev;
+		cfg.init_data = init_data;
+		cfg.driver_data = chip;
+		cfg.of_node = chip->dev->of_node;
+
+		init_data->constraints.valid_ops_mask
+			|= REGULATOR_CHANGE_STATUS;
+
+		chip->otg_vreg.rdev = regulator_register(
+					&chip->otg_vreg.rdesc, &cfg);
+		if (IS_ERR(chip->otg_vreg.rdev)) {
+			rc = PTR_ERR(chip->otg_vreg.rdev);
+			chip->otg_vreg.rdev = NULL;
+			if (rc != -EPROBE_DEFER)
+				dev_err(chip->dev,
+					"OTG reg failed, rc=%d\n", rc);
+		}
+	}
+
+	return rc;
+}
+
+static int smb1360_check_batt_profile(struct smb1360_chip *chip)
+{
+	int rc, i, timeout = 50;
+	u8 reg = 0, loaded_profile, new_profile = 0, bid_mask;
+
+	if (!chip->connected_rid) {
+		pr_debug("Skip batt-profile loading connected_rid=%d\n",
+						chip->connected_rid);
+		return 0;
+	}
+
+	rc = smb1360_read(chip, SHDW_FG_BATT_STATUS, &reg);
+	if (rc) {
+		pr_err("Couldn't read FG_BATT_STATUS rc=%d\n", rc);
+		return rc;
+	}
+
+	loaded_profile = !!(reg & BATTERY_PROFILE_BIT) ?
+			BATTERY_PROFILE_B : BATTERY_PROFILE_A;
+
+	pr_debug("fg_batt_status=%x loaded_profile=%d\n", reg, loaded_profile);
+
+	for (i = 0; i < BATTERY_PROFILE_MAX; i++) {
+		pr_debug("profile=%d profile_rid=%d connected_rid=%d\n", i,
+						chip->profile_rid[i],
+						chip->connected_rid);
+		if (abs(chip->profile_rid[i] - chip->connected_rid) <
+				(div_u64(chip->connected_rid, 10)))
+			break;
+	}
+
+	if (i == BATTERY_PROFILE_MAX) {
+		pr_err("None of the battery-profiles match the connected-RID\n");
+		return 0;
+	} else {
+		if (i == loaded_profile) {
+			pr_debug("Loaded Profile-RID == connected-RID\n");
+			return 0;
+		} else {
+			new_profile = (loaded_profile == BATTERY_PROFILE_A) ?
+					BATTERY_PROFILE_B : BATTERY_PROFILE_A;
+			bid_mask = (new_profile == BATTERY_PROFILE_A) ?
+					BATT_PROFILEA_MASK : BATT_PROFILEB_MASK;
+			pr_info("Loaded Profile-RID != connected-RID, switch-profile old_profile=%d new_profile=%d\n",
+						loaded_profile, new_profile);
+		}
+	}
+
+	/* set the BID mask */
+	rc = smb1360_masked_write(chip, CFG_FG_BATT_CTRL_REG,
+				BATT_PROFILE_SELECT_MASK, bid_mask);
+	if (rc) {
+		pr_err("Couldn't reset battery-profile rc=%d\n", rc);
+		//goto fail_profile;
+                return rc;
+	}
+
+	/* enable FG access */
+	//rc = smb1360_masked_write(chip, CMD_I2C_REG, FG_ACCESS_ENABLED_BIT,
+	//						FG_ACCESS_ENABLED_BIT);
+	
+        /*if (rc) {
+		pr_err("Couldn't enable FG access rc=%d\n", rc);
+		//goto fail_profile;
+	}
+
+	while (timeout) {
+		// delay for FG access to be granted 
+		msleep(100);
+		rc = smb1360_read(chip, IRQ_I_REG, &reg);
+		if (rc) {
+			pr_err("Could't read IRQ_I_REG rc=%d\n", rc);
+			goto restore_fg;
+		}
+		if (reg & FG_ACCESS_ALLOWED_BIT)
+			break;
+		timeout--;
+	}
+	if (!timeout) {
+		pr_err("FG access timed-out\n");
+		rc = -EAGAIN;
+		goto restore_fg;
+	} */
+        rc = smb1360_enable_fg_access(chip);
+        if (rc) {
+            pr_err("FG access timed-out, rc = %d\n", rc);
+            return rc;
+        }
+
+	/* delay after handshaking for profile-switch to continue */
+	msleep(1500);
+
+	/* reset FG */
+	//rc = smb1360_masked_write(chip, CMD_I2C_REG, FG_RESET_BIT,
+	//					FG_RESET_BIT);
+	rc = smb1360_force_fg_reset(chip);
+        if (rc) {
+                pr_err("Couldn't reset FG rc=%d\n", rc);
+                goto restore_fg;
+        }
+
+	/* un-reset FG */
+	/*rc = smb1360_masked_write(chip, CMD_I2C_REG, FG_RESET_BIT, 0);
+	if (rc) {
+		pr_err("Couldn't un-reset FG rc=%d\n", rc);
+		goto restore_fg;
+	}
+
+	//  disable FG access 
+	rc = smb1360_masked_write(chip, CMD_I2C_REG, FG_ACCESS_ENABLED_BIT, 0);*/
+        rc = smb1360_disable_fg_access(chip);
+	if (rc) {
+		//pr_err("Couldn't disable FG access rc=%d\n", rc);
+		//goto restore_fg;
+               pr_err("disable FG access failed, rc = %d\n", rc);
+               return rc;
+	}
+
+	timeout = 10;
+	while (timeout) {
+		/* delay for profile to change */
+		msleep(500);
+		rc = smb1360_read(chip, SHDW_FG_BATT_STATUS, &reg);
+		if (rc) {
+			pr_err("Could't read FG_BATT_STATUS rc=%d\n", rc);
+		//	goto restore_fg;
+                        return rc;
+		}
+
+		reg = !!(reg & BATTERY_PROFILE_BIT);
+		if (reg == new_profile) {
+			pr_info("New profile=%d loaded\n", new_profile);
+			break;
+		}
+		timeout--;
+	}
+
+	if (!timeout) {
+		pr_err("New profile could not be loaded\n");
+		return -EBUSY;
+	}
+
+	return 0;
+
+restore_fg:
+	//smb1360_masked_write(chip, CMD_I2C_REG, FG_ACCESS_ENABLED_BIT, 0);
+        smb1360_disable_fg_access(chip);
+	return rc;
+}
+
+#define UPDATE_IRQ_STAT(irq_reg, value) \
+		handlers[irq_reg - IRQ_A_REG].prev_val = value;
+
+static int determine_initial_status(struct smb1360_chip *chip)
+{
+	int rc;
+	u8 reg = 0;
+
+	/*
+	 * It is okay to read the IRQ status as the irq's are
+	 * not registered yet.
+	 */
+	chip->batt_present = true;
+	rc = smb1360_read(chip, IRQ_B_REG, &reg);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't read IRQ_B_REG rc = %d\n", rc);
+		return rc;
+	}
+	UPDATE_IRQ_STAT(IRQ_B_REG, reg);
+
+	if (reg & IRQ_B_BATT_TERMINAL_BIT || reg & IRQ_B_BATT_MISSING_BIT)
+		chip->batt_present = false;
+
+	rc = smb1360_read(chip, IRQ_C_REG, &reg);
+	if (rc) {
+		dev_err(chip->dev, "Couldn't read IRQ_C_REG rc = %d\n", rc);
+		return rc;
+	}
+	UPDATE_IRQ_STAT(IRQ_C_REG, reg);
+
+	if (reg & IRQ_C_CHG_TERM)
+		chip->batt_full = true;
+
+	rc = smb1360_read(chip, IRQ_A_REG, &reg);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't read irq A rc = %d\n", rc);
+		return rc;
+	}
+	UPDATE_IRQ_STAT(IRQ_A_REG, reg);
+
+	if (chip->workaround_flags & WRKRND_HARD_JEITA) {
+		schedule_delayed_work(&chip->jeita_work, 0);
+	} else {
+		if (reg & IRQ_A_HOT_HARD_BIT)
+			chip->batt_hot = true;
+		if (reg & IRQ_A_COLD_HARD_BIT)
+			chip->batt_cold = true;
+		if (!chip->config_hard_thresholds) {
+			if (reg & IRQ_A_HOT_SOFT_BIT)
+				chip->batt_warm = true;
+			if (reg & IRQ_A_COLD_SOFT_BIT)
+				chip->batt_cool = true;
+		}
+	}
+
+	rc = smb1360_read(chip, IRQ_E_REG, &reg);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't read irq E rc = %d\n", rc);
+		return rc;
+	}
+	UPDATE_IRQ_STAT(IRQ_E_REG, reg);
+
+	chip->usb_present = (reg & IRQ_E_USBIN_UV_BIT) ? false : true;
+	power_supply_set_present(chip->usb_psy, chip->usb_present);
+
+	return 0;
+}
+
+
+static void smb1360_rest_at_pon_work_func(struct work_struct *work)
+{
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct smb1360_chip *chip = container_of(dwork, struct smb1360_chip,one_shot_delay);
+	int v_predicted, v_now;
+	int rc,temp;
+	u8  reg2[2];
+
+	rc = smb1360_enable_fg_access(chip);
+	if (rc) {
+		pr_err("Couldn't enable FG access rc=%d\n", rc);
+		goto  abnormal;
+	}
+
+	rc = smb1360_read_bytes(chip, VOLTAGE_PREDICTED_REG, reg2, 2);
+	if (rc) {
+		pr_err("Failed to read VOLTAGE_PREDICTED rc=%d\n", rc);
+		goto disable_fg_reset;
+	}
+	v_predicted = (reg2[1] << 8) | reg2[0];
+	v_predicted = div_u64(v_predicted * 5000, 0x7FFF);
+
+	rc = smb1360_read_bytes(chip, SHDW_FG_VTG_NOW, reg2, 2);
+	if (rc) {
+		pr_err("Failed to read SHDW_FG_VTG_NOW rc=%d\n", rc);
+		goto disable_fg_reset;
+	}
+	v_now = (reg2[1] << 8) | reg2[0];
+	v_now = div_u64(v_now * 5000, 0x7FFF);
+
+	pr_debug("v_predicted=%d v_now=%d reset_threshold=%d\n",
+			v_predicted, v_now, chip->fg_reset_threshold_mv);
+
+	/*
+	 * Reset FG if the predicted voltage is off wrt
+	 * the real-time voltage.
+	 */
+	temp = abs(v_predicted - v_now);
+	if (temp >= chip->fg_reset_threshold_mv) {
+		pr_info("Reseting FG - v_delta=%d threshold=%d\n",
+				temp, chip->fg_reset_threshold_mv);
+		/* delay for the FG access to settle */
+		msleep(1500);
+
+		/* reset FG */
+		/*rc = smb1360_masked_write(chip, CMD_I2C_REG,
+				FG_RESET_BIT, FG_RESET_BIT);
+		if (rc) {
+			pr_err("Couldn't reset FG rc=%d\n", rc);
+			goto disable_fg_reset;
+		}*/
+                rc = smb1360_force_fg_reset(chip);
+		if (rc) {
+			pr_err("Couldn't reset FG rc=%d\n", rc);
+			goto disable_fg_reset;
+		}
+
+		/* un-reset FG */
+		/*rc = smb1360_masked_write(chip, CMD_I2C_REG,
+				FG_RESET_BIT, 0);
+		if (rc) {
+			pr_err("Couldn't un-reset FG rc=%d\n", rc);
+				goto disable_fg_reset;
+		}*/
+	}
+disable_fg_reset:
+	smb1360_disable_fg_access(chip);
+abnormal:
+	schedule_delayed_work(&chip->abnormal_detect,0);
+}
+
+
+static int smb1360_fg_config(struct smb1360_chip *chip)
+{
+	int rc = 0, temp, fcc_mah;
+	u8 reg = 0, reg2[2];
+	/*
+	 * The below IRQ thresholds are not accessible in REV_1
+	 * of SMB1360.
+	 */
+	if (!(chip->workaround_flags & WRKRND_FG_CONFIG_FAIL)) {
+		if (chip->delta_soc != -EINVAL) {
+			reg = abs(((chip->delta_soc * MAX_8_BITS) / 100) - 1);
+			pr_debug("delta_soc=%d reg=%x\n", chip->delta_soc, reg);
+			rc = smb1360_write(chip, SOC_DELTA_REG, reg);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't write to SOC_DELTA_REG rc=%d\n",
+						rc);
+				return rc;
+			}
+		}
+
+		if (chip->soc_min != -EINVAL) {
+			if (is_between(chip->soc_min, 0, 100)) {
+				reg = DIV_ROUND_UP(chip->soc_min * MAX_8_BITS,
+									100);
+				pr_debug("soc_min=%d reg=%x\n",
+						chip->soc_min, reg);
+				rc = smb1360_write(chip, SOC_MIN_REG, reg);
+				if (rc) {
+					dev_err(chip->dev, "Couldn't write to SOC_MIN_REG rc=%d\n",
+							rc);
+					return rc;
+				}
+			}
+		}
+
+		if (chip->soc_max != -EINVAL) {
+			if (is_between(chip->soc_max, 0, 100)) {
+				reg = DIV_ROUND_UP(chip->soc_max * MAX_8_BITS,
+									100);
+				pr_debug("soc_max=%d reg=%x\n",
+						chip->soc_max, reg);
+				rc = smb1360_write(chip, SOC_MAX_REG, reg);
+				if (rc) {
+					dev_err(chip->dev, "Couldn't write to SOC_MAX_REG rc=%d\n",
+							rc);
+					return rc;
+				}
+			}
+		}
+
+		if (chip->voltage_min_mv != -EINVAL) {
+			temp = (chip->voltage_min_mv - 2500) * MAX_8_BITS;
+			reg = DIV_ROUND_UP(temp, 2500);
+			pr_debug("voltage_min=%d reg=%x\n",
+					chip->voltage_min_mv, reg);
+			rc = smb1360_write(chip, VTG_MIN_REG, reg);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't write to VTG_MIN_REG rc=%d\n",
+							rc);
+				return rc;
+			}
+		}
+
+		if (chip->voltage_empty_mv != -EINVAL) {
+			temp = (chip->voltage_empty_mv - 2500) * MAX_8_BITS;
+			reg = DIV_ROUND_UP(temp, 2500);
+			pr_debug("voltage_empty=%d reg=%x\n",
+					chip->voltage_empty_mv, reg);
+			rc = smb1360_write(chip, VTG_EMPTY_REG, reg);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't write to VTG_EMPTY_REG rc=%d\n",
+							rc);
+				return rc;
+			}
+		}
+	}
+
+	/* scratch-pad register config */
+	if (chip->batt_capacity_mah != -EINVAL
+		|| chip->v_cutoff_mv != -EINVAL
+		|| chip->fg_iterm_ma != -EINVAL
+		|| chip->fg_ibatt_standby_ma != -EINVAL
+		|| chip->fg_thermistor_c1_coeff != -EINVAL
+		|| chip->fg_cc_to_cv_mv != -EINVAL
+		|| chip->fg_auto_recharge_soc != -EINVAL) {
+
+		rc = smb1360_enable_fg_access(chip);
+		if (rc) {
+			pr_err("Couldn't enable FG access rc=%d\n", rc);
+			return rc;
+		}
+
+		/* Update battery capacity */
+		if (chip->batt_capacity_mah != -EINVAL) {
+			rc = smb1360_read_bytes(chip, ACTUAL_CAPACITY_REG,
+								reg2, 2);
+			if (rc) {
+				pr_err("Failed to read ACTUAL CAPACITY rc=%d\n",
+									rc);
+				goto disable_fg;
+			}
+			fcc_mah = (reg2[1] << 8) | reg2[0];
+			if (fcc_mah == chip->batt_capacity_mah) {
+				pr_debug("battery capacity correct\n");
+			} else {
+				/* Update the battery capacity */
+				reg2[1] =
+					(chip->batt_capacity_mah & 0xFF00) >> 8;
+				reg2[0] = (chip->batt_capacity_mah & 0xFF);
+				rc = smb1360_write_bytes(chip,
+					ACTUAL_CAPACITY_REG, reg2, 2);
+				if (rc) {
+					pr_err("Couldn't write batt-capacity rc=%d\n",
+									rc);
+					goto disable_fg;
+				}
+				rc = smb1360_write_bytes(chip,
+					NOMINAL_CAPACITY_REG, reg2, 2);
+				if (rc) {
+					pr_err("Couldn't write batt-capacity rc=%d\n",
+									rc);
+					goto disable_fg;
+				}
+
+				/* Update CC to SOC COEFF */
+				if (chip->cc_soc_coeff != -EINVAL) {
+					reg2[1] =
+					(chip->cc_soc_coeff & 0xFF00) >> 8;
+					reg2[0] = (chip->cc_soc_coeff & 0xFF);
+					rc = smb1360_write_bytes(chip,
+						CC_TO_SOC_COEFF, reg2, 2);
+					if (rc) {
+						pr_err("Couldn't write cc_soc_coeff rc=%d\n",
+									rc);
+						goto disable_fg;
+					}
+				}
+			}
+		}
+
+		/* Update cutoff voltage for SOC = 0 */
+		if (chip->v_cutoff_mv != -EINVAL) {
+			temp = (u16) div_u64(chip->v_cutoff_mv * 0x7FFF, 5000);
+			reg2[1] = (temp & 0xFF00) >> 8;
+			reg2[0] = temp & 0xFF;
+			rc = smb1360_write_bytes(chip, FG_SYS_CUTOFF_V_REG,
+								reg2, 2);
+			if (rc) {
+				pr_err("Couldn't write cutoff_mv rc=%d\n", rc);
+				goto disable_fg;
+			}
+		}
+
+		/*
+		 * Update FG iterm for SOC = 100, this value is always assumed
+		 * to be -ve
+		 */
+		if (chip->fg_iterm_ma != -EINVAL) {
+			int iterm = chip->fg_iterm_ma * -1;
+			temp = (s16) div_s64(iterm * 0x7FFF, 2500);
+			reg2[1] = (temp & 0xFF00) >> 8;
+			reg2[0] = temp & 0xFF;
+			rc = smb1360_write_bytes(chip, FG_ITERM_REG,
+							reg2, 2);
+			if (rc) {
+				pr_err("Couldn't write fg_iterm rc=%d\n", rc);
+				goto disable_fg;
+			}
+		}
+
+		/*
+		 * Update FG iterm standby for SOC = 0, this value is always
+		 * assumed to be +ve
+		 */
+		if (chip->fg_ibatt_standby_ma != -EINVAL) {
+			int iterm = chip->fg_ibatt_standby_ma;
+			temp = (u16) div_u64(iterm * 0x7FFF, 2500);
+			reg2[1] = (temp & 0xFF00) >> 8;
+			reg2[0] = temp & 0xFF;
+			rc = smb1360_write_bytes(chip, FG_IBATT_STANDBY_REG,
+								reg2, 2);
+			if (rc) {
+				pr_err("Couldn't write fg_iterm rc=%d\n", rc);
+				goto disable_fg;
+			}
+		}
+
+		/* Update CC_to_CV voltage threshold */
+		if (chip->fg_cc_to_cv_mv != -EINVAL) {
+			temp = (u16) div_u64(chip->fg_cc_to_cv_mv * 0x7FFF,
+								5000);
+			reg2[1] = (temp & 0xFF00) >> 8;
+			reg2[0] = temp & 0xFF;
+			rc = smb1360_write_bytes(chip, FG_CC_TO_CV_V_REG,
+								reg2, 2);
+			if (rc) {
+				pr_err("Couldn't write cc_to_cv_mv rc=%d\n",
+								rc);
+				goto disable_fg;
+			}
+		}
+
+		/* Update the thermistor c1 coefficient */
+		if (chip->fg_thermistor_c1_coeff != -EINVAL) {
+			reg2[1] = (chip->fg_thermistor_c1_coeff & 0xFF00) >> 8;
+			reg2[0] = (chip->fg_thermistor_c1_coeff & 0xFF);
+			rc = smb1360_write_bytes(chip, FG_THERM_C1_COEFF_REG,
+								reg2, 2);
+			if (rc) {
+				pr_err("Couldn't write thermistor_c1_coeff rc=%d\n",
+							rc);
+				goto disable_fg;
+			}
+		}
+
+		/* Update SoC based resume charging threshold */
+		if (chip->fg_auto_recharge_soc != -EINVAL) {
+			rc = smb1360_masked_write(chip, CFG_CHG_FUNC_CTRL_REG,
+						CHG_RECHG_THRESH_FG_SRC_BIT,
+						CHG_RECHG_THRESH_FG_SRC_BIT);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't write to CFG_CHG_FUNC_CTRL_REG rc=%d\n",
+									rc);
+				goto disable_fg;
+			}
+
+			reg = DIV_ROUND_UP(chip->fg_auto_recharge_soc *
+							MAX_8_BITS, 100);
+			pr_debug("fg_auto_recharge_soc=%d reg=%x\n",
+					chip->fg_auto_recharge_soc, reg);
+			rc = smb1360_write(chip, FG_AUTO_RECHARGE_SOC, reg);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't write to FG_AUTO_RECHARGE_SOC rc=%d\n",
+									rc);
+				goto disable_fg;
+			}
+		}
+
+disable_fg:
+		/* disable FG access */
+		smb1360_disable_fg_access(chip);
+	}
+
+	return rc;
+}
+
+static void smb1360_check_feature_support(struct smb1360_chip *chip)
+{
+
+	if (is_usb100_broken(chip)) {
+		pr_debug("USB100 is not supported\n");
+		chip->workaround_flags |= WRKRND_USB100_FAIL;
+	}
+
+	/*
+	 * FG Configuration
+	 *
+	 * The REV_1 of the chip does not allow access to
+	 * FG config registers (20-2FH). Set the workaround flag.
+	 * Also, the battery detection does not work when the DCIN is absent,
+	 * add a workaround flag for it.
+	*/
+	if (chip->revision == SMB1360_REV_1) {
+		pr_debug("FG config and Battery detection is not supported\n");
+		chip->workaround_flags |=
+			WRKRND_FG_CONFIG_FAIL | WRKRND_BATT_DET_FAIL;
+	}
+}
+
+static int smb1360_enable(struct smb1360_chip *chip, bool enable)
+{
+	int rc = 0;
+	u8 val = 0, shdn_cmd_polar;
+
+	rc = smb1360_read(chip, SHDN_CTRL_REG, &val);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't read 0x1A reg rc = %d\n", rc);
+		return rc;
+	}
+
+	/* Ignore if a CMD based shutdown is not enabled */
+	if (!(val & SHDN_CMD_USE_BIT)) {
+		pr_debug("SMB not configured for CMD based shutdown\n");
+		return 0;
+	}
+
+	shdn_cmd_polar = !!(val & SHDN_CMD_POLARITY_BIT);
+	val = (shdn_cmd_polar ^ enable) ? SHDN_CMD_BIT : 0;
+
+	pr_debug("enable=%d shdn_polarity=%d value=%d\n", enable,
+						shdn_cmd_polar, val);
+
+	rc = smb1360_masked_write(chip, CMD_IL_REG, SHDN_CMD_BIT, val);
+	if (rc < 0)
+		pr_err("Couldn't shutdown smb1360 rc = %d\n", rc);
+
+	return rc;
+}
+
+static inline int smb1360_poweroff(struct smb1360_chip *chip)
+{
+	pr_debug("power off smb1360\n");
+	return smb1360_enable(chip, false);
+}
+
+static inline int smb1360_poweron(struct smb1360_chip *chip)
+{
+	pr_debug("power on smb1360\n");
+	return smb1360_enable(chip, true);
+}
+
+static int smb1360_jeita_init(struct smb1360_chip *chip)
+{
+	int rc = 0;
+	int temp;
+
+	if (chip->config_hard_thresholds) {
+		if (chip->soft_jeita_supported) {
+			chip->workaround_flags |= WRKRND_HARD_JEITA;
+			rc = smb1360_set_soft_jeita_threshold(chip,
+			chip->cool_bat_decidegc, chip->warm_bat_decidegc);
+			if (rc) {
+				dev_err(chip->dev,
+					"Couldn't set jeita threshold\n");
+				return rc;
+			}
+		} else {
+			rc = smb1360_set_soft_jeita_threshold(chip,
+			chip->cold_bat_decidegc, chip->hot_bat_decidegc);
+			if (rc) {
+				dev_err(chip->dev,
+					"Couldn't set jeita threshold\n");
+				return rc;
+			}
+		}
+	} else {
+		if (chip->soft_jeita_supported) {
+			temp = min(chip->warm_bat_ma, chip->cool_bat_ma);
+			rc = smb1360_set_jeita_comp_curr(chip, temp);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't set comp current\n");
+				return rc;
+			}
+
+			temp = (chip->vfloat_mv - chip->warm_bat_mv) / 10;
+			rc = smb1360_masked_write(chip, CFG_FVC_REG,
+					FLT_VTG_COMP_MASK, temp);
+			if (rc < 0) {
+				dev_err(chip->dev, "Couldn't set VFLT compensation = %d",
+									rc);
+				return rc;
+			}
+
+			rc = smb1360_set_soft_jeita_threshold(chip,
+			chip->cool_bat_decidegc, chip->warm_bat_decidegc);
+			if (rc) {
+				dev_err(chip->dev,
+					"Couldn't set jeita threshold\n");
+				return rc;
+			}
+
+			rc = smb1360_soft_jeita_comp_enable(chip, true);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't enable jeita\n");
+				return rc;
+			}
+		}
+	}
+
+	return rc;
+}
+
+static int smb1360_otp_gain_init(struct smb1360_chip *chip)
+{
+	int rc = 0, gain_factor;
+	bool otp_gain_config = false;
+
+	if (chip->rsense_10mohm) {
+		gain_factor = 2;
+		otp_gain_config = true;
+	}
+
+	mutex_lock(&chip->otp_gain_lock);
+	if (chip->otg_fet_present) {
+		/*
+		 * Reset current gain to the default value if OTG
+		 * is not enabled
+		 */
+		if (!chip->fet_gain_enabled) {
+			otp_gain_config = true;
+			gain_factor = 0;
+		}
+	}
+
+	if (otp_gain_config) {
+		rc = smb1360_otp_gain_config(chip, gain_factor);
+		if (rc < 0)
+			pr_err("Couldn't config OTP gain rc=%d\n", rc);
+	}
+	mutex_unlock(&chip->otp_gain_lock);
+
+	return rc;
+}
+static int smb1360_hw_init(struct smb1360_chip *chip)
+{
+	int rc;
+	int i;
+	u8 reg, mask;
+	u8 temp_data = 0;
+
+	smb1360_check_feature_support(chip);
+
+	rc = smb1360_enable_volatile_writes(chip);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't configure for volatile rc = %d\n",
+				rc);
+		return rc;
+	}
+
+	/* Bring SMB1360 out of shutdown, if it was enabled by default */
+	rc = smb1360_poweron(chip);
+	if (rc < 0) {
+		pr_err("smb1360 power on failed\n");
+		return rc;
+	} else {
+	/*
+	 * A 2 seconds delay is mandatory after bringing the chip out
+	 * of shutdown. This guarantees that FG is in a proper state.
+	 */
+	schedule_delayed_work(&chip->delayed_init_work,
+			msecs_to_jiffies(SMB1360_POWERON_DELAY_MS));
+        }
+
+/*	if (chip->rsense_10mohm) {
+		rc = smb1360_otp_gain_config(chip, 2);
+		if (rc < 0) {
+			pr_err("Couldn't config OTP rc=%d\n", rc);
+			return rc;
+		}
+	}
+
+	if (chip->otg_fet_present) {
+		// Configure OTG FET control gpio 
+		rc = devm_gpio_request_one(chip->dev,
+				chip->otg_fet_enable_gpio,
+				GPIOF_OPEN_DRAIN | GPIOF_INIT_HIGH,
+				"smb1360_otg_fet_gpio");
+		if (rc) {
+			pr_err("Unable to request gpio rc=%d\n", rc);
+			return rc;
+		}
+
+		// Reset current gain to the default value 
+		rc = smb1360_otp_gain_config(chip, 0);
+		if (rc < 0) {
+			pr_err("Couldn't config OTP gain rc=%d\n", rc);
+			return rc;
+		}
+	}
+
+	rc = smb1360_check_batt_profile(chip);
+	if (rc)
+		pr_err("Unable to modify battery profile\n");
+        */
+	/*
+	 * set chg en by cmd register, set chg en by writing bit 1,
+	 * enable auto pre to fast
+	 */
+	rc = smb1360_masked_write(chip, CFG_CHG_MISC_REG,
+					CHG_EN_BY_PIN_BIT
+					| CHG_EN_ACTIVE_LOW_BIT
+					| PRE_TO_FAST_REQ_CMD_BIT,
+					0);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't set CFG_CHG_MISC_REG rc=%d\n", rc);
+		return rc;
+	}
+
+	/* USB/AC pin settings */
+	rc = smb1360_masked_write(chip, CFG_BATT_CHG_ICL_REG,
+					AC_INPUT_ICL_PIN_BIT
+					| AC_INPUT_PIN_HIGH_BIT
+					| RESET_STATE_USB_500,
+					AC_INPUT_PIN_HIGH_BIT
+					| RESET_STATE_USB_500);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't set CFG_BATT_CHG_ICL_REG rc=%d\n",
+				rc);
+		return rc;
+	}
+
+	/* set the switching frequency to 3.2MHz*/
+	rc = smb1360_masked_write(chip, CFG_BATT_CHG_FREQ_REG, SWITCH_FREQ_BIT, 0);
+	if (0 > rc ) {
+		dev_err(chip->dev, "Couldn't set CFG_BATT_CHG_FREQ_REG rc=%d\n", rc);
+	}
+
+	/* AICL enable and set input-uv glitch flt to 20ms*/
+	reg = AICL_ENABLED_BIT | INPUT_UV_GLITCH_FLT_20MS_BIT;
+	rc = smb1360_masked_write(chip, CFG_GLITCH_FLT_REG, reg, reg);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't set CFG_GLITCH_FLT_REG rc=%d\n",
+				rc);
+		return rc;
+	}
+
+	/* set the float voltage */
+	if (chip->vfloat_mv != -EINVAL) {
+		rc = smb1360_float_voltage_set(chip, chip->vfloat_mv);
+		if (rc < 0) {
+			dev_err(chip->dev,
+				"Couldn't set float voltage rc = %d\n", rc);
+			return rc;
+		}
+	}
+	/* set iterm */
+	if (chip->iterm_ma != -EINVAL) {
+		if (chip->iterm_disabled) {
+			dev_err(chip->dev, "Error: Both iterm_disabled and iterm_ma set\n");
+			return -EINVAL;
+		} else {
+			if (chip->rsense_10mohm)
+				chip->iterm_ma /= 2;
+
+			if (chip->iterm_ma < 25)
+				reg = CHG_ITERM_25MA;
+			else if (chip->iterm_ma > 200)
+				reg = CHG_ITERM_200MA;
+			else
+				reg = DIV_ROUND_UP(chip->iterm_ma, 25) - 1;
+
+			rc = smb1360_masked_write(chip, CFG_BATT_CHG_REG,
+						CHG_ITERM_MASK, reg);
+			if (rc) {
+				dev_err(chip->dev,
+					"Couldn't set iterm rc = %d\n", rc);
+				return rc;
+			}
+
+			rc = smb1360_masked_write(chip, CFG_CHG_MISC_REG,
+					CHG_CURR_TERM_DIS_BIT, 0);
+			if (rc) {
+				dev_err(chip->dev,
+					"Couldn't enable iterm rc = %d\n", rc);
+				return rc;
+			}
+		}
+	} else  if (chip->iterm_disabled) {
+		rc = smb1360_masked_write(chip, CFG_CHG_MISC_REG,
+						CHG_CURR_TERM_DIS_BIT,
+						CHG_CURR_TERM_DIS_BIT);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set iterm rc = %d\n",
+								rc);
+			return rc;
+		}
+	}
+
+	/* set the safety time voltage */
+	if (chip->safety_time != -EINVAL) {
+		if (chip->safety_time == 0) {
+			/* safety timer disabled */
+			rc = smb1360_masked_write(chip, CFG_SFY_TIMER_CTRL_REG,
+			SAFETY_TIME_DISABLE_BIT, SAFETY_TIME_DISABLE_BIT);
+			if (rc < 0) {
+				dev_err(chip->dev,
+				"Couldn't disable safety timer rc = %d\n",
+								rc);
+				return rc;
+			}
+		} else {
+			for (i = 0; i < ARRAY_SIZE(chg_time); i++) {
+				if (chip->safety_time <= chg_time[i]) {
+					reg = i << SAFETY_TIME_MINUTES_SHIFT;
+					break;
+				}
+			}
+			rc = smb1360_masked_write(chip, CFG_SFY_TIMER_CTRL_REG,
+			SAFETY_TIME_DISABLE_BIT | SAFETY_TIME_MINUTES_MASK,
+								reg);
+			if (rc < 0) {
+				dev_err(chip->dev,
+					"Couldn't set safety timer rc = %d\n",
+									rc);
+				return rc;
+			}
+		}
+	}
+
+	/* configure resume threshold, auto recharge and charge inhibit */
+	if (chip->resume_delta_mv != -EINVAL) {
+		if (chip->recharge_disabled && chip->chg_inhibit_disabled) {
+			dev_err(chip->dev, "Error: Both recharge_disabled and recharge_mv set\n");
+			return -EINVAL;
+		} else {
+			rc = smb1360_recharge_threshold_set(chip,
+						chip->resume_delta_mv);
+			if (rc) {
+				dev_err(chip->dev,
+					"Couldn't set rechg thresh rc = %d\n",
+									rc);
+				return rc;
+			}
+		}
+	}
+
+	rc = smb1360_masked_write(chip, CFG_CHG_MISC_REG,
+					CFG_AUTO_RECHG_DIS_BIT,
+					chip->recharge_disabled ?
+					CFG_AUTO_RECHG_DIS_BIT : 0);
+	if (rc) {
+		dev_err(chip->dev, "Couldn't set rechg-cfg rc = %d\n", rc);
+		return rc;
+	}
+	rc = smb1360_masked_write(chip, CFG_CHG_MISC_REG,
+					CFG_CHG_INHIBIT_EN_BIT,
+					chip->chg_inhibit_disabled ?
+					0 : CFG_CHG_INHIBIT_EN_BIT);
+	if (rc) {
+		dev_err(chip->dev, "Couldn't set chg_inhibit rc = %d\n", rc);
+		return rc;
+	}
+
+	/* battery missing detection */
+	rc = smb1360_masked_write(chip, CFG_BATT_MISSING_REG,
+				BATT_MISSING_SRC_THERM_BIT,
+				BATT_MISSING_SRC_THERM_BIT);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't set batt_missing config = %d\n",
+									rc);
+		return rc;
+	}
+
+	rc = smb1360_jeita_init(chip);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't init jeita, rc = %d\n", rc);
+		return rc;
+	}
+
+	/* interrupt enabling - active low */
+	if (chip->client->irq) {
+		mask = CHG_STAT_IRQ_ONLY_BIT
+			| CHG_STAT_ACTIVE_HIGH_BIT
+			| CHG_STAT_DISABLE_BIT
+			| CHG_TEMP_CHG_ERR_BLINK_BIT;
+
+		if (!chip->pulsed_irq)
+			reg = CHG_STAT_IRQ_ONLY_BIT;
+		else
+			reg = CHG_TEMP_CHG_ERR_BLINK_BIT;
+		rc = smb1360_masked_write(chip, CFG_STAT_CTRL_REG, mask, reg);
+		if (rc < 0) {
+			dev_err(chip->dev, "Couldn't set irq config rc = %d\n",
+					rc);
+			return rc;
+		}
+
+		/* enabling only interesting interrupts */
+		rc = smb1360_write(chip, IRQ_CFG_REG,
+				IRQ_BAT_HOT_COLD_HARD_BIT
+				| IRQ_BAT_HOT_COLD_SOFT_BIT
+				| IRQ_INTERNAL_TEMPERATURE_BIT
+				| IRQ_DCIN_UV_BIT
+				| IRQ_AICL_DONE_BIT);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set irq1 config rc = %d\n",
+					rc);
+			return rc;
+		}
+
+		rc = smb1360_write(chip, IRQ2_CFG_REG,
+				IRQ2_SAFETY_TIMER_BIT
+				| IRQ2_CHG_ERR_BIT
+				| IRQ2_CHG_PHASE_CHANGE_BIT
+				| IRQ2_POWER_OK_BIT
+				| IRQ2_BATT_MISSING_BIT
+				| IRQ2_VBAT_LOW_BIT);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set irq2 config rc = %d\n",
+					rc);
+			return rc;
+		}
+
+		rc = smb1360_write(chip, IRQ3_CFG_REG,
+                                IRQ3_FG_ACCESS_OK_BIT
+				| IRQ3_SOC_CHANGE_BIT
+				| IRQ3_SOC_MIN_BIT
+				| IRQ3_SOC_MAX_BIT
+				| IRQ3_SOC_EMPTY_BIT
+				| IRQ3_SOC_FULL_BIT);
+		if (rc < 0) {
+			dev_err(chip->dev, "Couldn't set irq3 enable rc = %d\n",
+					rc);
+			return rc;
+		}
+	}
+
+	/* batt-id configuration */
+	if (chip->batt_id_disabled) {
+		mask = BATT_ID_ENABLED_BIT | CHG_BATT_ID_FAIL;
+		reg = CHG_BATT_ID_FAIL;
+		rc = smb1360_masked_write(chip, CFG_FG_BATT_CTRL_REG,
+						mask, reg);
+		if (rc < 0) {
+			dev_err(chip->dev, "Couldn't set batt_id_reg rc = %d\n",
+					rc);
+			return rc;
+		}
+	}
+
+	/* USB OTG current limit configuration */
+	if (chip->otg_batt_curr_limit != -EINVAL) {
+		for (i = 0; i < ARRAY_SIZE(otg_curr_ma); i++) {
+			if (otg_curr_ma[i] >= chip->otg_batt_curr_limit)
+				break;
+		}
+
+		if (i == ARRAY_SIZE(otg_curr_ma))
+			i = i - 1;
+
+		rc = smb1360_masked_write(chip, CFG_BATT_CHG_REG,
+						OTG_CURRENT_MASK,
+					i << OTG_CURRENT_SHIFT);
+		if (rc)
+			pr_err("Couldn't set OTG current limit, rc = %d\n", rc);
+	}
+	rc = smb1360_read(chip,CMD_IL_REG,&temp_data);
+	if (rc)
+		pr_err("read CMD_IL_REG failed %d\n", rc);
+	if(get_usbcharger_type()==4)//usb
+	{
+	     temp_data=(temp_data&0x0f);
+		if(temp_data== 2)
+		{
+		    rc = smb1360_masked_write(chip, CMD_IL_REG,
+					USB_CTRL_MASK, USB_500_BIT);
+		}
+
+		if (rc)
+			pr_err("Couldn't set USB ICL mA rc=%d\n", rc);
+	}
+#if 1
+	//add 2015-01-06 start
+	/*TOG voltage thresdhold 2.75V*/
+    rc = smb1360_masked_write(chip, OTG_UVLO_REG, OTG_UVLO_MASK,
+						OTG_UVLO_DATA << OTG_UVLO_SHIFT);
+    if (rc)
+		pr_err("Couldn't set  OTG_UVLO_REG mode rc=%d\n", rc);
+    /*pre_to_fast voltage thresdhold 3.1V*/
+	rc = smb1360_masked_write(chip, OTG_UVLO_REG, PRE_TO_FAST_MASK,
+						PRE_TO_FAST_DATA << PRE_TO_FAST_SHIFT);
+    if (rc)
+		pr_err("Couldn't set  PRE_TO_FAST_VOLTAGE mode rc=%d\n", rc);
+	//precharging current
+    rc = smb1360_masked_write(chip, CHG_CURRENT_REG, PRE_CHARGE_CURRENT_MASK,
+						PRE_CHARGE_CURRENT_DATA << PRE_CHARGE_CURRENT_SHIFT);
+    if (rc)
+		pr_err("Couldn't set  OTG_UVLO_REG mode rc=%d\n", rc);
+	//add 2015-01-06 end
+#endif
+/*	rc = smb1360_fg_config(chip);
+	if (rc < 0) {
+		pr_err("Couldn't configure FG rc=%d\n", rc);
+		return rc;
+	}*/
+
+	rc = smb1360_charging_disable(chip, USER, !!chip->charging_disabled);
+	if (rc)
+		dev_err(chip->dev, "Couldn't '%s' charging rc = %d\n",
+			chip->charging_disabled ? "disable" : "enable", rc);
+
+	if (chip->parallel_charging) {
+		rc = smb1360_parallel_charger_enable(chip, PARALLEL_USER,
+						!chip->charging_disabled);
+		if (rc)
+			dev_err(chip->dev, "Couldn't '%s' parallel-charging rc = %d\n",
+			chip->charging_disabled ? "disable" : "enable", rc);
+	}
+
+	return rc;
+}
+
+static int smb1360_delayed_hw_init(struct smb1360_chip *chip)
+{
+	int rc;
+
+	pr_debug("delayed hw init start!\n");
+
+	rc = smb1360_check_batt_profile(chip);
+	if (rc) {
+		pr_err("Unable to modify battery profile, rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = smb1360_otp_gain_init(chip);
+	if (rc) {
+		pr_err("Unable to config otp gain, rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = smb1360_fg_config(chip);
+	if (rc) {
+		pr_err("Couldn't configure FG rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = smb1360_check_cycle_stretch(chip);
+	if (rc) {
+		pr_err("Unable to check cycle-stretch\n");
+		return rc;
+	}
+
+	pr_debug("delayed hw init complete!\n");
+	return rc;
+}
+
+static void smb1360_delayed_init_work_fn(struct work_struct *work)
+{
+	int rc = 0;
+	struct smb1360_chip *chip = container_of(work, struct smb1360_chip,
+						delayed_init_work.work);
+
+	rc = smb1360_delayed_hw_init(chip);
+
+	if (!rc) {
+		/*
+		 * If the delayed hw init successfully, update battery
+		 * power_supply to make sure the correct SoC reported
+		 * timely.
+		 */
+		power_supply_changed(&chip->batt_psy);
+	} else if (rc == -ETIMEDOUT) {
+		/*
+		 * If the delayed hw init failed causing by waiting for
+		 * FG access timed-out, force a FG reset and queue the
+		 * worker again to retry the initialization.
+		 */
+		pr_debug("delayed hw init timed-out, retry!");
+		rc = smb1360_force_fg_reset(chip);
+		if (rc) {
+			pr_err("couldn't reset FG, rc = %d\n", rc);
+			return;
+		}
+		schedule_delayed_work(&chip->delayed_init_work, 0);
+	} else {
+		pr_err("delayed hw init failed, rc=%d\n", rc);
+	}
+}
+
+static int smb_parse_batt_id(struct smb1360_chip *chip)
+{
+	int rc = 0, rpull = 0, vref = 0;
+	int64_t denom, batt_id_uv;
+	struct device_node *node = chip->dev->of_node;
+	struct qpnp_vadc_result result;
+
+	chip->vadc_dev = qpnp_get_vadc(chip->dev, "smb1360");
+	if (IS_ERR(chip->vadc_dev)) {
+		rc = PTR_ERR(chip->vadc_dev);
+		if (rc == -EPROBE_DEFER)
+			pr_err("vadc not found - defer rc=%d\n", rc);
+		else
+			pr_err("vadc property missing, rc=%d\n", rc);
+
+		return rc;
+	}
+
+	rc = of_property_read_u32(node, "qcom,profile-a-rid-kohm",
+						&chip->profile_rid[0]);
+	if (rc < 0) {
+		pr_err("Couldn't read profile-a-rid-kohm rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = of_property_read_u32(node, "qcom,profile-b-rid-kohm",
+						&chip->profile_rid[1]);
+	if (rc < 0) {
+		pr_err("Couldn't read profile-b-rid-kohm rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = of_property_read_u32(node, "qcom,batt-id-vref-uv", &vref);
+	if (rc < 0) {
+		pr_err("Couldn't read batt-id-vref-uv rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = of_property_read_u32(node, "qcom,batt-id-rpullup-kohm", &rpull);
+	if (rc < 0) {
+		pr_err("Couldn't read batt-id-rpullup-kohm rc=%d\n", rc);
+		return rc;
+	}
+
+	/* read battery ID */
+	rc = qpnp_vadc_read(chip->vadc_dev, LR_MUX2_BAT_ID, &result);
+	if (rc) {
+		pr_err("error reading batt id channel = %d, rc = %d\n",
+					LR_MUX2_BAT_ID, rc);
+		return rc;
+	}
+	batt_id_uv = result.physical;
+
+	if (batt_id_uv == 0) {
+		/* vadc not correct or batt id line grounded, report 0 kohms */
+		pr_err("batt_id_uv = 0, batt-id grounded using same profile\n");
+		return 0;
+	}
+
+	denom = div64_s64(vref * 1000000LL, batt_id_uv) - 1000000LL;
+	if (denom == 0) {
+		/* batt id connector might be open, return 0 kohms */
+		return 0;
+	}
+	chip->connected_rid = div64_s64(rpull * 1000000LL + denom/2, denom);
+
+	pr_debug("batt_id_voltage = %lld, connected_rid = %d\n",
+			batt_id_uv, chip->connected_rid);
+
+	return 0;
+}
+
+/*
+ * Note the below:
+ * 1. if both qcom,soft-jeita-supported and qcom,config-hard-thresholds
+ * are not defined, SMB continues with default OTP configuration.
+ * 2. if both are enabled, the hard thresholds are modified.
+ * 3. if only qcom,config-hard-thresholds is defined, the soft JEITA is disabled
+ * 4. if only qcom,soft-jeita-supported is defined, the soft JEITA thresholds
+ * are modified.
+ */
+static int smb1360_parse_jeita_params(struct smb1360_chip *chip)
+{
+	int rc = 0;
+	struct device_node *node = chip->dev->of_node;
+
+	if (of_property_read_bool(node, "qcom,config-hard-thresholds")) {
+		rc = of_property_read_u32(node,
+			"qcom,cold-bat-decidegc", &chip->cold_bat_decidegc);
+		if (rc) {
+			pr_err("cold_bat_decidegc property error, rc = %d\n",
+								rc);
+			return -EINVAL;
+		}
+
+		rc = of_property_read_u32(node,
+			"qcom,hot-bat-decidegc", &chip->hot_bat_decidegc);
+		if (rc) {
+			pr_err("hot_bat_decidegc property error, rc = %d\n",
+								rc);
+			return -EINVAL;
+		}
+
+		chip->config_hard_thresholds = true;
+		pr_debug("config_hard_thresholds = %d, cold_bat_decidegc = %d, hot_bat_decidegc = %d\n",
+			chip->config_hard_thresholds, chip->cold_bat_decidegc,
+			chip->hot_bat_decidegc);
+	}
+
+	if (of_property_read_bool(node, "qcom,soft-jeita-supported")) {
+		rc = of_property_read_u32(node, "qcom,warm-bat-decidegc",
+						&chip->warm_bat_decidegc);
+		if (rc) {
+			pr_err("warm_bat_decidegc property error, rc = %d\n",
+								rc);
+			return -EINVAL;
+		}
+
+		rc = of_property_read_u32(node, "qcom,cool-bat-decidegc",
+						&chip->cool_bat_decidegc);
+		if (rc) {
+			pr_err("cool_bat_decidegc property error, rc = %d\n",
+								rc);
+			return -EINVAL;
+		}
+		rc = of_property_read_u32(node, "qcom,cool-bat-mv",
+						&chip->cool_bat_mv);
+		if (rc) {
+			pr_err("cool_bat_mv property error, rc = %d\n", rc);
+			return -EINVAL;
+		}
+
+		rc = of_property_read_u32(node, "qcom,warm-bat-mv",
+						&chip->warm_bat_mv);
+		if (rc) {
+			pr_err("warm_bat_mv property error, rc = %d\n", rc);
+			return -EINVAL;
+		}
+
+		rc = of_property_read_u32(node, "qcom,cool-bat-ma",
+						&chip->cool_bat_ma);
+		if (rc) {
+			pr_err("cool_bat_ma property error, rc = %d\n", rc);
+			return -EINVAL;
+		}
+
+		rc = of_property_read_u32(node, "qcom,warm-bat-ma",
+						&chip->warm_bat_ma);
+
+		if (rc) {
+			pr_err("warm_bat_ma property error, rc = %d\n", rc);
+			return -EINVAL;
+		}
+
+		chip->soft_jeita_supported = true;
+	}
+
+	pr_debug("soft-jeita-enabled = %d, warm-bat-decidegc = %d, cool-bat-decidegc = %d, cool-bat-mv = %d, warm-bat-mv = %d, cool-bat-ma = %d, warm-bat-ma = %d\n",
+		chip->soft_jeita_supported, chip->warm_bat_decidegc,
+		chip->cool_bat_decidegc, chip->cool_bat_mv, chip->warm_bat_mv,
+		chip->cool_bat_ma, chip->warm_bat_ma);
+
+	return rc;
+}
+
+#define MAX_PARALLEL_CURRENT		540
+static int smb1360_parse_parallel_charging_params(struct smb1360_chip *chip)
+{
+	struct device_node *node = chip->dev->of_node;
+
+	if (of_property_read_bool(node, "qcom,parallel-charging-enabled")) {
+
+		if (!chip->rsense_10mohm) {
+			pr_err("10mohm-rsense configuration not enabled - parallel-charging disabled\n");
+			return 0;
+		}
+		chip->parallel_charging = true;
+		chip->max_parallel_chg_current = MAX_PARALLEL_CURRENT;
+		of_property_read_u32(node, "qcom,max-parallel-current-ma",
+					&chip->max_parallel_chg_current);
+
+		pr_debug("Max parallel charger current = %dma\n",
+				chip->max_parallel_chg_current);
+
+		/* mark the parallel-charger as disabled */
+		chip->parallel_chg_disable_status |= PARALLEL_CURRENT;
+	}
+
+	return 0;
+}
+
+static int smb_parse_dt(struct smb1360_chip *chip)
+{
+	int rc;
+	struct device_node *node = chip->dev->of_node;
+
+	if (!node) {
+		dev_err(chip->dev, "device tree info. missing\n");
+		return -EINVAL;
+	}
+
+	chip->rsense_10mohm = of_property_read_bool(node, "qcom,rsense-10mhom");
+
+	if (of_property_read_bool(node, "qcom,batt-profile-select")) {
+		rc = smb_parse_batt_id(chip);
+		if (rc < 0) {
+			if (rc != -EPROBE_DEFER)
+				pr_err("Unable to parse batt-id rc=%d\n", rc);
+			return rc;
+		}
+	}
+
+	chip->otg_fet_present = of_property_read_bool(node,
+						"qcom,otg-fet-present");
+	if (chip->otg_fet_present) {
+		chip->otg_fet_enable_gpio = of_get_named_gpio(node,
+						"qcom,otg-fet-enable-gpio", 0);
+		if (!gpio_is_valid(chip->otg_fet_enable_gpio)) {
+			if (chip->otg_fet_enable_gpio != -EPROBE_DEFER)
+				pr_err("Unable to get OTG FET enable gpio=%d\n",
+						chip->otg_fet_enable_gpio);
+			return chip->otg_fet_enable_gpio;
+                } else {
+                       /* Configure OTG FET control gpio */
+                       rc = devm_gpio_request_one(chip->dev,
+                                       chip->otg_fet_enable_gpio,
+                                       GPIOF_OPEN_DRAIN | GPIOF_INIT_HIGH,
+                                       "smb1360_otg_fet_gpio");
+                       if (rc) {
+                               pr_err("Unable to request gpio rc=%d\n", rc);
+                               return rc;
+                       }
+		}
+	}
+
+	chip->pulsed_irq = of_property_read_bool(node, "qcom,stat-pulsed-irq");
+
+	rc = of_property_read_u32(node, "qcom,float-voltage-mv",
+						&chip->vfloat_mv);
+	if (rc < 0)
+		chip->vfloat_mv = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,charging-timeout",
+						&chip->safety_time);
+	if (rc < 0)
+		chip->safety_time = -EINVAL;
+
+	if (!rc && (chip->safety_time > chg_time[ARRAY_SIZE(chg_time) - 1])) {
+		dev_err(chip->dev, "Bad charging-timeout %d\n",
+						chip->safety_time);
+		return -EINVAL;
+	}
+
+	rc = of_property_read_u32(node, "qcom,recharge-thresh-mv",
+						&chip->resume_delta_mv);
+	if (rc < 0)
+		chip->resume_delta_mv = -EINVAL;
+
+	chip->recharge_disabled = of_property_read_bool(node,
+						"qcom,recharge-disabled");
+
+	rc = of_property_read_u32(node, "qcom,iterm-ma", &chip->iterm_ma);
+	if (rc < 0)
+		chip->iterm_ma = -EINVAL;
+
+	chip->iterm_disabled = of_property_read_bool(node,
+						"qcom,iterm-disabled");
+
+	chip->chg_inhibit_disabled = of_property_read_bool(node,
+						"qcom,chg-inhibit-disabled");
+
+	chip->charging_disabled = of_property_read_bool(node,
+						"qcom,charging-disabled");
+
+	chip->batt_id_disabled = of_property_read_bool(node,
+						"qcom,batt-id-disabled");
+
+	chip->shdn_after_pwroff = of_property_read_bool(node,
+						"qcom,shdn-after-pwroff");
+
+	chip->min_icl_usb100 = of_property_read_bool(node,
+						"qcom,min-icl-100ma");
+
+	rc = smb1360_parse_parallel_charging_params(chip);
+	if (rc) {
+		pr_err("Couldn't parse parallel charginng params rc=%d\n", rc);
+		return rc;
+	}
+
+	if (of_find_property(node, "qcom,thermal-mitigation",
+					&chip->thermal_levels)) {
+		chip->thermal_mitigation = devm_kzalloc(chip->dev,
+					chip->thermal_levels,
+						GFP_KERNEL);
+
+		if (chip->thermal_mitigation == NULL) {
+			pr_err("thermal mitigation kzalloc() failed.\n");
+			return -ENOMEM;
+		}
+
+		chip->thermal_levels /= sizeof(int);
+		rc = of_property_read_u32_array(node,
+				"qcom,thermal-mitigation",
+				chip->thermal_mitigation, chip->thermal_levels);
+		if (rc) {
+			pr_err("Couldn't read threm limits rc = %d\n", rc);
+			return rc;
+		}
+	}
+
+	rc = smb1360_parse_jeita_params(chip);
+	if (rc < 0) {
+		pr_err("Couldn't parse jeita params, rc = %d\n", rc);
+		return rc;
+	}
+
+	/* fg params */
+	chip->empty_soc_disabled = of_property_read_bool(node,
+						"qcom,empty-soc-disabled");
+
+	rc = of_property_read_u32(node, "qcom,fg-delta-soc", &chip->delta_soc);
+	if (rc < 0)
+		chip->delta_soc = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-soc-max", &chip->soc_max);
+	if (rc < 0)
+		chip->soc_max = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-soc-min", &chip->soc_min);
+	if (rc < 0)
+		chip->soc_min = -EINVAL;
+
+	chip->awake_min_soc = of_property_read_bool(node,
+					"qcom,awake-min-soc");
+
+	rc = of_property_read_u32(node, "qcom,fg-voltage-min-mv",
+					&chip->voltage_min_mv);
+	if (rc < 0)
+		chip->voltage_min_mv = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-voltage-empty-mv",
+					&chip->voltage_empty_mv);
+	if (rc < 0)
+		chip->voltage_empty_mv = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-batt-capacity-mah",
+					&chip->batt_capacity_mah);
+	if (rc < 0)
+		chip->batt_capacity_mah = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-cc-soc-coeff",
+					&chip->cc_soc_coeff);
+	if (rc < 0)
+		chip->cc_soc_coeff = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-cutoff-voltage-mv",
+						&chip->v_cutoff_mv);
+	if (rc < 0)
+		chip->v_cutoff_mv = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-iterm-ma",
+					&chip->fg_iterm_ma);
+	if (rc < 0)
+		chip->fg_iterm_ma = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-ibatt-standby-ma",
+					&chip->fg_ibatt_standby_ma);
+	if (rc < 0)
+		chip->fg_ibatt_standby_ma = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,thermistor-c1-coeff",
+					&chip->fg_thermistor_c1_coeff);
+	if (rc < 0)
+		chip->fg_thermistor_c1_coeff = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-cc-to-cv-mv",
+					&chip->fg_cc_to_cv_mv);
+	if (rc < 0)
+		chip->fg_cc_to_cv_mv = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,otg-batt-curr-limit",
+					&chip->otg_batt_curr_limit);
+	if (rc < 0)
+		chip->otg_batt_curr_limit = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-suspend-voltage-empty-mv",
+					&chip->suspend_voltage_empty_mv);
+	if (rc < 0)
+		chip->voltage_empty_mv = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-auto-recharge-soc",
+					&chip->fg_auto_recharge_soc);
+	if (rc < 0)
+		chip->fg_auto_recharge_soc = -EINVAL;
+
+	if (of_property_read_bool(node, "qcom,fg-reset-at-pon")) {
+		chip->fg_reset_at_pon = true;
+		rc = of_property_read_u32(node, "qcom,fg-reset-thresold-mv",
+						&chip->fg_reset_threshold_mv);
+		if (rc) {
+			pr_debug("FG reset voltage threshold not specified using 50mV\n");
+			chip->fg_reset_threshold_mv = FG_RESET_THRESHOLD_MV;
+		}
+	}
+	rc = of_property_read_u32(node, "qcom,hot-bat-mv",
+					&chip->hot_bat_mv);
+	if (rc < 0)
+		chip->fg_auto_recharge_soc = -EINVAL;
+
+	return 0;
+}
+/**wuboadd start**/
+
+static int get_usbcharger_type()
+{
+	struct power_supply *usb_psy;
+	union power_supply_propval val;
+	char *type_text[] = {
+		"Unknown", "Battery", "UPS", "Mains", "USB",
+		"USB_DCP", "USB_CDP", "USB_ACA", "Wireless", "BMS",
+		"USB_Parallel"
+	};
+	usb_psy = power_supply_get_by_name("usb");
+	if(usb_psy)
+	{
+	usb_psy->get_property(usb_psy,POWER_SUPPLY_PROP_TYPE,&val);
+	pr_debug("usb_charger_type id :%d name:%s",val.intval,type_text[val.intval]);
+	return val.intval;
+	}
+	else
+	{
+	pr_err("can not get USB charger type!!!");
+	return 0xDE;
+	}
+}
+static void charger_abnormal_detect_work(struct work_struct *work)
+{
+
+	struct smb1360_chip *chip;
+    struct power_supply *usb_psy;
+	struct power_supply *battery_psy;
+	union power_supply_propval val;
+	int chargertype = 0;
+	int temperature = -200;
+    usb_psy = power_supply_get_by_name("usb");
+	battery_psy = power_supply_get_by_name("battery");
+
+	usb_psy->get_property(usb_psy,POWER_SUPPLY_PROP_PRESENT,&val);
+    chip = container_of(battery_psy,struct smb1360_chip,batt_psy);
+	if(val.intval == 1)
+	{
+		temperature = smb1360_get_prop_batt_temp(chip);
+		 chargertype = get_usbcharger_type();
+
+		 if(chargertype == 5)//AC
+		 {
+			 int rc = 0;
+		   if(temperature>MIN_CHARGING_TEMPERATURE && temperature <=MIDDLE_CHARGING_TEMPERATURE)
+		   	 {
+				rc = smb1360_change_normal_voltage(chip);
+				if (rc < 0) {
+					pr_debug("Couldn't configure change foloat volatile rc = %d\n",rc);
+				}
+		   	    chip->usb_psy_ma = CURRENT_AC_BETWEEN_00_10;//600 ;
+		   	 }
+			 else if(temperature>MIDDLE_CHARGING_TEMPERATURE && temperature <=MAX_CHARGING_TEMPERATURE)
+			 {
+				rc = smb1360_change_normal_voltage(chip);
+				if (rc < 0) {
+					pr_debug("Couldn't configure change foloat volatile rc = %d\n",rc);
+				}
+			    chip->usb_psy_ma =CURRENT_AC_BETWEEN_10_45;//1500 ;
+			 }
+			 else if (temperature>MAX_CHARGING_TEMPERATURE && temperature <OVER_CHARGING_TEMPERATURE) {
+				rc = smb1360_change_float_voltage(chip);
+				if (rc < 0) {
+				pr_debug("Couldn't configure change foloat volatile rc = %d\n",rc);
+				}
+				chip->usb_psy_ma =CURRENT_AC_BETWEEN_45_55;//1050 ;
+			 }
+		 }else if(chargertype == 4)//USB
+		 {
+		      chip->usb_psy_ma =500;
+		 }else
+		 {
+		     pr_info("charger type %d\n",chargertype);
+		 }
+		 smb1360_set_appropriate_usb_current(chip);
+		 power_supply_changed(battery_psy);
+		 smb1360_log_printk("wuboadd usb_online temp %d chip->usb_psy_ma:%d\n",temperature,chip->usb_psy_ma);
+	 }
+	 else
+	 {
+		  release_AC_charger_wakelock();
+		  power_supply_changed(battery_psy);
+	 }
+     schedule_delayed_work(&chip->abnormal_detect,msecs_to_jiffies(10000));
+
+}
+/**wuboadd end**/
+
+
+static int smb1360_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	u8 reg;
+	int rc;
+	struct smb1360_chip *chip;
+	struct power_supply *usb_psy;
+	pr_err("mask:smb1360 probe start!");
+	usb_psy = power_supply_get_by_name("usb");
+	if (!usb_psy) {
+		dev_dbg(&client->dev, "USB supply not found; defer probe\n");
+		return -EPROBE_DEFER;
+	}
+
+	chip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip) {
+		dev_err(&client->dev, "Unable to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	chip->resume_completed = true;
+	chip->client = client;
+	chip->dev = &client->dev;
+	chip->usb_psy = usb_psy;
+	chip->fake_battery_soc = -EINVAL;
+	mutex_init(&chip->read_write_lock);
+	mutex_init(&chip->parallel_chg_lock);
+        mutex_init(&chip->otp_gain_lock);
+        mutex_init(&chip->fg_access_request_lock);
+
+	INIT_DELAYED_WORK(&chip->jeita_work, smb1360_jeita_work_fn);
+        INIT_DELAYED_WORK(&chip->delayed_init_work,
+                      smb1360_delayed_init_work_fn);
+        init_completion(&chip->fg_mem_access_granted);
+
+	INIT_DELAYED_WORK(&chip->one_shot_delay, smb1360_rest_at_pon_work_func);
+
+	/* probe the device to check if its actually connected */
+	rc = smb1360_read(chip, CFG_BATT_CHG_REG, &reg);
+	if (rc) {
+		pr_err("Failed to detect SMB1360, device may be absent\n");
+		return -ENODEV;
+	}
+
+	rc = read_revision(chip, &chip->revision);
+	if (rc)
+		dev_err(chip->dev, "Couldn't read revision rc = %d\n", rc);
+
+	rc = smb_parse_dt(chip);
+	if (rc < 0) {
+		dev_err(&client->dev, "Unable to parse DT nodes\n");
+		return rc;
+	}
+
+	device_init_wakeup(chip->dev, 1);
+	i2c_set_clientdata(client, chip);
+	mutex_init(&chip->irq_complete);
+	mutex_init(&chip->charging_disable_lock);
+	mutex_init(&chip->current_change_lock);
+	INIT_DELAYED_WORK(&chip->abnormal_detect, charger_abnormal_detect_work);
+	chip->default_i2c_addr = client->addr;
+	INIT_WORK(&chip->parallel_work, smb1360_parallel_work);
+
+	pr_debug("default_i2c_addr=%x\n", chip->default_i2c_addr);
+
+	rc = smb1360_hw_init(chip);
+	if (rc < 0) {
+		dev_err(&client->dev,
+			"Unable to intialize hardware rc = %d\n", rc);
+		return rc;
+	}
+
+	rc = smb1360_regulator_init(chip);
+	if  (rc) {
+		dev_err(&client->dev,
+			"Couldn't initialize smb349 ragulator rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = determine_initial_status(chip);
+	if (rc < 0) {
+		dev_err(&client->dev,
+			"Unable to determine init status rc = %d\n", rc);
+		goto fail_hw_init;
+	}
+
+	chip->batt_psy.name		= "battery";
+	chip->batt_psy.type		= POWER_SUPPLY_TYPE_BATTERY;
+	chip->batt_psy.get_property	= smb1360_battery_get_property;
+	chip->batt_psy.set_property	= smb1360_battery_set_property;
+	chip->batt_psy.properties	= smb1360_battery_properties;
+	chip->batt_psy.num_properties  = ARRAY_SIZE(smb1360_battery_properties);
+	chip->batt_psy.external_power_changed = smb1360_external_power_changed;
+	chip->batt_psy.property_is_writeable = smb1360_battery_is_writeable;
+
+	rc = power_supply_register(chip->dev, &chip->batt_psy);
+	if (rc < 0) {
+		dev_err(&client->dev,
+			"Unable to register batt_psy rc = %d\n", rc);
+		goto fail_hw_init;
+	}
+
+	/* STAT irq configuration */
+	if (client->irq) {
+		rc = devm_request_threaded_irq(&client->dev, client->irq, NULL,
+				smb1360_stat_handler, IRQF_ONESHOT,
+				"smb1360_stat_irq", chip);
+		if (rc < 0) {
+			dev_err(&client->dev,
+				"request_irq for irq=%d  failed rc = %d\n",
+				client->irq, rc);
+			goto unregister_batt_psy;
+		}
+		enable_irq_wake(client->irq);
+	}
+	wake_lock_init(&ac_charger_wakelock,WAKE_LOCK_SUSPEND,"AC_CHARGER_WAKELOCK");
+    device_create_file(&client->dev,&dev_attr_smb1360_icinfo);//wubo add create icinfo node.
+	chip->debug_root = debugfs_create_dir("smb1360", NULL);
+	if (!chip->debug_root)
+		dev_err(chip->dev, "Couldn't create debug dir\n");
+
+	if (chip->debug_root) {
+		struct dentry *ent;
+
+		ent = debugfs_create_file("config_registers", S_IFREG | S_IRUGO,
+					  chip->debug_root, chip,
+					  &cnfg_debugfs_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create cnfg debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_file("status_registers", S_IFREG | S_IRUGO,
+					  chip->debug_root, chip,
+					  &status_debugfs_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create status debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_file("irq_status", S_IFREG | S_IRUGO,
+					  chip->debug_root, chip,
+					  &irq_stat_debugfs_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create irq_stat debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_file("cmd_registers", S_IFREG | S_IRUGO,
+					  chip->debug_root, chip,
+					  &cmd_debugfs_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create cmd debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_file("fg_regs",
+				S_IFREG | S_IRUGO, chip->debug_root, chip,
+					  &fg_regs_debugfs_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create fg_scratch_pad debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_x32("address", S_IFREG | S_IWUSR | S_IRUGO,
+					  chip->debug_root,
+					  &(chip->peek_poke_address));
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create address debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_file("data", S_IFREG | S_IWUSR | S_IRUGO,
+					  chip->debug_root, chip,
+					  &poke_poke_debug_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create data debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_x32("fg_address",
+					S_IFREG | S_IWUSR | S_IRUGO,
+					chip->debug_root,
+					&(chip->fg_peek_poke_address));
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create address debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_file("fg_data",
+					S_IFREG | S_IWUSR | S_IRUGO,
+					chip->debug_root, chip,
+					&fg_poke_poke_debug_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create data debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_x32("fg_access_type",
+					S_IFREG | S_IWUSR | S_IRUGO,
+					chip->debug_root,
+					&(chip->fg_access_type));
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create data debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_x32("skip_writes",
+					  S_IFREG | S_IWUSR | S_IRUGO,
+					  chip->debug_root,
+					  &(chip->skip_writes));
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create data debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_x32("skip_reads",
+					  S_IFREG | S_IWUSR | S_IRUGO,
+					  chip->debug_root,
+					  &(chip->skip_reads));
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create data debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_file("irq_count", S_IFREG | S_IRUGO,
+					  chip->debug_root, chip,
+					  &irq_count_debugfs_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create count debug file rc = %d\n",
+				rc);
+	}
+
+	smb1360_chip_global = chip;
+	//the_chip = chip; //patch add
+	//smb1360_fg_reset();//patch add
+        schedule_delayed_work(&chip->one_shot_delay,0);
+	dev_info(chip->dev, "SMB1360 revision=0x%x probe success! batt=%d usb=%d soc=%d\n",
+			chip->revision,
+			smb1360_get_prop_batt_present(chip),
+			chip->usb_present,
+			smb1360_get_prop_batt_capacity(chip));
+
+	return 0;
+
+unregister_batt_psy:
+	power_supply_unregister(&chip->batt_psy);
+fail_hw_init:
+	regulator_unregister(chip->otg_vreg.rdev);
+	return rc;
+}
+
+static int smb1360_remove(struct i2c_client *client)
+{
+	struct smb1360_chip *chip = i2c_get_clientdata(client);
+	cancel_delayed_work(&chip->abnormal_detect);//wuboadd
+	regulator_unregister(chip->otg_vreg.rdev);
+	power_supply_unregister(&chip->batt_psy);
+	mutex_destroy(&chip->charging_disable_lock);
+	mutex_destroy(&chip->current_change_lock);
+	mutex_destroy(&chip->read_write_lock);
+	mutex_destroy(&chip->irq_complete);
+        mutex_destroy(&chip->otp_gain_lock);
+        mutex_destroy(&chip->fg_access_request_lock);
+	debugfs_remove_recursive(chip->debug_root);
+
+	return 0;
+}
+
+static int smb1360_suspend(struct device *dev)
+{
+	int i, rc;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct smb1360_chip *chip = i2c_get_clientdata(client);
+	cancel_delayed_work(&chip->abnormal_detect);//wuboadd
+	/* Save the current IRQ config */
+	for (i = 0; i < 3; i++) {
+		rc = smb1360_read(chip, IRQ_CFG_REG + i,
+					&chip->irq_cfg_mask[i]);
+		if (rc)
+			pr_err("Couldn't save irq cfg regs rc=%d\n", rc);
+	}
+
+	rc = smb1360_set_batt_empty_voltage(chip,chip->suspend_voltage_empty_mv);
+	if (rc)
+	{
+		pr_err("Couldn't set batt empty voltage rc=%d\n", rc);
+	}
+
+	/* enable only important IRQs */
+	rc = smb1360_write(chip, IRQ_CFG_REG, IRQ_DCIN_UV_BIT
+						| IRQ_AICL_DONE_BIT
+						| IRQ_BAT_HOT_COLD_SOFT_BIT
+						| IRQ_BAT_HOT_COLD_HARD_BIT);
+	if (rc < 0)
+		pr_err("Couldn't set irq_cfg rc=%d\n", rc);
+
+	rc = smb1360_write(chip, IRQ2_CFG_REG, IRQ2_BATT_MISSING_BIT
+						| IRQ2_VBAT_LOW_BIT
+						| IRQ2_POWER_OK_BIT);
+	if (rc < 0)
+		pr_err("Couldn't set irq2_cfg rc=%d\n", rc);
+
+	rc = smb1360_write(chip, IRQ3_CFG_REG, IRQ3_SOC_FULL_BIT
+					| IRQ3_SOC_MIN_BIT
+					| IRQ3_SOC_EMPTY_BIT);
+	if (rc < 0)
+		pr_err("Couldn't set irq3_cfg rc=%d\n", rc);
+	
+	mutex_lock(&chip->irq_complete);
+	chip->resume_completed = false;
+	mutex_unlock(&chip->irq_complete);
+
+	return 0;
+}
+
+static int smb1360_suspend_noirq(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct smb1360_chip *chip = i2c_get_clientdata(client);
+
+	if (chip->irq_waiting) {
+		pr_err_ratelimited("Aborting suspend, an interrupt was detected while suspending\n");
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static int smb1360_resume(struct device *dev)
+{
+	int i, rc;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct smb1360_chip *chip = i2c_get_clientdata(client);
+
+
+	/* Restore the IRQ config */
+	for (i = 0; i < 3; i++) {
+		rc = smb1360_write(chip, IRQ_CFG_REG + i,
+					chip->irq_cfg_mask[i]);
+		if (rc)
+			pr_err("Couldn't restore irq cfg regs rc=%d\n", rc);
+	}
+
+	first_AC_in = 1;
+	mutex_lock(&chip->irq_complete);
+	chip->resume_completed = true;
+	if (chip->irq_waiting) {
+		mutex_unlock(&chip->irq_complete);
+		smb1360_stat_handler(client->irq, chip);
+		enable_irq(client->irq);
+	} else {
+		mutex_unlock(&chip->irq_complete);
+	}
+	schedule_delayed_work(&chip->abnormal_detect,msecs_to_jiffies(5000));
+	rc = smb1360_set_batt_empty_voltage(chip, chip->voltage_empty_mv);
+	if (rc)
+	{
+		pr_err("Couldn't set batt empty voltage rc=%d\n", rc);
+	}
+	return 0;
+}
+
+static void smb1360_shutdown(struct i2c_client *client)
+{
+	int rc;
+	struct smb1360_chip *chip = i2c_get_clientdata(client);
+
+	rc = smb1360_otg_disable(chip);
+	if (rc)
+		pr_err("Couldn't disable OTG mode rc=%d\n", rc);
+
+	if (chip->shdn_after_pwroff) {
+		rc = smb1360_poweroff(chip);
+		if (rc)
+			pr_err("Couldn't shutdown smb1360, rc = %d\n", rc);
+		pr_info("smb1360 power off\n");
+	}
+}
+
+static const struct dev_pm_ops smb1360_pm_ops = {
+	.resume		= smb1360_resume,
+	.suspend_noirq	= smb1360_suspend_noirq,
+	.suspend	= smb1360_suspend,
+};
+
+static struct of_device_id smb1360_match_table[] = {
+	{ .compatible = "qcom,smb1360-chg-fg",},
+	{ },
+};
+
+static const struct i2c_device_id smb1360_id[] = {
+	{"smb1360-chg-fg", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, smb1360_id);
+
+static struct i2c_driver smb1360_driver = {
+	.driver		= {
+		.name		= "smb1360-chg-fg",
+		.owner		= THIS_MODULE,
+		.of_match_table	= smb1360_match_table,
+		.pm		= &smb1360_pm_ops,
+	},
+	.probe		= smb1360_probe,
+	.remove		= smb1360_remove,
+	.shutdown	= smb1360_shutdown,
+	.id_table	= smb1360_id,
+};
+
+module_i2c_driver(smb1360_driver);
+
+MODULE_DESCRIPTION("SMB1360 Charger and Fuel Gauge");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("i2c:smb1360-chg-fg");
diff --git a/drivers/power/smb1360-charger-fg-testplus.c b/drivers/power/smb1360-charger-fg-testplus.c
new file mode 100755
index 00000000000..8fcb8b039bc
--- /dev/null
+++ b/drivers/power/smb1360-charger-fg-testplus.c
@@ -0,0 +1,5348 @@
+/* Copyright (c) 2013-2015 The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "SMB:%s: " fmt, __func__
+
+#include <linux/i2c.h>
+#include <linux/debugfs.h>
+#include <linux/gpio.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/math64.h>
+#include <linux/slab.h>
+#include <linux/power_supply.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/regulator/machine.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/bitops.h>
+#include <linux/qpnp/qpnp-adc.h>
+#include <linux/completion.h>
+#include <linux/kthread.h> 
+#include <linux/wakelock.h> // wubo add
+//add start 2015-01-06
+#include <linux/leds.h>    
+static int get_usbcharger_type(void);
+extern long get_msm_thermal_cpu_temperature(uint32_t id);
+static struct wake_lock    ac_charger_wakelock;
+static int g_ac_charger_wakelock_count = 0;
+static int android_disable_charging = 0;
+static int first_AC_in = 1;
+struct smb1360_chip *smb1360_chip_global;
+int first_mic = 0;
+EXPORT_SYMBOL(first_mic);
+
+extern void smb1360_redled_gpio_output(void);
+
+#define CHG_CURRENT_AC_MA 1200
+#define CHG_CURRENT_USB_MA 500
+
+#define DEFAULT_OVERTEMP_DISCHG_HARD 550
+#define DEFAULT_LOWTEMP_DISCHG_HARD 0
+
+//add end 2015-01-06
+static struct smb1360_chip *the_chip; //patch add
+
+#define _SMB1360_MASK(BITS, POS) \
+	((unsigned char)(((1 << (BITS)) - 1) << (POS)))
+#define SMB1360_MASK(LEFT_BIT_POS, RIGHT_BIT_POS) \
+		_SMB1360_MASK((LEFT_BIT_POS) - (RIGHT_BIT_POS) + 1, \
+				(RIGHT_BIT_POS))
+
+/* Charger Registers */
+#define CFG_BATT_CHG_REG		0x00
+#define CHG_ITERM_MASK			SMB1360_MASK(2, 0)
+#define CHG_ITERM_25MA			0x0
+#define CHG_ITERM_200MA			0x7
+#define RECHG_MV_MASK			SMB1360_MASK(6, 5)
+#define RECHG_MV_SHIFT			5
+#define OTG_CURRENT_MASK		SMB1360_MASK(4, 3)
+#define OTG_CURRENT_SHIFT		3
+
+#define CFG_BATT_CHG_FREQ_REG          0x03
+#define SWITCH_FREQ_BIT                BIT(7)
+
+#define CFG_BATT_CHG_ICL_REG		0x05
+#define AC_INPUT_ICL_PIN_BIT		BIT(7)
+#define AC_INPUT_PIN_HIGH_BIT		BIT(6)
+#define RESET_STATE_USB_500		BIT(5)
+#define INPUT_CURR_LIM_MASK		SMB1360_MASK(3, 0)
+#define INPUT_CURR_LIM_300MA		0x0
+
+#define CFG_GLITCH_FLT_REG		0x06
+#define AICL_ENABLED_BIT		BIT(0)
+#define INPUT_UV_GLITCH_FLT_20MS_BIT	BIT(7)
+
+#define CFG_CHG_MISC_REG		0x7
+#define CHG_EN_BY_PIN_BIT		BIT(7)
+#define CHG_EN_ACTIVE_LOW_BIT		BIT(6)
+#define PRE_TO_FAST_REQ_CMD_BIT		BIT(5)
+#define CHG_CURR_TERM_DIS_BIT		BIT(3)
+#define CFG_AUTO_RECHG_DIS_BIT		BIT(2)
+#define CFG_CHG_INHIBIT_EN_BIT		BIT(0)
+
+#define CFG_CHG_FUNC_CTRL_REG		0x08
+#define CHG_RECHG_THRESH_FG_SRC_BIT	BIT(1)
+
+#define CFG_STAT_CTRL_REG		0x09
+#define CHG_STAT_IRQ_ONLY_BIT		BIT(4)
+#define CHG_TEMP_CHG_ERR_BLINK_BIT	BIT(3)
+#define CHG_STAT_ACTIVE_HIGH_BIT	BIT(1)
+#define CHG_STAT_DISABLE_BIT		BIT(0)
+
+#define CFG_SFY_TIMER_CTRL_REG		0x0A
+#define SAFETY_TIME_DISABLE_BIT		BIT(5)
+#define SAFETY_TIME_MINUTES_SHIFT	2
+#define SAFETY_TIME_MINUTES_MASK	SMB1360_MASK(3, 2)
+
+#define CFG_BATT_MISSING_REG		0x0D
+#define BATT_MISSING_SRC_THERM_BIT	BIT(1)
+
+#define CFG_FG_BATT_CTRL_REG		0x0E
+#define CFG_FG_OTP_BACK_UP_ENABLE	BIT(7)
+#define BATT_ID_ENABLED_BIT		BIT(5)
+#define CHG_BATT_ID_FAIL		BIT(4)
+#define BATT_ID_FAIL_SELECT_PROFILE	BIT(3)
+#define BATT_PROFILE_SELECT_MASK	SMB1360_MASK(3, 0)
+#define BATT_PROFILEA_MASK		0x0
+#define BATT_PROFILEB_MASK		0xF
+
+#define IRQ_CFG_REG			0x0F
+#define IRQ_BAT_HOT_COLD_HARD_BIT	BIT(7)
+#define IRQ_BAT_HOT_COLD_SOFT_BIT	BIT(6)
+#define IRQ_DCIN_UV_BIT			BIT(2)
+#define IRQ_AICL_DONE_BIT		BIT(1)
+#define IRQ_INTERNAL_TEMPERATURE_BIT	BIT(0)
+
+#define IRQ2_CFG_REG			0x10
+#define IRQ2_SAFETY_TIMER_BIT		BIT(7)
+#define IRQ2_CHG_ERR_BIT		BIT(6)
+#define IRQ2_CHG_PHASE_CHANGE_BIT	BIT(4)
+#define IRQ2_POWER_OK_BIT		BIT(2)
+#define IRQ2_BATT_MISSING_BIT		BIT(1)
+#define IRQ2_VBAT_LOW_BIT		BIT(0)
+
+#define IRQ3_CFG_REG			0x11
+#define IRQ3_FG_ACCESS_OK_BIT		BIT(6)
+#define IRQ3_SOC_CHANGE_BIT		BIT(4)
+#define IRQ3_SOC_MIN_BIT		BIT(3)
+#define IRQ3_SOC_MAX_BIT		BIT(2)
+#define IRQ3_SOC_EMPTY_BIT		BIT(1)
+#define IRQ3_SOC_FULL_BIT		BIT(0)
+//add start 2015-01-06
+#define OTG_UVLO_REG			0x12
+#define OTG_UVLO_MASK		SMB1360_MASK(4, 2)
+#define OTG_UVLO_DATA		2
+#define OTG_UVLO_SHIFT		2
+
+#define PRE_TO_FAST_MASK		SMB1360_MASK(7, 5)
+#define PRE_TO_FAST_DATA		7
+#define PRE_TO_FAST_SHIFT		5
+
+#define PRE_CHARGE_CURRENT_MASK		SMB1360_MASK(1, 0)
+#define PRE_CHARGE_CURRENT_SHIFT		0
+#define PRE_CHARGE_CURRENT_DATA    1
+//add end 2015-01-06
+#define CHG_CURRENT_REG			0x13
+#define FASTCHG_CURR_MASK		SMB1360_MASK(4, 2)
+#define FASTCHG_CURR_SHIFT		2
+
+#define CHG_CMP_CFG			0x14
+#define JEITA_COMP_CURR_MASK		SMB1360_MASK(3, 0)
+#define JEITA_COMP_EN_MASK		SMB1360_MASK(7, 4)
+#define JEITA_COMP_EN_SHIFT		4
+#define JEITA_COMP_EN_BIT		SMB1360_MASK(7, 4)
+#define BATT_CHG_FLT_VTG_REG		0x15
+#define VFLOAT_MASK			SMB1360_MASK(6, 0)
+#define CFG_FVC_REG			0x16
+#define FLT_VTG_COMP_MASK		SMB1360_MASK(6, 0)
+
+#define SHDN_CTRL_REG			0x1A
+#define SHDN_CMD_USE_BIT		BIT(1)
+#define SHDN_CMD_POLARITY_BIT		BIT(2)
+
+#define CURRENT_GAIN_LSB_REG		0x1D
+#define CURRENT_GAIN_MSB_REG		0x1E
+
+/* Command Registers */
+#define CMD_I2C_REG			0x40
+#define ALLOW_VOLATILE_BIT		BIT(6)
+#define FG_ACCESS_ENABLED_BIT		BIT(5)
+#define FG_RESET_BIT			BIT(4)
+#define CYCLE_STRETCH_CLEAR_BIT		BIT(3)
+
+#define CMD_IL_REG			0x41
+#define USB_CTRL_MASK			SMB1360_MASK(1 , 0)
+#define USB_100_BIT			0x01
+#define USB_500_BIT			0x00
+#define USB_AC_BIT			0x02
+#define SHDN_CMD_BIT			BIT(7)
+
+#define CMD_CHG_REG			0x42
+#define CMD_CHG_EN			BIT(1)
+#define CMD_OTG_EN_BIT			BIT(0)
+
+/* Status Registers */
+#define STATUS_1_REG			0x48
+#define AICL_CURRENT_STATUS_MASK	SMB1360_MASK(6, 0)
+#define AICL_LIMIT_1200MA		0xC
+
+#define STATUS_3_REG			0x4B
+#define CHG_HOLD_OFF_BIT		BIT(3)
+#define CHG_TYPE_MASK			SMB1360_MASK(2, 1)
+#define CHG_TYPE_SHIFT			1
+#define BATT_NOT_CHG_VAL		0x0
+#define BATT_PRE_CHG_VAL		0x1
+#define BATT_FAST_CHG_VAL		0x2
+#define BATT_TAPER_CHG_VAL		0x3
+#define CHG_EN_BIT			BIT(0)
+
+#define STATUS_4_REG			0x4C
+#define CYCLE_STRETCH_ACTIVE_BIT	BIT(5)
+
+#define REVISION_CTRL_REG		0x4F
+#define DEVICE_REV_MASK			SMB1360_MASK(3, 0)
+
+/* IRQ Status Registers */
+#define IRQ_A_REG			0x50
+#define IRQ_A_HOT_HARD_BIT		BIT(6)
+#define IRQ_A_COLD_HARD_BIT		BIT(4)
+#define IRQ_A_HOT_SOFT_BIT		BIT(2)
+#define IRQ_A_COLD_SOFT_BIT		BIT(0)
+
+#define IRQ_B_REG			0x51
+#define IRQ_B_BATT_TERMINAL_BIT		BIT(6)
+#define IRQ_B_BATT_MISSING_BIT		BIT(4)
+
+#define IRQ_C_REG			0x52
+#define IRQ_C_CHG_TERM			BIT(0)
+
+#define IRQ_D_REG			0x53
+#define IRQ_E_REG			0x54
+#define IRQ_E_USBIN_UV_BIT		BIT(0)
+
+#define IRQ_F_REG			0x55
+
+#define IRQ_G_REG			0x56
+
+#define IRQ_H_REG			0x57
+#define IRQ_I_REG			0x58
+#define FG_ACCESS_ALLOWED_BIT		BIT(0)
+#define BATT_ID_RESULT_BIT		SMB1360_MASK(6, 4)
+#define BATT_ID_SHIFT			4
+
+/* FG registers - IRQ config register */
+#define SOC_MAX_REG			0x24
+#define SOC_MIN_REG			0x25
+#define VTG_EMPTY_REG			0x26
+#define SOC_DELTA_REG			0x28
+#define JEITA_SOFT_COLD_REG		0x29
+#define JEITA_SOFT_HOT_REG		0x2A
+#define VTG_MIN_REG			0x2B
+
+/* FG SHADOW registers */
+#define SHDW_FG_ESR_ACTUAL		0x20
+#define SHDW_FG_BATT_STATUS		0x60
+#define BATTERY_PROFILE_BIT		BIT(0)
+
+#define SHDW_FG_MSYS_SOC		0x61
+#define SHDW_FG_CAPACITY		0x62
+#define SHDW_FG_VTG_NOW			0x69
+#define SHDW_FG_CURR_NOW		0x6B
+#define SHDW_FG_BATT_TEMP		0x6D
+
+#define VOLTAGE_PREDICTED_REG		0x80
+#define CC_TO_SOC_COEFF			0xBA
+#define NOMINAL_CAPACITY_REG		0xBC
+#define ACTUAL_CAPACITY_REG		0xBE
+#define FG_AUTO_RECHARGE_SOC		0xD2
+#define FG_SYS_CUTOFF_V_REG		0xD3
+#define FG_CC_TO_CV_V_REG		0xD5
+#define FG_ITERM_REG			0xD9
+#define FG_THERM_C1_COEFF_REG		0xDB
+#define FG_IBATT_STANDBY_REG		0xCF
+
+#define FG_I2C_CFG_MASK			SMB1360_MASK(2, 1)
+#define FG_CFG_I2C_ADDR			0x2
+#define FG_PROFILE_A_ADDR		0x4
+#define FG_PROFILE_B_ADDR		0x6
+
+/* Constants */
+#define CURRENT_100_MA			100
+#define CURRENT_500_MA			500
+#define MAX_8_BITS			255
+#define JEITA_WORK_MS			3000
+
+#define FG_RESET_THRESHOLD_MV		50
+#define SMB1360_REV_1			0x01
+
+#define SMB1360_POWERON_DELAY_MS   2000
+#define SMB1360_FG_RESET_DELAY_MS  1500
+
+/*****************************************************************************
+ *  Log
+ ****************************************************************************/
+#define SMB1360_LOG_ENABLE 0
+
+#define smb1360_log_printk(fmt, ...) \
+    do { \
+        if (0 < SMB1360_LOG_ENABLE) { \
+            printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__); \
+        } \
+    } while(0)
+
+enum {
+	WRKRND_FG_CONFIG_FAIL = BIT(0),
+	WRKRND_BATT_DET_FAIL = BIT(1),
+	WRKRND_USB100_FAIL = BIT(2),
+	WRKRND_HARD_JEITA = BIT(3),
+};
+
+enum {
+	USER	= BIT(0),
+	CURRENT = BIT(1),
+	JEITA_SOFT = BIT(2),
+	JEITA_HARD = BIT(3),
+	EOC = BIT(4),
+};
+
+enum {
+	PARALLEL_USER = BIT(0),
+	PARALLEL_CURRENT = BIT(1),
+	PARALLEL_JEITA_SOFT = BIT(2),
+	PARALLEL_JEITA_HARD = BIT(3),
+	PARALLEL_EOC = BIT(4),
+};
+
+enum fg_i2c_access_type {
+	FG_ACCESS_CFG = 0x1,
+	FG_ACCESS_PROFILE_A = 0x2,
+	FG_ACCESS_PROFILE_B = 0x3
+};
+
+enum {
+	BATTERY_PROFILE_A,
+	BATTERY_PROFILE_B,
+	BATTERY_PROFILE_MAX,
+};
+
+static int otg_curr_ma[] = {350, 550, 950, 1500};
+
+struct smb1360_otg_regulator {
+	struct regulator_desc	rdesc;
+	struct regulator_dev	*rdev;
+};
+
+void acquire_AC_charger_wakelock(void)
+{
+    if(g_ac_charger_wakelock_count==0)
+    {
+    pr_info("AC_charger wake_lock\n");
+    g_ac_charger_wakelock_count = 1;
+    wake_lock(&ac_charger_wakelock);
+    }
+}
+EXPORT_SYMBOL(acquire_AC_charger_wakelock);
+void release_AC_charger_wakelock(void)
+{
+	if(g_ac_charger_wakelock_count==1)
+	{
+	    pr_info("AC_charger wake_unlock\n");
+		g_ac_charger_wakelock_count = 0;
+		wake_unlock(&ac_charger_wakelock);
+	}
+}
+EXPORT_SYMBOL(release_AC_charger_wakelock);
+void set_android_charging_enable(void)
+{
+    android_disable_charging = 0;
+	pr_info("android_disable_charging = 0\n");
+}
+EXPORT_SYMBOL(set_android_charging_enable);
+struct smb1360_chip {
+	struct i2c_client		*client;
+	struct device			*dev;
+	u8				revision;
+	u8				soft_hot_rt_stat;
+	u8				soft_cold_rt_stat;
+	struct delayed_work		jeita_work;
+	struct delayed_work		delayed_init_work;
+	unsigned short			default_i2c_addr;
+	unsigned short			fg_i2c_addr;
+	bool				pulsed_irq;
+	struct completion		fg_mem_access_granted;
+
+	/* configuration data - charger */
+	int				fake_battery_soc;
+	bool				batt_id_disabled;
+	bool				charging_disabled;
+	bool				recharge_disabled;
+	bool				chg_inhibit_disabled;
+	bool				iterm_disabled;
+	bool				shdn_after_pwroff;
+	bool				config_hard_thresholds;
+	bool				config_rechg_temp;
+	bool				soft_jeita_supported;
+	int				iterm_ma;
+	int				vfloat_mv;
+	int				safety_time;
+	int				resume_delta_mv;
+	u32				default_batt_profile;
+	unsigned int			thermal_levels;
+	unsigned int			therm_lvl_sel;
+	unsigned int			*thermal_mitigation;
+	int				otg_batt_curr_limit;
+	bool				min_icl_usb100;
+	int				cold_bat_decidegc;
+	int				hot_bat_decidegc;
+	int				rechg_warm_bat_decidegc;
+	int				rechg_cool_bat_decidegc;
+	int				rechg_cold_bat_decidegc;
+	bool				soft_disable_charging;
+	int				suspend_voltage_empty_mv;
+	int				cool_bat_decidegc;
+	int				warm_bat_decidegc;
+	int				cool_bat_mv;
+	int				warm_bat_mv;
+	int				hot_bat_mv;
+	int				cool_bat_ma;
+	int				warm_bat_ma;
+	int				soft_cold_thresh;
+	int				soft_hot_thresh;
+	bool            ckt_therengine_control;/* qcom,ckt-therengine-control 2015-6-9 15:20:42*/
+	/* parallel-chg params */
+	int				fastchg_current;
+	int				parallel_chg_disable_status;
+	int				max_parallel_chg_current;
+	bool				parallel_charging;
+
+	/* configuration data - fg */
+	int				soc_max;
+	int				soc_min;
+	int				delta_soc;
+	int				voltage_min_mv;
+	int				voltage_empty_mv;
+	int				batt_capacity_mah;
+	int				cc_soc_coeff;
+	int				v_cutoff_mv;
+	int				fg_iterm_ma;
+	int				fg_ibatt_standby_ma;
+	int				fg_thermistor_c1_coeff;
+	int				fg_cc_to_cv_mv;
+	int				fg_auto_recharge_soc;
+	bool				empty_soc_disabled;
+	int				fg_reset_threshold_mv;
+	bool				fg_reset_at_pon;
+	bool				rsense_10mohm;
+	bool				otg_fet_present;
+	bool				fet_gain_enabled;
+	int				otg_fet_enable_gpio;
+
+	/* status tracking */
+	int				voltage_now;
+	int				current_now;
+	int				resistance_now;
+	int				temp_now;
+	int				soc_now;
+	int				fcc_mah;
+	bool				usb_present;
+	bool				batt_present;
+	bool				batt_hot;
+	bool				batt_cold;
+	bool				batt_warm;
+	bool				batt_cool;
+	bool				batt_full;
+	bool				resume_completed;
+	bool				irq_waiting;
+	bool				empty_soc;
+	bool				awake_min_soc;
+	int				workaround_flags;
+	u8				irq_cfg_mask[3];
+	int				usb_psy_ma;
+	int				charging_disabled_status;
+	u32				connected_rid;
+	u32				profile_rid[BATTERY_PROFILE_MAX];
+
+	u32				peek_poke_address;
+	u32				fg_access_type;
+	u32				fg_peek_poke_address;
+	int				skip_writes;
+	int				skip_reads;
+	struct dentry			*debug_root;
+
+	struct qpnp_vadc_chip		*vadc_dev;
+	struct power_supply		*parallel_psy;
+	struct power_supply		*usb_psy;
+	struct power_supply		batt_psy;
+	struct smb1360_otg_regulator	otg_vreg;
+	struct mutex			irq_complete;
+	struct mutex			charging_disable_lock;
+	struct mutex			current_change_lock;
+	struct mutex			read_write_lock;
+	struct mutex			parallel_chg_lock;
+	struct work_struct		parallel_work;
+    struct mutex            otp_gain_lock;
+    struct mutex            fg_access_request_lock;
+	struct delayed_work abnormal_detect;//add 2015-01-06 wendu
+	struct delayed_work one_shot_delay;//mask add 2015-03-30
+};
+
+static int chg_time[] = {
+	192,
+	384,
+	768,
+	1536,
+};
+//add 
+void setAcInstat(void)
+{
+    first_AC_in = 1;
+	smb1360_log_printk("wuboadd setting first_AC_in = 1\n");
+};
+EXPORT_SYMBOL(setAcInstat);
+
+//add end
+static int input_current_limit[] = {
+	300, 400, 450, 500, 600, 700, 800, 850, 900,
+	950, 1000, 1100, 1200, 1300, 1400, 1500,
+};
+
+static int fastchg_current[] = {
+	450, 600, 750, 900, 1050, 1200, 1350, 1500,
+};
+
+static int is_between(int value, int left, int right)
+{
+	if (left >= right && left >= value && value >= right)
+		return 1;
+	if (left <= right && left <= value && value <= right)
+		return 1;
+
+	return 0;
+}
+
+static int bound(int val, int min, int max)
+{
+	if (val < min)
+		return min;
+	if (val > max)
+		return max;
+
+	return val;
+}
+
+static int __smb1360_read(struct smb1360_chip *chip, int reg,
+				u8 *val)
+{
+	s32 ret;
+
+	ret = i2c_smbus_read_byte_data(chip->client, reg);
+	if (ret < 0) {
+		dev_err(chip->dev,
+			"i2c read fail: can't read from %02x: %d\n", reg, ret);
+		return ret;
+	} else {
+		*val = ret;
+	}
+	pr_debug("Reading 0x%02x=0x%02x\n", reg, *val);
+
+	return 0;
+}
+
+static int __smb1360_write(struct smb1360_chip *chip, int reg,
+						u8 val)
+{
+	s32 ret;
+
+	ret = i2c_smbus_write_byte_data(chip->client, reg, val);
+	if (ret < 0) {
+		dev_err(chip->dev,
+			"i2c write fail: can't write %02x to %02x: %d\n",
+			val, reg, ret);
+		return ret;
+	}
+	pr_debug("Writing 0x%02x=0x%02x\n", reg, val);
+	return 0;
+}
+
+static int smb1360_read(struct smb1360_chip *chip, int reg,
+				u8 *val)
+{
+	int rc;
+
+	if (chip->skip_reads) {
+		*val = 0;
+		return 0;
+	}
+	mutex_lock(&chip->read_write_lock);
+	rc = __smb1360_read(chip, reg, val);
+	mutex_unlock(&chip->read_write_lock);
+
+	return rc;
+}
+
+static int smb1360_write(struct smb1360_chip *chip, int reg,
+						u8 val)
+{
+	int rc;
+
+	if (chip->skip_writes)
+		return 0;
+
+	mutex_lock(&chip->read_write_lock);
+	rc = __smb1360_write(chip, reg, val);
+	mutex_unlock(&chip->read_write_lock);
+
+	return rc;
+}
+
+static int smb1360_fg_read(struct smb1360_chip *chip, int reg,
+				u8 *val)
+{
+	int rc;
+
+	if (chip->skip_reads) {
+		*val = 0;
+		return 0;
+	}
+
+	mutex_lock(&chip->read_write_lock);
+	chip->client->addr = chip->fg_i2c_addr;
+	rc = __smb1360_read(chip, reg, val);
+	chip->client->addr = chip->default_i2c_addr;
+	mutex_unlock(&chip->read_write_lock);
+
+	return rc;
+}
+
+static int smb1360_fg_write(struct smb1360_chip *chip, int reg,
+						u8 val)
+{
+	int rc;
+
+	if (chip->skip_writes)
+		return 0;
+
+	mutex_lock(&chip->read_write_lock);
+	chip->client->addr = chip->fg_i2c_addr;
+	rc = __smb1360_write(chip, reg, val);
+	chip->client->addr = chip->default_i2c_addr;
+	mutex_unlock(&chip->read_write_lock);
+
+	return rc;
+}
+
+static int smb1360_read_bytes(struct smb1360_chip *chip, int reg,
+						u8 *val, u8 bytes)
+{
+	s32 rc;
+
+	if (chip->skip_reads) {
+		*val = 0;
+		return 0;
+	}
+
+	mutex_lock(&chip->read_write_lock);
+	rc = i2c_smbus_read_i2c_block_data(chip->client, reg, bytes, val);
+	if (rc < 0)
+		dev_err(chip->dev,
+			"i2c read fail: can't read %d bytes from %02x: %d\n",
+							bytes, reg, rc);
+	mutex_unlock(&chip->read_write_lock);
+
+	return (rc < 0) ? rc : 0;
+}
+//add start 2015-01-06 ic_version
+static ssize_t smb1360_icinfo_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+	struct smb1360_chip *chip = i2c_get_clientdata(client);	
+	
+	return snprintf(buf, 30,"%s %d \n","SMB1360",chip->revision);
+}
+
+DEVICE_ATTR(smb1360_icinfo, 0444, smb1360_icinfo_show, NULL);
+//add end
+
+static int smb1360_write_bytes(struct smb1360_chip *chip, int reg,
+						u8 *val, u8 bytes)
+{
+	s32 rc;
+
+	if (chip->skip_writes) {
+		*val = 0;
+		return 0;
+	}
+
+	mutex_lock(&chip->read_write_lock);
+	rc = i2c_smbus_write_i2c_block_data(chip->client, reg, bytes, val);
+	if (rc < 0)
+		dev_err(chip->dev,
+			"i2c write fail: can't read %d bytes from %02x: %d\n",
+							bytes, reg, rc);
+	mutex_unlock(&chip->read_write_lock);
+
+	return (rc < 0) ? rc : 0;
+}
+
+static int smb1360_masked_write(struct smb1360_chip *chip, int reg,
+						u8 mask, u8 val)
+{
+	s32 rc;
+	u8 temp;
+
+	if (chip->skip_writes || chip->skip_reads)
+		return 0;
+
+	mutex_lock(&chip->read_write_lock);
+	rc = __smb1360_read(chip, reg, &temp);
+	if (rc < 0) {
+		dev_err(chip->dev, "read failed: reg=%03X, rc=%d\n", reg, rc);
+		goto out;
+	}
+	temp &= ~mask;
+	temp |= val & mask;
+	rc = __smb1360_write(chip, reg, temp);
+	if (rc < 0) {
+		dev_err(chip->dev,
+			"write failed: reg=%03X, rc=%d\n", reg, rc);
+	}
+out:
+	mutex_unlock(&chip->read_write_lock);
+	return rc;
+}
+
+#define EXPONENT_MASK		0xF800
+#define MANTISSA_MASK		0x3FF
+#define SIGN_MASK		0x400
+#define EXPONENT_SHIFT		11
+#define SIGN_SHIFT		10
+#define MICRO_UNIT		1000000ULL
+static int64_t float_decode(u16 reg)
+{
+	int64_t final_val, exponent_val, mantissa_val;
+	int exponent, mantissa, n;
+	bool sign;
+
+	exponent = (reg & EXPONENT_MASK) >> EXPONENT_SHIFT;
+	mantissa = (reg & MANTISSA_MASK);
+	sign = !!(reg & SIGN_MASK);
+
+	pr_debug("exponent=%d mantissa=%d sign=%d\n", exponent, mantissa, sign);
+
+	mantissa_val = mantissa * MICRO_UNIT;
+
+	n = exponent - 15;
+	if (n < 0)
+		exponent_val = MICRO_UNIT >> -n;
+	else
+		exponent_val = MICRO_UNIT << n;
+
+	n = n - 10;
+	if (n < 0)
+		mantissa_val >>= -n;
+	else
+		mantissa_val <<= n;
+
+	final_val = exponent_val + mantissa_val;
+
+	if (sign)
+		final_val *= -1;
+
+	return final_val;
+}
+
+#define MAX_MANTISSA    (1023 * 1000000ULL)
+unsigned int float_encode(int64_t float_val)
+{
+	int exponent = 0, sign = 0;
+	unsigned int final_val = 0;
+
+	if (float_val == 0)
+		return 0;
+
+	if (float_val < 0) {
+		sign = 1;
+		float_val = -float_val;
+	}
+
+	/* Reduce large mantissa until it fits into 10 bit */
+	while (float_val >= MAX_MANTISSA) {
+		exponent++;
+		float_val >>= 1;
+	}
+
+	/* Increase small mantissa to improve precision */
+	while (float_val < MAX_MANTISSA && exponent > -25) {
+		exponent--;
+		float_val <<= 1;
+	}
+
+	exponent = exponent + 25;
+
+	/* Convert mantissa from micro-units to units */
+	float_val = div_s64((float_val + MICRO_UNIT), (int)MICRO_UNIT);
+
+	if (float_val == 1024) {
+		exponent--;
+		float_val <<= 1;
+	}
+
+	float_val -= 1024;
+
+	/* Ensure that resulting number is within range */
+	if (float_val > MANTISSA_MASK)
+		float_val = MANTISSA_MASK;
+
+	/* Convert to 5 bit exponent, 11 bit mantissa */
+	final_val = (float_val & MANTISSA_MASK) | (sign << SIGN_SHIFT) |
+		((exponent << EXPONENT_SHIFT) & EXPONENT_MASK);
+
+	return final_val;
+}
+
+/* FG reset could only be done after FG access being granted */
+static int smb1360_force_fg_reset(struct smb1360_chip *chip)
+{
+	int rc;
+
+	rc = smb1360_masked_write(chip, CMD_I2C_REG, FG_RESET_BIT,
+						FG_RESET_BIT);
+	if (rc) {
+		pr_err("Couldn't reset FG rc=%d\n", rc);
+		return rc;
+	}
+
+	msleep(SMB1360_FG_RESET_DELAY_MS);
+
+	rc = smb1360_masked_write(chip, CMD_I2C_REG, FG_RESET_BIT, 0);
+	if (rc)
+		pr_err("Couldn't un-reset FG rc=%d\n", rc);
+
+	return rc;
+}
+
+/*
+ * Requesting FG access relys on the FG_ACCESS_ALLOWED IRQ.
+ * This function can only be called after interrupt handler
+ * being installed successfully.
+ */
+#define SMB1360_FG_ACCESS_TIMEOUT_MS	5000
+#define SMB1360_FG_ACCESS_RETRY_COUNT	3
+static int smb1360_enable_fg_access(struct smb1360_chip *chip)
+{
+	int rc = 0;
+	u8 reg, retry = SMB1360_FG_ACCESS_RETRY_COUNT;
+
+	pr_debug("request FG memory access\n");
+	/*
+	 * read the ACCESS_ALLOW status bit firstly to
+	 * check if the access was granted before
+	 */
+	mutex_lock(&chip->fg_access_request_lock);
+	pm_stay_awake(chip->dev);
+	rc = smb1360_read(chip, IRQ_I_REG, &reg);
+	if (rc) {
+		pr_err("Couldn't read IRQ_I_REG, rc=%d\n", rc);
+		goto bail_i2c;
+	} else if (reg & FG_ACCESS_ALLOWED_BIT) {
+		pr_debug("FG access was granted\n");
+		goto bail_i2c;
+	}
+
+	/* request FG access */
+	rc = smb1360_masked_write(chip, CMD_I2C_REG, FG_ACCESS_ENABLED_BIT,
+							FG_ACCESS_ENABLED_BIT);
+	if (rc) {
+		pr_err("Couldn't enable FG access rc=%d\n", rc);
+		goto bail_i2c;
+	}
+
+	while (retry--) {
+		rc = wait_for_completion_interruptible_timeout(
+			&chip->fg_mem_access_granted,
+			msecs_to_jiffies(SMB1360_FG_ACCESS_TIMEOUT_MS));
+		if (rc <= 0)
+			pr_debug("FG access timeout, retry: %d\n", retry);
+		else
+			break;
+	}
+	if (rc == 0) /* timed out */
+		rc = -ETIMEDOUT;
+	else if (rc > 0) /* completed */
+		rc = 0;
+
+	/* Clear the FG access bit if request failed */
+	if (rc < 0) {
+		rc = smb1360_masked_write(chip, CMD_I2C_REG,
+				FG_ACCESS_ENABLED_BIT, 0);
+		if (rc)
+			pr_err("Couldn't disable FG access rc=%d\n", rc);
+	}
+
+bail_i2c:
+	pm_relax(chip->dev);
+	mutex_unlock(&chip->fg_access_request_lock);
+	return rc;
+}
+
+static inline bool is_device_suspended(struct smb1360_chip *chip)
+{
+	return !chip->resume_completed;
+}
+
+static int smb1360_disable_fg_access(struct smb1360_chip *chip)
+{
+	int rc;
+
+	rc = smb1360_masked_write(chip, CMD_I2C_REG, FG_ACCESS_ENABLED_BIT, 0);
+	if (rc)
+		pr_err("Couldn't disable FG access rc=%d\n", rc);
+
+	INIT_COMPLETION(chip->fg_mem_access_granted);
+
+	return rc;
+}
+
+static int smb1360_enable_volatile_writes(struct smb1360_chip *chip)
+{
+	int rc;
+
+	rc = smb1360_masked_write(chip, CMD_I2C_REG,
+		ALLOW_VOLATILE_BIT, ALLOW_VOLATILE_BIT);
+	if (rc < 0)
+		dev_err(chip->dev,
+			"Couldn't set VOLATILE_W_PERM_BIT rc=%d\n", rc);
+
+	return rc;
+}
+
+/*patch add start*/
+int smb1360_fg_reset(void)
+{
+	int rc;
+
+	if (!the_chip) {
+		pr_err("chip not initialized\n");
+		return 0;
+	}
+
+	rc = smb1360_enable_fg_access(the_chip);
+	if (rc)
+		pr_err("Unable to enable FG access\n");
+
+	msleep(1500);
+
+	/* reset FG */
+	rc = smb1360_masked_write(the_chip, CMD_I2C_REG, FG_RESET_BIT,
+						FG_RESET_BIT);
+	if (rc) {
+		pr_err("Couldn't reset FG rc=%d\n", rc);
+		goto disable_access;
+	}
+
+	/* un-reset FG */
+	rc = smb1360_masked_write(the_chip, CMD_I2C_REG, FG_RESET_BIT, 0);
+	if (rc) {
+		pr_err("Couldn't un-reset FG rc=%d\n", rc);
+		goto disable_access;
+	}
+
+disable_access:
+	smb1360_disable_fg_access(the_chip);
+
+	msleep(1500);
+
+	return rc;
+}
+EXPORT_SYMBOL(smb1360_fg_reset);
+/*patch add end*/
+
+
+
+#define TRIM_1C_REG		0x1C
+#define CHECK_USB100_GOOD_BIT	BIT(6)
+static bool is_usb100_broken(struct smb1360_chip *chip)
+{
+	int rc;
+	u8 reg;
+
+	rc = smb1360_read(chip, TRIM_1C_REG, &reg);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't read trim 1C reg rc = %d\n", rc);
+		return rc;
+	}
+	return !!(reg & CHECK_USB100_GOOD_BIT);
+}
+
+static int read_revision(struct smb1360_chip *chip, u8 *revision)
+{
+	int rc;
+
+	*revision = 0;
+	rc = smb1360_read(chip, REVISION_CTRL_REG, revision);
+	if (rc)
+		dev_err(chip->dev, "Couldn't read REVISION_CTRL_REG rc=%d", rc);
+
+	*revision &= DEVICE_REV_MASK;
+
+	return rc;
+}
+
+#define MIN_FLOAT_MV		3460
+#define MAX_FLOAT_MV		4730
+#define VFLOAT_STEP_MV		10
+static int smb1360_float_voltage_set(struct smb1360_chip *chip, int vfloat_mv)
+{
+	u8 temp;
+
+	if ((vfloat_mv < MIN_FLOAT_MV) || (vfloat_mv > MAX_FLOAT_MV)) {
+		dev_err(chip->dev, "bad float voltage mv =%d asked to set\n",
+					vfloat_mv);
+		return -EINVAL;
+	}
+	pr_debug(" zms bad float voltage mv =%d asked to set\n", vfloat_mv);
+	temp = (vfloat_mv - MIN_FLOAT_MV) / VFLOAT_STEP_MV;
+
+	return smb1360_masked_write(chip, BATT_CHG_FLT_VTG_REG,
+				VFLOAT_MASK, temp);
+}
+
+#define MIN_RECHG_MV		50
+#define MAX_RECHG_MV		300
+static int smb1360_recharge_threshold_set(struct smb1360_chip *chip,
+							int resume_mv)
+{
+	u8 temp;
+
+	if ((resume_mv < MIN_RECHG_MV) || (resume_mv > MAX_RECHG_MV)) {
+		dev_err(chip->dev, "bad rechg_thrsh =%d asked to set\n",
+							resume_mv);
+		return -EINVAL;
+	}
+
+	temp = resume_mv / 100;
+
+	return smb1360_masked_write(chip, CFG_BATT_CHG_REG,
+		RECHG_MV_MASK, temp << RECHG_MV_SHIFT);
+}
+
+static int __smb1360_charging_disable(struct smb1360_chip *chip, bool disable)
+{
+	int rc;
+
+	rc = smb1360_masked_write(chip, CMD_CHG_REG,
+			CMD_CHG_EN, disable ? 0 : CMD_CHG_EN);
+	if (rc < 0)
+		pr_err("Couldn't set CHG_ENABLE_BIT disable=%d rc = %d\n",
+							disable, rc);
+	else
+		pr_debug("CHG_EN status=%d\n", !disable);
+
+	return rc;
+}
+
+static int smb1360_set_batt_empty_voltage(struct smb1360_chip *chip, int empty_voltage)
+{
+	int rc = 0;
+	int temp;
+	u8 reg;
+
+	if (empty_voltage != -EINVAL)
+	{
+		temp = (empty_voltage - 2500) * MAX_8_BITS;
+		reg = DIV_ROUND_UP(temp, 2500);
+		pr_debug("voltage_empty=%d reg=%x\n",
+				chip->voltage_empty_mv, reg);
+		rc = smb1360_write(chip, VTG_EMPTY_REG, reg);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't write to VTG_EMPTY_REG rc=%d\n",
+						rc);
+			return rc;
+		}
+	}
+
+	return rc;
+}
+static int smb1360_charging_disable(struct smb1360_chip *chip, int reason,
+								int disable)
+{
+	int rc = 0;
+	int disabled;
+
+	mutex_lock(&chip->charging_disable_lock);
+
+	disabled = chip->charging_disabled_status;
+
+	pr_debug("reason=%d requested_disable=%d disabled_status=%d\n",
+					reason, disable, disabled);
+
+	if (disable == true)
+		disabled |= reason;
+	else
+		disabled &= ~reason;
+
+	if (disabled)
+		rc = __smb1360_charging_disable(chip, true);
+	else
+		rc = __smb1360_charging_disable(chip, false);
+
+	if (rc)
+		pr_err("Couldn't disable charging for reason=%d rc=%d\n",
+							rc, reason);
+	else
+		chip->charging_disabled_status = disabled;
+	mutex_unlock(&chip->charging_disable_lock);
+
+	return rc;
+}
+
+static int smb1360_soft_jeita_comp_enable(struct smb1360_chip *chip,
+								bool enable)
+{
+	int rc = 0;
+
+	rc = smb1360_masked_write(chip, CHG_CMP_CFG, JEITA_COMP_EN_MASK,
+					enable ? JEITA_COMP_EN_BIT : 0);
+	if (rc)
+		pr_err("Couldn't %s JEITA compensation\n", enable ?
+						"enable" : "disable");
+
+	return rc;
+}
+
+static enum power_supply_property smb1360_battery_properties[] = {
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_CHARGING_ENABLED,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_RESISTANCE,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL,
+};
+
+static int smb1360_get_prop_batt_present(struct smb1360_chip *chip)
+{
+	return chip->batt_present;
+}
+
+static int smb1360_get_prop_batt_status(struct smb1360_chip *chip)
+{
+	int rc;
+	u8 reg = 0, chg_type;
+
+	if (is_device_suspended(chip))
+		return POWER_SUPPLY_STATUS_UNKNOWN;
+
+	if (chip->batt_full)
+		return POWER_SUPPLY_STATUS_FULL;
+
+	rc = smb1360_read(chip, STATUS_3_REG, &reg);
+	if (rc) {
+		pr_err("Couldn't read STATUS_3_REG rc=%d\n", rc);
+		return POWER_SUPPLY_STATUS_UNKNOWN;
+	}
+
+	pr_debug("STATUS_3_REG = %x\n", reg);
+
+	if (reg & CHG_HOLD_OFF_BIT)
+		return POWER_SUPPLY_STATUS_NOT_CHARGING;
+
+	chg_type = (reg & CHG_TYPE_MASK) >> CHG_TYPE_SHIFT;
+
+	if (chg_type == BATT_NOT_CHG_VAL)
+		return POWER_SUPPLY_STATUS_DISCHARGING;
+	else
+		return POWER_SUPPLY_STATUS_CHARGING;
+}
+
+static int smb1360_get_prop_charging_status(struct smb1360_chip *chip)
+{
+	int rc;
+	u8 reg = 0;
+
+	rc = smb1360_read(chip, STATUS_3_REG, &reg);
+	if (rc) {
+		pr_err("Couldn't read STATUS_3_REG rc=%d\n", rc);
+		return 0;
+	}
+
+	return (reg & CHG_EN_BIT) ? 1 : 0;
+}
+
+static int smb1360_get_prop_charge_type(struct smb1360_chip *chip)
+{
+	int rc;
+	u8 reg = 0;
+	u8 chg_type;
+
+	if (is_device_suspended(chip))
+		return POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+
+	rc = smb1360_read(chip, STATUS_3_REG, &reg);
+	if (rc) {
+		pr_err("Couldn't read STATUS_3_REG rc=%d\n", rc);
+		return POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+	}
+
+	chg_type = (reg & CHG_TYPE_MASK) >> CHG_TYPE_SHIFT;
+	if (chg_type == BATT_NOT_CHG_VAL)
+		return POWER_SUPPLY_CHARGE_TYPE_NONE;
+	else if ((chg_type == BATT_FAST_CHG_VAL) ||
+			(chg_type == BATT_TAPER_CHG_VAL))
+		return POWER_SUPPLY_CHARGE_TYPE_FAST;
+	else if (chg_type == BATT_PRE_CHG_VAL)
+		return POWER_SUPPLY_CHARGE_TYPE_TRICKLE;
+
+	return POWER_SUPPLY_CHARGE_TYPE_NONE;
+}
+
+static int smb1360_get_prop_batt_health(struct smb1360_chip *chip)
+{
+	union power_supply_propval ret = {0, };
+
+	if (chip->batt_hot)
+		ret.intval = POWER_SUPPLY_HEALTH_OVERHEAT;
+	else if (chip->batt_cold)
+		ret.intval = POWER_SUPPLY_HEALTH_COLD;
+	else if (chip->batt_warm)
+		ret.intval = POWER_SUPPLY_HEALTH_GOOD;
+	else if (chip->batt_cool)
+		ret.intval = POWER_SUPPLY_HEALTH_GOOD;
+	else
+		ret.intval = POWER_SUPPLY_HEALTH_GOOD;
+
+	return ret.intval;
+}
+
+static int smb1360_get_prop_batt_capacity(struct smb1360_chip *chip)
+{
+	u8 reg;
+	u32 temp = 0;
+	int rc, soc = 0;
+
+	if (chip->fake_battery_soc >= 0)
+		return chip->fake_battery_soc;
+
+	if (chip->empty_soc) {
+		pr_debug("empty_soc\n");
+		return 0;
+	}
+
+	if (is_device_suspended(chip))
+		return chip->soc_now;
+
+	rc = smb1360_read(chip, SHDW_FG_MSYS_SOC, &reg);
+	if (rc) {
+		pr_err("Failed to read FG_MSYS_SOC rc=%d\n", rc);
+		return rc;
+	}
+	soc = (100 * reg) / MAX_8_BITS;
+
+	temp = (100 * reg) % MAX_8_BITS;
+	if (temp > (MAX_8_BITS / 2))
+		soc += 1;
+
+	pr_debug("msys_soc_reg=0x%02x, fg_soc=%d batt_full = %d\n", reg,
+						soc, chip->batt_full);
+
+	return  bound(soc, 0, 100);
+}
+
+static int smb1360_get_prop_chg_full_design(struct smb1360_chip *chip)
+{
+	u8 reg[2];
+	int rc, fcc_mah = 0;
+
+	if (is_device_suspended(chip))
+		return chip->fcc_mah;
+
+	rc = smb1360_read_bytes(chip, SHDW_FG_CAPACITY, reg, 2);
+	if (rc) {
+		pr_err("Failed to read SHDW_FG_CAPACITY rc=%d\n", rc);
+		return rc;
+	}
+	fcc_mah = (reg[1] << 8) | reg[0];
+
+	pr_debug("reg[0]=0x%02x reg[1]=0x%02x fcc_mah=%d\n",
+				reg[0], reg[1], fcc_mah);
+
+	chip->fcc_mah = fcc_mah * 1000;
+
+	return chip->fcc_mah;
+}
+
+static int smb1360_get_prop_batt_temp(struct smb1360_chip *chip)
+{
+	u8 reg[2];
+	int rc, temp = 0;
+
+	if (is_device_suspended(chip))
+		return chip->temp_now;
+
+	rc = smb1360_read_bytes(chip, SHDW_FG_BATT_TEMP, reg, 2);
+	if (rc) {
+		pr_err("Failed to read SHDW_FG_BATT_TEMP rc=%d\n", rc);
+		return rc;
+	}
+
+	temp = (reg[1] << 8) | reg[0];
+	temp = div_u64(temp * 625, 10000UL);	/* temperature in kelvin */
+	temp = (temp - 273) * 10;		/* temperature in decideg */
+
+	pr_debug("reg[0]=0x%02x reg[1]=0x%02x temperature=%d\n",
+					reg[0], reg[1], temp);
+
+	chip->temp_now = temp;
+
+	return chip->temp_now;
+}
+
+static int smb1360_get_prop_voltage_now(struct smb1360_chip *chip)
+{
+	u8 reg[2];
+	int rc, temp = 0;
+
+	if (is_device_suspended(chip))
+		return chip->voltage_now;
+
+	rc = smb1360_read_bytes(chip, SHDW_FG_VTG_NOW, reg, 2);
+	if (rc) {
+		pr_err("Failed to read SHDW_FG_VTG_NOW rc=%d\n", rc);
+		return rc;
+	}
+
+	temp = (reg[1] << 8) | reg[0];
+	temp = div_u64(temp * 5000, 0x7FFF);
+
+	pr_debug("reg[0]=0x%02x reg[1]=0x%02x voltage=%d\n",
+				reg[0], reg[1], temp * 1000);
+
+	chip->voltage_now = temp * 1000;
+
+	return chip->voltage_now;
+}
+
+static int smb1360_get_prop_batt_resistance(struct smb1360_chip *chip)
+{
+	u8 reg[2];
+	u16 temp;
+	int rc;
+	int64_t resistance;
+
+	if (is_device_suspended(chip))
+		return chip->resistance_now;
+
+	rc = smb1360_read_bytes(chip, SHDW_FG_ESR_ACTUAL, reg, 2);
+	if (rc) {
+		pr_err("Failed to read FG_ESR_ACTUAL rc=%d\n", rc);
+		return rc;
+	}
+	temp = (reg[1] << 8) | reg[0];
+
+	resistance = float_decode(temp) * 2;
+
+	pr_debug("reg=0x%02x resistance=%lld\n", temp, resistance);
+
+	/* resistance in uohms */
+	chip->resistance_now = resistance;
+
+	return chip->resistance_now;
+}
+
+static int smb1360_get_prop_current_now(struct smb1360_chip *chip)
+{
+	u8 reg[2];
+	int rc, temp = 0;
+
+	if (is_device_suspended(chip))
+		return chip->current_now;
+
+	rc = smb1360_read_bytes(chip, SHDW_FG_CURR_NOW, reg, 2);
+	if (rc) {
+		pr_err("Failed to read SHDW_FG_CURR_NOW rc=%d\n", rc);
+		return rc;
+	}
+
+	temp = ((s8)reg[1] << 8) | reg[0];
+	temp = div_s64(temp * 2500, 0x7FFF);
+
+	pr_debug("reg[0]=0x%02x reg[1]=0x%02x current=%d\n",
+				reg[0], reg[1], temp * 1000);
+
+	chip->current_now = temp * 1000;
+
+	return chip->current_now;
+}
+
+static int smb1360_set_minimum_usb_current(struct smb1360_chip *chip)
+{
+	int rc = 0;
+
+	if (chip->min_icl_usb100) {
+		pr_debug("USB min current set to 100mA\n");
+		/* set input current limit to minimum (300mA) */
+		rc = smb1360_masked_write(chip, CFG_BATT_CHG_ICL_REG,
+						INPUT_CURR_LIM_MASK,
+						INPUT_CURR_LIM_300MA);
+		if (rc)
+			pr_err("Couldn't set ICL mA rc=%d\n", rc);
+
+		if (!(chip->workaround_flags & WRKRND_USB100_FAIL))
+			rc = smb1360_masked_write(chip, CMD_IL_REG,
+					USB_CTRL_MASK, USB_100_BIT);
+			if (rc)
+				pr_err("Couldn't configure for USB100 rc=%d\n",
+								rc);
+	} else {
+		pr_debug("USB min current set to 500mA\n");
+		rc = smb1360_masked_write(chip, CMD_IL_REG,
+				USB_CTRL_MASK, USB_500_BIT);
+		if (rc)
+			pr_err("Couldn't configure for USB100 rc=%d\n",
+							rc);
+	}
+
+	return rc;
+}
+
+static struct power_supply *get_parallel_psy(struct smb1360_chip *chip)
+{
+	if (chip->parallel_psy)
+		return chip->parallel_psy;
+	chip->parallel_psy = power_supply_get_by_name("usb-parallel");
+	if (!chip->parallel_psy)
+		pr_debug("parallel charger not found\n");
+	return chip->parallel_psy;
+}
+
+static int __smb1360_parallel_charger_enable(struct smb1360_chip *chip,
+							bool enable)
+{
+	struct power_supply *parallel_psy = get_parallel_psy(chip);
+	union power_supply_propval pval = {0, };
+
+	if (!parallel_psy)
+		return 0;
+
+	pval.intval = (enable ? (chip->max_parallel_chg_current * 1000) : 0);
+	parallel_psy->set_property(parallel_psy,
+		POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX, &pval);
+	pval.intval = (enable ? 1 : 0);
+	parallel_psy->set_property(parallel_psy,
+		POWER_SUPPLY_PROP_CHARGING_ENABLED, &pval);
+
+	pr_debug("Parallel-charger %s max_chg_current=%d\n",
+		enable ? "enabled" : "disabled",
+		enable ? (chip->max_parallel_chg_current * 1000) : 0);
+
+	return 0;
+}
+
+static int smb1360_parallel_charger_enable(struct smb1360_chip *chip,
+						int reason, bool enable)
+{
+	int disabled, *disabled_status;
+
+	mutex_lock(&chip->parallel_chg_lock);
+
+	disabled = chip->parallel_chg_disable_status;
+	disabled_status = &chip->parallel_chg_disable_status;
+
+	pr_debug("reason=0x%x requested=%s disabled_status=0x%x\n",
+			reason, enable ? "enable" : "disable", disabled);
+
+	if (enable == true)
+		disabled &= ~reason;
+	else
+		disabled |= reason;
+
+	if (*disabled_status && !disabled)
+		__smb1360_parallel_charger_enable(chip, true);
+
+	if (!(*disabled_status) && disabled)
+		__smb1360_parallel_charger_enable(chip, false);
+
+	*disabled_status = disabled;
+
+	pr_debug("disabled_status = %x\n", *disabled_status);
+
+	mutex_unlock(&chip->parallel_chg_lock);
+
+	return 0;
+}
+
+static void smb1360_parallel_work(struct work_struct *work)
+{
+	u8 reg;
+	int rc;
+	struct smb1360_chip *chip = container_of(work,
+				struct smb1360_chip, parallel_work);
+
+	/* check the AICL settled value */
+	rc = smb1360_read(chip, STATUS_1_REG, &reg);
+	if (rc) {
+		pr_debug("Unable to read AICL status rc=%d\n", rc);
+		goto exit_work;
+	}
+	pr_debug("STATUS_1 (aicl status)=0x%x\n", reg);
+
+	if ((reg & AICL_CURRENT_STATUS_MASK) >= AICL_LIMIT_1200MA) {
+		smb1360_parallel_charger_enable(chip, PARALLEL_CURRENT, true);
+	} else {
+		/* Weak-charger - Disable parallel path */
+		smb1360_parallel_charger_enable(chip, PARALLEL_CURRENT, false);
+	}
+
+exit_work:
+	pm_relax(chip->dev);
+}
+
+static int smb1360_set_appropriate_usb_current(struct smb1360_chip *chip)
+{
+	int rc = 0, i, therm_ma, current_ma;
+	int path_current = chip->usb_psy_ma;
+	u8  temp_data =0;
+	int current_changed = 0, fg_capacity = 0;
+	static int pre_charging_current =1;
+	int en_therengine_ctrl = 0;
+	/*
+	 * If battery is absent do not modify the current at all, these
+	 * would be some appropriate values set by the bootloader or default
+	 * configuration and since it is the only source of power we should
+	 * not change it
+	 */
+	if (!chip->batt_present) {
+		pr_debug("ignoring current request since battery is absent\n");
+		return 0;
+	}
+
+	if (chip->therm_lvl_sel >= 0
+			&& chip->therm_lvl_sel < (chip->thermal_levels - 1)){
+		/*
+		 * consider thermal limit only when it is active and not at
+		 * the highest level
+		 */
+		if ( chip->ckt_therengine_control == true )
+			en_therengine_ctrl = 1 ;
+
+		therm_ma = chip->thermal_mitigation[chip->therm_lvl_sel];
+	}else{
+		therm_ma = path_current;
+	}
+    /*if ( en_therengine_ctrl == 1 ){
+	    current_ma = therm_ma;
+	}
+	else {*/
+	   current_ma = min(therm_ma, path_current);
+    //}
+	
+	if (chip->workaround_flags & WRKRND_HARD_JEITA) {
+		if (chip->batt_warm)
+			current_ma = min(current_ma, chip->warm_bat_ma);
+		else if (chip->batt_cool)
+			current_ma = min(current_ma, chip->cool_bat_ma);
+	}
+	
+	if (current_ma <= 2) {
+		/*
+		 * SMB1360 does not support USB suspend -
+		 * so set the current-limit to minimum in suspend.
+		 */
+		pr_debug("current_ma=%d <= 2 set USB current to minimum\n",
+								current_ma);
+		rc = smb1360_set_minimum_usb_current(chip);
+		if (rc < 0)
+			pr_err("Couldn't to set minimum USB current rc = %d\n",
+								rc);
+		/* disable parallel charger */
+		if (chip->parallel_charging)
+			smb1360_parallel_charger_enable(chip,
+					PARALLEL_CURRENT, false);
+
+		return rc;
+	}
+
+	if ((current_ma <= CURRENT_100_MA) &&
+		((chip->workaround_flags & WRKRND_USB100_FAIL) ||
+				!chip->min_icl_usb100)) {
+		pr_debug("usb100 not supported: usb100_wrkrnd=%d min_icl_100=%d\n",
+			!!(chip->workaround_flags & WRKRND_USB100_FAIL),
+						chip->min_icl_usb100);
+		current_ma = CURRENT_500_MA;
+	}
+
+	for (i = ARRAY_SIZE(input_current_limit) - 1; i >= 0; i--) {
+		if (input_current_limit[i] <= current_ma)
+			break;
+	}
+	if (i < 0) {
+		pr_debug("Couldn't find ICL mA rc=%d\n", rc);
+		i = 0;
+	}
+	rc = smb1360_read(chip,CFG_BATT_CHG_ICL_REG,&temp_data);
+	if (rc)
+		pr_err("read CFG_BATT_CHG_ICL_REG failed %d\n", rc);
+	/* set input current limit */
+	if((temp_data&0x0f) != i) {
+		rc = smb1360_masked_write(chip, CFG_BATT_CHG_ICL_REG,
+				INPUT_CURR_LIM_MASK, i);
+		if (rc)
+			pr_err("Couldn't set USB ICL mA rc=%d\n", rc);
+	}
+	pr_debug("ICL set to = %d\n", input_current_limit[i]);
+
+	fg_capacity = smb1360_get_prop_batt_capacity(chip);
+	if ((current_ma <= CURRENT_100_MA) || ((1 == first_mic) && (99 <= fg_capacity))) {
+		/* USB 100 */
+		first_AC_in = 1;
+		rc = smb1360_masked_write(chip, CMD_IL_REG,
+				USB_CTRL_MASK, USB_100_BIT);
+		if (rc)
+			pr_err("Couldn't configure for USB100 rc=%d\n", rc);
+		pr_debug("Setting USB 100\n");
+	} else if ((current_ma <= CURRENT_500_MA) || (1 == first_mic)) {
+		/* USB 500 */
+		first_AC_in = 1;
+		rc = smb1360_masked_write(chip, CMD_IL_REG,
+				USB_CTRL_MASK, USB_500_BIT);
+		if (rc)
+			pr_err("Couldn't configure for USB500 rc=%d\n", rc);
+		pr_debug("Setting USB 500\n");
+	} else {
+		/* USB AC */
+		if(pre_charging_current!=current_ma) {
+			pre_charging_current = current_ma;
+			smb1360_log_printk("charging current changed\n");
+			current_changed = 1;
+		} else {
+			current_changed = 0;
+		}
+		pr_debug("AC charging current_ma : %d \n",current_ma);
+
+		if (chip->rsense_10mohm) {
+			current_ma /= 2;
+			if (!chip->parallel_chg_disable_status)
+				current_ma += (chip->max_parallel_chg_current / 2);
+		}
+
+		for (i = ARRAY_SIZE(fastchg_current) - 1; i >= 0; i--) {
+			if (fastchg_current[i] <= current_ma)
+				break;
+		}
+		if (i < 0) {
+			pr_debug("Couldn't find fastchg mA rc=%d\n", rc);
+			i = 0;
+		}
+
+		chip->fastchg_current = fastchg_current[i];
+
+		/* set fastchg limit */
+		rc = smb1360_masked_write(chip, CHG_CURRENT_REG,
+				FASTCHG_CURR_MASK, i << FASTCHG_CURR_SHIFT);
+		if (rc)
+			pr_err("Couldn't set fastchg mA rc=%d\n", rc);
+
+		/*
+		 * To move to a new (higher) input-current setting,
+		 * first set USB500 and then USBAC. This makes sure
+		 * that the new ICL setting takes affect.
+		 */
+		 if(first_AC_in == 1 || current_changed==1) {
+			first_AC_in=2;
+			rc = smb1360_masked_write(chip, CMD_IL_REG,
+					USB_CTRL_MASK, USB_500_BIT);
+			if (rc)
+				pr_err("Couldn't configure for USB500 rc=%d\n", rc);
+
+			rc = smb1360_masked_write(chip, CMD_IL_REG,
+					USB_CTRL_MASK, USB_AC_BIT);
+			if (rc)
+				pr_err("Couldn't configure for USB AC rc=%d\n", rc);
+
+			pr_debug("fast-chg current set to = %d\n", fastchg_current[i]);
+		}
+	}
+	return rc;
+}
+
+void smb1360_set_usb_current_call(int current_limit_enable)
+{
+
+    struct smb1360_chip *chip = smb1360_chip_global;
+    int charger_type = 0;
+    int rc = 0, fg_capacity = 0;
+    u8 temp_data = 0;
+
+    first_mic = current_limit_enable;
+    charger_type = get_usbcharger_type();
+    pr_debug("current_limit_enable=%d\n", current_limit_enable);
+    fg_capacity = smb1360_get_prop_batt_capacity(chip);
+    if (((5 == charger_type) || (4 == charger_type)) && (99 <= fg_capacity)) {
+        rc = smb1360_read(chip,CMD_IL_REG,&temp_data);
+        if (rc)
+            pr_err("read CMD_IL_REG failed %d\n", rc);
+        temp_data = temp_data & 0x03;
+        pr_debug("read CMD_IL_REG 0x41=%d\n", temp_data);
+
+        if ((1 == current_limit_enable) && (0x01 != temp_data)){
+            rc = smb1360_masked_write(chip, CMD_IL_REG,
+                    USB_CTRL_MASK, USB_100_BIT);
+            if (rc)
+                pr_err("Call Couldn't configure for USB100 rc=%d\n", rc);
+            pr_debug("Call config for USB100\n");
+        } else if (0 == current_limit_enable){
+            if (4 == charger_type) {
+                rc = smb1360_masked_write(chip, CMD_IL_REG,
+                        USB_CTRL_MASK, USB_500_BIT);
+                if (rc)
+                    pr_err("Call Couldn't configure for USB 500 rc=%d\n", rc);
+                pr_debug("Call config for USB 500\n");
+             }
+               else if (5 == charger_type) {
+                 rc = smb1360_masked_write(chip, CMD_IL_REG,
+                        USB_CTRL_MASK, USB_AC_BIT);
+                if (rc)
+                    pr_err("Call Couldn't configure for USB AC rc=%d\n", rc);
+                pr_debug("Call config for USB AC\n");
+               }
+        }
+    }
+
+    return ;
+}
+EXPORT_SYMBOL(smb1360_set_usb_current_call);
+
+static int smb1360_set_jeita_comp_curr(struct smb1360_chip *chip,
+							int current_ma)
+{
+	int i;
+	int rc = 0;
+
+	for (i = ARRAY_SIZE(fastchg_current) - 1; i >= 0; i--) {
+		if (fastchg_current[i] <= current_ma)
+			break;
+	}
+	if (i < 0) {
+		pr_debug("Couldn't find fastchg_current %dmA\n", current_ma);
+		i = 0;
+	}
+
+	rc = smb1360_masked_write(chip, CHG_CMP_CFG,
+			JEITA_COMP_CURR_MASK, i);
+	if (rc)
+		pr_err("Couldn't configure for Icomp, rc = %d\n", rc);
+
+	return rc;
+}
+
+#define TEMP_THRE_SET(x) ((x + 300) / 10)
+static int smb1360_set_soft_jeita_threshold(struct smb1360_chip *chip,
+					int cold_threshold, int hot_threshold)
+{
+	int rc = 0;
+
+	rc = smb1360_write(chip, JEITA_SOFT_COLD_REG,
+				TEMP_THRE_SET(cold_threshold));
+	if (rc) {
+		pr_err("Couldn't set cold threshold, rc = %d\n", rc);
+		return rc;
+	} else {
+		chip->soft_cold_thresh = cold_threshold;
+	}
+
+	rc = smb1360_write(chip, JEITA_SOFT_HOT_REG,
+				TEMP_THRE_SET(hot_threshold));
+	if (rc) {
+		pr_err("Couldn't set hot threshold, rc = %d\n", rc);
+		return rc;
+	} else {
+		chip->soft_hot_thresh = hot_threshold;
+	}
+
+	return rc;
+}
+
+static int smb1360_system_temp_level_set(struct smb1360_chip *chip,
+							int lvl_sel)
+{
+	int rc = 0;
+	int prev_therm_lvl;
+
+	if (!chip->thermal_mitigation) {
+		pr_err("Thermal mitigation not supported\n");
+		return -EINVAL;
+	}
+
+	if (lvl_sel < 0) {
+		pr_err("Unsupported level selected %d\n", lvl_sel);
+		return -EINVAL;
+	}
+
+	if (lvl_sel >= chip->thermal_levels) {
+		pr_err("Unsupported level selected %d forcing %d\n", lvl_sel,
+				chip->thermal_levels - 1);
+		lvl_sel = chip->thermal_levels - 1;
+	}
+
+	if (lvl_sel == chip->therm_lvl_sel)
+		return 0;
+
+	mutex_lock(&chip->current_change_lock);
+	prev_therm_lvl = chip->therm_lvl_sel;
+	chip->therm_lvl_sel = lvl_sel;
+
+	if (chip->therm_lvl_sel == (chip->thermal_levels - 1)) {
+		rc = smb1360_set_minimum_usb_current(chip);
+		if (rc)
+			pr_err("Couldn't set USB current to minimum rc = %d\n",
+							rc);
+	} else {
+		rc = smb1360_set_appropriate_usb_current(chip);
+		if (rc)
+			pr_err("Couldn't set USB current rc = %d\n", rc);
+	}
+
+	mutex_unlock(&chip->current_change_lock);
+	return rc;
+}
+
+static int smb1360_battery_set_property(struct power_supply *psy,
+				       enum power_supply_property prop,
+				       const union power_supply_propval *val)
+{
+	struct smb1360_chip *chip = container_of(psy,
+				struct smb1360_chip, batt_psy);
+
+	switch (prop) {
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		smb1360_charging_disable(chip, USER, !val->intval);
+		android_disable_charging = !val->intval;
+		if (chip->parallel_charging)
+			smb1360_parallel_charger_enable(chip,
+				PARALLEL_USER, val->intval);
+		power_supply_changed(&chip->batt_psy);
+		power_supply_changed(chip->usb_psy);
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		chip->fake_battery_soc = val->intval;
+		pr_info("fake_soc set to %d\n", chip->fake_battery_soc);
+		power_supply_changed(&chip->batt_psy);
+		break;
+	case POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL:
+		smb1360_system_temp_level_set(chip, val->intval);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int smb1360_battery_is_writeable(struct power_supply *psy,
+				       enum power_supply_property prop)
+{
+	int rc;
+
+	switch (prop) {
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+	case POWER_SUPPLY_PROP_CAPACITY:
+	case POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL:
+		rc = 1;
+		break;
+	default:
+		rc = 0;
+		break;
+	}
+	return rc;
+}
+
+static int smb1360_battery_get_property(struct power_supply *psy,
+				       enum power_supply_property prop,
+				       union power_supply_propval *val)
+{
+	struct smb1360_chip *chip = container_of(psy,
+				struct smb1360_chip, batt_psy);
+
+	switch (prop) {
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = smb1360_get_prop_batt_health(chip);
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = smb1360_get_prop_batt_present(chip);
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = smb1360_get_prop_batt_status(chip);
+		break;
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		val->intval = smb1360_get_prop_charging_status(chip);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		val->intval = smb1360_get_prop_charge_type(chip);
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = smb1360_get_prop_batt_capacity(chip);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		val->intval = smb1360_get_prop_chg_full_design(chip);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = smb1360_get_prop_voltage_now(chip);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = smb1360_get_prop_current_now(chip);
+		break;
+	case POWER_SUPPLY_PROP_RESISTANCE:
+		val->intval = smb1360_get_prop_batt_resistance(chip);
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = smb1360_get_prop_batt_temp(chip);
+		break;
+	case POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL:
+		val->intval = chip->therm_lvl_sel;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void smb1360_external_power_changed(struct power_supply *psy)
+{
+	struct smb1360_chip *chip = container_of(psy,struct smb1360_chip, batt_psy);
+	union power_supply_propval prop = {0,};
+	int rc, current_limit = 0;
+
+	rc = chip->usb_psy->get_property(chip->usb_psy,
+		POWER_SUPPLY_PROP_CURRENT_MAX, &prop);
+	if (rc < 0)
+		dev_err(chip->dev,
+			"could not read USB current_max property, rc=%d\n", rc);
+	else
+		current_limit = prop.intval / 1000;
+	pr_debug("current_limit = %d\n", current_limit);
+	if (chip->usb_psy_ma != current_limit) {
+		mutex_lock(&chip->current_change_lock);
+		chip->usb_psy_ma = current_limit;
+		rc = smb1360_set_appropriate_usb_current(chip);
+		if (rc < 0)
+			pr_err("Couldn't set usb current rc = %d\n", rc);
+		mutex_unlock(&chip->current_change_lock);
+	}
+
+	rc = chip->usb_psy->get_property(chip->usb_psy,
+				POWER_SUPPLY_PROP_ONLINE, &prop);
+	if (rc < 0)
+		pr_err("could not read USB ONLINE property, rc=%d\n", rc);
+
+	/* update online property */
+	rc = 0;
+	if (chip->usb_present && !chip->charging_disabled_status) {
+		if (prop.intval == 0)
+			rc = power_supply_set_online(chip->usb_psy, true);
+	} else {
+		if (prop.intval == 1)
+			rc = power_supply_set_online(chip->usb_psy, false);
+	}
+	if (rc < 0)
+		pr_err("could not set usb online, rc=%d\n", rc);
+}
+
+static int hot_hard_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+	chip->batt_hot = !!rt_stat;
+
+	if (chip->parallel_charging) {
+		pr_debug("%s parallel-charging\n", chip->batt_hot ?
+					"Disable" : "Enable");
+		smb1360_parallel_charger_enable(chip,
+				PARALLEL_JEITA_HARD, !chip->batt_hot);
+	}
+
+	return 0;
+}
+
+static int cold_hard_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+	chip->batt_cold = !!rt_stat;
+
+	if (chip->parallel_charging) {
+		pr_debug("%s parallel-charging\n", chip->batt_cold ?
+					"Disable" : "Enable");
+		smb1360_parallel_charger_enable(chip,
+				PARALLEL_JEITA_HARD, !chip->batt_cold);
+	}
+
+	return 0;
+}
+
+/*
+ * This worker thread should only be called when WRKRND_HARD_JEITA
+ * is set.
+ * It is needed to re-program JEITA soft thresholds, compensate
+ * target voltage and charging current manually.
+ * The function is required as JEITA hard thresholds can't be programmed.
+*/
+static void smb1360_jeita_work_fn(struct work_struct *work)
+{
+	int temp;
+	int rc = 0;
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct smb1360_chip *chip = container_of(dwork, struct smb1360_chip,
+							jeita_work);
+	temp = smb1360_get_prop_batt_temp(chip);
+
+	if (temp >= chip->hot_bat_decidegc) {
+		/* battery status is hot, only config thresholds */
+		if (chip->config_rechg_temp) {
+			rc = smb1360_set_soft_jeita_threshold(chip,
+					chip->warm_bat_decidegc, chip->rechg_warm_bat_decidegc);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't set jeita threshold\n");
+				goto end;
+			}
+		} else {
+			rc = smb1360_set_soft_jeita_threshold(chip,
+					chip->warm_bat_decidegc, chip->hot_bat_decidegc);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't set jeita threshold\n");
+				goto end;
+			}
+		}
+		/* soft over temperature disable charging */
+		if (chip->soft_disable_charging &&
+			(chip->hot_bat_decidegc < DEFAULT_OVERTEMP_DISCHG_HARD)) {
+			rc = smb1360_charging_disable(chip, JEITA_SOFT, true);
+			if (rc)
+				dev_err(chip->dev, "Overtemp Couldn't disable charging rc = %d\n", rc);
+			pr_info("JEITA Overtemp disable charging.\n");
+		}
+	} else if (temp > chip->warm_bat_decidegc ||
+		(temp == chip->warm_bat_decidegc && !!chip->soft_hot_rt_stat)) {
+		/* battery status is warm, do compensation manually */
+		chip->batt_warm = true;
+		chip->batt_cool = false;
+
+		rc = smb1360_float_voltage_set(chip, chip->warm_bat_mv);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set float voltage\n");
+			goto end;
+		}
+		rc = smb1360_set_appropriate_usb_current(chip);
+		if (rc)
+			pr_err("Couldn't set USB current\n");
+		rc = smb1360_set_soft_jeita_threshold(chip,
+			chip->warm_bat_decidegc, chip->hot_bat_decidegc);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set jeita threshold\n");
+			goto end;
+		}
+		/* soft warm restart charging */
+		if (chip->soft_disable_charging) {
+			rc = smb1360_charging_disable(chip, JEITA_SOFT, false);
+			if (rc)
+				dev_err(chip->dev, "Warm Couldn't enable charging rc = %d\n", rc);
+			pr_info("JEITA warm enable charging.\n");
+		}
+	} else if (temp > chip->cool_bat_decidegc ||
+		(temp == chip->cool_bat_decidegc && !chip->soft_cold_rt_stat)) {
+		/* battery status is good, do the normal charging */
+		chip->batt_warm = false;
+		chip->batt_cool = false;
+
+		rc = smb1360_set_soft_jeita_threshold(chip,
+			chip->cool_bat_decidegc, chip->warm_bat_decidegc);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set jeita threshold\n");
+			goto end;
+		}
+
+		if (temp > chip->cool_bat_decidegc && temp < chip->warm_bat_decidegc) {
+			rc = smb1360_float_voltage_set(chip, chip->vfloat_mv);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't set float voltage\n");
+				goto end;
+			}
+			rc = smb1360_set_appropriate_usb_current(chip);
+			if (rc)
+				pr_err("Couldn't set USB current\n");
+		}
+
+		/* soft normal restart charging */
+		if (chip->soft_disable_charging) {
+			rc = smb1360_charging_disable(chip, JEITA_SOFT, false);
+			if (rc)
+				dev_err(chip->dev, "normal Couldn't enable charging rc = %d\n", rc);
+			pr_info("JEITA good enable charging.\n");
+		}
+	} else if (temp > chip->cold_bat_decidegc) {
+		/* battery status is cool, do compensation manually */
+		chip->batt_cool = true;
+		chip->batt_warm = false;
+		rc = smb1360_float_voltage_set(chip, chip->cool_bat_mv);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set float voltage\n");
+			goto end;
+		}
+		rc = smb1360_set_soft_jeita_threshold(chip,
+			chip->cold_bat_decidegc, chip->cool_bat_decidegc);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set jeita threshold\n");
+			goto end;
+		}
+
+		/* soft cool restart charging */
+		if (chip->soft_disable_charging) {
+			rc = smb1360_charging_disable(chip, JEITA_SOFT, false);
+			if (rc)
+				dev_err(chip->dev, "Cool Couldn't enable charging rc = %d\n", rc);
+			pr_info("JEITA cool enable charging.\n");
+		}
+	} else {
+		/* battery status is cold, only config thresholds */
+		if (chip->config_rechg_temp) {
+			rc = smb1360_set_soft_jeita_threshold(chip,
+					chip->cold_bat_decidegc, chip->rechg_cool_bat_decidegc);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't set jeita threshold\n");
+				goto end;
+			}
+		} else {
+			rc = smb1360_set_soft_jeita_threshold(chip,
+					chip->cold_bat_decidegc, chip->rechg_cold_bat_decidegc);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't set jeita threshold\n");
+				goto end;
+			}
+		}
+		/* soft cold disable charging */
+		if (chip->soft_disable_charging &&
+			(chip->cold_bat_decidegc > DEFAULT_LOWTEMP_DISCHG_HARD)) {
+			rc = smb1360_charging_disable(chip, JEITA_SOFT, true);
+			if (rc)
+				dev_err(chip->dev, "Cold Couldn't disable charging rc = %d\n", rc);
+			pr_info("JEITA cold disable charging.\n");
+		}
+	}
+
+	pr_debug("warm %d, cool %d, soft_cold_rt_sts %d, soft_hot_rt_sts %d, jeita supported %d, threshold_now %d %d\n",
+		chip->batt_warm, chip->batt_cool, !!chip->soft_cold_rt_stat,
+		!!chip->soft_hot_rt_stat, chip->soft_jeita_supported,
+		chip->soft_cold_thresh, chip->soft_hot_thresh);
+end:
+	pm_relax(chip->dev);
+}
+
+static int hot_soft_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	chip->soft_hot_rt_stat = rt_stat;
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+	if (!chip->config_hard_thresholds)
+		chip->batt_warm = !!rt_stat;
+
+	if (chip->workaround_flags & WRKRND_HARD_JEITA) {
+		cancel_delayed_work_sync(&chip->jeita_work);
+		schedule_delayed_work(&chip->jeita_work,
+					msecs_to_jiffies(JEITA_WORK_MS));
+		pm_stay_awake(chip->dev);
+	}
+
+	if (chip->parallel_charging) {
+		pr_debug("%s parallel-charging\n", chip->batt_warm ?
+					"Disable" : "Enable");
+		smb1360_parallel_charger_enable(chip,
+				PARALLEL_JEITA_SOFT, !chip->batt_warm);
+	}
+	return 0;
+}
+
+static int cold_soft_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	chip->soft_cold_rt_stat = rt_stat;
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+	if (!chip->config_hard_thresholds)
+		chip->batt_cool = !!rt_stat;
+
+	if (chip->workaround_flags & WRKRND_HARD_JEITA) {
+		cancel_delayed_work_sync(&chip->jeita_work);
+		schedule_delayed_work(&chip->jeita_work,
+					msecs_to_jiffies(JEITA_WORK_MS));
+		pm_stay_awake(chip->dev);
+	}
+
+	if (chip->parallel_charging) {
+		pr_debug("%s parallel-charging\n", chip->batt_cool ?
+					"Disable" : "Enable");
+		smb1360_parallel_charger_enable(chip,
+				PARALLEL_JEITA_SOFT, !chip->batt_cool);
+	}
+
+	return 0;
+}
+
+static int battery_missing_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+	chip->batt_present = !rt_stat;
+	return 0;
+}
+
+static int vbat_low_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("vbat low\n");
+
+	return 0;
+}
+
+static int chg_hot_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_warn_ratelimited("chg hot\n");
+	return 0;
+}
+
+static int chg_term_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+	chip->batt_full = !!rt_stat;
+
+	if (chip->parallel_charging) {
+		pr_debug("%s parallel-charging\n", chip->batt_full ?
+					"Disable" : "Enable");
+		smb1360_parallel_charger_enable(chip,
+				PARALLEL_EOC, !chip->batt_full);
+	}
+
+	return 0;
+}
+
+static int chg_fastchg_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+
+	return 0;
+}
+
+static int usbin_uv_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	bool usb_present = !rt_stat;
+
+	pr_debug("chip->usb_present = %d usb_present = %d\n",
+				chip->usb_present, usb_present);
+	if (chip->usb_present && !usb_present) {
+		/* USB removed */
+		chip->usb_present = usb_present;
+		power_supply_set_present(chip->usb_psy, usb_present);
+	}
+
+	if (!chip->usb_present && usb_present) {
+		/* USB inserted */
+		chip->usb_present = usb_present;
+		power_supply_set_present(chip->usb_psy, usb_present);
+	}
+
+	return 0;
+}
+
+static int aicl_done_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	bool aicl_done = !!rt_stat;
+
+	pr_debug("AICL done=%d\n", aicl_done);
+
+	if (chip->parallel_charging && aicl_done) {
+		cancel_work_sync(&chip->parallel_work);
+		pm_stay_awake(chip->dev);
+		schedule_work(&chip->parallel_work);
+	}
+
+	return 0;
+}
+
+static int chg_inhibit_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	/*
+	 * charger is inserted when the battery voltage is high
+	 * so h/w won't start charging just yet. Treat this as
+	 * battery full
+	 */
+	pr_debug("rt_stat = 0x%02x\n", rt_stat);
+	chip->batt_full = !!rt_stat;
+	return 0;
+}
+
+static int delta_soc_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("SOC changed! - rt_stat = 0x%02x\n", rt_stat);
+
+	return 0;
+}
+
+static int min_soc_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("SOC dropped below min SOC, rt_stat = 0x%02x\n", rt_stat);
+
+	if (chip->awake_min_soc)
+		rt_stat ? pm_stay_awake(chip->dev) : pm_relax(chip->dev);
+
+	return 0;
+}
+
+static int empty_soc_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("SOC empty! rt_stat = 0x%02x\n", rt_stat);
+
+	if (!chip->empty_soc_disabled) {
+		if (rt_stat) {
+			chip->empty_soc = true;
+			pm_stay_awake(chip->dev);
+			pr_warn_ratelimited("SOC is 0\n");
+		} else {
+			chip->empty_soc = false;
+			pm_relax(chip->dev);
+		}
+	}
+
+	return 0;
+}
+
+static int full_soc_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	if (rt_stat)
+		pr_debug("SOC is 100\n");
+
+	return 0;
+}
+
+static int fg_access_allowed_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("stat=%d\n", !!rt_stat);
+
+	if (rt_stat & FG_ACCESS_ALLOWED_BIT) {
+		pr_debug("FG access granted\n");
+		complete_all(&chip->fg_mem_access_granted);
+	}
+
+	return 0;
+}
+
+static int batt_id_complete_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	pr_debug("batt_id = %x\n", (rt_stat & BATT_ID_RESULT_BIT)
+						>> BATT_ID_SHIFT);
+
+	return 0;
+}
+
+static int smb1360_select_fg_i2c_address(struct smb1360_chip *chip)
+{
+	unsigned short addr = chip->default_i2c_addr << 0x1;
+
+	switch (chip->fg_access_type) {
+	case FG_ACCESS_CFG:
+		addr = (addr & ~FG_I2C_CFG_MASK) | FG_CFG_I2C_ADDR;
+		break;
+	case FG_ACCESS_PROFILE_A:
+		addr = (addr & ~FG_I2C_CFG_MASK) | FG_PROFILE_A_ADDR;
+		break;
+	case FG_ACCESS_PROFILE_B:
+		addr = (addr & ~FG_I2C_CFG_MASK) | FG_PROFILE_B_ADDR;
+		break;
+	default:
+		pr_err("Invalid FG access type=%d\n", chip->fg_access_type);
+		return -EINVAL;
+	}
+
+	chip->fg_i2c_addr = addr >> 0x1;
+	pr_debug("FG_access_type=%d fg_i2c_addr=%x\n", chip->fg_access_type,
+							chip->fg_i2c_addr);
+
+	return 0;
+}
+
+static int smb1360_adjust_current_gain(struct smb1360_chip *chip,
+							int gain_factor)
+{
+	int i, rc;
+	int64_t current_gain, new_current_gain;
+	u8 reg[2];
+	u16 reg_value1 = 0, reg_value2 = 0;
+	u8 reg_val_mapping[][2] = {
+			{0xE0, 0x1D},
+			{0xE1, 0x00},
+			{0xE2, 0x1E},
+			{0xE3, 0x00},
+			{0xE4, 0x00},
+			{0xE5, 0x00},
+			{0xE6, 0x00},
+			{0xE7, 0x00},
+			{0xE8, 0x00},
+			{0xE9, 0x00},
+			{0xEA, 0x00},
+			{0xEB, 0x00},
+			{0xEC, 0x00},
+			{0xED, 0x00},
+			{0xEF, 0x00},
+			{0xF0, 0x50},
+			{0xF1, 0x00},
+	};
+
+	if (gain_factor) {
+		rc = smb1360_fg_read(chip, CURRENT_GAIN_LSB_REG, &reg[0]);
+		if (rc) {
+			pr_err("Unable to set FG access I2C address rc=%d\n",
+									rc);
+			return rc;
+		}
+
+		rc = smb1360_fg_read(chip, CURRENT_GAIN_MSB_REG, &reg[1]);
+		if (rc) {
+			pr_err("Unable to set FG access I2C address rc=%d\n",
+									rc);
+			return rc;
+		}
+
+		reg_value1 = (reg[1] << 8) | reg[0];
+		current_gain = float_decode(reg_value1);
+		new_current_gain = MICRO_UNIT  + (gain_factor * current_gain);
+		reg_value2 = float_encode(new_current_gain);
+		reg[0] = reg_value2 & 0xFF;
+		reg[1] = (reg_value2 & 0xFF00) >> 8;
+		pr_debug("current_gain_reg=0x%x current_gain_decoded=%lld new_current_gain_decoded=%lld new_current_gain_reg=0x%x\n",
+			reg_value1, current_gain, new_current_gain, reg_value2);
+
+		for (i = 0; i < ARRAY_SIZE(reg_val_mapping); i++) {
+			if (reg_val_mapping[i][0] == 0xE1)
+				reg_val_mapping[i][1] = reg[0];
+			if (reg_val_mapping[i][0] == 0xE3)
+				reg_val_mapping[i][1] = reg[1];
+
+			pr_debug("Writing reg_add=%x value=%x\n",
+				reg_val_mapping[i][0], reg_val_mapping[i][1]);
+
+			rc = smb1360_fg_write(chip, reg_val_mapping[i][0],
+					reg_val_mapping[i][1]);
+			if (rc) {
+				pr_err("Write fg address 0x%x failed, rc = %d\n",
+						reg_val_mapping[i][0], rc);
+				return rc;
+			}
+		}
+	} else {
+		pr_debug("Disabling gain correction\n");
+		rc = smb1360_fg_write(chip, 0xF0, 0x00);
+		if (rc) {
+			pr_err("Write fg address 0x%x failed, rc = %d\n",
+								0xF0, rc);
+			return rc;
+		}
+	}
+
+	return 0;
+}
+
+static int smb1360_otp_gain_config(struct smb1360_chip *chip, int gain_factor)
+{
+	int rc = 0;
+
+	rc = smb1360_enable_fg_access(chip);
+	if (rc) {
+		pr_err("Couldn't request FG access rc = %d\n", rc);
+		return rc;
+	}
+	chip->fg_access_type = FG_ACCESS_CFG;
+
+	rc = smb1360_select_fg_i2c_address(chip);
+	if (rc) {
+		pr_err("Unable to set FG access I2C address\n");
+		goto restore_fg;
+	}
+
+	rc = smb1360_adjust_current_gain(chip, gain_factor);
+	if (rc) {
+		pr_err("Unable to modify current gain rc=%d\n", rc);
+		goto restore_fg;
+	}
+
+	rc = smb1360_masked_write(chip, CFG_FG_BATT_CTRL_REG,
+			CFG_FG_OTP_BACK_UP_ENABLE, CFG_FG_OTP_BACK_UP_ENABLE);
+	if (rc) {
+		pr_err("Write reg 0x0E failed, rc = %d\n", rc);
+		goto restore_fg;
+	}
+
+restore_fg:
+	rc = smb1360_disable_fg_access(chip);
+	if (rc) {
+		pr_err("Couldn't disable FG access rc = %d\n", rc);
+		return rc;
+	}
+
+	return rc;
+}
+
+static int smb1360_otg_disable(struct smb1360_chip *chip)
+{
+	int rc;
+
+	rc = smb1360_masked_write(chip, CMD_CHG_REG, CMD_OTG_EN_BIT, 0);
+	if (rc) {
+		pr_err("Couldn't disable OTG mode rc=%d\n", rc);
+		return rc;
+	}
+
+	mutex_lock(&chip->otp_gain_lock);
+	/* Disable current gain configuration */
+	if (chip->otg_fet_present && chip->fet_gain_enabled) {
+		/* Disable FET */
+		gpio_set_value(chip->otg_fet_enable_gpio, 1);
+		rc = smb1360_otp_gain_config(chip, 0);
+		if (rc < 0)
+			pr_err("Couldn't config OTP gain config rc=%d\n", rc);
+		else
+			chip->fet_gain_enabled = false;
+	}
+	mutex_unlock(&chip->otp_gain_lock);
+
+	return rc;
+}
+
+static int otg_fail_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	int rc;
+
+	pr_debug("OTG Failed stat=%d\n", rt_stat);
+	rc = smb1360_otg_disable(chip);
+	if (rc)
+		pr_err("Couldn't disable OTG mode rc=%d\n", rc);
+
+	return 0;
+}
+
+static int otg_oc_handler(struct smb1360_chip *chip, u8 rt_stat)
+{
+	int rc;
+
+	pr_debug("OTG over-current stat=%d\n", rt_stat);
+	rc = smb1360_otg_disable(chip);
+	if (rc)
+		pr_err("Couldn't disable OTG mode rc=%d\n", rc);
+
+	return 0;
+}
+
+struct smb_irq_info {
+	const char		*name;
+	int			(*smb_irq)(struct smb1360_chip *chip,
+							u8 rt_stat);
+	int			high;
+	int			low;
+};
+
+struct irq_handler_info {
+	u8			stat_reg;
+	u8			val;
+	u8			prev_val;
+	struct smb_irq_info	irq_info[4];
+};
+
+static struct irq_handler_info handlers[] = {
+	{IRQ_A_REG, 0, 0,
+		{
+			{
+				.name		= "cold_soft",
+				.smb_irq	= cold_soft_handler,
+			},
+			{
+				.name		= "hot_soft",
+				.smb_irq	= hot_soft_handler,
+			},
+			{
+				.name		= "cold_hard",
+				.smb_irq	= cold_hard_handler,
+			},
+			{
+				.name		= "hot_hard",
+				.smb_irq	= hot_hard_handler,
+			},
+		},
+	},
+	{IRQ_B_REG, 0, 0,
+		{
+			{
+				.name		= "chg_hot",
+				.smb_irq	= chg_hot_handler,
+			},
+			{
+				.name		= "vbat_low",
+				.smb_irq	= vbat_low_handler,
+			},
+			{
+				.name		= "battery_missing",
+				.smb_irq	= battery_missing_handler,
+			},
+			{
+				.name		= "battery_missing",
+				.smb_irq	= battery_missing_handler,
+			},
+		},
+	},
+	{IRQ_C_REG, 0, 0,
+		{
+			{
+				.name		= "chg_term",
+				.smb_irq	= chg_term_handler,
+			},
+			{
+				.name		= "taper",
+			},
+			{
+				.name		= "recharge",
+			},
+			{
+				.name		= "fast_chg",
+				.smb_irq	= chg_fastchg_handler,
+			},
+		},
+	},
+	{IRQ_D_REG, 0, 0,
+		{
+			{
+				.name		= "prechg_timeout",
+			},
+			{
+				.name		= "safety_timeout",
+			},
+			{
+				.name		= "aicl_done",
+				.smb_irq	= aicl_done_handler,
+			},
+			{
+				.name		= "battery_ov",
+			},
+		},
+	},
+	{IRQ_E_REG, 0, 0,
+		{
+			{
+				.name		= "usbin_uv",
+				.smb_irq	= usbin_uv_handler,
+			},
+			{
+				.name		= "usbin_ov",
+			},
+			{
+				.name		= "unused",
+			},
+			{
+				.name		= "chg_inhibit",
+				.smb_irq	= chg_inhibit_handler,
+			},
+		},
+	},
+	{IRQ_F_REG, 0, 0,
+		{
+			{
+				.name		= "power_ok",
+			},
+			{
+				.name		= "unused",
+			},
+			{
+				.name		= "otg_fail",
+				.smb_irq	= otg_fail_handler,
+			},
+			{
+				.name		= "otg_oc",
+				.smb_irq	= otg_oc_handler,
+			},
+		},
+	},
+	{IRQ_G_REG, 0, 0,
+		{
+			{
+				.name		= "delta_soc",
+				.smb_irq	= delta_soc_handler,
+			},
+			{
+				.name		= "chg_error",
+			},
+			{
+				.name		= "wd_timeout",
+			},
+			{
+				.name		= "unused",
+			},
+		},
+	},
+	{IRQ_H_REG, 0, 0,
+		{
+			{
+				.name		= "min_soc",
+				.smb_irq	= min_soc_handler,
+			},
+			{
+				.name		= "max_soc",
+			},
+			{
+				.name		= "empty_soc",
+				.smb_irq	= empty_soc_handler,
+			},
+			{
+				.name		= "full_soc",
+				.smb_irq	= full_soc_handler,
+			},
+		},
+	},
+	{IRQ_I_REG, 0, 0,
+		{
+			{
+				.name		= "fg_access_allowed",
+				.smb_irq	= fg_access_allowed_handler,
+			},
+			{
+				.name		= "fg_data_recovery",
+			},
+			{
+				.name		= "batt_id_complete",
+				.smb_irq	= batt_id_complete_handler,
+			},
+		},
+	},
+};
+
+#define IRQ_LATCHED_MASK	0x02
+#define IRQ_STATUS_MASK		0x01
+#define BATT_ID_LATCHED_MASK	0x08
+#define BATT_ID_STATUS_MASK	0x07
+#define BITS_PER_IRQ		2
+static irqreturn_t smb1360_stat_handler(int irq, void *dev_id)
+{
+	struct smb1360_chip *chip = dev_id;
+	int i, j;
+	u8 triggered;
+	u8 changed;
+	u8 rt_stat, prev_rt_stat, irq_latched_mask, irq_status_mask;
+	int rc;
+	int handler_count = 0;
+
+	mutex_lock(&chip->irq_complete);
+	chip->irq_waiting = true;
+	if (!chip->resume_completed) {
+		dev_dbg(chip->dev, "IRQ triggered before device-resume\n");
+		disable_irq_nosync(irq);
+		mutex_unlock(&chip->irq_complete);
+		return IRQ_HANDLED;
+	}
+	chip->irq_waiting = false;
+
+	for (i = 0; i < ARRAY_SIZE(handlers); i++) {
+		rc = smb1360_read(chip, handlers[i].stat_reg,
+					&handlers[i].val);
+		if (rc < 0) {
+			dev_err(chip->dev, "Couldn't read %d rc = %d\n",
+					handlers[i].stat_reg, rc);
+			continue;
+		}
+
+		for (j = 0; j < ARRAY_SIZE(handlers[i].irq_info); j++) {
+			if (handlers[i].stat_reg == IRQ_I_REG && j == 2) {
+				irq_latched_mask = BATT_ID_LATCHED_MASK;
+				irq_status_mask = BATT_ID_STATUS_MASK;
+			} else {
+				irq_latched_mask = IRQ_LATCHED_MASK;
+				irq_status_mask = IRQ_STATUS_MASK;
+			}
+			triggered = handlers[i].val
+			       & (irq_latched_mask << (j * BITS_PER_IRQ));
+			rt_stat = handlers[i].val
+				& (irq_status_mask << (j * BITS_PER_IRQ));
+			prev_rt_stat = handlers[i].prev_val
+				& (irq_status_mask << (j * BITS_PER_IRQ));
+			changed = prev_rt_stat ^ rt_stat;
+
+			if (triggered || changed)
+				rt_stat ? handlers[i].irq_info[j].high++ :
+						handlers[i].irq_info[j].low++;
+
+			if ((triggered || changed)
+				&& handlers[i].irq_info[j].smb_irq != NULL) {
+				handler_count++;
+				rc = handlers[i].irq_info[j].smb_irq(chip,
+								rt_stat);
+				if (rc < 0)
+					dev_err(chip->dev,
+						"Couldn't handle %d irq for reg 0x%02x rc = %d\n",
+						j, handlers[i].stat_reg, rc);
+			}
+		}
+		handlers[i].prev_val = handlers[i].val;
+	}
+
+	pr_debug("handler count = %d\n", handler_count);
+	if (handler_count)
+		power_supply_changed(&chip->batt_psy);
+
+	mutex_unlock(&chip->irq_complete);
+
+	return IRQ_HANDLED;
+}
+
+static int show_irq_count(struct seq_file *m, void *data)
+{
+	int i, j, total = 0;
+
+	for (i = 0; i < ARRAY_SIZE(handlers); i++)
+		for (j = 0; j < 4; j++) {
+			if (!handlers[i].irq_info[j].name)
+				continue;
+			seq_printf(m, "%s=%d\t(high=%d low=%d)\n",
+						handlers[i].irq_info[j].name,
+						handlers[i].irq_info[j].high
+						+ handlers[i].irq_info[j].low,
+						handlers[i].irq_info[j].high,
+						handlers[i].irq_info[j].low);
+			total += (handlers[i].irq_info[j].high
+					+ handlers[i].irq_info[j].low);
+		}
+
+	seq_printf(m, "\n\tTotal = %d\n", total);
+
+	return 0;
+}
+
+static int irq_count_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct smb1360_chip *chip = inode->i_private;
+
+	return single_open(file, show_irq_count, chip);
+}
+
+static const struct file_operations irq_count_debugfs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= irq_count_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int get_reg(void *data, u64 *val)
+{
+	struct smb1360_chip *chip = data;
+	int rc;
+	u8 temp;
+
+	rc = smb1360_read(chip, chip->peek_poke_address, &temp);
+	if (rc < 0) {
+		dev_err(chip->dev,
+			"Couldn't read reg %x rc = %d\n",
+			chip->peek_poke_address, rc);
+		return -EAGAIN;
+	}
+	*val = temp;
+	return 0;
+}
+
+static int set_reg(void *data, u64 val)
+{
+	struct smb1360_chip *chip = data;
+	int rc;
+	u8 temp;
+
+	temp = (u8) val;
+	rc = smb1360_write(chip, chip->peek_poke_address, temp);
+	if (rc < 0) {
+		dev_err(chip->dev,
+			"Couldn't write 0x%02x to 0x%02x rc= %d\n",
+			chip->peek_poke_address, temp, rc);
+		return -EAGAIN;
+	}
+	return 0;
+}
+DEFINE_SIMPLE_ATTRIBUTE(poke_poke_debug_ops, get_reg, set_reg, "0x%02llx\n");
+
+static int fg_get_reg(void *data, u64 *val)
+{
+	struct smb1360_chip *chip = data;
+	int rc;
+	u8 temp;
+
+	rc = smb1360_select_fg_i2c_address(chip);
+	if (rc) {
+		pr_err("Unable to set FG access I2C address\n");
+		return -EINVAL;
+	}
+
+	rc = smb1360_fg_read(chip, chip->fg_peek_poke_address, &temp);
+	if (rc < 0) {
+		dev_err(chip->dev,
+			"Couldn't read reg %x rc = %d\n",
+			chip->fg_peek_poke_address, rc);
+		return -EAGAIN;
+	}
+	*val = temp;
+	return 0;
+}
+
+static int fg_set_reg(void *data, u64 val)
+{
+	struct smb1360_chip *chip = data;
+	int rc;
+	u8 temp;
+
+	rc = smb1360_select_fg_i2c_address(chip);
+	if (rc) {
+		pr_err("Unable to set FG access I2C address\n");
+		return -EINVAL;
+	}
+
+	temp = (u8) val;
+	rc = smb1360_fg_write(chip, chip->fg_peek_poke_address, temp);
+	if (rc < 0) {
+		dev_err(chip->dev,
+			"Couldn't write 0x%02x to 0x%02x rc= %d\n",
+			chip->fg_peek_poke_address, temp, rc);
+		return -EAGAIN;
+	}
+	return 0;
+}
+DEFINE_SIMPLE_ATTRIBUTE(fg_poke_poke_debug_ops, fg_get_reg,
+				fg_set_reg, "0x%02llx\n");
+
+#define LAST_CNFG_REG	0x17
+static int show_cnfg_regs(struct seq_file *m, void *data)
+{
+	struct smb1360_chip *chip = m->private;
+	int rc;
+	u8 reg;
+	u8 addr;
+
+	for (addr = 0; addr <= LAST_CNFG_REG; addr++) {
+		rc = smb1360_read(chip, addr, &reg);
+		if (!rc)
+			seq_printf(m, "0x%02x = 0x%02x\n", addr, reg);
+	}
+
+	return 0;
+}
+
+static int cnfg_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct smb1360_chip *chip = inode->i_private;
+
+	return single_open(file, show_cnfg_regs, chip);
+}
+
+static const struct file_operations cnfg_debugfs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= cnfg_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+#define FIRST_CMD_REG	0x40
+#define LAST_CMD_REG	0x42
+static int show_cmd_regs(struct seq_file *m, void *data)
+{
+	struct smb1360_chip *chip = m->private;
+	int rc;
+	u8 reg;
+	u8 addr;
+
+	for (addr = FIRST_CMD_REG; addr <= LAST_CMD_REG; addr++) {
+		rc = smb1360_read(chip, addr, &reg);
+		if (!rc)
+			seq_printf(m, "0x%02x = 0x%02x\n", addr, reg);
+	}
+
+	return 0;
+}
+
+static int cmd_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct smb1360_chip *chip = inode->i_private;
+
+	return single_open(file, show_cmd_regs, chip);
+}
+
+static const struct file_operations cmd_debugfs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= cmd_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+#define FIRST_STATUS_REG	0x48
+#define LAST_STATUS_REG		0x4B
+static int show_status_regs(struct seq_file *m, void *data)
+{
+	struct smb1360_chip *chip = m->private;
+	int rc;
+	u8 reg;
+	u8 addr;
+
+	for (addr = FIRST_STATUS_REG; addr <= LAST_STATUS_REG; addr++) {
+		rc = smb1360_read(chip, addr, &reg);
+		if (!rc)
+			seq_printf(m, "0x%02x = 0x%02x\n", addr, reg);
+	}
+
+	return 0;
+}
+
+static int status_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct smb1360_chip *chip = inode->i_private;
+
+	return single_open(file, show_status_regs, chip);
+}
+
+static const struct file_operations status_debugfs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= status_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+#define FIRST_IRQ_REG		0x50
+#define LAST_IRQ_REG		0x58
+static int show_irq_stat_regs(struct seq_file *m, void *data)
+{
+	struct smb1360_chip *chip = m->private;
+	int rc;
+	u8 reg;
+	u8 addr;
+
+	for (addr = FIRST_IRQ_REG; addr <= LAST_IRQ_REG; addr++) {
+		rc = smb1360_read(chip, addr, &reg);
+		if (!rc)
+			seq_printf(m, "0x%02x = 0x%02x\n", addr, reg);
+	}
+
+	return 0;
+}
+
+static int irq_stat_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct smb1360_chip *chip = inode->i_private;
+
+	return single_open(file, show_irq_stat_regs, chip);
+}
+
+static const struct file_operations irq_stat_debugfs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= irq_stat_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int data_8(u8 *reg)
+{
+	return reg[0];
+}
+static int data_16(u8 *reg)
+{
+	return (reg[1] << 8) | reg[0];
+}
+static int data_24(u8 *reg)
+{
+	return  (reg[2] << 16) | (reg[1] << 8) | reg[0];
+}
+static int data_28(u8 *reg)
+{
+	return  ((reg[3] & 0xF) << 24) | (reg[2] << 16) |
+					(reg[1] << 8) | reg[0];
+}
+static int data_32(u8 *reg)
+{
+	return  (reg[3]  << 24) | (reg[2] << 16) |
+				(reg[1] << 8) | reg[0];
+}
+
+struct fg_regs {
+	int index;
+	int length;
+	char *param_name;
+	int (*calc_func) (u8 *);
+};
+
+static struct fg_regs fg_scratch_pad[] = {
+	{0, 2, "v_current_predicted", data_16},
+	{2, 2, "v_cutoff_predicted", data_16},
+	{4, 2, "v_full_predicted", data_16},
+	{6, 2, "ocv_estimate", data_16},
+	{8, 2, "rslow_drop", data_16},
+	{10, 2, "voltage_old", data_16},
+	{12, 2, "current_old", data_16},
+	{14, 4, "current_average_full", data_32},
+	{18, 2, "temperature", data_16},
+	{20, 2, "temp_last_track", data_16},
+	{22, 2, "ESR_nominal", data_16},
+	{26, 2, "Rslow", data_16},
+	{28, 2, "counter_imptr", data_16},
+	{30, 2, "counter_pulse", data_16},
+	{32, 1, "IRQ_delta_prev", data_8},
+	{33, 1, "cap_learning_counter", data_8},
+	{34, 4, "Vact_int_error", data_32},
+	{38, 3, "SOC_cutoff", data_24},
+	{41, 3, "SOC_full", data_24},
+	{44, 3, "SOC_auto_rechrge_temp", data_24},
+	{47, 3, "Battery_SOC", data_24},
+	{50, 4, "CC_SOC", data_28},
+	{54, 2, "SOC_filtered", data_16},
+	{56, 2, "SOC_Monotonic", data_16},
+	{58, 2, "CC_SOC_coeff", data_16},
+	{60, 2, "nominal_capacity", data_16},
+	{62, 2, "actual_capacity", data_16},
+	{68, 1, "temperature_counter", data_8},
+	{69, 3, "Vbatt_filtered", data_24},
+	{72, 3, "Ibatt_filtered", data_24},
+	{75, 2, "Current_CC_shadow", data_16},
+	{79, 2, "Ibatt_standby", data_16},
+	{82, 1, "Auto_recharge_SOC_threshold", data_8},
+	{83, 2, "System_cutoff_voltage", data_16},
+	{85, 2, "System_CC_to_CV_voltage", data_16},
+	{87, 2, "System_term_current", data_16},
+	{89, 2, "System_fake_term_current", data_16},
+	{91, 2, "thermistor_c1_coeff", data_16},
+};
+
+static struct fg_regs fg_cfg[] = {
+	{0, 2, "ESR_actual", data_16},
+	{4, 1, "IRQ_SOC_max", data_8},
+	{5, 1, "IRQ_SOC_min", data_8},
+	{6, 1, "IRQ_volt_empty", data_8},
+	{7, 1, "Temp_external", data_8},
+	{8, 1, "IRQ_delta_threshold", data_8},
+	{9, 1, "JIETA_soft_cold", data_8},
+	{10, 1, "JIETA_soft_hot", data_8},
+	{11, 1, "IRQ_volt_min", data_8},
+	{14, 2, "ESR_sys_replace", data_16},
+};
+
+static struct fg_regs fg_shdw[] = {
+	{0, 1, "Latest_battery_info", data_8},
+	{1, 1, "Latest_Msys_SOC", data_8},
+	{2, 2, "Battery_capacity", data_16},
+	{4, 2, "Rslow_drop", data_16},
+	{6, 1, "Latest_SOC", data_8},
+	{7, 1, "Latest_Cutoff_SOC", data_8},
+	{8, 1, "Latest_full_SOC", data_8},
+	{9, 2, "Voltage_shadow", data_16},
+	{11, 2, "Current_shadow", data_16},
+	{13, 2, "Latest_temperature", data_16},
+	{15, 1, "Latest_system_sbits", data_8},
+};
+
+#define FIRST_FG_CFG_REG		0x20
+#define LAST_FG_CFG_REG			0x2F
+#define FIRST_FG_SHDW_REG		0x60
+#define LAST_FG_SHDW_REG		0x6F
+#define FG_SCRATCH_PAD_MAX		93
+#define FG_SCRATCH_PAD_BASE_REG		0x80
+#define SMB1360_I2C_READ_LENGTH		32
+
+static int smb1360_check_cycle_stretch(struct smb1360_chip *chip)
+{
+	int rc = 0;
+	u8 reg;
+
+	rc = smb1360_read(chip, STATUS_4_REG, &reg);
+	if (rc) {
+		pr_err("Unable to read status regiseter\n");
+	} else if (reg & CYCLE_STRETCH_ACTIVE_BIT) {
+		/* clear cycle stretch */
+		rc = smb1360_masked_write(chip, CMD_I2C_REG,
+			CYCLE_STRETCH_CLEAR_BIT, CYCLE_STRETCH_CLEAR_BIT);
+		if (rc)
+			pr_err("Unable to clear cycle stretch\n");
+	}
+
+	return rc;
+}
+
+static int show_fg_regs(struct seq_file *m, void *data)
+{
+	struct smb1360_chip *chip = m->private;
+	int rc, i , j, rem_length;
+	u8 reg[FG_SCRATCH_PAD_MAX];
+
+	rc = smb1360_check_cycle_stretch(chip);
+	if (rc)
+		pr_err("Unable to check cycle-stretch\n");
+
+	rc = smb1360_enable_fg_access(chip);
+	if (rc) {
+		pr_err("Couldn't request FG access rc=%d\n", rc);
+		return rc;
+	}
+
+	for (i = 0; i < (FG_SCRATCH_PAD_MAX / SMB1360_I2C_READ_LENGTH); i++) {
+		j = i * SMB1360_I2C_READ_LENGTH;
+		rc = smb1360_read_bytes(chip, FG_SCRATCH_PAD_BASE_REG + j,
+					&reg[j], SMB1360_I2C_READ_LENGTH);
+		if (rc) {
+			pr_err("Couldn't read scratch registers rc=%d\n", rc);
+			break;
+		}
+	}
+
+	j = i * SMB1360_I2C_READ_LENGTH;
+	rem_length = (FG_SCRATCH_PAD_MAX % SMB1360_I2C_READ_LENGTH);
+	if (rem_length) {
+		rc = smb1360_read_bytes(chip, FG_SCRATCH_PAD_BASE_REG + j,
+						&reg[j], rem_length);
+		if (rc)
+			pr_err("Couldn't read scratch registers rc=%d\n", rc);
+	}
+
+	rc = smb1360_disable_fg_access(chip);
+	if (rc) {
+		pr_err("Couldn't disable FG access rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = smb1360_check_cycle_stretch(chip);
+	if (rc)
+		pr_err("Unable to check cycle-stretch\n");
+
+
+	seq_puts(m, "FG scratch-pad registers\n");
+	for (i = 0; i < ARRAY_SIZE(fg_scratch_pad); i++)
+		seq_printf(m, "\t%s = %x\n", fg_scratch_pad[i].param_name,
+		fg_scratch_pad[i].calc_func(&reg[fg_scratch_pad[i].index]));
+
+	rem_length = LAST_FG_CFG_REG - FIRST_FG_CFG_REG + 1;
+	rc = smb1360_read_bytes(chip, FIRST_FG_CFG_REG,
+					&reg[0], rem_length);
+	if (rc)
+		pr_err("Couldn't read config registers rc=%d\n", rc);
+
+	seq_puts(m, "FG config registers\n");
+	for (i = 0; i < ARRAY_SIZE(fg_cfg); i++)
+		seq_printf(m, "\t%s = %x\n", fg_cfg[i].param_name,
+				fg_cfg[i].calc_func(&reg[fg_cfg[i].index]));
+
+	rem_length = LAST_FG_SHDW_REG - FIRST_FG_SHDW_REG + 1;
+	rc = smb1360_read_bytes(chip, FIRST_FG_SHDW_REG,
+					&reg[0], rem_length);
+	if (rc)
+		pr_err("Couldn't read shadow registers rc=%d\n", rc);
+
+	seq_puts(m, "FG shadow registers\n");
+	for (i = 0; i < ARRAY_SIZE(fg_shdw); i++)
+		seq_printf(m, "\t%s = %x\n", fg_shdw[i].param_name,
+				fg_shdw[i].calc_func(&reg[fg_shdw[i].index]));
+
+	return rc;
+}
+
+static int fg_regs_open(struct inode *inode, struct file *file)
+{
+	struct smb1360_chip *chip = inode->i_private;
+
+	return single_open(file, show_fg_regs, chip);
+}
+
+static const struct file_operations fg_regs_debugfs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= fg_regs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int smb1360_otg_regulator_enable(struct regulator_dev *rdev)
+{
+	int rc = 0;
+	struct smb1360_chip *chip = rdev_get_drvdata(rdev);
+
+	if ( !chip->usb_present ) smb1360_redled_gpio_output();
+	rc = smb1360_masked_write(chip, CMD_CHG_REG, CMD_OTG_EN_BIT,
+						CMD_OTG_EN_BIT);
+	if (rc) {
+		pr_err("Couldn't enable  OTG mode rc=%d\n", rc);
+		return rc;
+	}
+
+	pr_debug("OTG mode enabled\n");
+	/* Enable current gain configuration */
+	mutex_lock(&chip->otp_gain_lock);
+	if (chip->otg_fet_present) {
+		/* Enable FET */
+		gpio_set_value(chip->otg_fet_enable_gpio, 0);
+		rc = smb1360_otp_gain_config(chip, 3);
+		if (rc < 0)
+			pr_err("Couldn't config OTP gain config rc=%d\n", rc);
+		else
+			chip->fet_gain_enabled = true;
+	}
+    mutex_unlock(&chip->otp_gain_lock);
+	return rc;
+}
+
+static int smb1360_otg_regulator_disable(struct regulator_dev *rdev)
+{
+	int rc = 0;
+	struct smb1360_chip *chip = rdev_get_drvdata(rdev);
+
+	rc = smb1360_otg_disable(chip);
+	if (rc)
+		pr_err("Couldn't disable OTG regulator rc=%d\n", rc);
+
+	pr_debug("OTG mode disabled\n");
+	return rc;
+}
+
+static int smb1360_otg_regulator_is_enable(struct regulator_dev *rdev)
+{
+	u8 reg = 0;
+	int rc = 0;
+	struct smb1360_chip *chip = rdev_get_drvdata(rdev);
+
+	rc = smb1360_read(chip, CMD_CHG_REG, &reg);
+	if (rc) {
+		pr_err("Couldn't read OTG enable bit rc=%d\n", rc);
+		return rc;
+	}
+
+	return  (reg & CMD_OTG_EN_BIT) ? 1 : 0;
+}
+
+struct regulator_ops smb1360_otg_reg_ops = {
+	.enable		= smb1360_otg_regulator_enable,
+	.disable	= smb1360_otg_regulator_disable,
+	.is_enabled	= smb1360_otg_regulator_is_enable,
+};
+
+static int smb1360_regulator_init(struct smb1360_chip *chip)
+{
+	int rc = 0;
+	struct regulator_init_data *init_data;
+	struct regulator_config cfg = {};
+
+	init_data = of_get_regulator_init_data(chip->dev, chip->dev->of_node);
+	if (!init_data) {
+		dev_err(chip->dev, "Unable to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	if (init_data->constraints.name) {
+		chip->otg_vreg.rdesc.owner = THIS_MODULE;
+		chip->otg_vreg.rdesc.type = REGULATOR_VOLTAGE;
+		chip->otg_vreg.rdesc.ops = &smb1360_otg_reg_ops;
+		chip->otg_vreg.rdesc.name = init_data->constraints.name;
+
+		cfg.dev = chip->dev;
+		cfg.init_data = init_data;
+		cfg.driver_data = chip;
+		cfg.of_node = chip->dev->of_node;
+
+		init_data->constraints.valid_ops_mask
+			|= REGULATOR_CHANGE_STATUS;
+
+		chip->otg_vreg.rdev = regulator_register(
+					&chip->otg_vreg.rdesc, &cfg);
+		if (IS_ERR(chip->otg_vreg.rdev)) {
+			rc = PTR_ERR(chip->otg_vreg.rdev);
+			chip->otg_vreg.rdev = NULL;
+			if (rc != -EPROBE_DEFER)
+				dev_err(chip->dev,
+					"OTG reg failed, rc=%d\n", rc);
+		}
+	}
+
+	return rc;
+}
+
+static int smb1360_check_batt_profile(struct smb1360_chip *chip)
+{
+	int rc, i, timeout = 50;
+	u8 reg = 0, loaded_profile, new_profile = 0, bid_mask;
+
+	if (!chip->connected_rid) {
+		pr_debug("Skip batt-profile loading connected_rid=%d\n",
+						chip->connected_rid);
+		return 0;
+	}
+
+	rc = smb1360_read(chip, SHDW_FG_BATT_STATUS, &reg);
+	if (rc) {
+		pr_err("Couldn't read FG_BATT_STATUS rc=%d\n", rc);
+		return rc;
+	}
+
+	loaded_profile = !!(reg & BATTERY_PROFILE_BIT) ?
+			BATTERY_PROFILE_B : BATTERY_PROFILE_A;
+
+	pr_debug("fg_batt_status=%x loaded_profile=%d\n", reg, loaded_profile);
+
+	for (i = 0; i < BATTERY_PROFILE_MAX; i++) {
+		pr_debug("profile=%d profile_rid=%d connected_rid=%d\n", i,
+						chip->profile_rid[i],
+						chip->connected_rid);
+		if (abs(chip->profile_rid[i] - chip->connected_rid) <
+				(div_u64(chip->connected_rid, 10)))
+			break;
+	}
+
+	if (i == BATTERY_PROFILE_MAX) {
+		pr_err("None of the battery-profiles match the connected-RID\n");
+		return 0;
+	} else {
+		if (i == loaded_profile) {
+			pr_debug("Loaded Profile-RID == connected-RID\n");
+			return 0;
+		} else {
+			new_profile = (loaded_profile == BATTERY_PROFILE_A) ?
+					BATTERY_PROFILE_B : BATTERY_PROFILE_A;
+			bid_mask = (new_profile == BATTERY_PROFILE_A) ?
+					BATT_PROFILEA_MASK : BATT_PROFILEB_MASK;
+			pr_info("Loaded Profile-RID != connected-RID, switch-profile old_profile=%d new_profile=%d\n",
+						loaded_profile, new_profile);
+		}
+	}
+
+	/* set the BID mask */
+	rc = smb1360_masked_write(chip, CFG_FG_BATT_CTRL_REG,
+				BATT_PROFILE_SELECT_MASK, bid_mask);
+	if (rc) {
+		pr_err("Couldn't reset battery-profile rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = smb1360_enable_fg_access(chip);
+	if (rc) {
+		pr_err("FG access timed-out, rc = %d\n", rc);
+		return rc;
+	}
+	/* delay after handshaking for profile-switch to continue */
+	msleep(1500);
+
+	rc = smb1360_force_fg_reset(chip);
+	if (rc) {
+		pr_err("Couldn't reset FG rc=%d\n", rc);
+		goto restore_fg;
+	}
+
+	rc = smb1360_disable_fg_access(chip);
+	if (rc) {
+		pr_err("disable FG access failed, rc = %d\n", rc);
+		return rc;
+	}
+
+	timeout = 10;
+	while (timeout) {
+		/* delay for profile to change */
+		msleep(500);
+		rc = smb1360_read(chip, SHDW_FG_BATT_STATUS, &reg);
+		if (rc) {
+			pr_err("Could't read FG_BATT_STATUS rc=%d\n", rc);
+			return rc;
+		}
+
+		reg = !!(reg & BATTERY_PROFILE_BIT);
+		if (reg == new_profile) {
+			pr_info("New profile=%d loaded\n", new_profile);
+			break;
+		}
+		timeout--;
+	}
+
+	if (!timeout) {
+		pr_err("New profile could not be loaded\n");
+		return -EBUSY;
+	}
+
+	return 0;
+
+restore_fg:
+	smb1360_disable_fg_access(chip);
+	return rc;
+}
+
+#define UPDATE_IRQ_STAT(irq_reg, value) \
+		handlers[irq_reg - IRQ_A_REG].prev_val = value;
+
+static int determine_initial_status(struct smb1360_chip *chip)
+{
+	int rc;
+	u8 reg = 0;
+
+	/*
+	 * It is okay to read the IRQ status as the irq's are
+	 * not registered yet.
+	 */
+	chip->batt_present = true;
+	rc = smb1360_read(chip, IRQ_B_REG, &reg);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't read IRQ_B_REG rc = %d\n", rc);
+		return rc;
+	}
+	UPDATE_IRQ_STAT(IRQ_B_REG, reg);
+
+	if (reg & IRQ_B_BATT_TERMINAL_BIT || reg & IRQ_B_BATT_MISSING_BIT)
+		chip->batt_present = false;
+
+	rc = smb1360_read(chip, IRQ_C_REG, &reg);
+	if (rc) {
+		dev_err(chip->dev, "Couldn't read IRQ_C_REG rc = %d\n", rc);
+		return rc;
+	}
+	UPDATE_IRQ_STAT(IRQ_C_REG, reg);
+
+	if (reg & IRQ_C_CHG_TERM)
+		chip->batt_full = true;
+
+	rc = smb1360_read(chip, IRQ_A_REG, &reg);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't read irq A rc = %d\n", rc);
+		return rc;
+	}
+	UPDATE_IRQ_STAT(IRQ_A_REG, reg);
+
+	if (chip->workaround_flags & WRKRND_HARD_JEITA) {
+		schedule_delayed_work(&chip->jeita_work, 0);
+	} else {
+		if (reg & IRQ_A_HOT_HARD_BIT)
+			chip->batt_hot = true;
+		if (reg & IRQ_A_COLD_HARD_BIT)
+			chip->batt_cold = true;
+		if (!chip->config_hard_thresholds) {
+			if (reg & IRQ_A_HOT_SOFT_BIT)
+				chip->batt_warm = true;
+			if (reg & IRQ_A_COLD_SOFT_BIT)
+				chip->batt_cool = true;
+		}
+	}
+
+	rc = smb1360_read(chip, IRQ_E_REG, &reg);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't read irq E rc = %d\n", rc);
+		return rc;
+	}
+	UPDATE_IRQ_STAT(IRQ_E_REG, reg);
+
+	chip->usb_present = (reg & IRQ_E_USBIN_UV_BIT) ? false : true;
+	power_supply_set_present(chip->usb_psy, chip->usb_present);
+
+	return 0;
+}
+
+
+static void smb1360_rest_at_pon_work_func(struct work_struct *work)
+{
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct smb1360_chip *chip = container_of(dwork, struct smb1360_chip,one_shot_delay);
+	int v_predicted, v_now;
+	int rc,temp;
+	u8  reg2[2];
+
+	rc = smb1360_enable_fg_access(chip);
+	if (rc) {
+		pr_err("Couldn't enable FG access rc=%d\n", rc);
+		goto  abnormal;
+	}
+
+	rc = smb1360_read_bytes(chip, VOLTAGE_PREDICTED_REG, reg2, 2);
+	if (rc) {
+		pr_err("Failed to read VOLTAGE_PREDICTED rc=%d\n", rc);
+		goto disable_fg_reset;
+	}
+	v_predicted = (reg2[1] << 8) | reg2[0];
+	v_predicted = div_u64(v_predicted * 5000, 0x7FFF);
+
+	rc = smb1360_read_bytes(chip, SHDW_FG_VTG_NOW, reg2, 2);
+	if (rc) {
+		pr_err("Failed to read SHDW_FG_VTG_NOW rc=%d\n", rc);
+		goto disable_fg_reset;
+	}
+	v_now = (reg2[1] << 8) | reg2[0];
+	v_now = div_u64(v_now * 5000, 0x7FFF);
+
+	pr_debug("v_predicted=%d v_now=%d reset_threshold=%d\n",
+			v_predicted, v_now, chip->fg_reset_threshold_mv);
+
+	/*
+	 * Reset FG if the predicted voltage is off wrt
+	 * the real-time voltage.
+	 */
+	temp = abs(v_predicted - v_now);
+	if (temp >= chip->fg_reset_threshold_mv) {
+		pr_info("Reseting FG - v_delta=%d threshold=%d\n",
+				temp, chip->fg_reset_threshold_mv);
+		/* delay for the FG access to settle */
+		msleep(1500);
+
+        rc = smb1360_force_fg_reset(chip);
+		if (rc) {
+			pr_err("Couldn't reset FG rc=%d\n", rc);
+			goto disable_fg_reset;
+		}
+
+	}
+disable_fg_reset:
+	smb1360_disable_fg_access(chip);
+abnormal:
+	schedule_delayed_work(&chip->abnormal_detect,0);
+}
+
+
+static int smb1360_fg_config(struct smb1360_chip *chip)
+{
+	int rc = 0, temp, fcc_mah;
+	u8 reg = 0, reg2[2];
+	/*
+	 * The below IRQ thresholds are not accessible in REV_1
+	 * of SMB1360.
+	 */
+	if (!(chip->workaround_flags & WRKRND_FG_CONFIG_FAIL)) {
+		if (chip->delta_soc != -EINVAL) {
+			reg = abs(((chip->delta_soc * MAX_8_BITS) / 100) - 1);
+			pr_debug("delta_soc=%d reg=%x\n", chip->delta_soc, reg);
+			rc = smb1360_write(chip, SOC_DELTA_REG, reg);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't write to SOC_DELTA_REG rc=%d\n",
+						rc);
+				return rc;
+			}
+		}
+
+		if (chip->soc_min != -EINVAL) {
+			if (is_between(chip->soc_min, 0, 100)) {
+				reg = DIV_ROUND_UP(chip->soc_min * MAX_8_BITS,
+									100);
+				pr_debug("soc_min=%d reg=%x\n",
+						chip->soc_min, reg);
+				rc = smb1360_write(chip, SOC_MIN_REG, reg);
+				if (rc) {
+					dev_err(chip->dev, "Couldn't write to SOC_MIN_REG rc=%d\n",
+							rc);
+					return rc;
+				}
+			}
+		}
+
+		if (chip->soc_max != -EINVAL) {
+			if (is_between(chip->soc_max, 0, 100)) {
+				reg = DIV_ROUND_UP(chip->soc_max * MAX_8_BITS,
+									100);
+				pr_debug("soc_max=%d reg=%x\n",
+						chip->soc_max, reg);
+				rc = smb1360_write(chip, SOC_MAX_REG, reg);
+				if (rc) {
+					dev_err(chip->dev, "Couldn't write to SOC_MAX_REG rc=%d\n",
+							rc);
+					return rc;
+				}
+			}
+		}
+
+		if (chip->voltage_min_mv != -EINVAL) {
+			temp = (chip->voltage_min_mv - 2500) * MAX_8_BITS;
+			reg = DIV_ROUND_UP(temp, 2500);
+			pr_debug("voltage_min=%d reg=%x\n",
+					chip->voltage_min_mv, reg);
+			rc = smb1360_write(chip, VTG_MIN_REG, reg);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't write to VTG_MIN_REG rc=%d\n",
+							rc);
+				return rc;
+			}
+		}
+
+		if (chip->voltage_empty_mv != -EINVAL) {
+			temp = (chip->voltage_empty_mv - 2500) * MAX_8_BITS;
+			reg = DIV_ROUND_UP(temp, 2500);
+			pr_debug("voltage_empty=%d reg=%x\n",
+					chip->voltage_empty_mv, reg);
+			rc = smb1360_write(chip, VTG_EMPTY_REG, reg);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't write to VTG_EMPTY_REG rc=%d\n",
+							rc);
+				return rc;
+			}
+		}
+	}
+
+	/* scratch-pad register config */
+	if (chip->batt_capacity_mah != -EINVAL
+		|| chip->v_cutoff_mv != -EINVAL
+		|| chip->fg_iterm_ma != -EINVAL
+		|| chip->fg_ibatt_standby_ma != -EINVAL
+		|| chip->fg_thermistor_c1_coeff != -EINVAL
+		|| chip->fg_cc_to_cv_mv != -EINVAL
+		|| chip->fg_auto_recharge_soc != -EINVAL) {
+
+		rc = smb1360_enable_fg_access(chip);
+		if (rc) {
+			pr_err("Couldn't enable FG access rc=%d\n", rc);
+			return rc;
+		}
+
+		/* Update battery capacity */
+		if (chip->batt_capacity_mah != -EINVAL) {
+			rc = smb1360_read_bytes(chip, ACTUAL_CAPACITY_REG,
+								reg2, 2);
+			if (rc) {
+				pr_err("Failed to read ACTUAL CAPACITY rc=%d\n",
+									rc);
+				goto disable_fg;
+			}
+			fcc_mah = (reg2[1] << 8) | reg2[0];
+			if (fcc_mah == chip->batt_capacity_mah) {
+				pr_debug("battery capacity correct\n");
+			} else {
+				/* Update the battery capacity */
+				reg2[1] =
+					(chip->batt_capacity_mah & 0xFF00) >> 8;
+				reg2[0] = (chip->batt_capacity_mah & 0xFF);
+				rc = smb1360_write_bytes(chip,
+					ACTUAL_CAPACITY_REG, reg2, 2);
+				if (rc) {
+					pr_err("Couldn't write batt-capacity rc=%d\n",
+									rc);
+					goto disable_fg;
+				}
+				rc = smb1360_write_bytes(chip,
+					NOMINAL_CAPACITY_REG, reg2, 2);
+				if (rc) {
+					pr_err("Couldn't write batt-capacity rc=%d\n",
+									rc);
+					goto disable_fg;
+				}
+
+				/* Update CC to SOC COEFF */
+				if (chip->cc_soc_coeff != -EINVAL) {
+					reg2[1] =
+					(chip->cc_soc_coeff & 0xFF00) >> 8;
+					reg2[0] = (chip->cc_soc_coeff & 0xFF);
+					rc = smb1360_write_bytes(chip,
+						CC_TO_SOC_COEFF, reg2, 2);
+					if (rc) {
+						pr_err("Couldn't write cc_soc_coeff rc=%d\n",
+									rc);
+						goto disable_fg;
+					}
+				}
+			}
+		}
+
+		/* Update cutoff voltage for SOC = 0 */
+		if (chip->v_cutoff_mv != -EINVAL) {
+			temp = (u16) div_u64(chip->v_cutoff_mv * 0x7FFF, 5000);
+			reg2[1] = (temp & 0xFF00) >> 8;
+			reg2[0] = temp & 0xFF;
+			rc = smb1360_write_bytes(chip, FG_SYS_CUTOFF_V_REG,
+								reg2, 2);
+			if (rc) {
+				pr_err("Couldn't write cutoff_mv rc=%d\n", rc);
+				goto disable_fg;
+			}
+		}
+
+		/*
+		 * Update FG iterm for SOC = 100, this value is always assumed
+		 * to be -ve
+		 */
+		if (chip->fg_iterm_ma != -EINVAL) {
+			int iterm = chip->fg_iterm_ma * -1;
+			temp = (s16) div_s64(iterm * 0x7FFF, 2500);
+			reg2[1] = (temp & 0xFF00) >> 8;
+			reg2[0] = temp & 0xFF;
+			rc = smb1360_write_bytes(chip, FG_ITERM_REG,
+							reg2, 2);
+			if (rc) {
+				pr_err("Couldn't write fg_iterm rc=%d\n", rc);
+				goto disable_fg;
+			}
+		}
+
+		/*
+		 * Update FG iterm standby for SOC = 0, this value is always
+		 * assumed to be +ve
+		 */
+		if (chip->fg_ibatt_standby_ma != -EINVAL) {
+			int iterm = chip->fg_ibatt_standby_ma;
+			temp = (u16) div_u64(iterm * 0x7FFF, 2500);
+			reg2[1] = (temp & 0xFF00) >> 8;
+			reg2[0] = temp & 0xFF;
+			rc = smb1360_write_bytes(chip, FG_IBATT_STANDBY_REG,
+								reg2, 2);
+			if (rc) {
+				pr_err("Couldn't write fg_iterm rc=%d\n", rc);
+				goto disable_fg;
+			}
+		}
+
+		/* Update CC_to_CV voltage threshold */
+		if (chip->fg_cc_to_cv_mv != -EINVAL) {
+			temp = (u16) div_u64(chip->fg_cc_to_cv_mv * 0x7FFF,
+								5000);
+			reg2[1] = (temp & 0xFF00) >> 8;
+			reg2[0] = temp & 0xFF;
+			rc = smb1360_write_bytes(chip, FG_CC_TO_CV_V_REG,
+								reg2, 2);
+			if (rc) {
+				pr_err("Couldn't write cc_to_cv_mv rc=%d\n",
+								rc);
+				goto disable_fg;
+			}
+		}
+
+		/* Update the thermistor c1 coefficient */
+		if (chip->fg_thermistor_c1_coeff != -EINVAL) {
+			reg2[1] = (chip->fg_thermistor_c1_coeff & 0xFF00) >> 8;
+			reg2[0] = (chip->fg_thermistor_c1_coeff & 0xFF);
+			rc = smb1360_write_bytes(chip, FG_THERM_C1_COEFF_REG,
+								reg2, 2);
+			if (rc) {
+				pr_err("Couldn't write thermistor_c1_coeff rc=%d\n",
+							rc);
+				goto disable_fg;
+			}
+		}
+
+		/* Update SoC based resume charging threshold */
+		if (chip->fg_auto_recharge_soc != -EINVAL) {
+			rc = smb1360_masked_write(chip, CFG_CHG_FUNC_CTRL_REG,
+						CHG_RECHG_THRESH_FG_SRC_BIT,
+						CHG_RECHG_THRESH_FG_SRC_BIT);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't write to CFG_CHG_FUNC_CTRL_REG rc=%d\n",
+									rc);
+				goto disable_fg;
+			}
+
+			reg = DIV_ROUND_UP(chip->fg_auto_recharge_soc *
+							MAX_8_BITS, 100);
+			pr_debug("fg_auto_recharge_soc=%d reg=%x\n",
+					chip->fg_auto_recharge_soc, reg);
+			rc = smb1360_write(chip, FG_AUTO_RECHARGE_SOC, reg);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't write to FG_AUTO_RECHARGE_SOC rc=%d\n",
+									rc);
+				goto disable_fg;
+			}
+		}
+
+disable_fg:
+		/* disable FG access */
+		smb1360_disable_fg_access(chip);
+	}
+
+	return rc;
+}
+
+static void smb1360_check_feature_support(struct smb1360_chip *chip)
+{
+
+	if (is_usb100_broken(chip)) {
+		pr_debug("USB100 is not supported\n");
+		chip->workaround_flags |= WRKRND_USB100_FAIL;
+	}
+
+	/*
+	 * FG Configuration
+	 *
+	 * The REV_1 of the chip does not allow access to
+	 * FG config registers (20-2FH). Set the workaround flag.
+	 * Also, the battery detection does not work when the DCIN is absent,
+	 * add a workaround flag for it.
+	*/
+	if (chip->revision == SMB1360_REV_1) {
+		pr_debug("FG config and Battery detection is not supported\n");
+		chip->workaround_flags |=
+			WRKRND_FG_CONFIG_FAIL | WRKRND_BATT_DET_FAIL;
+	}
+}
+
+static int smb1360_enable(struct smb1360_chip *chip, bool enable)
+{
+	int rc = 0;
+	u8 val = 0, shdn_cmd_polar;
+
+	rc = smb1360_read(chip, SHDN_CTRL_REG, &val);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't read 0x1A reg rc = %d\n", rc);
+		return rc;
+	}
+
+	/* Ignore if a CMD based shutdown is not enabled */
+	if (!(val & SHDN_CMD_USE_BIT)) {
+		pr_debug("SMB not configured for CMD based shutdown\n");
+		return 0;
+	}
+
+	shdn_cmd_polar = !!(val & SHDN_CMD_POLARITY_BIT);
+	val = (shdn_cmd_polar ^ enable) ? SHDN_CMD_BIT : 0;
+
+	pr_debug("enable=%d shdn_polarity=%d value=%d\n", enable,
+						shdn_cmd_polar, val);
+
+	rc = smb1360_masked_write(chip, CMD_IL_REG, SHDN_CMD_BIT, val);
+	if (rc < 0)
+		pr_err("Couldn't shutdown smb1360 rc = %d\n", rc);
+
+	return rc;
+}
+
+static inline int smb1360_poweroff(struct smb1360_chip *chip)
+{
+	pr_debug("power off smb1360\n");
+	return smb1360_enable(chip, false);
+}
+
+static inline int smb1360_poweron(struct smb1360_chip *chip)
+{
+	pr_debug("power on smb1360\n");
+	return smb1360_enable(chip, true);
+}
+
+static int smb1360_jeita_init(struct smb1360_chip *chip)
+{
+	int rc = 0;
+	int temp;
+
+	if (chip->config_hard_thresholds) {
+		if (chip->soft_jeita_supported) {
+			chip->workaround_flags |= WRKRND_HARD_JEITA;
+			rc = smb1360_set_soft_jeita_threshold(chip,
+			chip->cool_bat_decidegc, chip->warm_bat_decidegc);
+			if (rc) {
+				dev_err(chip->dev,
+					"Couldn't set jeita threshold\n");
+				return rc;
+			}
+		} else {
+			rc = smb1360_set_soft_jeita_threshold(chip,
+			chip->cold_bat_decidegc, chip->hot_bat_decidegc);
+			if (rc) {
+				dev_err(chip->dev,
+					"Couldn't set jeita threshold\n");
+				return rc;
+			}
+		}
+	} else {
+		if (chip->soft_jeita_supported) {
+			temp = min(chip->warm_bat_ma, chip->cool_bat_ma);
+			rc = smb1360_set_jeita_comp_curr(chip, temp);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't set comp current\n");
+				return rc;
+			}
+
+			temp = (chip->vfloat_mv - chip->warm_bat_mv) / 10;
+			rc = smb1360_masked_write(chip, CFG_FVC_REG,
+					FLT_VTG_COMP_MASK, temp);
+			if (rc < 0) {
+				dev_err(chip->dev, "Couldn't set VFLT compensation = %d",
+									rc);
+				return rc;
+			}
+
+			rc = smb1360_set_soft_jeita_threshold(chip,
+			chip->cool_bat_decidegc, chip->warm_bat_decidegc);
+			if (rc) {
+				dev_err(chip->dev,
+					"Couldn't set jeita threshold\n");
+				return rc;
+			}
+
+			rc = smb1360_soft_jeita_comp_enable(chip, true);
+			if (rc) {
+				dev_err(chip->dev, "Couldn't enable jeita\n");
+				return rc;
+			}
+		}
+	}
+
+	return rc;
+}
+
+static int smb1360_otp_gain_init(struct smb1360_chip *chip)
+{
+	int rc = 0, gain_factor;
+	bool otp_gain_config = false;
+
+	if (chip->rsense_10mohm) {
+		gain_factor = 2;
+		otp_gain_config = true;
+	}
+
+	mutex_lock(&chip->otp_gain_lock);
+	if (chip->otg_fet_present) {
+		/*
+		 * Reset current gain to the default value if OTG
+		 * is not enabled
+		 */
+		if (!chip->fet_gain_enabled) {
+			otp_gain_config = true;
+			gain_factor = 0;
+		}
+	}
+
+	if (otp_gain_config) {
+		rc = smb1360_otp_gain_config(chip, gain_factor);
+		if (rc < 0)
+			pr_err("Couldn't config OTP gain rc=%d\n", rc);
+	}
+	mutex_unlock(&chip->otp_gain_lock);
+
+	return rc;
+}
+
+static int smb1360_hw_init(struct smb1360_chip *chip)
+{
+	int rc;
+	int i;
+	u8 reg, mask;
+	u8 temp_data = 0;
+
+	smb1360_check_feature_support(chip);
+
+	rc = smb1360_enable_volatile_writes(chip);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't configure for volatile rc = %d\n",
+				rc);
+		return rc;
+	}
+
+	/* Bring SMB1360 out of shutdown, if it was enabled by default */
+	rc = smb1360_poweron(chip);
+	if (rc < 0) {
+		pr_err("smb1360 power on failed\n");
+		return rc;
+	} else {
+		/*
+		 * A 2 seconds delay is mandatory after bringing the chip out
+		 * of shutdown. This guarantees that FG is in a proper state.
+		 */
+		schedule_delayed_work(&chip->delayed_init_work,
+				msecs_to_jiffies(SMB1360_POWERON_DELAY_MS));
+	}
+	/*
+	 * set chg en by cmd register, set chg en by writing bit 1,
+	 * enable auto pre to fast
+	 */
+	rc = smb1360_masked_write(chip, CFG_CHG_MISC_REG,
+					CHG_EN_BY_PIN_BIT
+					| CHG_EN_ACTIVE_LOW_BIT
+					| PRE_TO_FAST_REQ_CMD_BIT,
+					0);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't set CFG_CHG_MISC_REG rc=%d\n", rc);
+		return rc;
+	}
+
+	/* USB/AC pin settings */
+	rc = smb1360_masked_write(chip, CFG_BATT_CHG_ICL_REG,
+					AC_INPUT_ICL_PIN_BIT
+					| AC_INPUT_PIN_HIGH_BIT
+					| RESET_STATE_USB_500,
+					AC_INPUT_PIN_HIGH_BIT
+					| RESET_STATE_USB_500);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't set CFG_BATT_CHG_ICL_REG rc=%d\n",
+				rc);
+		return rc;
+	}
+
+	/* set the switching frequency to 3.2MHz*/
+	rc = smb1360_masked_write(chip, CFG_BATT_CHG_FREQ_REG, SWITCH_FREQ_BIT, 0);
+	if (0 > rc ) {
+		dev_err(chip->dev, "Couldn't set CFG_BATT_CHG_FREQ_REG rc=%d\n", rc);
+	}
+
+	/* AICL enable and set input-uv glitch flt to 20ms*/
+	reg = AICL_ENABLED_BIT | INPUT_UV_GLITCH_FLT_20MS_BIT;
+	rc = smb1360_masked_write(chip, CFG_GLITCH_FLT_REG, reg, reg);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't set CFG_GLITCH_FLT_REG rc=%d\n",
+				rc);
+		return rc;
+	}
+
+	/* set the float voltage */
+	if (chip->vfloat_mv != -EINVAL) {
+		rc = smb1360_float_voltage_set(chip, chip->vfloat_mv);
+		if (rc < 0) {
+			dev_err(chip->dev,
+				"Couldn't set float voltage rc = %d\n", rc);
+			return rc;
+		}
+	}
+	/* set iterm */
+	if (chip->iterm_ma != -EINVAL) {
+		if (chip->iterm_disabled) {
+			dev_err(chip->dev, "Error: Both iterm_disabled and iterm_ma set\n");
+			return -EINVAL;
+		} else {
+			if (chip->rsense_10mohm)
+				chip->iterm_ma /= 2;
+
+			if (chip->iterm_ma < 25)
+				reg = CHG_ITERM_25MA;
+			else if (chip->iterm_ma > 200)
+				reg = CHG_ITERM_200MA;
+			else
+				reg = DIV_ROUND_UP(chip->iterm_ma, 25) - 1;
+
+			rc = smb1360_masked_write(chip, CFG_BATT_CHG_REG,
+						CHG_ITERM_MASK, reg);
+			if (rc) {
+				dev_err(chip->dev,
+					"Couldn't set iterm rc = %d\n", rc);
+				return rc;
+			}
+
+			rc = smb1360_masked_write(chip, CFG_CHG_MISC_REG,
+					CHG_CURR_TERM_DIS_BIT, 0);
+			if (rc) {
+				dev_err(chip->dev,
+					"Couldn't enable iterm rc = %d\n", rc);
+				return rc;
+			}
+		}
+	} else  if (chip->iterm_disabled) {
+		rc = smb1360_masked_write(chip, CFG_CHG_MISC_REG,
+						CHG_CURR_TERM_DIS_BIT,
+						CHG_CURR_TERM_DIS_BIT);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set iterm rc = %d\n",
+								rc);
+			return rc;
+		}
+	}
+
+	/* set the safety time voltage */
+	if (chip->safety_time != -EINVAL) {
+		if (chip->safety_time == 0) {
+			/* safety timer disabled */
+			rc = smb1360_masked_write(chip, CFG_SFY_TIMER_CTRL_REG,
+			SAFETY_TIME_DISABLE_BIT, SAFETY_TIME_DISABLE_BIT);
+			if (rc < 0) {
+				dev_err(chip->dev,
+				"Couldn't disable safety timer rc = %d\n",
+								rc);
+				return rc;
+			}
+		} else {
+			for (i = 0; i < ARRAY_SIZE(chg_time); i++) {
+				if (chip->safety_time <= chg_time[i]) {
+					reg = i << SAFETY_TIME_MINUTES_SHIFT;
+					break;
+				}
+			}
+			rc = smb1360_masked_write(chip, CFG_SFY_TIMER_CTRL_REG,
+			SAFETY_TIME_DISABLE_BIT | SAFETY_TIME_MINUTES_MASK,
+								reg);
+			if (rc < 0) {
+				dev_err(chip->dev,
+					"Couldn't set safety timer rc = %d\n",
+									rc);
+				return rc;
+			}
+		}
+	}
+
+	/* configure resume threshold, auto recharge and charge inhibit */
+	if (chip->resume_delta_mv != -EINVAL) {
+		if (chip->recharge_disabled && chip->chg_inhibit_disabled) {
+			dev_err(chip->dev, "Error: Both recharge_disabled and recharge_mv set\n");
+			return -EINVAL;
+		} else {
+			rc = smb1360_recharge_threshold_set(chip,
+						chip->resume_delta_mv);
+			if (rc) {
+				dev_err(chip->dev,
+					"Couldn't set rechg thresh rc = %d\n",
+									rc);
+				return rc;
+			}
+		}
+	}
+
+	rc = smb1360_masked_write(chip, CFG_CHG_MISC_REG,
+					CFG_AUTO_RECHG_DIS_BIT,
+					chip->recharge_disabled ?
+					CFG_AUTO_RECHG_DIS_BIT : 0);
+	if (rc) {
+		dev_err(chip->dev, "Couldn't set rechg-cfg rc = %d\n", rc);
+		return rc;
+	}
+	rc = smb1360_masked_write(chip, CFG_CHG_MISC_REG,
+					CFG_CHG_INHIBIT_EN_BIT,
+					chip->chg_inhibit_disabled ?
+					0 : CFG_CHG_INHIBIT_EN_BIT);
+	if (rc) {
+		dev_err(chip->dev, "Couldn't set chg_inhibit rc = %d\n", rc);
+		return rc;
+	}
+
+	/* battery missing detection */
+	rc = smb1360_masked_write(chip, CFG_BATT_MISSING_REG,
+				BATT_MISSING_SRC_THERM_BIT,
+				BATT_MISSING_SRC_THERM_BIT);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't set batt_missing config = %d\n",
+									rc);
+		return rc;
+	}
+
+	rc = smb1360_jeita_init(chip);
+	if (rc < 0) {
+		dev_err(chip->dev, "Couldn't init jeita, rc = %d\n", rc);
+		return rc;
+	}
+
+	/* interrupt enabling - active low */
+	if (chip->client->irq) {
+		mask = CHG_STAT_IRQ_ONLY_BIT
+			| CHG_STAT_ACTIVE_HIGH_BIT
+			| CHG_STAT_DISABLE_BIT
+			| CHG_TEMP_CHG_ERR_BLINK_BIT;
+
+		if (!chip->pulsed_irq)
+			reg = CHG_STAT_IRQ_ONLY_BIT;
+		else
+			reg = CHG_TEMP_CHG_ERR_BLINK_BIT;
+		rc = smb1360_masked_write(chip, CFG_STAT_CTRL_REG, mask, reg);
+		if (rc < 0) {
+			dev_err(chip->dev, "Couldn't set irq config rc = %d\n",
+					rc);
+			return rc;
+		}
+
+		/* enabling only interesting interrupts */
+		rc = smb1360_write(chip, IRQ_CFG_REG,
+				IRQ_BAT_HOT_COLD_HARD_BIT
+				| IRQ_BAT_HOT_COLD_SOFT_BIT
+				| IRQ_INTERNAL_TEMPERATURE_BIT
+				| IRQ_DCIN_UV_BIT
+				| IRQ_AICL_DONE_BIT);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set irq1 config rc = %d\n",
+					rc);
+			return rc;
+		}
+
+		rc = smb1360_write(chip, IRQ2_CFG_REG,
+				IRQ2_SAFETY_TIMER_BIT
+				| IRQ2_CHG_ERR_BIT
+				| IRQ2_CHG_PHASE_CHANGE_BIT
+				| IRQ2_POWER_OK_BIT
+				| IRQ2_BATT_MISSING_BIT
+				| IRQ2_VBAT_LOW_BIT);
+		if (rc) {
+			dev_err(chip->dev, "Couldn't set irq2 config rc = %d\n",
+					rc);
+			return rc;
+		}
+
+		rc = smb1360_write(chip, IRQ3_CFG_REG,
+				IRQ3_FG_ACCESS_OK_BIT
+				| IRQ3_SOC_CHANGE_BIT
+				| IRQ3_SOC_MIN_BIT
+				| IRQ3_SOC_MAX_BIT
+				| IRQ3_SOC_EMPTY_BIT
+				| IRQ3_SOC_FULL_BIT);
+		if (rc < 0) {
+			dev_err(chip->dev, "Couldn't set irq3 enable rc = %d\n",
+					rc);
+			return rc;
+		}
+	}
+
+	/* batt-id configuration */
+	if (chip->batt_id_disabled) {
+		mask = BATT_ID_ENABLED_BIT | CHG_BATT_ID_FAIL;
+		reg = CHG_BATT_ID_FAIL;
+		rc = smb1360_masked_write(chip, CFG_FG_BATT_CTRL_REG,
+						mask, reg);
+		if (rc < 0) {
+			dev_err(chip->dev, "Couldn't set batt_id_reg rc = %d\n",
+					rc);
+			return rc;
+		}
+	}
+
+	/* USB OTG current limit configuration */
+	if (chip->otg_batt_curr_limit != -EINVAL) {
+		for (i = 0; i < ARRAY_SIZE(otg_curr_ma); i++) {
+			if (otg_curr_ma[i] >= chip->otg_batt_curr_limit)
+				break;
+		}
+
+		if (i == ARRAY_SIZE(otg_curr_ma))
+			i = i - 1;
+
+		rc = smb1360_masked_write(chip, CFG_BATT_CHG_REG,
+						OTG_CURRENT_MASK,
+					i << OTG_CURRENT_SHIFT);
+		if (rc)
+			pr_err("Couldn't set OTG current limit, rc = %d\n", rc);
+	}
+	rc = smb1360_read(chip,CMD_IL_REG,&temp_data);
+	if (rc)
+		pr_err("read CMD_IL_REG failed %d\n", rc);
+	if(get_usbcharger_type()==4)//usb
+	{
+	     temp_data=(temp_data&0x0f);
+		if(temp_data== 2)
+		{
+		    rc = smb1360_masked_write(chip, CMD_IL_REG,
+					USB_CTRL_MASK, USB_500_BIT);
+		}
+
+		if (rc)
+			pr_err("Couldn't set USB ICL mA rc=%d\n", rc);
+	}
+#if 1
+	//add 2015-01-06 start
+	/*TOG voltage thresdhold 2.75V*/
+    rc = smb1360_masked_write(chip, OTG_UVLO_REG, OTG_UVLO_MASK,
+						OTG_UVLO_DATA << OTG_UVLO_SHIFT);
+    if (rc)
+		pr_err("Couldn't set  OTG_UVLO_REG mode rc=%d\n", rc);
+    /*pre_to_fast voltage thresdhold 3.1V*/
+	rc = smb1360_masked_write(chip, OTG_UVLO_REG, PRE_TO_FAST_MASK,
+						PRE_TO_FAST_DATA << PRE_TO_FAST_SHIFT);
+    if (rc)
+		pr_err("Couldn't set  PRE_TO_FAST_VOLTAGE mode rc=%d\n", rc);
+	//precharging current
+    rc = smb1360_masked_write(chip, CHG_CURRENT_REG, PRE_CHARGE_CURRENT_MASK,
+						PRE_CHARGE_CURRENT_DATA << PRE_CHARGE_CURRENT_SHIFT);
+    if (rc)
+		pr_err("Couldn't set  OTG_UVLO_REG mode rc=%d\n", rc);
+	//add 2015-01-06 end
+#endif
+
+	rc = smb1360_charging_disable(chip, USER, !!chip->charging_disabled);
+	if (rc)
+		dev_err(chip->dev, "Couldn't '%s' charging rc = %d\n",
+			chip->charging_disabled ? "disable" : "enable", rc);
+
+	if (chip->parallel_charging) {
+		rc = smb1360_parallel_charger_enable(chip, PARALLEL_USER,
+						!chip->charging_disabled);
+		if (rc)
+			dev_err(chip->dev, "Couldn't '%s' parallel-charging rc = %d\n",
+			chip->charging_disabled ? "disable" : "enable", rc);
+	}
+
+	return rc;
+}
+
+static int smb1360_delayed_hw_init(struct smb1360_chip *chip)
+{
+	int rc;
+
+	pr_debug("delayed hw init start!\n");
+
+	rc = smb1360_check_batt_profile(chip);
+	if (rc) {
+		pr_err("Unable to modify battery profile, rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = smb1360_otp_gain_init(chip);
+	if (rc) {
+		pr_err("Unable to config otp gain, rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = smb1360_fg_config(chip);
+	if (rc) {
+		pr_err("Couldn't configure FG rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = smb1360_check_cycle_stretch(chip);
+	if (rc) {
+		pr_err("Unable to check cycle-stretch\n");
+		return rc;
+	}
+
+	pr_debug("delayed hw init complete!\n");
+	return rc;
+}
+
+static void smb1360_delayed_init_work_fn(struct work_struct *work)
+{
+	int rc = 0;
+	struct smb1360_chip *chip = container_of(work, struct smb1360_chip,
+						delayed_init_work.work);
+
+	rc = smb1360_delayed_hw_init(chip);
+
+	if (!rc) {
+		/*
+		 * If the delayed hw init successfully, update battery
+		 * power_supply to make sure the correct SoC reported
+		 * timely.
+		 */
+		power_supply_changed(&chip->batt_psy);
+	} else if (rc == -ETIMEDOUT) {
+		/*
+		 * If the delayed hw init failed causing by waiting for
+		 * FG access timed-out, force a FG reset and queue the
+		 * worker again to retry the initialization.
+		 */
+		pr_debug("delayed hw init timed-out, retry!");
+		rc = smb1360_force_fg_reset(chip);
+		if (rc) {
+			pr_err("couldn't reset FG, rc = %d\n", rc);
+			return;
+		}
+		schedule_delayed_work(&chip->delayed_init_work, 0);
+	} else {
+		pr_err("delayed hw init failed, rc=%d\n", rc);
+	}
+}
+
+static int smb_parse_batt_id(struct smb1360_chip *chip)
+{
+	int rc = 0, rpull = 0, vref = 0;
+	int64_t denom, batt_id_uv;
+	struct device_node *node = chip->dev->of_node;
+	struct qpnp_vadc_result result;
+
+	chip->vadc_dev = qpnp_get_vadc(chip->dev, "smb1360");
+	if (IS_ERR(chip->vadc_dev)) {
+		rc = PTR_ERR(chip->vadc_dev);
+		if (rc == -EPROBE_DEFER)
+			pr_err("vadc not found - defer rc=%d\n", rc);
+		else
+			pr_err("vadc property missing, rc=%d\n", rc);
+
+		return rc;
+	}
+
+	rc = of_property_read_u32(node, "qcom,profile-a-rid-kohm",
+						&chip->profile_rid[0]);
+	if (rc < 0) {
+		pr_err("Couldn't read profile-a-rid-kohm rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = of_property_read_u32(node, "qcom,profile-b-rid-kohm",
+						&chip->profile_rid[1]);
+	if (rc < 0) {
+		pr_err("Couldn't read profile-b-rid-kohm rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = of_property_read_u32(node, "qcom,batt-id-vref-uv", &vref);
+	if (rc < 0) {
+		pr_err("Couldn't read batt-id-vref-uv rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = of_property_read_u32(node, "qcom,batt-id-rpullup-kohm", &rpull);
+	if (rc < 0) {
+		pr_err("Couldn't read batt-id-rpullup-kohm rc=%d\n", rc);
+		return rc;
+	}
+
+	/* read battery ID */
+	rc = qpnp_vadc_read(chip->vadc_dev, LR_MUX2_BAT_ID, &result);
+	if (rc) {
+		pr_err("error reading batt id channel = %d, rc = %d\n",
+					LR_MUX2_BAT_ID, rc);
+		return rc;
+	}
+	batt_id_uv = result.physical;
+
+	if (batt_id_uv == 0) {
+		/* vadc not correct or batt id line grounded, report 0 kohms */
+		pr_err("batt_id_uv = 0, batt-id grounded using same profile\n");
+		return 0;
+	}
+
+	denom = div64_s64(vref * 1000000LL, batt_id_uv) - 1000000LL;
+	if (denom == 0) {
+		/* batt id connector might be open, return 0 kohms */
+		return 0;
+	}
+	chip->connected_rid = div64_s64(rpull * 1000000LL + denom/2, denom);
+
+	pr_debug("batt_id_voltage = %lld, connected_rid = %d\n",
+			batt_id_uv, chip->connected_rid);
+
+	return 0;
+}
+
+/*
+ * Note the below:
+ * 1. if both qcom,soft-jeita-supported and qcom,config-hard-thresholds
+ * are not defined, SMB continues with default OTP configuration.
+ * 2. if both are enabled, the hard thresholds are modified.
+ * 3. if only qcom,config-hard-thresholds is defined, the soft JEITA is disabled
+ * 4. if only qcom,soft-jeita-supported is defined, the soft JEITA thresholds
+ * are modified.
+ */
+static int smb1360_parse_jeita_params(struct smb1360_chip *chip)
+{
+	int rc = 0;
+	struct device_node *node = chip->dev->of_node;
+
+	if (of_property_read_bool(node, "qcom,config-hard-thresholds")) {
+		rc = of_property_read_u32(node,
+			"qcom,cold-bat-decidegc", &chip->cold_bat_decidegc);
+		if (rc) {
+			pr_err("cold_bat_decidegc property error, rc = %d\n",
+								rc);
+			return -EINVAL;
+		}
+
+		rc = of_property_read_u32(node,
+			"qcom,hot-bat-decidegc", &chip->hot_bat_decidegc);
+		if (rc) {
+			pr_err("hot_bat_decidegc property error, rc = %d\n",
+								rc);
+			return -EINVAL;
+		}
+
+		if (of_property_read_bool(node,"qcom,soft-disable-charging"))
+			chip->soft_disable_charging = true;
+		else
+			chip->soft_disable_charging = false;
+
+		if (of_property_read_bool(node,"qcom,config-rechg-temp"))
+			chip->config_rechg_temp = true;
+		else
+			chip->config_rechg_temp = false;
+
+		if (chip->config_rechg_temp) {
+			rc = of_property_read_u32(node,
+					"qcom,rechg-warm-bat-decidegc", &chip->rechg_warm_bat_decidegc);
+			if (rc) {
+				pr_err("rechg_warm_bat_decidegc property error, rc = %d\n",
+						rc);
+				return -EINVAL;
+			}
+			rc = of_property_read_u32(node,
+					"qcom,rechg-cool-bat-decidegc", &chip->rechg_cool_bat_decidegc);
+			if (rc) {
+				pr_err("rechg_cool_bat_decidegc property error, rc = %d\n",
+						rc);
+				return -EINVAL;
+			}
+		}
+		chip->config_hard_thresholds = true;
+		pr_debug("config_hard_thresholds = %d, cold_bat_decidegc = %d, hot_bat_decidegc = %d\n",
+			chip->config_hard_thresholds, chip->cold_bat_decidegc,
+			chip->hot_bat_decidegc);
+	}
+
+	if (of_property_read_bool(node, "qcom,soft-jeita-supported")) {
+		rc = of_property_read_u32(node, "qcom,warm-bat-decidegc",
+						&chip->warm_bat_decidegc);
+		if (rc) {
+			pr_err("warm_bat_decidegc property error, rc = %d\n",
+								rc);
+			return -EINVAL;
+		}
+
+		rc = of_property_read_u32(node, "qcom,cool-bat-decidegc",
+						&chip->cool_bat_decidegc);
+		if (rc) {
+			pr_err("cool_bat_decidegc property error, rc = %d\n",
+								rc);
+			return -EINVAL;
+		}
+		rc = of_property_read_u32(node, "qcom,cool-bat-mv",
+						&chip->cool_bat_mv);
+		if (rc) {
+			pr_err("cool_bat_mv property error, rc = %d\n", rc);
+			return -EINVAL;
+		}
+
+		rc = of_property_read_u32(node, "qcom,warm-bat-mv",
+						&chip->warm_bat_mv);
+		if (rc) {
+			pr_err("warm_bat_mv property error, rc = %d\n", rc);
+			return -EINVAL;
+		}
+
+		rc = of_property_read_u32(node, "qcom,cool-bat-ma",
+						&chip->cool_bat_ma);
+		if (rc) {
+			pr_err("cool_bat_ma property error, rc = %d\n", rc);
+			return -EINVAL;
+		}
+
+		rc = of_property_read_u32(node, "qcom,warm-bat-ma",
+						&chip->warm_bat_ma);
+
+		if (rc) {
+			pr_err("warm_bat_ma property error, rc = %d\n", rc);
+			return -EINVAL;
+		}
+
+		rc = of_property_read_u32(node, "qcom,rechg-cold-bat-decidegc",
+						&chip->rechg_cold_bat_decidegc);
+
+		if (rc) {
+			pr_err("rechg_cold_bat_decidegc property error, rc = %d\n", rc);
+			return -EINVAL;
+		}
+
+		chip->soft_jeita_supported = true;
+	}
+
+	pr_debug("soft-jeita-enabled = %d, warm-bat-decidegc = %d, cool-bat-decidegc = %d, cool-bat-mv = %d, warm-bat-mv = %d, cool-bat-ma = %d, warm-bat-ma = %d\n",
+		chip->soft_jeita_supported, chip->warm_bat_decidegc,
+		chip->cool_bat_decidegc, chip->cool_bat_mv, chip->warm_bat_mv,
+		chip->cool_bat_ma, chip->warm_bat_ma);
+
+	return rc;
+}
+
+#define MAX_PARALLEL_CURRENT		540
+static int smb1360_parse_parallel_charging_params(struct smb1360_chip *chip)
+{
+	struct device_node *node = chip->dev->of_node;
+
+	if (of_property_read_bool(node, "qcom,parallel-charging-enabled")) {
+
+		if (!chip->rsense_10mohm) {
+			pr_err("10mohm-rsense configuration not enabled - parallel-charging disabled\n");
+			return 0;
+		}
+		chip->parallel_charging = true;
+		chip->max_parallel_chg_current = MAX_PARALLEL_CURRENT;
+		of_property_read_u32(node, "qcom,max-parallel-current-ma",
+					&chip->max_parallel_chg_current);
+
+		pr_debug("Max parallel charger current = %dma\n",
+				chip->max_parallel_chg_current);
+
+		/* mark the parallel-charger as disabled */
+		chip->parallel_chg_disable_status |= PARALLEL_CURRENT;
+	}
+
+	return 0;
+}
+
+static int smb_parse_dt(struct smb1360_chip *chip)
+{
+	int rc;
+	struct device_node *node = chip->dev->of_node;
+
+	if (!node) {
+		dev_err(chip->dev, "device tree info. missing\n");
+		return -EINVAL;
+	}
+
+	chip->rsense_10mohm = of_property_read_bool(node, "qcom,rsense-10mhom");
+
+	if (of_property_read_bool(node, "qcom,batt-profile-select")) {
+		rc = smb_parse_batt_id(chip);
+		if (rc < 0) {
+			if (rc != -EPROBE_DEFER)
+				pr_err("Unable to parse batt-id rc=%d\n", rc);
+			return rc;
+		}
+	}
+
+	chip->otg_fet_present = of_property_read_bool(node,
+						"qcom,otg-fet-present");
+	if (chip->otg_fet_present) {
+		chip->otg_fet_enable_gpio = of_get_named_gpio(node,
+						"qcom,otg-fet-enable-gpio", 0);
+		if (!gpio_is_valid(chip->otg_fet_enable_gpio)) {
+			if (chip->otg_fet_enable_gpio != -EPROBE_DEFER)
+				pr_err("Unable to get OTG FET enable gpio=%d\n",
+						chip->otg_fet_enable_gpio);
+			return chip->otg_fet_enable_gpio;
+		} else {
+			/* Configure OTG FET control gpio */
+			rc = devm_gpio_request_one(chip->dev,
+					chip->otg_fet_enable_gpio,
+					GPIOF_OPEN_DRAIN | GPIOF_INIT_HIGH,
+					"smb1360_otg_fet_gpio");
+			if (rc) {
+				pr_err("Unable to request gpio rc=%d\n", rc);
+				return rc;
+			}
+		}
+	}
+
+	chip->pulsed_irq = of_property_read_bool(node, "qcom,stat-pulsed-irq");
+
+	rc = of_property_read_u32(node, "qcom,float-voltage-mv",
+						&chip->vfloat_mv);
+	if (rc < 0)
+		chip->vfloat_mv = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,charging-timeout",
+						&chip->safety_time);
+	if (rc < 0)
+		chip->safety_time = -EINVAL;
+
+	if (!rc && (chip->safety_time > chg_time[ARRAY_SIZE(chg_time) - 1])) {
+		dev_err(chip->dev, "Bad charging-timeout %d\n",
+						chip->safety_time);
+		return -EINVAL;
+	}
+
+	rc = of_property_read_u32(node, "qcom,recharge-thresh-mv",
+						&chip->resume_delta_mv);
+	if (rc < 0)
+		chip->resume_delta_mv = -EINVAL;
+
+	chip->recharge_disabled = of_property_read_bool(node,
+						"qcom,recharge-disabled");
+
+	rc = of_property_read_u32(node, "qcom,iterm-ma", &chip->iterm_ma);
+	if (rc < 0)
+		chip->iterm_ma = -EINVAL;
+
+	chip->iterm_disabled = of_property_read_bool(node,
+						"qcom,iterm-disabled");
+
+	chip->chg_inhibit_disabled = of_property_read_bool(node,
+						"qcom,chg-inhibit-disabled");
+
+	chip->charging_disabled = of_property_read_bool(node,
+						"qcom,charging-disabled");
+
+	chip->batt_id_disabled = of_property_read_bool(node,
+						"qcom,batt-id-disabled");
+
+	chip->shdn_after_pwroff = of_property_read_bool(node,
+						"qcom,shdn-after-pwroff");
+
+	chip->min_icl_usb100 = of_property_read_bool(node,
+						"qcom,min-icl-100ma");
+
+	rc = smb1360_parse_parallel_charging_params(chip);
+	if (rc) {
+		pr_err("Couldn't parse parallel charginng params rc=%d\n", rc);
+		return rc;
+	}
+
+	if (of_find_property(node, "qcom,thermal-mitigation",
+					&chip->thermal_levels)) {
+		chip->thermal_mitigation = devm_kzalloc(chip->dev,
+					chip->thermal_levels,
+						GFP_KERNEL);
+
+		if (chip->thermal_mitigation == NULL) {
+			pr_err("thermal mitigation kzalloc() failed.\n");
+			return -ENOMEM;
+		}
+
+		chip->thermal_levels /= sizeof(int);
+		rc = of_property_read_u32_array(node,
+				"qcom,thermal-mitigation",
+				chip->thermal_mitigation, chip->thermal_levels);
+		if (rc) {
+			pr_err("Couldn't read threm limits rc = %d\n", rc);
+			return rc;
+		}
+	}
+
+	rc = smb1360_parse_jeita_params(chip);
+	if (rc < 0) {
+		pr_err("Couldn't parse jeita params, rc = %d\n", rc);
+		return rc;
+	}
+
+	/* fg params */
+	chip->empty_soc_disabled = of_property_read_bool(node,
+						"qcom,empty-soc-disabled");
+
+	rc = of_property_read_u32(node, "qcom,fg-delta-soc", &chip->delta_soc);
+	if (rc < 0)
+		chip->delta_soc = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-soc-max", &chip->soc_max);
+	if (rc < 0)
+		chip->soc_max = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-soc-min", &chip->soc_min);
+	if (rc < 0)
+		chip->soc_min = -EINVAL;
+
+	chip->awake_min_soc = of_property_read_bool(node,
+					"qcom,awake-min-soc");
+
+	rc = of_property_read_u32(node, "qcom,fg-voltage-min-mv",
+					&chip->voltage_min_mv);
+	if (rc < 0)
+		chip->voltage_min_mv = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-voltage-empty-mv",
+					&chip->voltage_empty_mv);
+	if (rc < 0)
+		chip->voltage_empty_mv = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-batt-capacity-mah",
+					&chip->batt_capacity_mah);
+	if (rc < 0)
+		chip->batt_capacity_mah = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-cc-soc-coeff",
+					&chip->cc_soc_coeff);
+	if (rc < 0)
+		chip->cc_soc_coeff = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-cutoff-voltage-mv",
+						&chip->v_cutoff_mv);
+	if (rc < 0)
+		chip->v_cutoff_mv = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-iterm-ma",
+					&chip->fg_iterm_ma);
+	if (rc < 0)
+		chip->fg_iterm_ma = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-ibatt-standby-ma",
+					&chip->fg_ibatt_standby_ma);
+	if (rc < 0)
+		chip->fg_ibatt_standby_ma = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,thermistor-c1-coeff",
+					&chip->fg_thermistor_c1_coeff);
+	if (rc < 0)
+		chip->fg_thermistor_c1_coeff = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-cc-to-cv-mv",
+					&chip->fg_cc_to_cv_mv);
+	if (rc < 0)
+		chip->fg_cc_to_cv_mv = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,otg-batt-curr-limit",
+					&chip->otg_batt_curr_limit);
+	if (rc < 0)
+		chip->otg_batt_curr_limit = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-suspend-voltage-empty-mv",
+					&chip->suspend_voltage_empty_mv);
+	if (rc < 0)
+		chip->voltage_empty_mv = -EINVAL;
+
+	rc = of_property_read_u32(node, "qcom,fg-auto-recharge-soc",
+					&chip->fg_auto_recharge_soc);
+	if (rc < 0)
+		chip->fg_auto_recharge_soc = -EINVAL;
+
+	if (of_property_read_bool(node, "qcom,fg-reset-at-pon")) {
+		chip->fg_reset_at_pon = true;
+		rc = of_property_read_u32(node, "qcom,fg-reset-thresold-mv",
+						&chip->fg_reset_threshold_mv);
+		if (rc) {
+			pr_debug("FG reset voltage threshold not specified using 50mV\n");
+			chip->fg_reset_threshold_mv = FG_RESET_THRESHOLD_MV;
+		}
+	}
+	if (of_property_read_bool(node, "qcom,ckt-therengine-control")) {
+		chip->ckt_therengine_control = true;
+		pr_err("chip->qcom,ckt-therengine-control = true;\n");
+	}
+	
+	rc = of_property_read_u32(node, "qcom,hot-bat-mv",
+					&chip->hot_bat_mv);
+	if (rc < 0)
+		chip->fg_auto_recharge_soc = -EINVAL;
+
+	return 0;
+}
+/**wuboadd start**/
+
+static int get_usbcharger_type()
+{
+	struct power_supply *usb_psy;
+	union power_supply_propval val;
+	char *type_text[] = {
+		"Unknown", "Battery", "UPS", "Mains", "USB",
+		"USB_DCP", "USB_CDP", "USB_ACA", "Wireless", "BMS",
+		"USB_Parallel"
+	};
+	usb_psy = power_supply_get_by_name("usb");
+	if(usb_psy)
+	{
+	usb_psy->get_property(usb_psy,POWER_SUPPLY_PROP_TYPE,&val);
+	pr_debug("usb_charger_type id :%d name:%s\n",val.intval,type_text[val.intval]);
+	return val.intval;
+	}
+	else
+	{
+	pr_err("can not get USB charger type!!!\n");
+	return 0xDE;
+	}
+}
+static void charger_abnormal_detect_work(struct work_struct *work)
+{
+
+	struct smb1360_chip *chip;
+	struct power_supply *usb_psy;
+	struct power_supply *battery_psy;
+	union power_supply_propval val;
+	int chargertype = 0;
+	int temperature = -200;
+	usb_psy = power_supply_get_by_name("usb");
+	battery_psy = power_supply_get_by_name("battery");
+
+	usb_psy->get_property(usb_psy,POWER_SUPPLY_PROP_PRESENT,&val);
+	chip = container_of(battery_psy,struct smb1360_chip,batt_psy);
+	if(val.intval == 1) {
+		temperature = smb1360_get_prop_batt_temp(chip);
+		chargertype = get_usbcharger_type();
+
+		if(chargertype == 5)//AC
+			chip->usb_psy_ma =CHG_CURRENT_AC_MA;
+		else if(chargertype == 4)//USB
+			chip->usb_psy_ma =CHG_CURRENT_USB_MA;
+		else
+			pr_err("charger type %d\n",chargertype);
+
+		smb1360_set_appropriate_usb_current(chip);
+		pr_err("usb_present temp %d chip->usb_psy_ma:%d\n",temperature,chip->usb_psy_ma);
+	} else
+		release_AC_charger_wakelock();
+
+	power_supply_changed(battery_psy);
+
+	schedule_delayed_work(&chip->abnormal_detect,msecs_to_jiffies(10000));
+}
+/**wuboadd end**/
+
+
+static int smb1360_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	u8 reg;
+	int rc;
+	struct smb1360_chip *chip;
+	struct power_supply *usb_psy;
+	pr_err("mask:smb1360 probe start!");
+	usb_psy = power_supply_get_by_name("usb");
+	if (!usb_psy) {
+		dev_dbg(&client->dev, "USB supply not found; defer probe\n");
+		return -EPROBE_DEFER;
+	}
+
+	chip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip) {
+		dev_err(&client->dev, "Unable to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	chip->resume_completed = true;
+	chip->client = client;
+	chip->dev = &client->dev;
+	chip->usb_psy = usb_psy;
+	chip->fake_battery_soc = -EINVAL;
+	mutex_init(&chip->read_write_lock);
+	mutex_init(&chip->parallel_chg_lock);
+    mutex_init(&chip->otp_gain_lock);
+    mutex_init(&chip->fg_access_request_lock);
+	INIT_DELAYED_WORK(&chip->jeita_work, smb1360_jeita_work_fn);
+    INIT_DELAYED_WORK(&chip->delayed_init_work,smb1360_delayed_init_work_fn);
+    init_completion(&chip->fg_mem_access_granted);
+	INIT_DELAYED_WORK(&chip->one_shot_delay, smb1360_rest_at_pon_work_func);
+
+	/* probe the device to check if its actually connected */
+	rc = smb1360_read(chip, CFG_BATT_CHG_REG, &reg);
+	if (rc) {
+		pr_err("Failed to detect SMB1360, device may be absent\n");
+		return -ENODEV;
+	}
+
+	rc = read_revision(chip, &chip->revision);
+	if (rc)
+		dev_err(chip->dev, "Couldn't read revision rc = %d\n", rc);
+
+	rc = smb_parse_dt(chip);
+	if (rc < 0) {
+		dev_err(&client->dev, "Unable to parse DT nodes\n");
+		return rc;
+	}
+
+	device_init_wakeup(chip->dev, 1);
+	i2c_set_clientdata(client, chip);
+	mutex_init(&chip->irq_complete);
+	mutex_init(&chip->charging_disable_lock);
+	mutex_init(&chip->current_change_lock);
+	INIT_DELAYED_WORK(&chip->abnormal_detect, charger_abnormal_detect_work);
+	chip->default_i2c_addr = client->addr;
+	INIT_WORK(&chip->parallel_work, smb1360_parallel_work);
+
+	pr_debug("default_i2c_addr=%x\n", chip->default_i2c_addr);
+
+	rc = smb1360_hw_init(chip);
+	if (rc < 0) {
+		dev_err(&client->dev,
+			"Unable to intialize hardware rc = %d\n", rc);
+		return rc;
+	}
+
+	rc = smb1360_regulator_init(chip);
+	if  (rc) {
+		dev_err(&client->dev,
+			"Couldn't initialize smb349 ragulator rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = determine_initial_status(chip);
+	if (rc < 0) {
+		dev_err(&client->dev,
+			"Unable to determine init status rc = %d\n", rc);
+		goto fail_hw_init;
+	}
+
+	chip->batt_psy.name		= "battery";
+	chip->batt_psy.type		= POWER_SUPPLY_TYPE_BATTERY;
+	chip->batt_psy.get_property	= smb1360_battery_get_property;
+	chip->batt_psy.set_property	= smb1360_battery_set_property;
+	chip->batt_psy.properties	= smb1360_battery_properties;
+	chip->batt_psy.num_properties  = ARRAY_SIZE(smb1360_battery_properties);
+	chip->batt_psy.external_power_changed = smb1360_external_power_changed;
+	chip->batt_psy.property_is_writeable = smb1360_battery_is_writeable;
+
+	rc = power_supply_register(chip->dev, &chip->batt_psy);
+	if (rc < 0) {
+		dev_err(&client->dev,
+			"Unable to register batt_psy rc = %d\n", rc);
+		goto fail_hw_init;
+	}
+
+	/* STAT irq configuration */
+	if (client->irq) {
+		rc = devm_request_threaded_irq(&client->dev, client->irq, NULL,
+				smb1360_stat_handler, IRQF_ONESHOT,
+				"smb1360_stat_irq", chip);
+		if (rc < 0) {
+			dev_err(&client->dev,
+				"request_irq for irq=%d  failed rc = %d\n",
+				client->irq, rc);
+			goto unregister_batt_psy;
+		}
+		enable_irq_wake(client->irq);
+	}
+	wake_lock_init(&ac_charger_wakelock,WAKE_LOCK_SUSPEND,"AC_CHARGER_WAKELOCK");
+    device_create_file(&client->dev,&dev_attr_smb1360_icinfo);//wubo add create icinfo node.
+	chip->debug_root = debugfs_create_dir("smb1360", NULL);
+	if (!chip->debug_root)
+		dev_err(chip->dev, "Couldn't create debug dir\n");
+
+	if (chip->debug_root) {
+		struct dentry *ent;
+
+		ent = debugfs_create_file("config_registers", S_IFREG | S_IRUGO,
+					  chip->debug_root, chip,
+					  &cnfg_debugfs_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create cnfg debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_file("status_registers", S_IFREG | S_IRUGO,
+					  chip->debug_root, chip,
+					  &status_debugfs_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create status debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_file("irq_status", S_IFREG | S_IRUGO,
+					  chip->debug_root, chip,
+					  &irq_stat_debugfs_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create irq_stat debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_file("cmd_registers", S_IFREG | S_IRUGO,
+					  chip->debug_root, chip,
+					  &cmd_debugfs_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create cmd debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_file("fg_regs",
+				S_IFREG | S_IRUGO, chip->debug_root, chip,
+					  &fg_regs_debugfs_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create fg_scratch_pad debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_x32("address", S_IFREG | S_IWUSR | S_IRUGO,
+					  chip->debug_root,
+					  &(chip->peek_poke_address));
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create address debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_file("data", S_IFREG | S_IWUSR | S_IRUGO,
+					  chip->debug_root, chip,
+					  &poke_poke_debug_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create data debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_x32("fg_address",
+					S_IFREG | S_IWUSR | S_IRUGO,
+					chip->debug_root,
+					&(chip->fg_peek_poke_address));
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create address debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_file("fg_data",
+					S_IFREG | S_IWUSR | S_IRUGO,
+					chip->debug_root, chip,
+					&fg_poke_poke_debug_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create data debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_x32("fg_access_type",
+					S_IFREG | S_IWUSR | S_IRUGO,
+					chip->debug_root,
+					&(chip->fg_access_type));
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create data debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_x32("skip_writes",
+					  S_IFREG | S_IWUSR | S_IRUGO,
+					  chip->debug_root,
+					  &(chip->skip_writes));
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create data debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_x32("skip_reads",
+					  S_IFREG | S_IWUSR | S_IRUGO,
+					  chip->debug_root,
+					  &(chip->skip_reads));
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create data debug file rc = %d\n",
+				rc);
+
+		ent = debugfs_create_file("irq_count", S_IFREG | S_IRUGO,
+					  chip->debug_root, chip,
+					  &irq_count_debugfs_ops);
+		if (!ent)
+			dev_err(chip->dev,
+				"Couldn't create count debug file rc = %d\n",
+				rc);
+	}
+
+	smb1360_chip_global = chip;
+	//the_chip = chip; //patch add
+	//smb1360_fg_reset();//patch add
+        schedule_delayed_work(&chip->one_shot_delay,0);
+	dev_info(chip->dev, "SMB1360 revision=0x%x probe success! batt=%d usb=%d soc=%d\n",
+			chip->revision,
+			smb1360_get_prop_batt_present(chip),
+			chip->usb_present,
+			smb1360_get_prop_batt_capacity(chip));
+
+	return 0;
+
+unregister_batt_psy:
+	power_supply_unregister(&chip->batt_psy);
+fail_hw_init:
+	regulator_unregister(chip->otg_vreg.rdev);
+	return rc;
+}
+
+static int smb1360_remove(struct i2c_client *client)
+{
+	struct smb1360_chip *chip = i2c_get_clientdata(client);
+	cancel_delayed_work(&chip->abnormal_detect);//wuboadd
+	regulator_unregister(chip->otg_vreg.rdev);
+	power_supply_unregister(&chip->batt_psy);
+	mutex_destroy(&chip->charging_disable_lock);
+	mutex_destroy(&chip->current_change_lock);
+	mutex_destroy(&chip->read_write_lock);
+	mutex_destroy(&chip->irq_complete);
+    mutex_destroy(&chip->otp_gain_lock);
+    mutex_destroy(&chip->fg_access_request_lock);
+	debugfs_remove_recursive(chip->debug_root);
+
+	return 0;
+}
+
+static int smb1360_suspend(struct device *dev)
+{
+	int i, rc;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct smb1360_chip *chip = i2c_get_clientdata(client);
+	cancel_delayed_work(&chip->abnormal_detect);//wuboadd
+	/* Save the current IRQ config */
+	for (i = 0; i < 3; i++) {
+		rc = smb1360_read(chip, IRQ_CFG_REG + i,
+					&chip->irq_cfg_mask[i]);
+		if (rc)
+			pr_err("Couldn't save irq cfg regs rc=%d\n", rc);
+	}
+
+	rc = smb1360_set_batt_empty_voltage(chip,chip->suspend_voltage_empty_mv);
+	if (rc)
+	{
+		pr_err("Couldn't set batt empty voltage rc=%d\n", rc);
+	}
+
+	/* enable only important IRQs */
+	rc = smb1360_write(chip, IRQ_CFG_REG, IRQ_DCIN_UV_BIT
+						| IRQ_AICL_DONE_BIT
+						| IRQ_BAT_HOT_COLD_SOFT_BIT
+						| IRQ_BAT_HOT_COLD_HARD_BIT);
+	if (rc < 0)
+		pr_err("Couldn't set irq_cfg rc=%d\n", rc);
+
+	rc = smb1360_write(chip, IRQ2_CFG_REG, IRQ2_BATT_MISSING_BIT
+						| IRQ2_VBAT_LOW_BIT
+						| IRQ2_POWER_OK_BIT);
+	if (rc < 0)
+		pr_err("Couldn't set irq2_cfg rc=%d\n", rc);
+
+	rc = smb1360_write(chip, IRQ3_CFG_REG, IRQ3_SOC_FULL_BIT
+					| IRQ3_SOC_MIN_BIT
+					| IRQ3_SOC_EMPTY_BIT);
+	if (rc < 0)
+		pr_err("Couldn't set irq3_cfg rc=%d\n", rc);
+	
+	mutex_lock(&chip->irq_complete);
+	chip->resume_completed = false;
+	mutex_unlock(&chip->irq_complete);
+
+	return 0;
+}
+
+static int smb1360_suspend_noirq(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct smb1360_chip *chip = i2c_get_clientdata(client);
+
+	if (chip->irq_waiting) {
+		pr_err_ratelimited("Aborting suspend, an interrupt was detected while suspending\n");
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static int smb1360_resume(struct device *dev)
+{
+	int i, rc;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct smb1360_chip *chip = i2c_get_clientdata(client);
+
+	rc = smb1360_set_batt_empty_voltage(chip,chip->voltage_empty_mv);
+	if (rc)
+	{
+		pr_err("Couldn't set batt empty voltage rc=%d\n", rc);
+	}
+
+	/* Restore the IRQ config */
+	for (i = 0; i < 3; i++) {
+		rc = smb1360_write(chip, IRQ_CFG_REG + i,
+					chip->irq_cfg_mask[i]);
+		if (rc)
+			pr_err("Couldn't restore irq cfg regs rc=%d\n", rc);
+	}
+
+	first_AC_in = 1;
+	mutex_lock(&chip->irq_complete);
+	chip->resume_completed = true;
+	if (chip->irq_waiting) {
+		mutex_unlock(&chip->irq_complete);
+		smb1360_stat_handler(client->irq, chip);
+		enable_irq(client->irq);
+	} else {
+		mutex_unlock(&chip->irq_complete);
+	}
+	schedule_delayed_work(&chip->abnormal_detect,0);
+	return 0;
+}
+
+static void smb1360_shutdown(struct i2c_client *client)
+{
+	int rc;
+	struct smb1360_chip *chip = i2c_get_clientdata(client);
+
+	rc = smb1360_otg_disable(chip);
+	if (rc)
+		pr_err("Couldn't disable OTG mode rc=%d\n", rc);
+
+	if (chip->shdn_after_pwroff) {
+		rc = smb1360_poweroff(chip);
+		if (rc)
+			pr_err("Couldn't shutdown smb1360, rc = %d\n", rc);
+		pr_info("smb1360 power off\n");
+	}
+}
+
+static const struct dev_pm_ops smb1360_pm_ops = {
+	.resume		= smb1360_resume,
+	.suspend_noirq	= smb1360_suspend_noirq,
+	.suspend	= smb1360_suspend,
+};
+
+static struct of_device_id smb1360_match_table[] = {
+	{ .compatible = "qcom,smb1360-chg-fg",},
+	{ },
+};
+
+static const struct i2c_device_id smb1360_id[] = {
+	{"smb1360-chg-fg", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, smb1360_id);
+
+static struct i2c_driver smb1360_driver = {
+	.driver		= {
+		.name		= "smb1360-chg-fg",
+		.owner		= THIS_MODULE,
+		.of_match_table	= smb1360_match_table,
+		.pm		= &smb1360_pm_ops,
+	},
+	.probe		= smb1360_probe,
+	.remove		= smb1360_remove,
+	.shutdown	= smb1360_shutdown,
+	.id_table	= smb1360_id,
+};
+
+module_i2c_driver(smb1360_driver);
+
+MODULE_DESCRIPTION("SMB1360 Charger and Fuel Gauge");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("i2c:smb1360-chg-fg");
diff --git a/drivers/power/smb1360-charger-fg.c b/drivers/power/smb1360-charger-fg.c
index 7931b6df9be..30e7e4bb318 100644
--- a/drivers/power/smb1360-charger-fg.c
+++ b/drivers/power/smb1360-charger-fg.c
@@ -4915,7 +4915,7 @@ static int smb1360_probe(struct i2c_client *client,
 	INIT_DELAYED_WORK(&chip->delayed_init_work,
 			smb1360_delayed_init_work_fn);
 	init_completion(&chip->fg_mem_access_granted);
-	smb1360_wakeup_src_init(chip);
+	//smb1360_wakeup_src_init(chip);
 
 	/* probe the device to check if its actually connected */
 	rc = smb1360_read(chip, CFG_BATT_CHG_REG, &reg);
@@ -4934,6 +4934,7 @@ static int smb1360_probe(struct i2c_client *client,
 		return rc;
 	}
 
+        smb1360_wakeup_src_init(chip);
 	device_init_wakeup(chip->dev, 1);
 	i2c_set_clientdata(client, chip);
 	mutex_init(&chip->irq_complete);
diff --git a/drivers/usb/gadget/android.c b/drivers/usb/gadget/android.c
index dcc1aca82da..134a2be06fa 100644
--- a/drivers/usb/gadget/android.c
+++ b/drivers/usb/gadget/android.c
@@ -3114,7 +3114,13 @@ static ssize_t remote_wakeup_store(struct device *pdev,
 
 	return size;
 }
-
+#if defined(CONFIG_MIRAGE_ONLY) || defined(CONFIG_TESTPLUS_ONLY)
+static ssize_t adb_name_show(struct device *pdev,
+			   struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%s\n", strings_dev[STRING_SERIAL_IDX].s);
+}
+#endif
 static ssize_t
 functions_show(struct device *pdev, struct device_attribute *attr, char *buf)
 {
@@ -3451,7 +3457,9 @@ DESCRIPTOR_ATTR(bDeviceProtocol, "%d\n")
 DESCRIPTOR_STRING_ATTR(iManufacturer, manufacturer_string)
 DESCRIPTOR_STRING_ATTR(iProduct, product_string)
 DESCRIPTOR_STRING_ATTR(iSerial, serial_string)
-
+#if defined(CONFIG_MIRAGE_ONLY) || defined(CONFIG_TESTPLUS_ONLY)
+static DEVICE_ATTR(adb_display_name, S_IRUGO | S_IWUSR, adb_name_show, NULL);
+#endif
 static DEVICE_ATTR(functions, S_IRUGO | S_IWUSR, functions_show,
 						 functions_store);
 static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, enable_show, enable_store);
@@ -3478,6 +3486,9 @@ static struct device_attribute *android_usb_attributes[] = {
 	&dev_attr_iManufacturer,
 	&dev_attr_iProduct,
 	&dev_attr_iSerial,
+#if defined(CONFIG_MIRAGE_ONLY) || defined(CONFIG_TESTPLUS_ONLY)
+	&dev_attr_adb_display_name,
+#endif
 	&dev_attr_functions,
 	&dev_attr_enable,
 	&dev_attr_pm_qos,
@@ -3840,6 +3851,8 @@ static int android_probe(struct platform_device *pdev)
 	struct android_usb_platform_data *pdata;
 	struct android_dev *android_dev;
 	struct resource *res;
+	const char *adb_name;
+
 	int ret = 0, i, len = 0, prop_len = 0;
 	u32 usb_core_id = 0;
 
@@ -3901,6 +3914,8 @@ static int android_probe(struct platform_device *pdev)
 		ret = of_property_read_u8(pdev->dev.of_node,
 				"qcom,android-usb-uicc-nluns",
 				&pdata->uicc_nluns);
+
+		ret = of_property_read_string(pdev->dev.of_node, "adb_diaplay_name", &adb_name);
 	} else {
 		pdata = pdev->dev.platform_data;
 	}
diff --git a/drivers/usb/phy/phy-msm-usb.c b/drivers/usb/phy/phy-msm-usb.c
index 0e41b21995c..490391f19c3 100644
--- a/drivers/usb/phy/phy-msm-usb.c
+++ b/drivers/usb/phy/phy-msm-usb.c
@@ -11,6 +11,8 @@
  *
  */
 
+//#define DEBUG 1
+
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/platform_device.h>
@@ -52,6 +54,12 @@
 
 #include <linux/msm-bus.h>
 
+extern void setAcInstat(void);//wuboadd
+extern void acquire_AC_charger_wakelock(void);
+extern void set_android_charging_enable(void);
+extern void smb1360_set_usb_current_call(int current_limit_enable);
+extern int first_mic;
+
 #define MSM_USB_BASE	(motg->regs)
 #define MSM_USB_PHY_CSR_BASE (motg->phy_csr_regs)
 
@@ -1879,6 +1887,20 @@ static int msm_otg_notify_chg_type(struct msm_otg *motg)
 		return -EINVAL;
 	}
 
+	//wuboadd start
+    if(charger_type == POWER_SUPPLY_TYPE_USB_DCP){
+		set_android_charging_enable();
+		setAcInstat();
+		if (1 == first_mic) {
+			smb1360_set_usb_current_call(1);
+		}
+		acquire_AC_charger_wakelock();
+    }
+	if(charger_type == POWER_SUPPLY_TYPE_USB){
+		set_android_charging_enable();	
+	}
+	//wuboadd end
+
 	pr_debug("setting usb power supply type %d\n", charger_type);
 	msm_otg_dbg_log_event(&motg->phy, "SET USB PWR SUPPLY TYPE",
 			motg->chg_type, charger_type);
@@ -3282,9 +3304,6 @@ static void msm_otg_sm_work(struct work_struct *w)
 				case USB_PROPRIETARY_CHARGER:
 					msm_otg_notify_charger(motg,
 							IDEV_CHG_MAX);
-					otg->phy->state =
-						OTG_STATE_B_CHARGER;
-					work = 0;
 					msm_otg_dbg_log_event(&motg->phy,
 					"PM RUNTIME: PROPCHG PUT",
 					get_pm_runtime_counter(otg->phy->dev),
@@ -3294,9 +3313,6 @@ static void msm_otg_sm_work(struct work_struct *w)
 				case USB_FLOATED_CHARGER:
 					msm_otg_notify_charger(motg,
 							IDEV_CHG_MAX);
-					otg->phy->state =
-						OTG_STATE_B_CHARGER;
-					work = 0;
 					msm_otg_dbg_log_event(&motg->phy,
 					"PM RUNTIME: FLCHG PUT",
 					get_pm_runtime_counter(otg->phy->dev),
@@ -3514,16 +3530,6 @@ static void msm_otg_sm_work(struct work_struct *w)
 			msm_otg_notify_charger(motg, IDEV_ACA_CHG_MAX);
 		}
 		break;
-	case OTG_STATE_B_CHARGER:
-		if (test_bit(B_SESS_VLD, &motg->inputs)) {
-			pr_debug("BSV set again\n");
-			msm_otg_dbg_log_event(&motg->phy, "BSV SET AGAIN",
-					motg->inputs, otg->phy->state);
-		} else if (!test_bit(B_SESS_VLD, &motg->inputs)) {
-			otg->phy->state = OTG_STATE_B_IDLE;
-			work = 1;
-		}
-		break;
 	case OTG_STATE_B_WAIT_ACON:
 		if (!test_bit(ID, &motg->inputs) ||
 				test_bit(ID_A, &motg->inputs) ||
diff --git a/drivers/video/msm/mdss/mdss_dsi.c b/drivers/video/msm/mdss/mdss_dsi.c
index 62c6f120b24..b6f990a55ca 100644
--- a/drivers/video/msm/mdss/mdss_dsi.c
+++ b/drivers/video/msm/mdss/mdss_dsi.c
@@ -1455,6 +1455,41 @@ static struct device_node *mdss_dsi_find_panel_of_node(
 	return dsi_pan_node;
 }
 
+static const char *buf_lcd_info;
+static struct class *lcd_class;
+
+static ssize_t lcd_info_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	if (buf_lcd_info)
+		return snprintf(buf, strlen(buf_lcd_info) + 2, "%s\n", buf_lcd_info);
+
+	return 0;
+}
+
+static CLASS_ATTR(lcd_info, S_IRUSR, lcd_info_show, NULL);
+
+static int create_lcd_info(struct platform_device *pdev, struct device_node *node)
+{
+	int rc = 0;
+
+	lcd_class = class_create(THIS_MODULE, "lcd");
+	if (IS_ERR_OR_NULL(lcd_class))
+		return PTR_ERR(lcd_class);
+
+	rc = class_create_file(lcd_class, &class_attr_lcd_info);
+	if (rc < 0) {
+		pr_err("%s: class_crate_file error!\n", __func__);
+		class_destroy(lcd_class);
+		return rc;
+	}
+
+	if (node)
+		buf_lcd_info = of_get_property(node, "qcom,mdss-dsi-panel-name", NULL);
+
+	return rc;
+}
+
 static int mdss_dsi_ctrl_probe(struct platform_device *pdev)
 {
 	int rc = 0, i = 0;
@@ -1604,6 +1639,11 @@ static int mdss_dsi_ctrl_probe(struct platform_device *pdev)
 		}
 		disable_irq(gpio_to_irq(ctrl_pdata->disp_te_gpio));
 	}
+
+	rc = create_lcd_info(pdev, dsi_pan_node);
+	if (rc < 0)
+		pr_err("%s create lcd info error!\n", __func__);
+
 	pr_debug("%s: Dsi Ctrl->%d initialized\n", __func__, index);
 	return 0;
 
diff --git a/drivers/video/msm/mdss/mdss_dsi_panel.c b/drivers/video/msm/mdss/mdss_dsi_panel.c
index b1687692357..d1d9ab45f99 100644
--- a/drivers/video/msm/mdss/mdss_dsi_panel.c
+++ b/drivers/video/msm/mdss/mdss_dsi_panel.c
@@ -37,6 +37,8 @@
 
 DEFINE_LED_TRIGGER(bl_led_trigger);
 
+static int flag = 0;
+
 void mdss_dsi_panel_pwm_cfg(struct mdss_dsi_ctrl_pdata *ctrl)
 {
 	if (ctrl->pwm_pmi)
@@ -187,6 +189,7 @@ static void mdss_dsi_panel_bklt_dcs(struct mdss_dsi_ctrl_pdata *ctrl, int level)
 	struct dcs_cmd_req cmdreq;
 	struct mdss_panel_info *pinfo;
 
+	if (flag != 0) {
 	pinfo = &(ctrl->panel_data.panel_info);
 	if (pinfo->dcs_cmd_by_left) {
 		if (ctrl->ndx != DSI_CTRL_LEFT)
@@ -205,6 +208,11 @@ static void mdss_dsi_panel_bklt_dcs(struct mdss_dsi_ctrl_pdata *ctrl, int level)
 	cmdreq.cb = NULL;
 
 	mdss_dsi_cmdlist_put(ctrl, &cmdreq);
+	}
+	else {
+
+		flag = 1;
+	}
 }
 
 static int mdss_dsi_request_gpios(struct mdss_dsi_ctrl_pdata *ctrl_pdata)
diff --git a/firmware/Makefile b/firmware/Makefile
index cbb09ce9730..aa05a54d822 100644
--- a/firmware/Makefile
+++ b/firmware/Makefile
@@ -136,6 +136,9 @@ fw-shipped-$(CONFIG_USB_VICAM) += vicam/firmware.fw
 fw-shipped-$(CONFIG_VIDEO_CPIA2) += cpia2/stv0672_vp4.bin
 fw-shipped-$(CONFIG_YAM) += yam/1200.bin yam/9600.bin
 
+fw-shipped-$(CONFIG_TEST_ONLY) += melfas/test_melfas_mip4.bin
+fw-shipped-$(CONFIG_TESTPLUS_ONLY) += melfas/testplus_melfas_mip4.bin
+
 fw-shipped-all := $(fw-shipped-y) $(fw-shipped-m) $(fw-shipped-)
 
 # Directories which we _might_ need to create, so we have a rule for them.
diff --git a/firmware/melfas/test_melfas_mip4.bin.ihex b/firmware/melfas/test_melfas_mip4.bin.ihex
new file mode 100755
index 00000000000..c07fecf1aca
--- /dev/null
+++ b/firmware/melfas/test_melfas_mip4.bin.ihex
@@ -0,0 +1,3079 @@
+:100000004D424E014D34485066010400010000008D
+:100010006000000000C000000000000000000000C0
+:100020000000380100000000000000000004000093
+:100030000100660101002600000400000098000095
+:100040000200090127002B00009C000000140000A2
+:10005000030009012C002F0000B000000010000078
+:100060000038002035020000000000000000000001
+:100070000000000000000000000000000000000080
+:100080000000000000000000000000000000000070
+:10009000000000000000000000000000550000000B
+:1000A0005700000051010000790000008D000000A1
+:1000B00000000000FEE708B5044B01221A70044B53
+:1000C0000022DA77034B1B68984708BD0000002028
+:1000D0000800005034000020034B01225A70A02376
+:1000E0000022DB051A70704700000020034B01223C
+:1000F0009A70A0230022DB059A7070470000002050
+:100100008D23013B002B01D0C046FAE7044B10229F
+:100110001B78DBB21807C00F134018437047C04666
+:100120002B0000500F4BF7B518261E700E4BA02762
+:100130001E70FFF7E5FFFF050B4B01AC00252C37C8
+:1001400060701D703E70FFF7DBFF064B20703D7046
+:100150001D7023786278181C504040001340034300
+:10016000D8B2FEBD2A0000502D00005000230360CD
+:1001700030B50B601312012B13D10423013B10D3B4
+:10018000084DD4B25D5D641BF8D4074A9D00126827
+:10019000AA58002A05D012190260044AD35C1C1B1D
+:1001A0000C6030BDE0030000DC030000E40300004D
+:1001B00070B58022D2051379DBB2002B19D12B4CFC
+:1001C0006360A3602A4B1289261C251C1B6892B20F
+:1001D00010361435E260301C291C002B06D09847DD
+:1001E0002169002937D1E268301C291CFFF7BEFFC6
+:1001F00031E0012B0CD11D4B186900282BD09968D8
+:100200005C69A14227DA4C1C9C60137A435422E0BB
+:10021000022B1BD1154C2369002B12D06068616939
+:1002200088420EDA1B5C1BBAD360124B1B68002B92
+:1002300003D0E268101880B29847636801336360A6
+:1002400009E080230022DB05DA6004E0032B02D101
+:10025000064B00229A60C0468023DB0501221A70FB
+:10026000C04602221A7000221A7070BD00000020E1
+:100270003C0000203800002080230222DB05FF32F2
+:100280001A600421024AFF31118000221A7070475F
+:1002900006000040F0B5A023DB059B68534A1F21F0
+:1002A0008DB0DBB21160D12B0BD0D02B01D8013334
+:1002B000DBB2A022D2059168FF20814319439160EF
+:1002C000F1E74B4B4B4A191D043B934203D20022EA
+:1002D0001A600B1CF6E7FFF7CFFF474A8023DB02CB
+:1002E0001A80464A0027093A92B25A809F80C04637
+:1002F000434ADE88434D10685268434C0A922A886C
+:1003000009ABB6B21A8123625E810990FFF70AFF3A
+:10031000A023DB05DA7C03AB1A7034214D225A701E
+:1003200099705A7148214522D9709A7150219C22A6
+:100330001971D8716362520005AB0597A3611A80E9
+:1003400007AB01220797E3615A70304B0697DA89B1
+:100350002F4B08975F882F4B211C1B8828310B706F
+:10036000211C1B0A29310B702B4901235B420B70A6
+:100370002A482B4903700B702A48211C2E312F3438
+:1003800003700B7023702B889E4229D1264B9A4212
+:1003900026D0BA4224D1254EF7899F4220D0F68933
+:1003A000B446234E7788BC451AD1224FF88998422B
+:1003B00016D0FF89EB889F4212D1174B17481A704D
+:1003C000120A73880270164A9BB2164813701B0AF1
+:1003D0000370EB889BB20B701B0A237000F048F887
+:1003E000154B02221A6062B6FEE7C0462800005094
+:1003F00004000020400000200004000000C00000B5
+:10040000F0BF0000F8BF0000000000200004000062
+:10041000FC9B0000FE0300002A0000202B000020AF
+:100420002C0000202D000020FFFF0000009C000099
+:10043000FCAF000000B0000000E100E01800002068
+:100440002030407008080C08FFFFFFFFFFFFFFFF90
+:10045000FFFFFFFFFFFFFFFFFFFFFFFFFFFF380171
+:100460004D344850434F54320000000000006601F4
+:10047000F0B5B7B002AF03F0FAFB05F09FF8B86132
+:1004800008F0DEF808F00CF909F0F2FB00F032FB9E
+:10049000B34AB44B1A60B44AB44B1A60B44AB54B71
+:1004A0001A6005F08BF8041E052C00D128E1052800
+:1004B00014D8022800D1E0E006D8002822D0012874
+:1004C00000D1CDE0BC61ECE7032800D10AE10428AB
+:1004D000F8D105F0F9F802F057F90CE1092800D13C
+:1004E0002BE107D8072800D113E10828EAD105F04D
+:1004F000EBF818E10A2800D148E10B28E2D105F019
+:10050000E3F807E205F070F80028DBD10125012DA2
+:1005100002D0022D0AD095E0002001F01FFE02F06B
+:10052000DDFFC0B205F09EF901F0FEFD924B6D4675
+:100530001B683D6158681E681B694643F3189B00A1
+:100540000A33DB08DB00E91A8D4602ADFD613D1C74
+:100550009435281C0021142208F0F4F93A1CBC320E
+:10056000BA64143AFA64283A3D657A65834D143AC0
+:10057000FA63143A3A642A680020FF3250728048C5
+:100580003B1C0268443353617E4BF8691B68391C7D
+:10059000B600861938311060916156602D331A7893
+:1005A00069465200131C0833DB08DB00C91A8D466C
+:1005B00002AB181C00217B6108F0C4F905F004FAB5
+:1005C000FA694178331C002000F07CFCB8690028EF
+:1005D00001D005F079F82B680021996005F03CF90D
+:1005E000051C02F07BFFA84204D0281C02F07BFF10
+:1005F00002251DE07D693A1C00953B1C311C4432EC
+:100600003833F86901F01AFA5C4B5F4A1B68051C25
+:100610009968914202D09A6801329A60002807D105
+:1006200004F0E2FF002803D104F0C8FF0028D5D071
+:100630005348002302681360536053619361396922
+:10064000BB618D4604F0D0FF002803D0002000F0ED
+:1006500093FE37E704F0B2FF002800D157E7F5E733
+:1006600005F032F804F0AAFF0128FBD007F0C4FF20
+:1006700000F040FA04F0A6FD24E700F051FE404BE4
+:100680001B68586900F078FE04F0DEFE002003F0DD
+:10069000E1F903F045F900F047F901F045FD05F0F7
+:1006A00013F805F02BF803280DD004D801280AD040
+:1006B000022808D00FE005280BD007D306280AD15E
+:1006C00002F0DCFC07E002F097F804E004F0A4FB81
+:1006D00001E002F0C1FC04F071FF0228E1D000F05B
+:1006E00031FEEFE604F0F0FF01F01EFD04F066FFBE
+:1006F0000328FBD0E6E604F061FF0428FBD0E1E626
+:1007000004F0E2FF03F0E8FA04F058FF0528FBD0FC
+:10071000D8E604F0D9FF012001F020FD04F04EFFDF
+:100720000728FBD0CEE6002003F0BEF803F0A0F9C6
+:1007300004F044FF0828F6D0C4E604F0C5FF00200A
+:1007400002F095FB002003F0AFF803F091F904F0FC
+:1007500035FF0928F6D0012002F089FBB2E6C04639
+:10076000295800003C000020A55800003800002057
+:10077000E114000034000020340300204000002079
+:1007800044000020880D0020FFFFFF7F6D46002001
+:100790003D6107F0BBFF07F083FF002003F05AF92B
+:1007A0005F4D69462B685E6818681B694643F318FD
+:1007B0000733DB08DB00C91A8D4602AAFA6102F092
+:1007C000CFFA02F0E5FA02F0D7FAFB699E19181C7D
+:1007D000311C7E6103F032FB2B686D465A681B6941
+:1007E000D3189B000A33DB08DB00ED1AAD4602ADDF
+:1007F000BD6104F069FF4A4D20202B6819681A7901
+:10080000C15521202221C255CA555A1DD27F1B69CC
+:1008100023202421C255CB5525220123D355FB6922
+:100820000022391C00930420131C203104F092FF95
+:100830007969F86904F010FA002003F035F82B68A4
+:1008400038485D6806687D60002139603A687D68D7
+:10085000AA4208DA3A68B16992008958BD69A9507C
+:1008600039680131F1E7AA00BD691969AD18066858
+:100870003960AC4600223868824206DA316A90005C
+:100880000958654629500132F5E71A682821CA55EA
+:1008900078689A6829252A21E855CA550533DB7FEF
+:1008A0002B25EB5504252D233968DD551D4B0132D1
+:1008B0001B6892005B692C209A18C1550092391C64
+:1008C0000022131C0220283104F044FF01233020B1
+:1008D000C355134B31211B6832201A79CA55C255B2
+:1008E0005A1DD27F1B693321CA553422D355352373
+:1008F000DD55BD690022391C05203031131C0095DF
+:1009000004F028FF04F05AFE0A2800D173E73D697D
+:10091000AD46D7E504F052FE0B28FBD0D2E5C04629
+:100920003403002040000020F8B5184D7146281C03
+:10093000764603F0E7FA164C276802F063FE786209
+:10094000276802F063FEB862276802F063FE7861F0
+:10095000276802F063FEF861276802F0B1FEB86113
+:10096000276802F0C3FE0B4B0B491B68096838620D
+:100970001878097C2268414302331161FC32281C3B
+:10098000311C536003F0D6FAF8BDC046C908000018
+:1009900040000020D00E0020880D0020014B186080
+:1009A0007047C046880D0020014B18687047C0464C
+:1009B000880D0020014B18607047C046D00E002003
+:1009C000014B18687047C046D00E0020014B1868D4
+:1009D0007047C04640000020014B58687047C04631
+:1009E0004000002082B0F0B589B0109C151C0F9318
+:1009F0000693029407900E1C119C02F0B1F94779FE
+:100A00003A4B04978279964206D11B680021DA6935
+:100A1000AB00D05A03910BE01A68354B5269196844
+:100A2000731C896803964B43EB1801339B00D05A23
+:100A30000499714349194A00A4182388069E01931A
+:100A4000019F7318874203D8C61B029FBE521CE049
+:100A5000029EB61805960027F65F013610D01F7863
+:100A60007EB2B446013601DA013703E06646002E55
+:100A700006DD013F1F7002235B42238001202FE02F
+:100A8000069F79180F78002F01D120800CE07FB2EB
+:100A90007C1C05D1019E059F301A3880002002E0A1
+:100AA000012F01D1FF2008701978039C049E079F35
+:100AB00048B274437D19002805DC029EB25E013203
+:100AC00008D0002906D12A5700203E2A08DC01312F
+:100AD000197005E02A57002A01DD0139197000203C
+:100AE00009B0F0BC08BC02B01847C0464000002066
+:100AF0003403002037B5114C7146201C754603F0B5
+:100B000001FA05F083FC02F043FF021E07D169469B
+:100B1000A923888000900B7104F056FEFEE7084B75
+:100B20001B6803CB02F0B0F905F088FCFFF7FCFE70
+:100B3000291C201C03F0FEF937BDC046950A0000B1
+:100B40003403002038B5144C7146201C754603F060
+:100B5000D9F9124B00221B68191CA0310A60181C1D
+:100B60000121B43049420160826008380260C182CC
+:100B70004283103802604161C2610C300183191C4C
+:100B8000C431026098330A8020390A60201C291C75
+:100B90001A6003F0CFF938BDE50A000040000020DC
+:100BA000F0B5754685B00395294D01900F1C281CA2
+:100BB000714603F0A7F9274B00211B680198DA69F9
+:100BC000920007F0BFFE04F0FFFE02904478214D32
+:100BD000002C21D0042002F067FE28684269561ECE
+:100BE000009617D383690099019E5943C91889005B
+:100BF00071180439013B0BD3866856439E190136A0
+:100C0000B600F5590E68AC46B44465460D60F0E791
+:100C1000009AE4E7013CDAE72F687D69013D11D3D2
+:100C2000BC69019A261C6E433619B6009619043E1B
+:100C3000013CF3D3029B3068597807F073FD000440
+:100C40003060F4E70248039903F074F905B0F0BD91
+:100C5000410B00003403002038B5054C7546714641
+:100C6000201C03F04FF9291C201C03F063F938BD48
+:100C7000F90B0000F0B52F4F73468BB07146381C4E
+:100C8000019303F03FF92C4D2B681A1CE4321178C4
+:100C9000603A002904D1191CC8310978002901D013
+:100CA000002111701478002C26D01A1C883212688A
+:100CB00003A907925A6B00240892DB6A07AA0993DA
+:100CC00003234B708B707C235B42CB700126102377
+:100CD000201C8C800E700B7104F076FD29680B1CB3
+:100CE00088338C311A6809688A4202DC92191A60CA
+:100CF00019E01C60341C16E05A6B05A90792DB6AE8
+:100D00000920089301230B7002234B708B707C2306
+:100D10005B42CB7007AA64238C800B7104F054FDF6
+:100D20002B6888331C60381C019903F003F9201CE0
+:100D30000BB0F0BD150C000040000020F0B587B0EE
+:100D400000AF7546786039615C487146FD6003F01C
+:100D5000D9F803F01DF883000A33DB08DB006E4688
+:100D6000F61AB546041C684603F01AF86300083307
+:100D7000DB08DB00F61A6D46301CB546BE6003F09A
+:100D80002BF84F4B1B68191CA0310A68632A07DD3A
+:100D90000120002240420A604861CA6108390A60A5
+:100DA0001A1CA032116801311160191C9C310E68A7
+:100DB000632E09DD002201200A60CA6140421A1C2C
+:100DC00048619832012111601A1C9C32116801316E
+:100DD0001160191CAC310A68012A07DD01200022CC
+:100DE00040420A60C8824A8308390A601A1CAC3241
+:100DF000116801311160191CA8310E68012E09DD3E
+:100E0000002201200A608A8340421A1C0883A4320F
+:100E1000012111601A1CA8321168013111600022F1
+:100E2000101C013C08D3A1006958BE68401861003D
+:100E3000715A521892B2F4E7191CC2310024BC2630
+:100E40001D19B446AC447D6165462D68854201D2CA
+:100E5000664630607E69B4363568854200D93060B8
+:100E60008E88964200D28A800E88964200D90A80E7
+:100E7000043C261C02390836E1D11A1C983212684B
+:100E80007D6892009A18111CB831B0320968126856
+:100E90003E698A1A2A801A1CA43212680748520036
+:100EA0009B181A1CC432C03312881B88F968D31AE5
+:100EB000338003F03FF8BD4607B0F0BDDD0C000005
+:100EC00040000020F0B5284E85B075460191041C05
+:100ED0007146301C1F1C0395009203F013F8234D3C
+:100EE00000212B680098DA68920007F02BFD2B6830
+:100EF000381C1A690021920007F024FD019D002D85
+:100F00000CD0201C02F0D0FC194B00981B68391C37
+:100F10005A69DB6905F03AFA013DF0E7002C0FD180
+:100F2000134B1B685D699E69029502F05AFB051C14
+:100F300002F060FB311C031C2A1C029804F05CFDCB
+:100F40000098391C019A04F049FF002C06D1084B87
+:100F5000201C1D6802F05CFEFC35A8600248039965
+:100F600002F0E8FF05B0F0BD650E0000340300207C
+:100F700040000020F0B595B004AF75467861396146
+:100F8000A5487146FA61BB61FD6002F0BBFF04F049
+:100F90001BFDA24B6C461B68BC601C687862043465
+:100FA0006400221C0832D2086846D200851A5A68AA
+:100FB000AD4604325200131C0833DB08DB006846E0
+:100FC000C01A04AD854604AE301C00213D6207F016
+:100FD000B9FC221C0021386A07F0B4FC904C7D69F2
+:100FE00023685A69191C9B690095386A2C310430B2
+:100FF0000190301D0290F86904F092FF2368894D3A
+:10100000191C78313960796A78602A68097B5869D7
+:1010100092680091396A029601912C33396807F081
+:10102000AFF8BA68236838699546191CDA691B6AF3
+:1010300000902C31B86905F00DF97E6821680643EF
+:10104000F6B22C31F8693E6204F052FD04F0CEFC99
+:101050000679012E0BD12B685B691B78002B06D11A
+:1010600004F0C2FA012802D0301C02F02AF82568E8
+:10107000281C291C78312C3004F018FF6A4A236898
+:101080001268E8670C24115F9D6E8D420EDC0E2005
+:10109000115EDC6E8C4209DB1025515F186F8842AF
+:1010A00004DC1221525E5B6F934221DA00233B87FE
+:1010B00038220123D35504F0B3FA002818D104F0E4
+:1010C00013F9002814D0564B1A68FF239168FE29A3
+:1010D00001DC9368DBB2381C022139243830E35537
+:1010E00004F0F8F9514802F061FF01F0EBFEE2E78D
+:1010F0004A4E2921336828255A681868CA559A68C3
+:101100002A23DA558023E8555B4202252B432B2006
+:101110000024C3552C215323BC850132CB55FB69D8
+:101120005200391C9A180120283104F04DFB326816
+:101130000121137C3020C15531203221C355CB55BC
+:1011400080235B422B433322D35534206D23391C3B
+:10115000BC863031C355BA69012004F035FB3368D1
+:1011600038211A683920CA555968C1559A683A20F9
+:10117000C255591DC97F3B20C1551B693D203C21EB
+:10118000CB55C35D7F218B43802149422B430B43C9
+:101190000132F96952008A18391CC35538310120CF
+:1011A000231C0092221C04F0D5FAFFF755FDFFF72F
+:1011B00061FDA04227D11A4C2368586902F0A2FCB5
+:1011C0002368D86F02F098FB02F064F93D6A002DA5
+:1011D0000DD12368F9691A1C2C321B68786904F058
+:1011E00013FD236838691A68B96904F067FD0220A5
+:1011F00001F094FFB86905F0E9F920680024803017
+:1012000006F08AFD00E02C1C0348F96802F092FE0B
+:10121000201CBD4611B0F0BD150F000034030020A6
+:101220004000002044000020D00E002010270000C5
+:10123000F0B585B002AF7446051C3C607960141CA3
+:101240007146144802F05EFEA200131C0A33DB084C
+:10125000DB006946C91A8D4602AC201C002107F04C
+:1012600071FB0D4E281C3268516A936A78320092E5
+:10127000221C06F073FD33687A68596A281C9B6A41
+:101280000092221C06F02EF93968024802F052FE44
+:10129000BD46F7BDD111000040000020F7B51E4F3C
+:1012A00075460C1C161C7146019500901D1C381CBF
+:1012B00002F028FE211C2B1C321C009806F042FB79
+:1012C000201C05F0DBFB154B201C1B68596A9A6A31
+:1012D00006F04EFC201C05F001FB2A1C201C311CD2
+:1012E00005F0A2F904F082FB051C05F0A1F8963088
+:1012F00003783C1C002B09D12B79002B06D004F07D
+:1013000073F9012802D0012001F0DBFE201C0199B5
+:1013100002F010FEF7BDC0463D1200004000002064
+:1013200038B5074C7146201C754602F0EBFD07F0FE
+:1013300033F901F01BFD291C201C02F0FBFD38BD18
+:10134000C112000038B50B4C7146201C754602F0E6
+:10135000D9FD07F0E1F907F027F901F007FD0020BA
+:1013600002F078FB01F08AFE291C201C02F0E2FD4D
+:1013700038BDC046E5120000F0B5C5B000AF7346F9
+:101380007146041C38487B603E1C02F0BBFD381CD3
+:101390002C360021142240303D1C07F0D3FAE835EA
+:1013A000301C0021142207F0CDFA00212822281C2D
+:1013B00007F0C8FA381C0A220C30002107F0C2FAE4
+:1013C0003B1C6833D022D351143BD422D351402349
+:1013D000DB19D822D351DC23DE51E0220C23D55176
+:1013E000DB19E422D351204E002C2AD16A46583D05
+:1013F0003A60281C211C142207F0A4FA3B1CB833C5
+:10140000FB61143B3B62283BBB62184B7D621B684F
+:101410001B6A5B00023B9A1C02D0FF22EA52F9E7EA
+:10142000381C391CCC30183105F048F905F078F932
+:10143000381C391CCC30183105F0E0FB3B689D4668
+:101440000BE0381CCC30211C05F038F905F068F9A8
+:10145000381CCC30211C05F0D1FB301C796802F01F
+:1014600069FDBD4645B0F0BD1913000034030020EE
+:10147000F7B5304E7146301C754602F043FD04F05E
+:10148000D7FF2D4C9630236801781A79002902D1B4
+:1014900051B2481C04D10027DF60BA420DD118E0D8
+:1014A000D8681A69904202DAD8680130D8600129F8
+:1014B0000FD0DB6893420CDB012700223B1C6946FE
+:1014C0000E33101C8A8000920B7104F07DF92368A2
+:1014D0001F7123681A79002A03D1184A12681278FA
+:1014E00004E0012A03D1154A126852781A6018687C
+:1014F00002F038FD2368071CFC33986802F056FDA3
+:101500003F1A002F0BDD2368186802F02BFD2368BB
+:10151000071CFC33986802F049FD381A00E00120EE
+:1015200001F0CFFD01F0EEFD301C291C02F002FDA0
+:10153000F7BDC0461114000040000020D00E00206E
+:1015400038B5094C7146201C754602F0DBFC04F0EE
+:101550004BF8002802D1022002F07EF9291C201C41
+:1015600002F0E8FC38BDC046E1140000F0B5734657
+:1015700091B0041C0E1CAF487146059302F0C2FCEA
+:1015800004F034FA049004F053FF2278AA4B002AA6
+:1015900008D172300278511E8A41D2B20292002ADA
+:1015A00006D001E0012002901A680021D03205E047
+:1015B0001A68D0321168FE2901DC013111601B6804
+:1015C00000211A1CCC3211700299002904D09B49C9
+:1015D0000968097D00295FD0181CCB300178C9B299
+:1015E000002908D003785BB2022B00D001231370CE
+:1015F0000023037084E11D1CC8352C78002C09D011
+:10160000012414701A1CC932D4330170297011706E
+:10161000196076E1029800283ED1191CD4310C687B
+:10162000002C09DD013C012C01D00C6034E0029B50
+:101630000B600323137064E11A1CFC32526811889A
+:101640007F4A914228D01A1CE03211887D4A1268E4
+:1016500052888A4220D8794C2068427C181CD030AD
+:101660000068904218DB0EAA1180E2331B8806A99D
+:101670005380029B02988B8001230B7002234B70D6
+:101680008B70CB7015230B7104F09EF86A4B2268A7
+:101690001B68927CD4331A60684C2768F87C002859
+:1016A00000D02DE10299644D002900D08AE02C6819
+:1016B000231CFF331B78002B5CD03B1C2C331B7886
+:1016C000002B57D0231C0E91F4331B680393231C6B
+:1016D000E03303981A8843009A533B1C2D33197842
+:1016E00002984B00F618031C994206D05A00B21A11
+:1016F000023A128801338018F6E707F061F80E907D
+:10170000FA8B231CF833904202DA1A68013200E0A7
+:1017100000221A603B1C221C2E33F8321B78126800
+:101720009A4219DD7C2308A900265B420124CB7074
+:10173000301C16230EAA8E800C700B714C708C70AE
+:1017400004F042F82B68301C1A1CF432F83316608F
+:101750001E6004F07BF8D4E03B1C2D331A7803990B
+:10176000231C013AF433914202DA0A1C013200E0F0
+:1017700000221A60DC340137FB7F22689A4219DBB1
+:1017800000240AA91223201C221C8C800A940B71AD
+:1017900004F01AF82A682948131CD833196800681D
+:1017A000013119600230C07F814203DB1C60CC3202
+:1017B000022313702A680023111CCA31DC320B701B
+:1017C000136049E02B681A1CD43210602A32127858
+:1017D000002A41D0191CE03109880EAA1180E23399
+:1017E0001B880CA9538001230B7002234B708B7054
+:1017F000CB70192388800B7103F0E6FF2B682268F9
+:10180000191CE0310C88D08B163984421CD2181C6C
+:10181000E2300488508D844216D2097800291BD109
+:10182000DC3301321968D27F914215DA0131196037
+:1018300012E0C0460D15000040000020880D002079
+:10184000FFFF0000D00E002001220A70191C0022A8
+:10185000DC31D8330A601A602D4D2B681A1CFE3219
+:101860001278002A4CD104980279002A46D01A1C1A
+:10187000C8321478002C43D1264ED86A3768798B49
+:10188000BA8BFB8A3F8B009704F058F836682B68B8
+:10189000718CB28C071CD86AF38C368D009604F0DC
+:1018A0004DF82B681A1CE0321188E233B94202DA93
+:1018B0001A88824214DB08AA11801B880EA9538063
+:1018C0000223002001254B708B70CB70172388807A
+:1018D0000D700B7103F078FF0D4B1B68C9331D7041
+:1018E0000B4B1B681A1CC9321278002A08D00299C7
+:1018F000002905D0C83301221A7002E0C9331A70DA
+:1019000001240548059902F015FB201C11B0F0BD1B
+:1019100040000020880D00200D150000F7B5754629
+:101920000195424D7146041C281C02F0EBFA404E12
+:1019300033681A1CC9321278002A24D01A1CFE32CD
+:101940001278002A1FD11A1CE432117800291AD10A
+:10195000C8331B78002B16D10123137001F00CFA49
+:10196000071C01F0FDF9334A031C12685D3303CAFA
+:101970003A1C9B3204F0E4F901F062FF022001F00E
+:101980006BFFFFF7DFF833681A1CE4321278002A85
+:1019900045D01A1C0020C8321070274A00901768E2
+:1019A000011C3A6A013A0BD3E5685600755B002DBD
+:1019B000F8D02EB20131B042F4DA301C0092F1E7D7
+:1019C0001A1CFE321278002A0ED101290CDD0122E8
+:1019D00022703A6A013A09D300998A42FAD0E5683E
+:1019E000510000204853F5E7002903D01A1C0021BC
+:1019F000EC3208E01A1C181CEC32E8301168006860
+:101A0000814201DC013111601A1CEC321168043A88
+:101A10001268914205DDC83301221A7001E0EC33EF
+:101A20001A600248019902F085FAF7BDBD1800005E
+:101A3000400000204400002034030020F0B5C1B075
+:101A400002AF7546F861B961D94871467D603A6266
+:101A5000BB6002F057FAD74E6C4632683C6113689F
+:101A600092689D1C520055430133291C5208534370
+:101A70000831C908C900601A8546013302AC5B0011
+:101A8000FC62E318CC4CBB622368FC6A00219C60BA
+:101A9000BC6A4C22DC60C94C20682C3006F052FF36
+:101AA0002A1C0021F86A06F04DFFA62300203821E9
+:101AB00000253887CB55391C2A1C281C34317D63FE
+:101AC00003F082FEFFF7D4FC21683C25081CE030BF
+:101AD000E231FFF733F9316800234022D35301206C
+:101AE0000B79E8553D223E25D355EB5540225B232B
+:101AF000D355042123683F20C155391C9A6902201F
+:101B00003C3103F061FE326800254823DD5301219A
+:101B1000137C4420C15545254620EB55C355482527
+:101B20006C23EB55042223684721CA55391C1A6AD5
+:101B30000220443103F048FE23683D1C1A1CE032A9
+:101B40001288DC352A80E2331B88391C4C31012293
+:101B5000002088800A700A716B800C2002232A1CE6
+:101B60004B708B70CB7003F02FFE3368391C5A68B2
+:101B7000186854314A709A680870581D1B698A7039
+:101B8000C07F0B7104234B71236801325B699200A3
+:101B90009A18C87000920022131C022003F0DAFD8C
+:101BA000F869B969FA6ABB6AFFF7E4F9F8620028D4
+:101BB00003D0386AFFF7E0FBCEE0684692B002AC93
+:101BC00092B0BC6202AC8AB0FC6102AC90B002AED2
+:101BD0008AB0BC6102AC88B0F8607C62F96A02AC81
+:101BE0004022B86A7C6106F0ADFEF96A4022F869CD
+:101BF00006F0A8FEF96A2022B86906F0A3FE301CA0
+:101C0000F96A402206F09EFEF96A2022786A06F000
+:101C100099FEF96A2022786906F094FE3C1CF96965
+:101C2000C034B86A7B6AA1606349BA696060636165
+:101C300078690B68E2601C63A061396A201C10227D
+:101C40002661FFF7F5FA3E1C8AB002AA8436BA6212
+:101C5000F96A1422301C06F075FE381CF96A142249
+:101C6000703006F06FFEF96A2822B86A06F06AFE44
+:101C7000381CF96A0A22643006F064FE3B1CAC335F
+:101C80006B60143BAB604C4A7023DB192B61B86A64
+:101C900013686421C9196861A961EE60201C1D6187
+:101CA000291C3A6ABB68FFF7F9FA88235B00D95907
+:101CB000281CFFF75BFC424B1B681B7D002B02D1ED
+:101CC000281CFFF72BFE3C1CDC34201C396A04F076
+:101CD00095FF25786C46AB000733DB08DB00E41A80
+:101CE000A54602AC3C622E1C12243B1CDC33D86897
+:101CF000025F002A09DD3A6A013E5B69B0006100BB
+:101D000010185918042206F0DBFD023CA31CECD18C
+:101D1000284B391C1B685C311C6858689A680C7029
+:101D200048708A700533DB7F0132CB707E235B42C3
+:101D30004B71224B52001B6800249B6A0C719A184D
+:101D400000923B6A03202A1C03F004FD1A4B1B6817
+:101D50001C611C63FC68A546174B00221B689A6037
+:101D6000DA603D69AD4601F037FC01F069FD01F034
+:101D7000FFF9012001F098FD01F04EFB0F4BCC2044
+:101D80001B68185600F0F2FB041E00D1FC6A0D4BD4
+:101D90001B681A680C4B9A4202D001F09DFFFEE7C7
+:101DA0000348796802F0C6F8201CBD463FB0F0BD7C
+:101DB000DD19000034030020440000204000002012
+:101DC000880D0020F40E0020CDCDCDCDF0B59DB016
+:101DD00002AF74467146CF487C6002F093F800F081
+:101DE000BFFF061C00F0D4FF386100F0C5FFCA4BEE
+:101DF0006D461C68B860E36800211A1C0E32D208D8
+:101E0000D200AD1A2269AD460E32D208D200684621
+:101E1000801A02AD8546FD6102AD7D6272799A1825
+:101E2000131C0E33DB08DB00C01A53000E33DB0833
+:101E3000DB008546C01A02AD8546C01ABD6102AD01
+:101E4000854602A87861B86906F07CFDE168727980
+:101E5000281C521801215200494206F073FDE36824
+:101E60007279AE49D2185200786906F06BFDE268CB
+:101E70003969F8693D6606F023FD3D69F020800070
+:101E800029182269786A4024002506F019FDFC60B3
+:101E90003D62796AF86902F0DFFE032001F004FD7B
+:101EA0009D4D00202B6838861A6858682C212D24F7
+:101EB000CA55E0559A6804242F23DC55984C5123C9
+:101EC0003020C35523682E21CA555B690132920028
+:101ED000391C9A1802202C3103F076FC012334229D
+:101EE000D3552B6836201B7C3525EB55C355002177
+:101EF0005A233825398704223721EB552368CA55E0
+:101F0000391CDA690220343103F05EFCB479013CFB
+:101F1000631C2CD07579013D6A1CF8D073797869FF
+:101F20006343EB185B001A5A7E4B9A42F3D0B969AF
+:101F300060223960F9657866D219694609CA09C113
+:101F4000211C3B68F8692A1CFEF74CFD002803D0D1
+:101F50003B6A01339BB23B627379BA696343386968
+:101F6000EB18D15CC25C8A18F969CA54D3E7F479DA
+:101F7000013C601C30D0B17973797D694B43E31823
+:101F80005B005A5B674B9A42F2D0BD6960203D60AE
+:101F9000FD65C0197D6984467D666846624628CA2B
+:101FA00028C0221C3B68786AFEF71CFD002803D07D
+:101FB0003B6A01339BB23B627379B279BD695A4384
+:101FC0002B193D69F0202919800009189A5C0B78BB
+:101FD0007D6AD3182B55CBE74F4B3C6A1B68DA68F8
+:101FE0001B69D3189C4206DAFB68013BDBB2FB603D
+:101FF000002B00D04DE700244025FC63EC53B3795F
+:102000003C20C35573793D213E223F25D355CB5506
+:10201000EB5D7F200125834380212B4349420B4305
+:102020003F22D3554020D223391CC3553C310820D0
+:10203000FA6903F0C9FB391C44317C648C800D7053
+:10204000F3797F224B708B70CB78082093431D432C
+:1020500080235B422B43CB707A6AD3230B7103F04E
+:10206000B3FBB379013B0FD37279013AFAD371799B
+:10207000BD685943FC698918E8186118A4300C78C8
+:10208000007820180870F0E7F379013B08D3BC68AA
+:102090007D6AE218C8321178EA5C8A18EA54F4E7DB
+:1020A000F869796A02F0D8FD391C4C310024FC64CF
+:1020B0008C80B3797F200B70737901254B708B7006
+:1020C000CB78802283432B4352421343CB70FA696F
+:1020D0001D2308200B7103F077FB391C54317C65FC
+:1020E0008C800D70F3797F244B708B70CB788026B9
+:1020F000A3431D4376421E237A6A2E4308200B71A8
+:10210000CE7003F061FB0348796801F013FFBD4610
+:102110001BB0F0BD6D1D000034030020FFFF000068
+:1021200040000020FEFF000038B50B4C7146201C1B
+:10213000754601F0E7FE00F01FFE98300378002B93
+:1021400002D1FFF743FE01E001F0AAFE291C201C8A
+:1021500001F0F0FE38BDC046C9200000F0B5A5B0C2
+:1021600000AF724671467861E1487A6001F0CAFEBC
+:10217000E04C23689B683B625B0001333B6501F0E8
+:102180009DF92368FF229B68F865D31A984200DD09
+:10219000FB65F86D3B6A0024C31AFB6101F096F9F8
+:1021A0003A6D694655002B1C0833DB08DB00C81A62
+:1021B00085466A466423DC53602001237965FA640E
+:1021C00061216222C355CB55D3557C235B426320EA
+:1021D000C3556421B123CB553A1C391C201C6031F6
+:1021E0005C3203F0F1FA3A6D944206DAF869F96C60
+:1021F00063002218CA520134F5E700246C23D1B2DF
+:10220000DC530126682069226A23C655D155D95569
+:10221000B96402236B20391CC3556831201CFA6C49
+:1022200003F0D2FA2B1C796D08338D46DB08DB00F6
+:102230006A46D21A9546D21A69469546F9637A6378
+:1022400001F0A6FD3861301C00F0CAFF211C2A1CD9
+:10225000786B06F077FB211CF86B2A1C06F072FBEA
+:10226000386D69468000031C0A33DB08DB00C91A9D
+:102270008D46C91A3B69B8619B00684638638D4634
+:10228000F962BB60FC640021BA69386B06F05AFB46
+:10229000F86AFF21BA6906F055FB00207865954B76
+:1022A000786D1B685B6898424BDAF9690026C9B201
+:1022B000081CB96301F017F901F0E0F800F086FF9F
+:1022C000FC6A3D6B386D0136F217C30F86425341ED
+:1022D000DBB2BB62002B06D1B96B8819C0B201F02A
+:1022E00002F901F0CBF86B46FB60BB686A460A3323
+:1022F000DB08DB00D01A85466A467A6401F050FD9F
+:1023000000231A1C39698A4205DA786C9100415819
+:1023100001325B18F6E72A68934200D92B602068E7
+:10232000834200D22360F968BA6A8D4604340435CA
+:10233000002A02D100F04AFFC4E77B6D01337B65C0
+:10234000ADE700216C4D79650C1C3A6D944217DAAB
+:102350003A6BF96AA300D058CB58C01A854204DD05
+:10236000FA69051CA2187A623C647B6D834200DA2C
+:10237000786500F01FFFF96B6300C8520134E4E791
+:10238000786D00F017FF5B4B1B685B88984206DA9C
+:102390007B69012B03D0F86D396A78623964574D37
+:1023A00032222C68396C231C98335A6064229A605C
+:1023B000022291401A61FA6A00268A580120586167
+:1023C0001E60101CDE603A60B96300F0F3FEB034AA
+:1023D000BB6B396B206058582C6800F0EBFE2B6803
+:1023E00001211A1CC232B8344942206011807A6936
+:1023F000C6331E80012A2BD17A6B331C396D8B4278
+:1024000009DAF86B5900415A1088884200D21180CD
+:1024100001330232F2E73A6C786B53001A5AF96CC6
+:10242000131C8A4200D20B1C9BB27021FB64012357
+:10243000CB557422BB6C0020D05372217122D3552E
+:10244000CB5573220223391CD35570317A6B10E0BF
+:10245000786D00F0AFFE391C80B278310222F8644A
+:10246000B86C0123CA70FA6B487088708E800B704C
+:10247000301C03F0A9F9386C8823D8537A6AFB6BB7
+:102480008A214400CA531C19FA6C23888E21CA532E
+:102490008C20391C8031C35304234B708B70002572
+:1024A00002233A1CCB708832B2230126281C8D806F
+:1024B0000E700B7103F088F92388104C2268111CF0
+:1024C000FC3149680988994225D206F025F9051C96
+:1024D00006F076F803787865002B11D0301C03F0F5
+:1024E000B5F923687E6DFC3302365E6024E0C04699
+:1024F000FD200000D00E0020FFFFFF7F40000020E5
+:10250000002D19D1164B1B68DB7C002B14D1301C1D
+:1025100003F090F910E0FF321278002A0CD0114E2F
+:10252000306842889A4207D9281C03F08FF9236843
+:102530003268FC3302325A60796900290AD17A6A1A
+:10254000D0B200F0D0FF0848796801F0F3FCBD4636
+:1025500025B0F0BD03F032F8072800D193E6EEE78E
+:10256000880D0020D00E0020FD200000F0B5814D28
+:102570008DB0724671460190281C039201F0C2FC96
+:1025800006F0CAF8061C03F067F8071C03F072F89F
+:10259000794C029023681A1CFC321278BA4226D079
+:1025A000002F0CD000226B469A8269463B230B75A4
+:1025B000101C04A90492022603F006F912E0029A04
+:1025C0003D1C002A0FD106A93C23381C3A1C8F80E1
+:1025D00006970B7103F0F8F82368FE331E78731E1C
+:1025E0009E41F6B201252368FC331F701FE01A1CC0
+:1025F000FD32127802998A4218D0002906D1FE33A2
+:102600001E78731E9E41F6B23A2301E0392302265A
+:10261000002208A9101C8A8008920B7103F0D4F8DC
+:102620002368029AFD331A70012500E0002502F0AC
+:10263000CDFF071C03F002F8019B032B02D0002FF3
+:1026400003D107E00125002F38D0002002F0C6FF9B
+:10265000012533E02368FC331F88002F2ED1019918
+:10266000012902D0022904D00EE0019803F0E2F81B
+:102670000AE0381C03F0DEF82368FF331B78002BD8
+:1026800002D0381C03F0E2F803F0CEF82368071CF0
+:10269000FE331B78834211D0002802D0112301267B
+:1026A00001E01223061C00220AA9101C8A800A924B
+:1026B0000B7103F089F82368FE331F7006F02CF8C5
+:1026C000B04237D006F028F805F06EFF071C301C2A
+:1026D00005F06AFF019006F01FF8301C06F016F8AE
+:1026E00005F0DEFF254B1B68187D002801D1012D68
+:1026F0000ED0234B3A1C1B689B3203CB019B9B33B0
+:1027000003F01EFB002001F0CFF8FEF71BFA04E0F7
+:102710002368E433187001F09DF9002003F096F867
+:10272000236800211A1CFF321170164AFC3312680C
+:1027300002325A6005F0F0FF05F042FF0378002BEB
+:1027400008D003F07DF82368FF331A78824201D065
+:102750001870012502F0AAFF041C03F069FE03793A
+:10276000A34200D004710348039901F0E3FB281C45
+:102770000DB0F0BD0D25000040000020880D0020A8
+:1027800044000020D00E002038B5054C7546714637
+:10279000201C01F0B7FB291C201C01F0CBFB38BD2D
+:1027A0002927000038B5054C75467146201C01F0FC
+:1027B000A9FB291C201C01F0BDFB38BD45270000EA
+:1027C00038B5054C75467146201C01F09BFB291C51
+:1027D000201C01F0AFFB38BD6127000038B5054C67
+:1027E00075467146201C01F08DFB291C201C01F050
+:1027F000A1FB38BD7D270000F0B599B000AF74464D
+:1028000071467862D2483C6101F07CFBD14D69464B
+:102810002C6865682068FD63684343195A000832D4
+:10282000D208D200891A9A008D460A326D46D20823
+:102830000733FD62D200FD6BDB08891ADB008D4691
+:10284000AD00C91A7D636D468D463D63C91A6D465C
+:10285000C14B8D46B8633D64386CB96B6D46FD6104
+:102860001D684618AE62E2686862002106F06AF8E8
+:102870002269301C002106F065F8E6680021321C50
+:10288000684606F05FF82469B86B221C0021684492
+:1028900006F058F8FA6BB86B53005B083B62FB6AB2
+:1028A000FA6AEB6143005908D3182B62B961B20090
+:1028B0000021386B06F046F8BD6BA200AB003D6B03
+:1028C0009C08EB18181C0021BB627C6106F03AF8EA
+:1028D000FEF76AF8786400F043FA7C6A022C00D1B3
+:1028E000A1E0032C00D13BE1012C00D004E27D6B80
+:1028F0007B6CAD08BD632F331E78002E46D00020C0
+:1029000000F0D2FF934C9549226809685368013B57
+:1029100021D39D0014683D64651EFD63F7D33D6CB3
+:1029200088694059956878636C431C19486901347B
+:10293000A4002558786B0024854200DD2C1AF86B22
+:10294000BD6B4543386B5D19AD0028580419386BD1
+:102950002C50FC6BE0E71369804A7C6911685A1EB1
+:1029600012193D6B9200AA18013B0DD388690438F7
+:102970000468486905680020A54200DD281B14682A
+:10298000043A20185060EFE7013EB6E7714D2E681B
+:102990007468013C16D33568013DFAD33B6A7A6C02
+:1029A0006B43E3185B003B64BB6B2F326B431178C6
+:1029B000E3183A6B9B00985805F002FF3B6CF96AEC
+:1029C0005852E9E77A693B6BB8699500F96A5D1975
+:1029D0004300CB1834693B63013C0AD37A6CA300F3
+:1029E0002F321178E85805F0EBFE3A6B66009053F1
+:1029F000F2E7FFF7D7FE574C492123684A241A799A
+:102A000018684825CA55E2555A1D1B69E8554C20DF
+:102A1000D27FC3557E234B255B424D21381CEA559E
+:102A2000CB55483092E07C6B7B6CA408BC633033A0
+:102A30001B787B637C6B474D002C41D0002000F05D
+:102A400033FF2A68454B11681E684B1E3B6424D334
+:102A50003C6CB86B536860435D1EAC4660443D6B94
+:102A600084002C19FC63013B15D390680124484372
+:102A700084469C44F86BA444006865467469AD00C4
+:102A8000386028593C688446A444F86B6546056064
+:102A90000438F863E7E7396CD7E7304B12691968F7
+:102AA0009300043B013A07D3BC6ACD69E458E85867
+:102AB0002018BC6AE050F4E77D6B013D7D63B9E707
+:102AC0002E687468013C16D33568013DFAD33B6A21
+:102AD0007A6C6B43E3185B003B64BB6B30326B4337
+:102AE0001178E3183A6B9B00985805F069FE3B6C2F
+:102AF000F96A5852E9E7BA69FB6A550034695D1909
+:102B0000013C0AD37A6CA30030321178BA6A6600AD
+:102B1000D05805F055FEA853F2E7FFF751FE0D4CD3
+:102B20005121236852241A7918685025CA55E25554
+:102B30005A1D1B69E8555420D27FC3557E23532567
+:102B40005B425521381CEA55CB555030F96AD1E02B
+:102B5000992700003403002044000020400000209A
+:102B60007C6B7B6CA4087C6231331B78FB62FD6A52
+:102B7000684C002D00D1A4E0002000F095FE664ACC
+:102B8000206815684368AC46013B50D30268511E6B
+:102B9000FAD38468654662439A186D6901329200DF
+:102BA00052593D6B7A637A6A4A439A189200545993
+:102BB0007A6BFF25A41AFF2C02DCE543ED172540B4
+:102BC0007A6CBD6133321278FD693A62EE18FA6BA5
+:102BD0003D6A4A43AC420DDDB45C0134E4B2B45406
+:102BE0007E6C64B232363678B44217DB3D6CEC183A
+:102BF000BD6912E07C6CB65632342478A6420DDAF8
+:102C00003D6CEC18A65CBD69B54200DA351CA554D4
+:102C1000FC690025E218FC6B4C4315557A6A7C6B05
+:102C20004A433D6B9A18920054510A1CAFE73A4A46
+:102C3000036916685A1E9200013B3ED3F569BC6ACF
+:102C4000AD58A4583D62601BFF2802DDFF257D635F
+:102C500003E0C443E41704407C63796CFC693331BE
+:102C60000978BD6B8C46611960450EDDC85C01308A
+:102C7000C0B2C854796C40B232310978884217DB4F
+:102C80003C6C61197D6BCD5412E0C8568446786C5B
+:102C90003230007884450BDA3C6CBD6B6019C45C43
+:102CA000A4467C6B644500DA6446C4540020C854D2
+:102CB000386ABD6AA850043ABEE7FC6A013CFC626F
+:102CC00055E7FFF78BFD2368582019681A795924B6
+:102CD0005A25C155E255EA555A1D1B69D27F5C2120
+:102CE0005B20CB557F23C2555B425D22381C396C7B
+:102CF000D355583002F00EFB084B00221B680848E1
+:102D00005A629A62DA611A62396901F013F9BD46B2
+:102D100019B0F0BD34030020400000204400002022
+:102D200099270000014B18607047C04658010020E9
+:102D3000014B18687047C04658010020014B586885
+:102D40007047C04658010020014B98687047C04644
+:102D500058010020014B18607047C046DC0E00206F
+:102D6000014B18687047C046DC0E0020014B18600C
+:102D70007047C046D80E0020014B18687047C04607
+:102D8000D80E0020014B18607047C046D40E0020BA
+:102D9000014B18687047C046D40E0020014B1868DC
+:102DA0007047C0466401002010B50D4B00201B7811
+:102DB000AA2B12D10B4B1C780B4B64B218780B4B1F
+:102DC00040B219780A4B20181A780A4B49B21B787E
+:102DD00040188018C01A43425841C0B210BDC046C6
+:102DE0005000020051000200520002005300020095
+:102DF00054000200550002008023DB0200221880EC
+:102E000059809A80C046024B188880B27047C046ED
+:102E10000600040013B5094A042413780021DBB22C
+:102E20001C4301910198F421FF31884205DC1370A5
+:102E3000C046147001990131F3E713BD0D00005035
+:102E400082B00022019201AB55221A7039225242FF
+:102E50009A700122DA70019AA023DB059A6102B010
+:102E60007047A023DB059869C001C00F704701229D
+:102E7000A023DB0510400206024998690840104370
+:102E800098617047FFFFFFFE82B00022019201228D
+:102E90000A40891801303F2201AB1040C9B21870B6
+:102EA000481C023102408900D9705A70019AA0234F
+:102EB000DB05DA61196A024A0A401A6202B07047F9
+:102EC000FFCFFFFF0002064B000A013800225860C6
+:102ED0009A6005221A60C0461A68D103FCD5704773
+:102EE00010E000E0F0B5514F85B03B6894339A781C
+:102EF00019681D78DE780F231407994312092D07EE
+:102F000001922D0F0B1C80222B4352001343484A81
+:102F10000395484D1340484A2B4048491340240F1D
+:102F20000B400199220413430A0545493607360F21
+:102F30000B40009613433206424E02943340134333
+:102F4000414AA024E4051340E360FFF763FF3B68B8
+:102F5000E26895331B781540DB069B0FDB021D43AF
+:102F6000E560E26880239B001343E360E26880230E
+:102F70009B011343E360029C039DFFF715FF0028AC
+:102F800013D0324F882039781E34C9B205F018FCAE
+:102F900039784443C9B2882005F012FC0F35454307
+:102FA0001E3C00230F3D9C4203DB231E0F2B00DD44
+:102FB0000F230F22954200DD151CA024E4051F49B4
+:102FC0001A40E36812040B401343E360EB43E268EA
+:102FD000DB171D400F239A431D401543E560E3684E
+:102FE000F022934380221343E360E368144A1848B5
+:102FF0001340E360E3683340E360FFF763FFE26898
+:1030000080235B051343E3600099E2680B061640DA
+:103010001E43E6600F48FFF755FF019B08491A055C
+:10302000E3680B401343E36005B0F0BDD80E002009
+:10303000FFF9FFFFFFE7FFFFFFDFFFFFFFFFF0FFED
+:10304000FFFF0FFFFFFFFFF0FFFFFFEF5400020045
+:10305000FF0F0000FF6F0000064A074B12680120B7
+:10306000E832126819789040021C0A43D2B21A70F2
+:103070007047C04664010020290000500549064BF6
+:1030800009681A78E83109680120884082431A707B
+:103090007047C0466401002029000050044B187896
+:1030A000044B1B68E8331B68184101231840704724
+:1030B0002900005064010020A0230122DB055A7082
+:1030C0007047044B82B0019001AA188092789A70E0
+:1030D00002B070472400005007B500F043FF064BD4
+:1030E000019001AA188092789A70044B00221A70FD
+:1030F000034B0122DA7707BD2400005000000020B6
+:1031000008000050034B00221A70034B0122DA77AB
+:103110007047C046000000200800005072B6084BFF
+:103120001B5C002B03D1C04662B630BFF6E762B627
+:10313000A023DB059968034A0A409A607047C0469D
+:1031400000000020FFFFF9FF72B6074B1B5C002B4D
+:1031500002D1C04662B6F7E762B6A023DB059968E4
+:10316000024A0A409A60704700000020FFFFF9FF02
+:10317000A023DB055A680121120E58689143034AC7
+:10318000090602400A435A607047C046FFFFFFFE2F
+:1031900008B5074B1B681A1C9C3212789D331B78AC
+:1031A000520001325043994005F00AFB08BDC04669
+:1031B000D80E002008B5044B1B689F3319784900CE
+:1031C0000131FFF7E5FF08BDD80E002008B5A023A8
+:1031D0000120DB055870FFF7A1FFFFF7C9FF08BD0D
+:1031E000F7B5A026041CF605042807D1554B1B682B
+:1031F0001A1CA432A83317681B6824E0524B1B68C2
+:103200001A1C8C331B68883217687361FDF7DEFB6C
+:10321000FF300378002B17D005F07EFA05F0D0F9C7
+:1032200001797F2211408904019171690B1C474982
+:103230000B400199194371614179444B0A4071690E
+:1032400092040B4013437361A023DB051F611E69C9
+:103250001F231E40FFF7A8FD00280AD03C4B882002
+:1032600019780436C9B205F0ABFA46430023043E90
+:1032700003D4331E1F2B00DD1F23A022D205108A8A
+:103280001F210B40884303431382022C16D007DC16
+:10329000002C13D0012C2DD12B4B1D689E3529E01D
+:1032A000042C07D023DB052C24D1264B00241D68D9
+:1032B000AF351FE0234B1D68AC351BE0FDF786FBE7
+:1032C000031CE4331B78002B03D01E4B1D685D35B7
+:1032D00010E0FF300378002B05D005F01DFA05F053
+:1032E0006FF9851D06E0184B1D689B3502E0164BF3
+:1032F0001D68A135A023DB05596928783F221040BD
+:1033000091430143596168781F215D690840114963
+:10331000C0022940014359610F49640009680C1932
+:10332000211C773108785968104091430143596056
+:103330007834217858680A401102084A02400A434A
+:103340005A60F7BDDC0E0020D80E0020FFFF03FE00
+:1033500054000200FF07FFFF64010020FFC0FFFFD1
+:10336000294BF0B51A68294B85B01B689E331B7832
+:103370005B069B0E0193931DD97F00238D00551989
+:10338000581E5B18002B27D053181B1826331B78A8
+:103390008024D3185E78A023DB055F68E4033C43F8
+:1033A0005C60019CB606240400945F68B60EBC46BF
+:1033B000174F64462740009C27435F60C046243671
+:1033C00076008400F65A2C19983426605E68114CF9
+:1033D00034405C60031CD3E76F460293BB8101233A
+:1033E0003B72931DDB7F7F217B72BB72FB7A98322D
+:1033F0008B4304210B43FB720F20B02302A93B73C4
+:1034000002F0E2F905B0F0BD64010020D80E002002
+:10341000FFFFC0FFFFFFBFFFF0B585B0FFF7A0FFC4
+:10342000154B00251E68B31DDC7F631C9B005B42AF
+:103430000093A300F3180193009B043D9D4208D024
+:10344000019A0121571998373868FFF7A1FE3860B3
+:10345000F2E76A4600239381012313720423D37297
+:10346000B023547294721373321C98320F2002A945
+:1034700002F0AAF905B0F0BD64010020044B00225F
+:103480005A70A023DB055A7001221A707047C0469B
+:1034900000000020A023DB059968064A0A4080212D
+:1034A00089020A439A60044A0021917001229A70AD
+:1034B0007047C046FFFFF9FF00000020024B1B6869
+:1034C000903318687047C04664010020024B1B68A7
+:1034D000903318607047C04664010020A023DB05CC
+:1034E0009868C0B2704730B5A023DB059B68DBB29B
+:1034F00083420ED001DA013300E0013BA022D20565
+:103500009568FF211C1C8D430C40291C21439160B0
+:10351000EEE730BDA023DB059968802252020A4302
+:103520009A609968094A0A409A609A6812011209D9
+:103530009A60D968064A0A40DA60D968054A0A40A2
+:10354000DA60D968044A0A40DA607047FFFFFFF08A
+:10355000FFFEFFFFFFDFFFFFFFFFFFEF1B4B10B57D
+:103560001A680121131C92331878A023DB059C688C
+:1035700008401749000421400143996093321078B4
+:103580009C681449000700092140014399601178A3
+:103590009A6809091201090712090A439A60D96851
+:1035A000802252000A43DA60D968802292010A43DD
+:1035B000DA60D968802252050A43FA20DA60800076
+:1035C00000F0F4FCFFF77EFC10BDC046D80E0020D2
+:1035D000FFFFFEFFFFFFFFF008B50020FFF79EFD95
+:1035E00008BD034B1B689C331878400001307047BE
+:1035F000D80E0020024B1B689D3318787047C046D8
+:10360000D80E002000487047001000500048704756
+:10361000002000500048704700400050074B012038
+:103620001B685B799A1C0340D318054A12686632FE
+:1036300010785843034B8000C0187047DC0E002000
+:103640006401002004400050F7B51B4B051C1C68AA
+:10365000A3795F1E15D36279013A10D36079561CA5
+:10366000811C019101210840019908185843311823
+:103670001248890009180868E8400860ECE73B1C1C
+:10368000E7E7FFF7CBFFA37A002201339C466346AE
+:10369000013B9C460FD3617A960001918619002365
+:1036A0000199994205D09F00F1590133E940F15148
+:1036B000F6E75218EBE7F7BDDC0E002000400050A3
+:1036C000074B01201B685B799A1C0340D318054AFD
+:1036D0001268723210785843034B8000C01870474C
+:1036E000DC0E00206401002004400050094B012141
+:1036F0001A685379D0799A1C0B40D318064A0130C6
+:1037000012686A3212785343C018044B8000C01804
+:103710007047C046DC0E00206401002000400050CD
+:10372000F7B5434B1D682A7853B2042B1DD1414B8A
+:1037300019680B1CAE331F7802235E1E77D34A79BB
+:10374000013A10D34C79551CA01C01900120044073
+:10375000019804195C432819374C8000001904684B
+:10376000FC400460ECE7331CE7E7002A45D0022B5D
+:1037700021D1FDF72BF9E43003782E4C002B02D039
+:1037800023685F3302E02D4B1B689D331878FFF7E9
+:103790005BFF2568EC79002C2FD0FFF7A7FF061CF4
+:1037A000013C2AD3697A201C05F060F889008A5907
+:1037B000A300F250F4E7032B03D1204B1B68A33383
+:1037C00018E0012B11D1FFF77BFF1A4B061C1B6879
+:1037D0005C79013C11D32B193A331B789B00985923
+:1037E000FFF7E8FCA300F050F3E7052B05D1114BE0
+:1037F0001B68B1331878FFF727FF104B1B689A330B
+:103800001B78002B13D00B4B1A685379013B0ED356
+:10381000517901258C1C294061189479581C614309
+:10382000401805498000401800210160EEE7F7BD0F
+:1038300064010020DC0E002000400050D80E002063
+:1038400008B5A0230120DB055870FFF767FCFFF7E0
+:103850008FFCFFF765FF08BD70B5041C104E114DBD
+:1038600011D10120FFF7BCFC336801221A70A0239C
+:10387000DB056C705C701A70FFF7E2FFFFF778FCF5
+:10388000FFF7CAFD0224201CFFF7AAFC33680022C0
+:103890001C70A023DB056A705A7001221A7070BD7B
+:1038A000640100200000002008B5FFF7D5FFFFF7F6
+:1038B000C7FF08BD08B5A023DB05011C58683F22DF
+:1038C00011409043084358605968586811400131CD
+:1038D0000A401102064A02400A4306495A60002281
+:1038E0004A705A7001221A70FFF7AAFF08BDC0463D
+:1038F000FFC0FFFF0000002010B5A023DB051C6AFD
+:103900000005064A000D010422400A431A621A6AA1
+:10391000120B12031043186210BDC046FFFF00F0E7
+:1039200073B5174BA0221B68D205903391681968B4
+:1039300091601C78FFF738FA124D002812D0124B14
+:10394000124A1B7812782E6852B25BB20092201C89
+:103950001021D12201F0F2FF2B68943630609433AD
+:103960001B68E418002C01DA002402E0FF2C00DDC3
+:10397000FF242B68E0B290331C60FFF7B4FD73BDE9
+:10398000D80E002064010020530002005200020003
+:1039900008B5FFF7C5FFFFF7A5FAFFF751FA234B6C
+:1039A000C022920098582249014099509958FF200E
+:1039B000814340200143995098581E49014080207E
+:1039C000000401439950985880210002000A09061A
+:1039D00001439950012102221A6008201960042134
+:1039E00019601860144B00205860144B186901438B
+:1039F0001961134B1B68197A124B1B68E8330029B5
+:103A000000D1032210491A6000230B700F49A02235
+:103A10000B700F49D2050B709363D36B9B0E9B0603
+:103A2000D36362B600F09CFE08BDC04600E100E032
+:103A3000FF00FFFFFFFF00FFFCE100E000ED00E002
+:103A4000DC0E0020640100202900005028000050F6
+:103A50002A00005008B5002801D0012801D100F04B
+:103A60007FFEFFF75DFFFFF73DFAFFF7E9F908BDBD
+:103A7000F0B5214B13211B680224DA7A0023133A94
+:103A8000D2B291425B41E41AA023DB0558693F2280
+:103A9000596810408022D2030A43A3B05A60411EE5
+:103AA000A023C9B2DB0502AAFF2910D05F683F2618
+:103AB000124D0E4036043D4035435D60C046251C26
+:103AC00024356D005D5B4B00D5520139E8E75C6839
+:103AD0000B4921405960694600238B8001230B70FC
+:103AE000022348708870CB700320B3230B7101F060
+:103AF0006BFE23B0F0BDC046DC0E0020FFFFC0FF10
+:103B0000FFFFBFFFF7B5041C02F080FC124B1A68E0
+:103B100000235068411C0191019D16689D420CDBF9
+:103B2000976801367E4399008C469E1900216546B0
+:103B3000B600615101333151EEE701239E420ADBA9
+:103B4000956800215D43AF002D180135AD00395156
+:103B500001332951F2E7F7BD34030020044B054936
+:103B600000221A6059609A6005221A607047C046A8
+:103B700010E000E0FFFFFF0010B5A023DB059C680C
+:103B800099680C4BC9B21B68E40394331B68E40FBB
+:103B9000591AFF31E62359430134074BA040C91895
+:103BA000041C064804F00CFEC1B2201C04F008FE00
+:103BB00010BDC046640100205C5D000040420F0063
+:103BC000014B00221A60704710E000E030B50E4D46
+:103BD0000E48AB6885B0C01A0193FFF7CDFF02A96C
+:103BE000012300240B704B708B7004230190CB7069
+:103BF000201C6F2301AA8C800B7101F0E5FD019858
+:103C00002C6005B030BDC04610E000E0FFFFFF00B3
+:103C100010B5041CFFF7A2FF201CFFF71DFEA02318
+:103C2000DB0501205870FFF78FFAFFF7A1FAFFF7C5
+:103C300077FDFFF7CBFF10BD37B5051C0424291C09
+:103C4000221C684604F03CFE2919221C01A804F03D
+:103C500037FE009980230ABADB05DA6001990ABAB7
+:103C60001A6137BD40BA80B2704700BA704700236E
+:103C7000114A12499A188A4204D21149C958043388
+:103C80001160F5E70F4B104A191D043B934203D214
+:103C900000221A600B1CF6E70C4B0D4A1360EFF381
+:103CA00008820433191D043B9A4203D9094818605D
+:103CB0000B1CF7E77047C046400000204803002077
+:103CC000A08A00004C030020880D0020180F00205F
+:103CD000F40E0020CDCDCDCDF0B5294D89B02948C9
+:103CE0002C6800F063F9FFF7EDF80026264FBC4280
+:103CF00022D280373B1B2027832B00DC9F1002A998
+:103D0000FAB2012300204A708A70BF10221C0B7087
+:103D1000CB70888001F058FD231C3A1C013A08D36F
+:103D2000002E04D119491868884200D01E1C0433A3
+:103D3000F4E7BF00E419D9E72B6804A9F31A0025BA
+:103D4000019304230124CB70281CA72301AA8D8092
+:103D50000C704C708C700B71843701F035FD06A926
+:103D60000420C870A823BE1B281C01AA8D800196C0
+:103D70000C704C708C700B7101F026FD09B0F0BD19
+:103D8000F40E0020801A060080370020CDCDCDCD66
+:103D9000024B1B680633D87F7047C0466401002081
+:103DA00070B5051CFFF78CFC0A4B1C68A31DDB7F5C
+:103DB0009A00AD180022511ED218002A09D0E2182C
+:103DC000521826321278920016588A00AE500A1CF9
+:103DD000F1E770BD6401002030B50B4B1B689A1DE4
+:103DE000D27F94001C195300C01800230133D11A4C
+:103DF000013107D09D00651B983559002D68494257
+:103E00004552F3E730BDC04664010020A02382B0D4
+:103E100080B2DB05D88502B07047A023DB05D88DC2
+:103E200082B002B070470722A023DB051040420198
+:103E3000188AE0218843104318827047F8B50C1C9B
+:103E4000051CFEF7A5FF144908688379013B11D3CF
+:103E50000E687279013AF9D30E6870790F4E5843A3
+:103E600036688018F6182818A03607783679BE19F3
+:103E70000670EFE70B68DB79013B08D3074AE15C8A
+:103E80001268D218C83212788A18E254F4E7281C53
+:103E9000211C00F0E1FEF8BDDC0E0020D80E002051
+:103EA000134BF7B51C686946E26800AF131C0E336C
+:103EB000DB08DB00C91A23698D460E33DB08DB0003
+:103EC000C91A0C4B6D461E688D467960281C311C42
+:103ED00004F0F6FCF0239B00F1182269786804F0E6
+:103EE000EFFC281C7968FFF7A9FFBD46F7BDC04667
+:103EF00034030020D40E0020A023DB05186900063F
+:103F0000400F704770B5051CFEF71EFF0468061CC5
+:103F1000013C08D37268E300D3181A68AA42F7D1AB
+:103F20005B689847F4E7024B013D1D6070BDC046D9
+:103F3000E00E002070B5051CFEF706FF8468061C25
+:103F4000013C08D3F268E300D3181A68AA42F7D1FB
+:103F50005B689847F4E7024B013D1D6070BDC046A9
+:103F6000E00E002038B5A023DB0599689D680C4B56
+:103F7000041C1B680B4894331B68ED03C91AC94322
+:103F8000E623C9B25943084BED0FC91804F018FCD9
+:103F9000044B01355843211C284104F011FC38BD65
+:103FA0006401002040420F005C5D000038B5A02392
+:103FB000DB0599689C680A4B051C1B68094894330B
+:103FC0001B68E403C91AC943E623C9B25943064B27
+:103FD000E40FC91804F0F4FB68430134204138BDF4
+:103FE0006401002040420F005C5D0000002801D009
+:103FF000133907E0122902DD262902DD12394910A2
+:1040000000E000E0081C7047F0B5AA4B00261D68D0
+:10401000041CEB7A1322133BDBB2301C9A42704132
+:10402000B1B0C7B2059702273F1A311C142209A864
+:1040300004F088FCA04B20681B68882201936B3336
+:104040001870019B61686E3319700EA8311C04F062
+:1040500079FC311C142209A804F074FC974B0EA8BB
+:104060001968442204F02CFC022F04D11FA80EA9C9
+:10407000442204F025FC00272E1C0497771B03978D
+:104080006B7901369F423EDAB77A0598391CFFF703
+:10409000ADFF09A9095C0EAB0291029A442151437C
+:1040A00009185918721B0A717911069109A90A5C3D
+:1040B00011214A43069952181F210F40063201214F
+:1040C0009200B9400F1CD1580F43D7500399019F5C
+:1040D0003F237A185178071C99438C4602991F4058
+:1040E00089010691614603970F431F40069B1F43BA
+:1040F000029B5770013309AFDBB23B54049F9F42D0
+:10410000BCDA0493BAE7019B049D6D3300261D7051
+:104110000296684B029E19688F79BE4200DBBEE0B2
+:10412000029D49190B1C2833DA79644B1E68331C35
+:104130009A331B78B446039303980023984204D023
+:10414000781E854201DA2931CB790120011C91408A
+:104150000591111C2039051C8D40A9011D1C203D15
+:10416000061CA840049D9E4089090696079001956B
+:10417000019D002D38D0019E4425013E75430196D6
+:1041800066680EA82E544519281C002620302E6281
+:104190004668B60EB606009646601F2A02DC0598F1
+:1041A000286204E08D01009EAD092E434660039D08
+:1041B000002DDDD0029E781E8642D9DA019E44256C
+:1041C00075430EA845191F2B04DC2E6A0698304350
+:1041D0002862CDE7686A079E0643B601800EB609DD
+:1041E000800630436862C3E7029E6046331C457810
+:1041F0006344C833AD065F79AD0EFEF7D5FD0028E8
+:1042000013D02F4E882031780137C9B204F0D8FA84
+:1042100031784743C9B2882004F0D2FA02354543C9
+:10422000013F023D019E791C03D03E1E1F2E00DD82
+:104230001F263F2D01DD3F2526E0EB43DB171D4008
+:1042400022E00199442251430EAB59188F781F2365
+:104250009F43301C18403B1C03434F788B703F2317
+:10426000281C9F4318403B1C034320684B703B288D
+:104270001CDC5043134FC01904F022FB2368019F3C
+:104280000133013723600197019F04988742D8DBEF
+:10429000029D6368013501330295636039E7064B7F
+:1042A00022681B6801206C331A7000E0002031B0D6
+:1042B000F0BDC046DC0E002064010020D80E0020B6
+:1042C000540002000080005030B585B0FEF760FD5C
+:1042D000064B01A81B68021C843332CB32C2FFF7A5
+:1042E00093FEFFF7DDFD05B030BDC0466401002040
+:1042F000F0B5564B9FB01B6800270493DB7A13225E
+:10430000133BDBB2391C9A427941CBB2051C391CF4
+:10431000142208A8079304F015FB4D4B2A681E6869
+:104320000DAC331C6F331A706968023359701F70FB
+:10433000391C4422201C04F005FB391C142208A857
+:1043400004F000FB434B201C1B684422191C0693FD
+:1043500004F0B6FAB31DDF77049A53799F4233DA3B
+:10436000049A0798D319DB7A191C0593FFF73EFED0
+:1043700008AB1B5C9C46002B0BD1B31DDA7F511C94
+:10438000B218D9770732FBB20DA9D37701330A18D7
+:1043900013710DAB19180979F2193A3201391170FC
+:1043A000059901374A110632920003921F220A40F2
+:1043B00001219140039AD2581143039AD150634688
+:1043C000013308A90B54C7E7069B5E78B606B60E04
+:1043D000FEF7EAFC00280AD01F4B88201978023625
+:1043E000C9B204F0EDF946430023023E03D4331E64
+:1043F0003F2B00DD3F23A2781F218A436178A27002
+:104400003F2291431340626A0B4369686370930EC5
+:1044100021709B06002119A814222162636204F016
+:1044200091FA2868442250430C4B211CC01804F018
+:1044300047FA6A682B6801326A60054A01331268DC
+:10444000012070322B6013701FB0F0BDDC0E002015
+:1044500064010020D80E00205400020000800050AB
+:10446000F0B5BA4BB1B01B680024039353331B78EB
+:10447000071C133BDBB21322201C9A426041C5B2D9
+:10448000059502252D1A211C142209A804F05AFAB8
+:10449000AF4B3E681B68211C049363331E70049B62
+:1044A00078686633187088220EA804F04BFA211C35
+:1044B000142209A804F046FAA64B0EA81968442253
+:1044C000443104F0FDF9022D04D11FA80EA94422A5
+:1044D00004F0F6F90025039C0695039E039DA61B98
+:1044E00007966B7A01349E4237DA231C52331D78CB
+:1044F0000598291CFFF77AFD09AA115C6E118C46FC
+:104500000296112166467143029E0EAB89191F2641
+:104510003540063101268900AE40351CCE58354362
+:10452000CD50079E049D3F23A919051C1D405831FD
+:1045300066460295B6018D790196029E9D432E43F3
+:104540001E40019B069D1E4363460133DBB28E7104
+:1045500013549D42C1DA0693BFE7069E049BF6B250
+:10456000653307961E700024784B04941B68049DE5
+:104570009A7A954200DB9BE0049D069C5A195832BA
+:1045800011780122081C2038161C82408E409001B0
+:10459000B44680090394039C002C1BD0039D442245
+:1045A000013D6A437E680EAC1655A2180395141C93
+:1045B0001F2905DC566A65461562B20E920607E0B1
+:1045C00000251562666A8201B50E9209AD062A437E
+:1045D0006262E0E75E4A1168221C587A824210DA71
+:1045E0008818583084794425A006A4096C43BE6815
+:1045F000800E20180EAD0136281806710132BE60FB
+:10460000EBE7544B1B681A1C4632453316781C786E
+:10461000F606A406F60EA40EFEF7C6FB002813D07D
+:104620004D4D882029780136C9B204F0C9F829789F
+:104630004643C9B2882004F0C3F802344443013E23
+:10464000023C0025701C03D0351E1F2D00DD1F25E8
+:104650003F2C01DD3F2402E0E343DB171C40039EB7
+:104660000698864221DA0399442251430EAB591829
+:104670008E781F239E43281C1840331C03434E781A
+:104680008B703F239E43201C1840331C0343386823
+:10469000324E50434B70801904F012F93B68039E70
+:1046A000013301363B600396D9E7049C01345BE794
+:1046B000274A3E681468079D221C643216703868C9
+:1046C000D07079680532517015700022597A8A428B
+:1046D00010DAA1185831897944208D068909484398
+:1046E000AD0EB96840190EAE0131301801710132BA
+:1046F000B960EBE71AAD03950025069EB5421EDAB8
+:1047000044236B430EA8C618706A0021820E9206DD
+:10471000316272620398142204F014F9386844215B
+:1047200048430E4A311C8018442204F0C9F83B6803
+:10473000039E013344363B6001350396DDE73B6859
+:1047400068340120237031B0F0BDC046DC0E00207B
+:1047500064010020D80E00205400020000800050A8
+:10476000F0B56B4B00241F681322FB7A211C133B0E
+:10477000DBB28DB09A4261410226CBB20C22761A8E
+:1047800004A8211C019304F0DDF8142207A8211CC1
+:1047900004F0D8F87A793D1C02920299EB1B8B4207
+:1047A00013DAE97A0198FFF721FC132801D90020D8
+:1047B000ACE007AA135C0135B342F8DA0133DBB28F
+:1047C00013549C42E9DA1C1CE7E701220492B879F1
+:1047D000002181420ADA131C9D1AA54203DA3B2B01
+:1047E000E5DC0133F8E701311A1CF2E70492FB79AA
+:1047F000002B11D1002304A80493FFF779FD04A82E
+:10480000FFF702FC424B434D1B68DE79002E3ED081
+:1048100004A8FFF725FE50E03B1C53331B7800250E
+:10482000133BDBB21322291C9A426941CAB202929D
+:104830000222521A019207A8291C142204F082F8BD
+:104840007B7A3E1C0393039AF31B934214DA331CC6
+:10485000533319780298FFF7C9FB1328A7D807AA82
+:10486000135C019901368B42A1DA0133DBB2135498
+:104870009D42E8DA1D1CE6E7EB43DB171D40BB7ADF
+:104880005D43049B6D00ED183B2DB3DD8FE7286879
+:10489000311C0422633004F055F82868311C0422CE
+:1048A000673004F04FF82B680499CAB2191C6331C1
+:1048B00068330A704A700A711A702D6864002B1CE4
+:1048C0006F331A78073BDA73291C1B7878310B7029
+:1048D0004A70083909782A1C7A3211700F3A167812
+:1048E000291C7B31281C0E707D305374022203F08A
+:1048F000E7FF2F1C2B1C7F33083734195C701E70A8
+:104900006E35FE672A7801339A6001200DB0F0BD44
+:10491000DC0E0020640100200D4B10B51C680D4B0F
+:1049200001681B681A1C673211704168D170191C2C
+:10493000693100220A70617A8A4204DA81680132A0
+:1049400001318160F7E70268683301201A7010BDF9
+:10495000DC0E002064010020A14BF0B51B68B3B051
+:104960001A1C0832D26F002406929E4A1321156841
+:10497000201CEA7A069F133AD2B2914260411A1C77
+:10498000C6B27332177076330296012202261A706D
+:10499000361A211C882210A803F0D4FF211C1422EF
+:1049A0000BA803F0CFFF291C603110A8442203F0AC
+:1049B00087FF022E04D121A810A9442203F080FF12
+:1049C0006E790027059603973C1C059FBC422ADAA6
+:1049D0002B19DE7A0298311CFFF708FB0BAB195C30
+:1049E00010AA8C46674644217943091851180134AE
+:1049F0000C711F5C7111049111214F4304997F18B0
+:104A0000B91D1F273E4001278900B7403E1C8F5823
+:104A10003E438E5062460132039ED2B21A549642F1
+:104A2000D3DA0392D1E7069D00240595039F0297F0
+:104A3000029F002F16D0029E4422013E724310AF07
+:104A4000BA180296D66A0021556A11629162B10EB7
+:104A50008906D378A80ED162202180060B435062CC
+:104A6000D370E5E75F4B221C186881798446079173
+:104A7000079D131BAB4248DA65462B1B9B182F334F
+:104A8000187801231F1C874051100497071C1940F8
+:104A9000203FE6B20991BB40039908961F1C0029EC
+:104AA00031D0013944234B4310AE651C9D55089D00
+:104AB000F318099E6DB20195B54210D01F2804DC91
+:104AC0001E6A049D35431D62E9E75D6A2E1C3E4364
+:104AD000B601AD0EB609AD0635435D62DFE71F28AE
+:104AE00004DC9E6A049D35439D62D8E71D1CDB6A89
+:104AF0003B439B019B090193EB6A9E0E019BB6060B
+:104B00003343EB62CBE70132B2E7374B1B685B19EB
+:104B1000C8335F79634661331D78AD06AD0EFEF78D
+:104B200043F9002813D0314E882031780137C9B2BB
+:104B300003F046FE31784743C9B2882003F040FEB7
+:104B400002354543013F023D0026781C03D03E1E3E
+:104B50001F2E00DD1F263F2D01DD3F2502E0EB4328
+:104B6000DB171D40059944274F43214ABF18029A7D
+:104B7000039B9A4220DA02994422514310AB591800
+:104B8000301C1F231840049088789843031C049815
+:104B900003438B70281C3F231840049048789843A7
+:104BA000031C049803434B70381C03F089FE0299E0
+:104BB000443701310291DAE7DB43039D059EDB17A1
+:104BC0002B40F61801340596022C00D02EE7044A3B
+:104BD000069D1268E918CB187432137033B0F0BD1B
+:104BE00064010020DC0E0020D80E002054000200DA
+:104BF00000800050F8B5164D061C2B680024633366
+:104C00001F782B68E1191A1C643212780134914222
+:104C100009DAE319442058430E4B311CC018142202
+:104C200003F090FEEDE76B331F7800242B68E21948
+:104C30006C331B7801349A4209DAE3194420584353
+:104C4000044B311CC018142203F07CFEEEE7F8BDC3
+:104C500064010020EC7F0050F0B5374B85B01B6835
+:104C600002901A1C039163321578344A00201168AF
+:104C7000041C8A7A94422BDA021C4F7A161ABE421E
+:104C80001FDA9E195836B679B7090096EF194426EF
+:104C90007E432B4FB4463E1C009F66440196BE06E1
+:104CA000039FB60EB446BE5C3F2E00DD3F26F6B233
+:104CB0000096019E0132371C6744009E30373E70DB
+:104CC000DBE7181C6530007801342D18101CD0E784
+:104CD0001A1C6B32147800208A79904229DA00225B
+:104CE0004D790195AA421EDA9E187678B709E71920
+:104CF000039744273D1C039FB6067D43AC46104DE9
+:104D0000B60E2F1C019D674445430397029FBF18B1
+:104D10007D5D3F2D00DD3F25039FEDB2BE1930368E
+:104D200035700132DCE71A1C6D3212780130A4189C
+:104D3000D2E705B0F0BDC04664010020DC0E0020C3
+:104D40000080005044235843044B111CC018C27803
+:104D50000F2319409A430A43C270704700800050E5
+:104D600038B5051C141CFEF71FF8002808D00A4BA4
+:104D7000882019780234C9B203F022FD4443023C72
+:104D800044206843054A3F23801802781C409A4318
+:104D90001443047038BDC046540002000180005026
+:104DA00010B5041CFEF700F8002808D0084B882036
+:104DB00019780434C9B203F003FD4443043CA02332
+:104DC000DB05198A1F22144091430C431C8210BD3D
+:104DD0005400020030B50F4B1B689979884203DA02
+:104DE0001B182833D87914E05A798D18411AA84233
+:104DF00002DA5B18D87A0CE09C7A8A1A2D19A8423C
+:104E000003DA9B185833187803E0141B1B1950332E
+:104E1000D87830BDDC0E0020F0B5D44DA024E405D8
+:104E2000A3682B6897B059799A7900AF8A18597A94
+:104E30009B7A5218D3181A1C5A437B62D31DDB0885
+:104E4000DB006846C01A85466B46FF217B6103F094
+:104E500079FDFF20FFF7AAF8C54B69461B1A786A4F
+:104E6000BB60C000031C0E33DB08DB003861C91ACD
+:104E7000786A8D466B4680003B62031C0A33DB0870
+:104E8000DB00C91A002200233A637B63F860F961F2
+:104E9000E268B84B8D461340E3602B685C79B34BF6
+:104EA000013C1B68621C14D01B19381CD97A503085
+:104EB000202203F0E7FC3D6D58207A6DAB00C0194D
+:104EC000C3180121283B91400A1C19680A431A6043
+:104ED000E5E79C79A54B013C1B68621C15D01B19AA
+:104EE0002833381CD9795030202203F0CBFC3D6D9B
+:104EF00058207A6DAB00C019C3180121283B91409E
+:104F00000A1C19680A431A60E4E75C7A974B013C73
+:104F10001B68621C15D01B195033381CD9785030CF
+:104F2000202203F0AFFC3D6D58207A6DAB00C01914
+:104F3000C3180121283B91400A1C19680A431A60D2
+:104F4000E4E79C7A013C621C17D0884B381C1B6834
+:104F500050301B1958331978202203F093FC3D6D13
+:104F600058207A6DAB00C019C3180121283B91402D
+:104F70000A1C19680A431A60E4E77D69BD610025CF
+:104F8000FD62FD6A786A854200DBDEE000213A6955
+:104F9000386A03F0D7FCA0240021FA68F86903F00E
+:104FA000D1FCE40500232363636B9B0E9B066363C4
+:104FB0003D6BA563786BB862E36B86019B0EB60907
+:104FC0009B063343E3636420FEF7F0FFFDF77AFFAF
+:104FD000F86AFFF7FFFEC1B2381C4830202203F008
+:104FE00051FC396B7A6BFB6CB963FA63BA6C0121C3
+:104FF000994058200B1CC01991004118081C2038FA
+:1050000002689A430260B86C131C00280AD0283941
+:105010000A6853409A01636B92099B0E9B061343E7
+:10502000636301E06B402363A024E405A563E36BA5
+:105030000A209B0E9B061E43E663FEF7B7FFFDF7B3
+:1050400041FFE26B8023DB041343E363B96BBA6A6D
+:105050004D40A563FB6B5A40E36B92019B0E920996
+:105060009B061343E363FEF779FDFD6BBE6B3B6A62
+:10507000AC460124404ABD689168A94214DB3F4A0E
+:1050800065461068526830402A405D68954203D3F7
+:10509000F0D11D688542EDD2FD69DA60A20098600A
+:1050A000A95001340833E5E7FEF78AFDA023DB05AC
+:1050B000D96B334A0A40DA63012C3ED0651E386A48
+:1050C000ED004519013C002C37D02B1C083B1A6819
+:1050D00029685B6891436A687E6A9A43A3003964D1
+:1050E0007A64013EBB62FA6A964224D0301CFFF714
+:1050F00071FE011C381C5030202203F0C3FB7B6D75
+:105100000122386D9A405821131CC91982008A184F
+:10511000183A12681A420CD0BB6AFA691720D258A2
+:1051200040425043174BC018FEF726FDB9690011E5
+:105130008855013ED7E7083DC4E7FD6A786A013526
+:10514000FD62BD692D18BD611BE7C3B2381C50302C
+:105150000370437083700023C37003717969012366
+:10516000437100F0D7F8BD4617B0F0BDDC0E00204B
+:10517000FFFFFF00FFFF0FFF10E000E040000050C6
+:10518000FFFFFFFBE9FFFF16014B18607047C046A9
+:10519000E80E0020014B18687047C046E80E00205A
+:1051A000014B18607047C046E40E0020014B1868A0
+:1051B0007047C046E40E0020014B18687047C04697
+:1051C00068010020F7B52F4F73467146381C0193D4
+:1051D000FEF798FEFBF7E8FB009001F017F9061CBC
+:1051E000FDF7BEFD284D1022041C0099286803F02D
+:1051F00067FB32882B68381C1A74120A5A74B288FA
+:105200009A74120ADA74214A12680532D27F002A8F
+:1052100003D0A2791A75627902E062791A75A279CF
+:105220005A75E2799A751A4A6B6812881A70120ACE
+:105230005A70184A52889A70120ADA70164A5288BE
+:105240001A71120A5A71154AD2889A71120ADA71C1
+:10525000134AAB68920A1A70124A920AD2B25A7072
+:105260009A70114A920AD2B2DA701A710F4A920AEF
+:10527000D2B25A719A710E4A920ADA710199FEF706
+:1052800059FEF7BD655100006C0100203403002079
+:10529000FE030000FC9B0000FCAF0000F8BF000014
+:1052A0000000000000040000009C000000B00000AE
+:1052B00000C00000F7B50A4C7146061C201C75465C
+:1052C000FEF720FE074A694681CA81C16B46B600D7
+:1052D000F658201C291CFEF72DFE301CFEBDC046D2
+:1052E000555200009089000070B5084C7146201C92
+:1052F0007646FEF707FE064B201CDB69311C5D7805
+:10530000EDB2FEF717FE281C70BDC04689520000A2
+:105310006C010020F8B5144D041C0F1C281C7146AC
+:105320007646FEF7EFFD114BFF215A6A11701049C6
+:105330009C620F60A0782778596B474320793F180B
+:1053400060794006400E784308609869A02101709A
+:10535000D969281C1378FF2B02D10B78022BF9D0C6
+:10536000311CFEF7E7FDF8BDB55200006C010020CE
+:105370007C04002038B50D4C7146201C7546FEF7A4
+:10538000C1FD0B4AD1694B780A49DBB20B72012B84
+:1053900005D0022B05D1936901225A7001E0FDF777
+:1053A0005BFE291C201CFEF7C5FD38BD155300000F
+:1053B0006C0100207C04002038B50D4C7146201C87
+:1053C0007546FEF79FFD0B4BDB68002B0BD00A4A9E
+:1053D000DBB2106C7F2119404832017093700133A9
+:1053E0005370FFF7C7FF291C201CFEF7A3FD38BD33
+:1053F000595300007C0400206C01002070B50F4C54
+:105400007146201C7546FEF77DFD0D4B261C1B7A50
+:105410000C4C012B05D0022B05D1A269002353703F
+:1054200001E0FDF72BFE236C7F211A78301C8A43A4
+:105430001A70291CFEF77EFD70BDC0469D5300000A
+:105440007C0400206C010020F7B51E4E7346301C12
+:1054500071460193FEF756FD1B4D00241B4E337A17
+:10546000012B07D0002B18D0022B17D1184B9B69AA
+:105470005C7813E0FDF712FE041C002D0BD1FDF744
+:10548000FDFD2E23FF33013B002B01D0C046FAE780
+:10549000FDF7E2FD0C4D013D00E01C1C0C4FFA69CC
+:1054A0005378327A9A4206D0FFF7A8FFFB69074A81
+:1054B0005B78137201E0002CD0D102480199FEF70D
+:1054C00039FDF7BDE9530000FF2C01007C040020EA
+:1054D0006C010020F7B5164D7346071C0E1C281CE6
+:1054E00071460193FEF70EFDFFF7AEFF114C8022CF
+:1054F000236C52421978606C0A431A70391C321CB2
+:1055000003F0DEF9236CF6B218787F229043311C49
+:105510001140021C0A431A704834A670FFF72AFF94
+:10552000FFF792FF281C0199FEF704FDF7BDC04666
+:10553000755400006C010020F8B5FBF735FA00F057
+:1055400065FFFDF70DFC1A4C051C666B03F01AF89D
+:105550007060FFF737FE174B1B681888E36B020A71
+:105560005A711871FFF7A6FEE26BC6B296712B68EE
+:10557000EF790136FF1801374743381C00F0EFF987
+:105580003A1C0021051C206403F0DCF9231C48337D
+:10559000013500225E7065649A7002F0EDFF064BE3
+:1055A0005860A023DB059A7CE36C1A70F8BDC046F6
+:1055B0006C010020E80E00207C040020024BDB6917
+:1055C0001878C0B27047C0466C010020024BDB69FE
+:1055D0009878C0B27047C0466C010020014BDB696F
+:1055E000987070476C010020024BDB69D878C0B21C
+:1055F0007047C0466C010020014BDB69D8707047D2
+:105600006C010020014BDB69586870476C01002079
+:10561000024BDB695A6858607047C0466C01002035
+:10562000024BDB69187AC0B27047C0466C0100209B
+:10563000014BDB69187270476C010020024BDB697B
+:10564000587AC0B27047C0466C010020014BDB693C
+:10565000587270476C010020024BDB69D87AC0B2E7
+:105660007047C0466C010020014BDB69D87270475F
+:105670006C010020024BDB69987AC0B27047C046CB
+:105680006C010020014BDB69987270476C010020AF
+:10569000024BDB69187BC0B27047C0466C0100202A
+:1056A000014BDB69187370476C010020024BDB690A
+:1056B000587BC0B27047C0466C010020014BDB69CB
+:1056C000587370476C010020034BA0229B691A702D
+:1056D0001A78A02AFCD070476C010020034BC2B29C
+:1056E0009B691A701A788242FCD070476C010020C6
+:1056F000014B5B6A187070476C010020024B5B6ABB
+:105700001878C0B27047C0466C010020014B1B687E
+:1057100018887047E80E002008B5FFF795FE024B89
+:105720000022DA6008BDC0467C04002070B5074B3B
+:10573000074CDA6BE668011C9579586C2A1C8019B5
+:10574000751903F0BDF8E56070BDC0466C0100201E
+:105750007C04002073B56C46E271194A0734556D1C
+:105760002E7886422AD1FF2028701366131C9433AA
+:105770001B6820789B6880009165D4651871114B77
+:1057800006980C7818608878536B60430C794979D7
+:1057900000194906490E414319609169A0230B7015
+:1057A000516DD3690A78FF2A02D11A78002AF9D0FC
+:1057B0000A78FF2A02D11A780A2AF3D073BDC046AC
+:1057C0006C0100207C04002070B5144C636B1D79C3
+:1057D000EDB2012D21D1854058781E78000230436A
+:1057E0009E7836043043DE7836063043284214D0A3
+:1057F000FF2018710A48A16302608C780D78C9787F
+:105800006C434906490E074A6143506B9269016037
+:10581000772111701A79FF2AFCD070BDEC010020AD
+:105820007C0400206C010020014BDB6B1878704772
+:10583000EC010020014BDB6B18707047EC0100207D
+:10584000014BDB6B58787047EC010020014BDB6BA0
+:1058500058707047EC010020014BDB6B9878704763
+:10586000EC010020014BDB6B98707047EC010020CD
+:10587000014BDB6BD8787047EC010020014BDB6BF0
+:10588000D8707047EC010020002303600B601B4BB5
+:10589000F7B59A4230DC1312194C122B1BD89B001F
+:1058A000E418646E002C27D0E368013B5D1C23D014
+:1058B000D5B2019565681E1CEF5C019D013BED1B97
+:1058C000F4D42768B300DB59002B15D05B190360B3
+:1058D000A3689B5D0EE0A36B266B013B0CD35D00C0
+:1058E000755B551BF9D4E66A9B00F25852190260A9
+:1058F000626BD3585D1B0D60F7BDC046FFEF000023
+:105900006C010020C02208B5D2000B4B904206D19A
+:105910009B691A78052A0DD005221A700AE01B6CC3
+:1059200084221B7892005B065B0E9B18984201D183
+:10593000FFF764FD08BDC0466C01002038B5051CAA
+:105940001C1C181C8D4209DB0498954206DAC01A0B
+:105950006D1A6843511A02F033FF201838BD044A0B
+:10596000033013688010800018181060181C7047EE
+:10597000F40E0020F8B501254E1E6C00B54202DA87
+:10598000165FB0420CDAA61E1D5F115F9B5F401AC6
+:10599000EB1A5843935FC91A02F012FF4019F8BD81
+:1059A0000135E9E7014B18607047C046040F00203D
+:1059B000014B18687047C046040F0020014B186067
+:1059C0007047C046FC0E0020014B18687047C04667
+:1059D000FC0E0020014B18607047C046000F0020ED
+:1059E000014B18687047C046000F0020014B186833
+:1059F0007047C04638030020F0B5394F8BB075466C
+:105A000003950E1C051C7146381C0024019202935C
+:105A1000FEF778FA6A464F239482201C137504A976
+:105A2000221C0494FFF7D0FE2E4B201C1A685368EA
+:105A3000013B10D3990074581168A4464C1EF7D34B
+:105A40009768794359180131890049596746C91B3C
+:105A50004018211CF2E7D16802F0B2FE224B071C6D
+:105A60001C68224E6588002D03D1336840229A605D
+:105A70000CE0A1883268681A8001791A009202F05D
+:105A80009FFE6E2800DD6E20009B9860A379642243
+:105A90005343019A5343029A13412278002A04D0B7
+:105AA000124A1268926853439B11326806A9D36068
+:105AB00001230B7002234B708B707C235B42002010
+:105AC000CB7008AA5023888008950B710997FFF7BF
+:105AD0007BFE03480399FEF72DFA0BB0F0BDC046DC
+:105AE0009959000034030020FC0E002038030020E8
+:105AF000F0B5D1B0764606900C1C4048714607962A
+:105B0000FEF700FA3E4B0A251B685B691B78012BE8
+:105B100004D1E7687D100A2D00DA0A25394B0021EF
+:105B20001E68902233687768013BDBB2013F08A80A
+:105B30000493FFB202F006FF90222CA8002102F08D
+:105B400001FF7BB2980008AA2CAF12183F189446A8
+:105B5000059301970022002B1FDB049F79B20029D7
+:105B600018DBB768481C4743DF19013706987F00E8
+:105B7000385E029060468058029FB84201DA604663
+:105B80008750019F0298BF58874201DD019FB8509E
+:105B90000139E4E7013B043ADDE70023E3612362D6
+:105BA00063620598984223D09900494260464218A2
+:105BB000043A1268AA4202DDE769BE18E66101985C
+:105BC0006E42411804390968B1420FDA276A7E181B
+:105BD0002662AA420ADD5218002A02DD626A0132F8
+:105BE00003E0002A02D0626A013A62620133D8E718
+:105BF00002480799FEF79EF951B0F0BD915A000096
+:105C00004400002034030020F0B5754687B00395AA
+:105C1000264D0291041C7146281C171C1E1CFEF701
+:105C200071F9234BBA6A1B68DB799A40131E00DCBA
+:105C30000123204A311C1268D068584302F0C0FD8D
+:105C40001D4B00901D682F68BC463A1C6B68561EA1
+:105C500016D3191C7143C918890061180439013B16
+:105C60000CD3AF6802985743DF1901377F00385EC5
+:105C7000009F47430868C01B0860EFE7321CE5E758
+:105C80006946DBB28A824B7462468B7404206023BF
+:105C90000B750A74C874221C04A9FFF795FD03480C
+:105CA0000399FEF747F9012007B0F0BDA95B00009A
+:105CB000FC0E00203803002034030020F0B51D4DF9
+:105CC00085B0744601940E1C041C7146281C171CD8
+:105CD000FEF718F9184B391C1B68D86802F070FDE4
+:105CE000164B00901B6819698A00A2180B1C043A15
+:105CF000013B07D35F00F05F009F47431068C01B64
+:105D00001060F4E76A4661230126C9B204201373C8
+:105D100010235373167251729172D07202A9221C11
+:105D2000FFF752FD281C0199FEF704F9301C05B05D
+:105D3000F0BDC0465D5C0000380300203403002045
+:105D4000F0B5244C85B07546019500911D1C714637
+:105D5000071C201C161CFEF7D5F86878B3787178FC
+:105D60004000013098404900AB78013199408003F0
+:105D700002F026FD00226946B4238A81051C0B73BC
+:105D8000101C02A90292FFF71FFD134B201C1E6876
+:105D90003268013A0DD37368191C5143C918890040
+:105DA00079180439013BF4D30C68A40B6C430C60E4
+:105DB000F7E73369009C9A00A218043A013B04D328
+:105DC0001468A10B69431160F7E70199FEF7B2F877
+:105DD00005B0F0BDE15C000034030020F0B589B0EF
+:105DE0007446069002912B48714607940392FEF781
+:105DF00089F8294B1E68294B34681B68009404936A
+:105E0000274B1B680593274B1F68009C013C00949F
+:105E10001FD374680099244A6143A5186D18069B26
+:105E2000AD0001915D19013CEFD30399286802F0A0
+:105E300079FC04990B78002B07D0059A0199531827
+:105E40001B5DBA6858435043001300042860043DAA
+:105E5000E9E7124B34691E68114B1F68013C13D3EC
+:105E60000299A5004859039902F05CFC3378002B95
+:105E700006D0F0223B1992009B181B7858438011E2
+:105E8000029B00045851E9E702480799FEF752F8CF
+:105E900009B0F0BD7D5D000034030020FC0E002041
+:105EA000000F002038030020FFFFFF3FF0B51A4C21
+:105EB000071C0E1C85B07146201C7546FEF722F8A3
+:105EC000164B3A371B683A78997C4A4331689209F5
+:105ED0008A4200DA0A1C997B4A43921101921B7B89
+:105EE0009A4200DA019302A900228A8001220A70F4
+:105EF0004A708A707C225242CA701F220A710620A0
+:105F000001AAFFF761FC201C291C019EFEF712F874
+:105F1000301C05B0F0BDC0464D5E0000FC0E0020F8
+:105F2000F0B599B0754611900C1CC24871460B92A1
+:105F300012931395FDF7E6FFFAF736FDFAF740FDE9
+:105F4000BD4B1A68BD4B1B68191C5F310978D174B1
+:105F5000191C5D3109785174191C5E3109789174EE
+:105F6000191C5C310978FF3311745B7A002B07D15F
+:105F7000B34B1B681E7A09960A201F5E089706E03D
+:105F8000B04B1B689D7809950427DE5F0896AE4FDD
+:105F900000253B6815A81A6805805126586814A981
+:105FA0006E440A7030709A68522153206944042369
+:105FB00068440A70037015A951230B7001320B9BC2
+:105FC00092009A1814A90220FFF7FEFB231C31331C
+:105FD0001D709D707F26013B1E709E705D71DD718E
+:105FE000396804331E709E704B680A68013BDBB24F
+:105FF0000D93934B954F1E68954B013A1B6852B217
+:106000000E938D4BB4461B6807970F9380231B0696
+:10601000069305950395002A00DAC7E00D98550010
+:1060200043B20A95002B00DABEE08E68551C75431A
+:106030000135ED18A8000B9F0095129D9E00C059D8
+:10604000AE59069F861BB74200DA0696079DB542F9
+:1060500000DD0796664637784E68002F09D0351C5C
+:1060600055430E9FFF187F5D0F9D7843AD686843D1
+:10607000001356431E9F9E19B600F659119F360C09
+:10608000301A009E7500E8536646002857DB0F253E
+:106090007557A84212DB2768451B7D192560656985
+:1060A000102701356561F757F67B656876B2B8420F
+:1060B00001DC861B00E0BE1BAE196660E568A842E5
+:1060C00004DDDEB2D7B210960C97E0606646357BF1
+:1060D000A8421EDB251C33350026AE579E4200DA4F
+:1060E0002B70251C32350026AE579E4200DD2B70EA
+:1060F000251C31350026AE57964200DA2A70251C41
+:1061000030350026AE57964200DD2A70059F0137D4
+:10611000059785B2209F5E000195BD5B019F7D19AB
+:106120002F1C209DAF531F9D0A9EAF5B019EF5194A
+:106130001F9F0A9EBD53039F3F18039732E0357B94
+:106140006D42A8421BDC251C37350026AE579E4207
+:1061500000DA2B70251C36350026AE579E4200DD36
+:106160002B70251C35350026AE57964200DA2A7072
+:10617000251C34350026AE57964200DD2A7067464E
+:1061800011257D57A84206DCA668451B7519A56038
+:10619000A5690135A5612769B84200DA2061039D30
+:1061A0002D1A0395013B3DE7013A34E7264B03984E
+:1061B0001B680125D96802F003FB7C2316A95B420A
+:1061C000221CCB70A062762328320026281C8E80E9
+:1061D0000D700B714D708D70FFF7F6FA059F231C43
+:1061E00001223133E7620021524259569A56124B2E
+:1061F0001B68914201DB1D7100E01E71069D079E28
+:10620000E563109F0C9D231C383326641F705D705E
+:10621000E668099F0125BE4205DA2369089CDD0F67
+:10622000E2179C42554103481399FDF783FEE8B2FB
+:1062300019B0F0BDC15E000038030020400000200E
+:10624000FC0E0020040F002034030020FFFFFF7F1E
+:10625000000F0020F0B589B075460C1C0390714604
+:10626000444804936E4605950027151CFDF74AFE29
+:10627000FAF79AFBFAF7A4FBFCF772FD0123B78348
+:1062800033763D4E6A46306806A9037C0220537679
+:1062900093760423D3765A2313772A1CFFF794FAB4
+:1062A000231C3A331F7080231B066364334BA364A3
+:1062B00033681A69324B1968324B1E68324BB44648
+:1062C0001B680193013A44D3049F9600BF59A85913
+:1062D000C31B676C9F4200DA6364A76C9F4200DDBA
+:1062E000A3640B78002B07D06746BB18F027BF00CC
+:1062F000DB191B78584380110E9FBB591B0C1B1ACE
+:1063000011D4487B834202DB019E012030710F20B3
+:106310000856834212DB2768181A38182060606913
+:10632000013060610AE011200856834206DCA6684D
+:10633000181A3018A060A0690130A061039F5000B6
+:106340003B52201C3A300678B34200DA331C03700B
+:10635000B8E70B4B3A341B6822781B7A00209A422C
+:106360004041C4B205990348FDF7E4FD201C09B083
+:10637000F0BDC046F561000034030020FFFFFF7F41
+:10638000FC0E0020000F002038030020F0B585B07F
+:1063900003931A4B00901C680291256801926F1EAE
+:1063A0001BD3636800981E1C7E43F618B60086193E
+:1063B000043E013B0FD3A168012269438C469C44F3
+:1063C0009444604601998000425830689446844461
+:1063D00061463160ECE73D1CE1E72269039D029CC8
+:1063E0009300E118E8180023043B013A04D3CE5887
+:1063F000C5587419CC50F7E705B0F0BD3403002040
+:10640000014B18607047C0460C0F0020014B186804
+:106410007047C0460C0F0020014B18607047C04603
+:10642000080F0020014B18687047C046080F002075
+:10643000014B18687047C0463C030020F0B5724617
+:1064400087B071465D480592FDF75CFD5C4C00210C
+:1064500020680A222C3002F075FA206800210A22F6
+:10646000363002F06FFA206800212822403002F016
+:1064700069FA206800210A22683002F063FA206875
+:1064800000210C22723002F05DFA206800210C22FB
+:106490007E3002F057FA2068002105228A3002F08F
+:1064A00051FA2068052200218F3002F04BFA454B4B
+:1064B00025681E68F369346A5B00181B61000002DE
+:1064C000019302F07DF90490A860B06A726A0090AE
+:1064D0005200009B101A59000002029202F070F95B
+:1064E000394B0390E86001981F68414202987B1D78
+:1064F000DA7F4042331CD63301901888604340183D
+:10650000002A0ED039680139614302F059F9331C71
+:10651000D833041C009A1888019B50437968C0182E
+:106520000DE079680139614302F04AF9331CD83330
+:10653000041C009A1888019B50433968C01801391F
+:10654000514302F03DF9844200DA041CE30F1C19A8
+:1065500079686410AC6104983C680139039A43007F
+:106560000902013C5918240253001C1929616C616D
+:106570000537FB7F371CD83600962E1CD637A4363D
+:10658000A835002B07D0009B1888000402F018F9EA
+:106590003060388806E03888000402F011F9009A6B
+:1065A00030601088211C000402F00AF90599286067
+:1065B0000248FDF7BFFC07B0F0BDC046DD63000038
+:1065C0003C0300200C0F002034030020F8B5134CCE
+:1065D0007146061C201C7546FDF794FC104B0021EB
+:1065E0001A68201C131C723319700E4B1B681B7C1D
+:1065F000013BDBB2FF2B0DD059008F5B191C3831EA
+:1066000049003CB25118002C01DD8F80F0E70024D6
+:106610008C80EDE7291CFDF78DFCF8BD6D65000051
+:106620003C03002034030020F0B5744685B002948A
+:106630000E1C041C71461F48151CFDF763FC1E4B05
+:106640001B681A6AD2B2013AD2B2FF2A2AD0F7687E
+:106650005300FF5E696860680191002F1AD0E768F7
+:10666000FF5E002F16D0C05A716807B20397C95E4B
+:10667000039F7F1A7F10BC4601996044A768C852E7
+:10668000F95AB76808B28446F85E6746381A40106F
+:10669000411804E00199C05AA768C852F95AA8687D
+:1066A000C152D0E7237803482B700299FDF742FCD2
+:1066B00005B0F0BDC965000034030020F7B575468C
+:1066C0000195144D041C0F1C281C7146FDF71AFC83
+:1066D000114E0A2230680021683002F033F90F4B66
+:1066E00036681B68281C1A6AD2B2013AD2B200235B
+:1066F000FF2A09D0E56851004B53B1180D1C28350D
+:1067000030312B718B71F0E7237001993B70FDF7ED
+:1067100011FCF7BD5D6600003C030020340300203F
+:10672000F7B5124E73467146301C0193FDF7EAFB34
+:106730000F4D002428680527031C72331C703A1C77
+:10674000211C8A3002F0FEF828683A1C211C8F3088
+:1067500002F0F8F82868211C0A22743002F0F2F8DE
+:10676000301C0199FDF7E6FBF7BDC046C16600008D
+:106770003C030020F8B5154E041C0D1C301C71465E
+:106780007746FDF7BFFB124B301C1B685A1DD17FAB
+:106790009A1D00290CD021882E8826802980D27F3E
+:1067A000002A0ED01A680733DB7F013AD31A04E0BF
+:1067B000D27F002A05D05B68013B22881B029B1A0E
+:1067C0002380391CFDF7B6FBF8BDC04615670000F5
+:1067D00034030020F0B5724689B07146061C3B4870
+:1067E0000592FDF78FFB7068694633681E3107AC70
+:1067F0000880201C2380FFF7BDFF354B1B685A1D06
+:10680000D17FDD1D334A81CB00290CD01268EB7F8C
+:10681000411E013F9068C91A3F02DB01019709023E
+:106820001B18D7680BE0791E1268EF7F0138C01B78
+:106830009368D2680002FF0109020190BF18264A3E
+:1068400015682A6802920022A05E029AC0185B00B6
+:10685000C918504301F0B4FF80B2039020806868EB
+:10686000694604901E20085E049A019BC0197F00AF
+:10687000D919504301F0A4FF039B80B269461AB2B4
+:106880002B1CC883D4331B789A4203DD0299CB1AA0
+:106890009A4200DB23802B1CD5331B7800B2984230
+:1068A00003DD0499CB1A984201DB6A46D38307AB18
+:1068B00000201B5E694633601E23CB5E0348736075
+:1068C0000599FDF737FB09B0F0BDC04675670000BC
+:1068D000340300203C0300200C0F0020F0B572466A
+:1068E0008BB07146041C61480592FDF70BFB604BB1
+:1068F00000201B6802905A681D6A013A1202039236
+:106900001A68013D013A1202AB0004926E00019335
+:10691000681C00D192E0574B1B681A1CE6321778AE
+:10692000012F1AD1E168885F5188A269884212DD7F
+:106930002069EA33815B1B7899420CD95755694627
+:106940000022B5238A830E200B7706A90692FEF754
+:106950003BFF029701E000235355464B1F683B1C49
+:10696000EB331B78012B63D1E3689A5F3B1CEE335A
+:106970001B889A425CDD6068825FFF2A09DDA1689E
+:106980008B5FFF2B05DD0398824202DC04998B426A
+:106990004EDA374B62691B680533D97F364B0029C5
+:1069A00015D0019801211218186800235156D356AA
+:1069B000CB1A011CA83109681B024B430321515615
+:1069C00092781B1452B2891A0902A43014E001997A
+:1069D00018685218022303215156D356CB1A011CB2
+:1069E000A43109681B024B430121515612781B1434
+:1069F00052B2891A0902A83002680A2051430914C8
+:106A00008B4201DB584301E04843191C01F0D8FEDA
+:106A1000EC373B7898420BDDA2690123535508A956
+:106A20000022B6230E208A8008920B71FEF7CCFE5E
+:106A3000019B013D043B023E019369E70299002955
+:106A400005D10A480599FDF775FA0BB0F0BD084B62
+:106A50001B681B6A013BF4D3E0685A00125E002AEF
+:106A6000F8DDA1690122CA54F4E7C0467D68000040
+:106A7000340300200C0F00203C030020F0B57246C8
+:106A800093B07146041C59480392FDF73BFA584AEB
+:106A9000584B12681B6811793822514359182C3110
+:106AA00004A801F00DFF544B00261B685A681F68AC
+:106AB000013A120202920733DB7F013FFF1A3F02C5
+:106AC0004D4B1B681A6A964200DB88E0E16875004E
+:106AD0004A5F002A00DC80E0454A12681279012AE8
+:106AE0007BD06268505FFF2819DC0533DB7F049997
+:106AF00005AA002B02D06B46323301E06B461E33F1
+:106B0000FEF738FF616800B24B1900215A5E013A66
+:106B1000FF3A504380110130FF30188020E0029A84
+:106B2000101AFF281CDC0533DB7F049905AA002B13
+:106B300001D00FAB00E00AABFEF71CFF029A6168C0
+:106B4000013AFF3A4B1901920022995E029A00B273
+:106B5000511A0139FF394843019A8011121A1A80DB
+:106B6000A368585F244BFF2819DC1B680499053380
+:106B7000DB7F05AA002B01D00AAB01E06B46323364
+:106B8000FEF7F8FEA16800B24D190022AB5E013B92
+:106B9000FF3B584380110130FF3028801DE0381A38
+:106BA000FF281ADC1B6804990533DB7F05AA002B3C
+:106BB00002D06B461E3300E00FABFEF7DBFEA3688E
+:106BC00000B25D1900216A5E7B1EBA1A013AFF3AD3
+:106BD0005043FF3B80111B1A2B80013670E703489E
+:106BE0000399FDF7A7F913B0F0BDC0461D6A000078
+:106BF0003C0300200C0F002034030020F0B5764643
+:106C000097B0041C0D1CD24871460796FDF77AF91F
+:106C1000D04B1B689E680696DE6803961E69019637
+:106C20005E699B6905960293FEF776FDCA4B0126C5
+:106C30001B68FC331B780496002B54D00026049666
+:106C4000C64B1B681B6A9E424DDA68687700C35FBB
+:106C5000A9680C93CB5F0CA80D93FFF7BBFDE2680E
+:106C6000D35F002B3DDD6068A168C35F0AA80A936B
+:106C7000CB5F0B93FFF7AEFD0A9B069A9A4209DAA7
+:106C80000398984206DD0B9A0199914202DA059821
+:106C9000904221DCE968CA5F002A19DDB04A126817
+:106CA00092192832127952B2012A11DD06980299FE
+:106CB000421A9A420CDA039842189A4208DD019867
+:106CC0000B9B421A9A4203DA059842189A4206DC54
+:106CD000E1680023CB5304E00122049201E0012388
+:106CE00004930136ACE79F4B1B78002B00D18DE05D
+:106CF0002378012B00D089E000206E4608A9B084DB
+:106D00000B702122222623216A446E4469441370A9
+:106D100033700B7009AAF323137008A9924AFEF787
+:106D200053FD924B00269B5F0E93914B00201B5E00
+:106D30000EA80F93FFF74EFD6168A2680023CB5E9B
+:106D400010A810930023D35E1193FFF743FD119B0E
+:106D50000F9A991A0A2901DD322B0CDCD21A0A2A61
+:106D600002DD844A934206DD109B0E9A991A0A2985
+:106D700003DD322B01DD00260CE0D21A0A2A05DCE5
+:106D8000784A00231370784A13703FE07A4A93429E
+:106D9000F1DDF5E7744B02961B78029E9E42EFDA16
+:106DA000029E724A7300D25E12A81292704AD35E9B
+:106DB0001393FFF70FFD14A80378802252421A4361
+:106DC000DF231A4040231A4310239A430F239A4388
+:106DD00001210A4346780270129A13991712321C45
+:106DE0009A431F4017430E121F40129B36018370B7
+:106DF0003E4332234670C1700371FEF797FCFEF7E5
+:106E0000DBFAFEF789FC029E0136C3E70126534BED
+:106E100002961B68029E186A013E0196864200DBBC
+:106E2000E5E0029E5548696833185F00CB5FAA68A9
+:106E30000C93D35F0CA80D93FFF7CCFCE668F35FCF
+:106E4000002B00DCA3E06068A168C35F0AA80A9376
+:106E5000CB5F0B93FFF7BEFC0C9B0B9E9C46404BFD
+:106E600003961B68019E06939B1968331E78444B5A
+:106E70000A9A0D981B68002E01D1503300E051335F
+:106E8000E9681B78CE5F002E0EDD039E301AC11715
+:106E900040184840984207DA6646911BC8170918FF
+:106EA0004140994200DA8FE0049E002E00D18BE031
+:106EB00014AE317880235B420B43DF210B4040212D
+:106EC0000B433370A169019BC85C012331781840E2
+:106ED000102399438C4602990F2319400591000114
+:106EE00061460843059998430143101218403170D8
+:106EF00071780590039899438C4601120901059811
+:106F000000916146084300991840B270039AE36803
+:106F100001437170F270DA5B131C12B2FF2A00DDBC
+:106F2000FF233371069B301CA0331B6801999847DF
+:106F3000301CFEF7FBFBEE68094BF25F1B68019EFD
+:106F40009B19002A1EDD1A1C683201231DE0C04671
+:106F50009D6B00000C0F0020400000203403002037
+:106F60003C030020F5040020F4040020E00400208D
+:106F7000CC0400204D07000005040000FFFFFF7F48
+:106F8000080F00201A1C6832002313701CE0E86808
+:106F9000C35F002B18DD14A800234360029B0F2160
+:106FA0000B40402213430C9A037013129C460D9B16
+:106FB00082701E123601019666463140019EC370F2
+:106FC0000E434670FEF7B2FBE068E968C35B626897
+:106FD000CB53D35B6E68A068F353C35BA968226987
+:106FE000CB532E69D35BF353029E01360FE71B6927
+:106FF0005E1E02960F2602981E40284F013034D0A4
+:107000000298396840000B181A1C80320190002049
+:10701000125E7433002A0FDC1B881AB2002A16DDB8
+:10702000002114A814914160802131430170FF2A8E
+:1070300000DDFF23037108E000215B5E002B06DC0E
+:1070400014A80023149343600670FEF76FFB019AA7
+:107050003B68013E9B181A1C74331B8880321380D6
+:10706000029B013B02930F23C5E723782B703B68FB
+:107070001A1C72321178117328780122002802D16B
+:107080000A1C511E8A4196331A70FEF795F904487E
+:107090000799FCF74FFF17B0F0BDC0463C03002036
+:1070A0009D6B000010B502248B7804575AB29442AD
+:1070B00000DD8370CB78032404575AB2944200DA7F
+:1070C000C3700B78002404575AB2944200DD037059
+:1070D0004B78012141565AB2914200DA437010BDFB
+:1070E000F0B58FB00A910A9C0893C36864001D5FD5
+:1070F0000C94069554000494069E1C5F0A9D4368F8
+:107100003619AD0005960131960009955D19071CE9
+:107110000D91985906992B6860434B430599C01807
+:107120000B9201F04DFBBB6800B22860099A985998
+:107130009D182B684443069805994343E01801F0D5
+:107140003FFB3969099C00B228600422081908999C
+:1071500001F0B6FBFB680C9D049C5A191B191088A2
+:1071600019884118118000221A807B695A191B5B0B
+:107170000025505F19B288420ADA1380BB69049D6A
+:107180001A190C9C52781B195A70BB695A5D1A5512
+:107190000B9B013301240F2B09DC159D0998A9597C
+:1071A0002A1815689C400C402C431460F1E7159D8B
+:1071B0000023AB510A9D0B9E211CB140AC40159A97
+:1071C000A446CD430B9EB3421ADA1068014214D094
+:1071D0000A9EB34203DA6446204310600AE00A9E26
+:1071E000B34207DD159C099EA019046801269E4044
+:1071F0002643066010682840106001330432E1E73E
+:10720000089C247864B20794089D0123EB56079EDE
+:107210009E4200DDACE0089DAD786DB2089E0495FD
+:107220000323079AF356049C01329C4200DD9DE043
+:10723000624B049C1B68149D9E68724301321219B4
+:10724000AA181178B4460139112900DC8BE001201D
+:10725000052340420024013B002B29D0584EF5184D
+:1072600001267642AE57079DAE1901366546754335
+:10727000534E0595F518ED79049E6DB20295149D57
+:10728000AD19059EAD19029EAD1905956D78013DAC
+:107290000F2DE0D80A9EB54202D00B9EB542DAD13E
+:1072A000461C03D0A842D6D00124D4E7281CD2E73C
+:1072B000002C58D0122955D10D9C05251470069527
+:1072C000069C013C0694002C4DD03D4B069E0724A5
+:1072D0009A19131C013B1B78079E5BB2F618374BBB
+:1072E00014571A68331C926801335343049D0133C9
+:1072F0002C19149D1B19EA181178B4460029DFD106
+:10730000169E5B009B5B002BDAD01221117078680F
+:10731000099D4619F8680C9D326840190290008852
+:10732000099D019001B2181C60434A4300021018E5
+:10733000BA685419654622685D4351432D02AC4634
+:10734000614405910199029A5D18ADB215802DB284
+:10735000291C01F035FA291C3060059801F030FA3B
+:107360002060ADE71170049D013557E707924BE7A8
+:107370000022AA56089E0123F3569A421BDC089C61
+:107380000223E356089D03202856511C834210DC3B
+:107390000A48149D00680B9E806841430131C9185A
+:1073A000691808780138B04201D10D9C0C70013386
+:1073B000E8E70A1CDEE70FB0F0BDC046340300204A
+:1073C00098890000F0B591B075460B91061C714686
+:1073D00041480D950C920793FCF794FD0024F76843
+:1073E0006300FA5E002A6DD0B0690125C3185D57AD
+:1073F0001B7809955BB20893013D0695099F069D90
+:1074000001370A97BD425DDC089F013F0597089B45
+:10741000059F01339F4252DC304B06991B680131B6
+:107420009A68059D51430B9F481C40193D5C013DE6
+:107430000F2D40D8AC423ED077696300DB5F284F08
+:1074400040003F683F89BC46079FC05B834232DCF7
+:10745000089F6046C91943430131079F4900C95B32
+:107460009B118B4227DA0A9F7A43059FBA18013293
+:10747000079F5200D25B93421DDAA54202DB2B1C10
+:10748000251C1C1C3769A100791804220FA801F0E3
+:1074900017FAA90079180FA8FFF704FE0B9F221C0A
+:1074A00000970C9F301C0197079F291C02970FAB78
+:1074B000FFF716FE2C1C059D02350595A7E7069DD6
+:1074C00002359AE701340F2C89DD03480D99FCF74A
+:1074D00031FD11B0F0BDC0466573000034030020DB
+:1074E000080F0020F0B5A7B07546071C0C91C848DE
+:1074F000714613920D931A95FCF704FD139A0D9B98
+:10750000381C0C99FFF75EFF2C9EC24B3278012A83
+:1075100007D13A78012A04D91B689C881494DB8827
+:1075200003E01B681D8814955B880F26159306964B
+:10753000069B069C013B002C00D171E1139C9A0034
+:10754000069D12590795EA400F9206930F9D002D54
+:10755000EED0079E102EEBD00F9E0120064200D1E8
+:107560004FE1079D069C7B68A400AE001959BA68DC
+:107570009B590894C91A14599359CD17E31A4C19F9
+:107580006C40DD1710945C196C40109D0B94A54263
+:1075900002DD1190180203E0002408021194191C66
+:1075A00001F00EF93C691CADA11904221290281CAF
+:1075B00001F086F908982118281CFFF773FD7968F7
+:1075C000089CFB680859079C20906100CC5E0994D8
+:1075D0007C68A4590A94069C6200D45E099B099AAF
+:1075E00058430A9BA2186343111CC0180E9201F065
+:1075F000E7F821900A98BB68089922905858099A90
+:1076000023909E59504374430E99001901F0D8F805
+:107610000024249000211DA80C22259601F092F947
+:107620002C5701260994AE57022416962C577A4BF4
+:107630001794ED781B686DB218951993099C169DE7
+:10764000AC4200DD9FE0099D179E2D020E95089625
+:107650000999089D189E0131B54200DD91E0199C01
+:10766000089EA0680C9C414301318919645C8446E2
+:10767000231C013B0A940F2B44DD0020012205232B
+:107680005242041C013B002B2BD0644EF5180126FE
+:107690007642AE57099DAE190136654675435F4E79
+:1076A0000595F518ED79089E6DB204950C9DAD1900
+:1076B000059EAD19049EAD191B956D78013D0F2DEA
+:1076C000E0D8069EB54202D0079EB54205D1561CB1
+:1076D00005D0AA42D6D00124D4E70120D2E72A1C43
+:1076E000D0E7013249D04900002C01D1002802D155
+:1076F0000D9C605A11E00D9D685A0A99113901F0EC
+:107700005FF80AE05E1C38D0069CA34202D0079DB9
+:10771000AB4232D10D9E4900885B00282DD0089CD9
+:1077200003232102013B28D3119D20AC23AA9E00F4
+:10773000002D09D095590E9A551B129A5543A259FE
+:107740002D12551B6D1A08E0A559129C4D1B65435F
+:1077500092592D120E9E551BAD1BEA17AD185540C0
+:10776000FF2DDFDC80267600751B45439C001DAA9B
+:10777000A6582D127519A550D4E7089C0134089419
+:1077800066E709915AE71F9B1D9C9C4200DD1C1C6B
+:10779000119E002E06D10B9D331C002D0DD0109E86
+:1077A00010950B960B9D1099A80101F009F83F2840
+:1077B00000DD3F20194B1818037C2D21149E159DC8
+:1077C000C81A70436B43C01800F0FAFF44431E9B75
+:1077D000A412A34215DD079E069CA64201DB079476
+:1077E00006960C9D139E0D9C00951CAB0196029471
+:1077F000381C0799069AFFF773FC069B079D0793B1
+:107800000695079E0F9C0136640807960F949DE627
+:1078100085740000080F00203403002098890000C0
+:107820002C4B3C70186801211C304942102201F099
+:1078300089F8069C251CF8686600825FE3B2002A7E
+:1078400024DD3A7801323A70224A1268121915770B
+:107850009D4219D07A68A300D158A8001150BA6887
+:107860000790D1581150FA686800925B011C101CF7
+:10787000FA6888523969079A8818C918042201F0F1
+:107880001FF8F868002383530135EDB20134102C42
+:10789000D1D123A9002323938B800F4B7F201B681A
+:1078A0000C9D1A680A705C684C709A68CB788A7074
+:1078B0008343012003431218CB70AA1830230620FB
+:1078C0000B71FDF781FF05481A99FCF733FB27B0D0
+:1078D000F0BDC0463C030020340300208574000046
+:1078E000164BC2171B68801850401A1CA43270B582
+:1078F000A8331468CA1789181D68514044434D4382
+:1079000024142D14AC4202DB231C2C1C1D1CA001D2
+:10791000291C00F055FF0A4E3018037C281C002B50
+:107920000BD05A22D21A52365200955B5B00684344
+:107930009D5B00146C432414001970BD3C030020AF
+:1079400098890000F0B575469BB0041C0F1C844854
+:1079500071460D9508921E1CFCF7D4FA814B1D68E8
+:1079600023782A6A934200DD131C01213B704942AF
+:1079700010220EA800F0E6FF12A8FF21202200F03E
+:10798000E1FF794B2D6A1B6809950A93774B002517
+:107990001B6804950B93049D0998854257DA089853
+:1079A000049DC0686D00435F0795002B4AD0049B7F
+:1079B0000A9D10339B000B985B592578C0689B008B
+:1079C0000C9500251B180595012506936D42059819
+:1079D0000C99C3B28B421FD20598E16843005B5EED
+:1079E000002B15D0830007997068425E6168C85803
+:1079F0000799801AB268525E9446A268D1586346CD
+:107A0000C91AFFF76DFF0699884201DA059D0690B5
+:107A1000059A01320592DAE76A1C13D00EAB59576A
+:107A20006A0012AB013108D0995A0698814209D9EF
+:107A30009852049B0EAA535504E006980EA998523A
+:107A4000049A4A55049B0133DBB20493A3E7002553
+:107A50002378AB4228D90EA94E5D73B2013320D0F2
+:107A60006068A9004258F6B278687300C252A068F4
+:107A70004258B868C252E0686A00105A0492FA6824
+:107A8000D0527A692369B00010185918042200F006
+:107A900017FF354B049812AA1B681036825AB6009D
+:107AA000F2500135EDB2D3E700252378AB423ED941
+:107AB0000EA94B57013337D1E3686A009A180026A4
+:107AC000935F0492002B2FD0264B00201B681B6A6B
+:107AD0000593059EB04227DA08994300C968CE5E37
+:107AE000002E1ED1FE68F6180022B15E069600290F
+:107AF00017D162680EAE7055A90056587A6880009A
+:107B0000D652A2685658BA68D652049A069E13886E
+:107B10007A693380236910185918042200F0D0FEC6
+:107B200002E00130C0B2D4E70135EDB2BDE70D4B44
+:107B3000002218680C4B1B68197F046AA14202DA04
+:107B40000EAD695C00E0FF210132D2B2197701333A
+:107B5000102AF1D102480D99FCF7ECF91BB0F0BDE9
+:107B6000E5780000340300203C030020080F0020CB
+:107B7000F0B59BB074460B91051C71466248129497
+:107B80000C92FCF7BFF9FEF753FC604B0D901B689D
+:107B90001C6A013C611C00D1B0E0EF686600BF19AF
+:107BA000059608970026BE5F0796002EF1DD6969ED
+:107BB000A300C918554B02201B68032208568A5699
+:107BC0001093534B00261B688C460E920A93039623
+:107BD00006960E99884263DC674601217956002299
+:107BE0000302BA560F9111930F9F431CBA4255DC02
+:107BF000109E571CB668391C714304960B9EC91819
+:107C0000735C0997102B23DD0523013B002B2BD040
+:107C1000404EF718F618013EFF7936787FB276B2FB
+:107C200002979619049F013677430B9E0197029F96
+:107C30003618F719019EBE1913967678002EE4D0F7
+:107C40000A9F76B2BE19F67E76B2A642DDD108E072
+:107C5000002B09D00D9F1B26FB189E570023A64220
+:107C600002D10C9E49008B5B6F68059E1202B95FC2
+:107C7000119E891BCF17C91979405943069EAF68D9
+:107C800076180696059EB95F039E8A1AD117521878
+:107C90004A405343F6180396099AA5E7181C98E73B
+:107CA0000799069800F08CFD0799061C039800F0D0
+:107CB00087FD011C301CFFF713FE0A9EB369984232
+:107CC00000DA181C2F69059E15A9B853089F80B2C9
+:107CD0000023FB5E1890199300238B8001230B7007
+:107CE00003234B708B707C235B42CB701220B0233C
+:107CF00017AA17940B71FDF767FD4AE7024812991E
+:107D0000FCF718F91BB0F0BD117B00003403002014
+:107D10003C030020988900000F4AC378126810B510
+:107D200051685CB201398C4201DA0133C370837847
+:107D300059B2002901DD013B83704378126859B2C2
+:107D4000013A914201DA0133437003785AB2002AB2
+:107D500001DD013B037010BD34030020F0B593B08A
+:107D600075460591071C7146CD48089209930B95FD
+:107D7000FCF7C8F80EA900238B80CA4B059C1B6832
+:107D80009A6858681E688A70012301324870CB7067
+:107D9000A218082306200B710E70FDF715FD1023A5
+:107DA000013BDBB2FF2B0BD03D699A00A9187F2065
+:107DB000087088703E69FF21B2185170D170EFE7EA
+:107DC000B94B00221B68189C1A600923E356189DC2
+:107DD0000822AA56934269DB189D0B22AA56189CCA
+:107DE0000A2161568A425FDBAE49059E0868591C2C
+:107DF000806841430131891870180478251C113DB1
+:107E00002D2D02D8002101704CE0013CE4B20F2C72
+:107E100048D8099D4900485BA3497E6809680D68F8
+:107E200001350D60A1007518061C5643B4462E6836
+:107E30006400B44466462E60BE687518061C5E4336
+:107E4000B4462E68B44466462E60FE6835192E8806
+:107E500086192E803E6975180226AE57B24200DAA6
+:107E6000AA703E6975180326AE57B24200DDEA706B
+:107E70003E6975180026AE57B34200DA2B703D6993
+:107E8000691801254D57AB4200DD4B707E693119F1
+:107E900000268D5F854205DA0880B86901194B70AC
+:107EA000B9690A55013A9AE7013B90E70026049622
+:107EB000F868049C035F002B01D10024F8E0049CC7
+:107EC0003D69640028190694FFF726FF3E693319BF
+:107ED00001269E573869069C002203199A5696423D
+:107EE00000DAD6E0DB785BB202933D69069C2B1981
+:107EF0009B78029D5BB29D4200DAC8E0694B029C10
+:107F00001B68059D9B6801930198731C43430133D3
+:107F10001B19ED182A780395002A02D03F2A00D0B9
+:107F2000B1E0099D5B005C5B002C00D1ABE000235D
+:107F30000D930523013B002B21D05C4A0725D11866
+:107F40000A1C4D57012149425156019871180131BF
+:107F500048430599844602980A1852196244517898
+:107F60004A1E0F2AE6D800220DA8855C002D01D1FB
+:107F70008154DFE78D42FBD00132D2B2F4E70DAA83
+:107F80009A5CDDB20195002A04D00133042BF6D1AE
+:107F9000019302E0019D002D75D00199201C00F095
+:107FA0000FFC019D039911350D700795029D311C41
+:107FB0004543414303950A91002301997D688C460E
+:107FC000012149428C440DAA63451CDAD25C241A73
+:107FD000013A91006D1800922A6801339446039A81
+:107FE000944462462A60BD6869180A6894460A9AF1
+:107FF000944465460D600099FD684A00AA181188EE
+:1080000009181180D9E7D35C5B1802999A00614383
+:10801000AD1828685B0041182960B968F8688A18AB
+:10802000211C71431568C318691811601A880799D3
+:1080300014191C800023122925D0634523DA01334B
+:108040001A1C019DAA42F8DA0DA8C1180139097855
+:10805000105C01390138C9B2C0B20124814208D292
+:10806000089D890069188440201C0C682043086022
+:1080700007E0089D800028188C40211C04682143DB
+:1080800001600132DDE7029C013C02942DE7013ED4
+:1080900020E7049D02350495202D00D008E70CE769
+:1080A000FD7C0000340300203C0300209889000080
+:1080B000FE686200925BE3B2002A19D07868A500DE
+:1080C000461911B232680291100200F079FBBB68C8
+:1080D00030605E19316801340802029900F070FBCB
+:1080E0003A6930605019FFF717FE102CE0D1231CBD
+:1080F00010A93B7000238B800B4B059E1B6806204C
+:108100009A681C685D688A7001230132CB70B218CE
+:108110002D230B710C704D70FDF756FB03480B9926
+:10812000FBF708FF13B0F0BD34030020FD7C000016
+:1081300070B5074C061C7146201C7546FBF7E2FE25
+:10814000044B291C201C1E60FBF7F4FE70BDC046CA
+:10815000D1800000100F002070B5074C7146201C24
+:108160007646FBF7CFFE054B201C1D68311CFBF744
+:10817000E1FE281C70BDC046F9800000100F0020F1
+:10818000F0B595B009931AAB1B7875460C90069123
+:10819000C5487146109311950A92FBF7B3FE069EEF
+:1081A000C24C00237372F37220687F233372B37260
+:1081B0000379002B07D1BD4B1B689A7B002A00D0A6
+:1081C00005E107921AE10323C3562027FF1A022371
+:1081D000C3567F00FF1A7F10FFB20797099F7F6881
+:1081E00005970622815E0823C25E0A23C356C07A21
+:1081F00040B20090381CFDF7A1FBAD4B80021D681A
+:10820000296800F0DDFA24686A682378002B00D121
+:108210006EE01C9D911CEB8849006B802B892E1C05
+:108220002B800B1FEB181D887552991E0988D98069
+:108230006178002903D0079D6FB27F0039E0023BCF
+:10824000013A39D35E88DD88032161567519079E8E
+:108250004D431F8871B21E89BE194E430221AD19CC
+:1082600061569E8871436918891141430914198127
+:10827000E5E7032565575988DE886D00AC460D1C7F
+:10828000B14200D2351CADB266466E431D89B4467C
+:108290001E88311CAE4200D2291C0225655789B2C6
+:1082A0009E887943754361444D19AD1145432D14A2
+:1082B0001D81023B013ADCD2099F0D207F680497A3
+:1082C00020560622A15E0823E25E0C23E3560090AE
+:1082D000381CFDF733FB764B80021C68616800F0A8
+:1082E0006FFA724B226819680B78002B0CD161E091
+:1082F000531C1C9F5B00FB18013ADDD31988023B1D
+:1083000041430914D980F7E71B9CE388251C63804F
+:108310002389261C2380941C6400231FEB181D88CE
+:1083200035539C1E2488DC804C78002C03D0079C9D
+:1083300067B27F003AE0023B013A00D23BE75E8839
+:10834000DD8803240C577519079E65431F8874B296
+:108350001E89BE1966430224AD190C579E887443CA
+:108360002C19A411444324141C81E4E703254D5720
+:108370005C88DE886D00AC46251CB44200D2351CFA
+:10838000ADB264466C431E881D89A446341CAE42BF
+:1083900000D22C1C02254D57A4B29E887C43754305
+:1083A00064446519AD1145432D141D81023B013A0A
+:1083B000DCD200E7531C1B9D5B00EB18013A00D296
+:1083C000F9E61988023B41430914D980F6E7099E72
+:1083D0001027D95F70680024079488420EDD1225AB
+:1083E0005A5F1B7D01265BB20093231CFDF7A6FAA2
+:1083F00010231B1A9B000B900D9307962C4B00210A
+:1084000018682A4B07681B68BC460E93099167469B
+:108410004368791E00D28FE01B9C4A00A2180F927D
+:10842000013B00D286E0079D8468002D42D066465D
+:1084300066430896F6180A9F01367600BD5B5F1CFE
+:108440002AB2D243D2172A408D1C654302967D1969
+:108450000A9E6D00AE5F12B20396964200DA039256
+:10846000089E341B3C190A9F6400E45F944200DAC2
+:10847000141C039E0A9F3519029C3E190224375F83
+:10848000141EBC4200DA3C1C023E2D190027F45F8A
+:10849000161EA64200DA261CAD190B9C0D9E6543E4
+:1084A0007243AA1892110CE021810000100F0020E5
+:1084B0003403002067467C431C1901340A9D640084
+:1084C000625F0E9E3479002C07D01C9F5C003C1923
+:1084D00024890F9D121B2C89121B109EB24218DD9D
+:1084E000069F0B243C579C4200DAFB72069D0A242F
+:1084F0002C579C4200DDAB72069E092434578C42F7
+:1085000000DA7172069F08243C578C4203DD3972F1
+:1085100001E0002A04DD099C944202DA099200E09D
+:108520000022846865466C431C1901340C9EA4002B
+:10853000A25175E78C466AE70999069C00222160E2
+:1085400012A98A80826805680C9E4B708A707C2311
+:1085500001325B429200CB70B218832305200B716D
+:108560000D70FDF731F903481199FBF7E3FC15B0E5
+:10857000F0BDC04621810000014B18687047C0461D
+:108580004003002000487047A4070000014B186812
+:108590007047C04640030020024B1868F930FF3096
+:1085A0007047C04640030020C4235B005843034B80
+:1085B0001B681818C3239B00C01870474003002095
+:1085C0000A235843034B1B681818BB239B00C01891
+:1085D0007047C04640030020014B18607047C046FA
+:1085E000140F0020014B18687047C046140F00207C
+:1085F00000487047B4B7000038B5FAF7B1FB0F4B2D
+:1086000041791B68012559604279941C2A40A218BF
+:108610009A6082791A604A43DA60427902219A614B
+:10862000AA40DA61026859611A62C2791A61017955
+:108630005A1DD17702790633DA7738BD340300202A
+:1086400010B5124C1249134A206800F039F920681D
+:10865000FAF780FB2068B430F8F7A0F92068EC3016
+:10866000FDF7A0F92068F430FDF7CAFE2068F53068
+:10867000FF30FCF789FDFFF7BFFF074C201CFAF71E
+:1086800081FB064BE018FDF7A5F910BD4003002063
+:1086900010B00000A4070000B4B70000C50300003C
+:1086A00038B5174BC424596864000A781B685443D2
+:1086B000C2229200A4181C19124B201D1860FAF750
+:1086C00055FBBA235B00E518281CFFF731FD201C81
+:1086D000F830F8F76FF9862149006018FDF76EF958
+:1086E00090225200A018FDF797FE281CFCF758FDB9
+:1086F000054B9E341B6822780733DA7738BDC046B5
+:1087000040030020140F002034030020014B5B685D
+:108710001870704740030020014B5B681878704761
+:1087200040030020002934D00123002210B48842E5
+:108730002CD301242407A14204D2814202D2090190
+:108740001B01F8E7E400A14204D2814202D24900B1
+:108750005B00F8E7884201D3401A1A434C08A04254
+:1087600002D3001B5C0822438C08A04202D3001BEA
+:108770009C082243CC08A04202D3001BDC08224301
+:10878000002803D01B0901D00909E3E7101C10BC25
+:108790007047002801D00020C04307B4024802A15E
+:1087A0004018029003BDC046D90000000029F0D057
+:1087B00003B5FFF7B9FF0EBC4243891A1847C046FC
+:1087C000002941D010B4041C4C40A44601230022CF
+:1087D000002900D54942002800D5404288422CD3C8
+:1087E00001242407A14204D2814202D209011B01C3
+:1087F000F8E7E400A14204D2814202D249005B00C2
+:10880000F8E7884201D3401A1A434C08A04202D329
+:10881000001B5C0822438C08A04202D3001B9C086A
+:108820002243CC08A04202D3001BDC0822430028CC
+:1088300003D01B0901D00909E3E7101C6446002C92
+:1088400000D5404210BC7047002806D003DB002052
+:10885000C043400801E08020000607B4024802A19E
+:108860004018029003BDC046190000000029EBD05B
+:1088700003B5FFF7A7FF0EBC4243891A1847C0464D
+:108880007047C046F8B50D1C041C081C111C161CB2
+:10889000FFF796FF311C071C281CFFF7E7FF002D90
+:1088A00005DB002908DB2760201C6160F8BD00297A
+:1088B000F9DD013F8919F6E70137891BF3E7C04667
+:1088C000F0B50F2A35D9031C0B439C0735D1161C74
+:1088D000103E36093501451910350C1C031C27685C
+:1088E0001F6067685F60A7689F60E7681034DF609B
+:1088F0001033AB42F3D1731C1B01C518C9180F23E9
+:108900001340032B1BD91C1FA4080134A40000230F
+:10891000CE58EE500433A342FAD1ED18C918032300
+:108920001A4005D00023CC5CEC5401339342FAD1B9
+:10893000F0BD051C002AF5D1FAE7051CF2E71A1C68
+:10894000F8E7C046F0B5830746D0541E002A42D04F
+:10895000CEB2031C032503E0621E002C3BD0141C86
+:1089600001335A1E16702B42F6D1032C2BD9FF254A
+:108970000D402A0215432A0415430F2C15D9271C34
+:10898000103F3F091E1C3A011036B6181A1C15601C
+:1089900055609560D5601032B242F8D101373F0181
+:1089A0000F22DB191440032C0DD9271FBF08BA0072
+:1089B0001E1DB6181A1C20C2B242FCD10137BF00DE
+:1089C0000322DB191440002C05D01C19C9B2197000
+:1089D0000133A342FBD1F0BD141C031CC5E7C04604
+:1089E000AE0174033B050207CD08940A590C1F0E13
+:1089F0000600000008000000FF000001FF01FF0169
+:108A000000FF0100FFFF010100010203040405064D
+:108A10000708090A0B0B0C0D0E0F1011111213147D
+:108A2000151516171818191A1B1B1C1D1D1E1F1FA4
+:108A300020212122232324242525262727282829ED
+:108A4000292A2A2B2B2C2C2D2D0000007804EF082E
+:108A5000660DDB115016C21A331FA1230C28742C8B
+:108A6000D93039359639EE3D42429046D94A1B4FAE
+:108A700058538E57BE5BE65F07641F68306C3970D1
+:108A800038742F781C7CFF7FD983A8876D8B278F44
+:108A9000D5927996109A9B9D1BA18DA4F3A74BAB01
+:108AA00097AED4B104B526B839BB3EBE34C11BC4A1
+:108AB000F2C6BAC973CC1BCFB3D13BD4B2D619D945
+:108AC0006EDBB3DDE6DF08E218E416E603E8DDE975
+:108AD000A5EB5BEDFEEE8FF00DF277F3CFF414F61D
+:108AE00046F764F86FF967FA4BFB1BFCD8FC81FD75
+:108AF00017FE98FE06FF5FFFA5FFD7FFF5FFFFFFFC
+:108B0000480000204803002000000000FF00000093
+:108B10000000000000000000000000000000000055
+:108B20000000000000000000000000000000000045
+:108B30000000000000000000000000000000000035
+:108B40000000000000000000000000000000000025
+:108B50000000000000000000000000000000000015
+:108B60000000000000000000000000000000000005
+:108B700000000000000000000000000000000000F5
+:108B800000000000000000000000000000000000E5
+:108B900000000000FFFFFFFF0000000000000000D9
+:108BA00000000000000000000000000000000000C5
+:108BB00000000000000000000000000000000000B5
+:108BC00000000000000000000000000000000000A5
+:108BD0000000000000000000000000000000000095
+:108BE0000000000000000000000000000000000085
+:108BF0000300000000000000000000000000000072
+:108C00000000000000000000000000000000000064
+:108C100000000000000000009003002090030020EE
+:108C200080030020900300207C040020AD0400207D
+:108C3000A50400209D04002000000000280300205F
+:108C40000000000026030020180300200A03002073
+:108C500009030020000000007C0400202C020020FA
+:108C60008C04002002000000EC0E00200000000038
+:108C700000000000070000009B0400200503002006
+:108C80009C04002000000000000000000000000024
+:108C900000000000E0020020CC02002000000000E4
+:108CA0000000000000000000B802002000000000EA
+:108CB000A4020020000000008C0200200000000040
+:108CC0007002002000000000000000000000000012
+:108CD000580200204402002030020020010300203E
+:108CE000FC0200200000000097040020002000602B
+:108CF000280200209404002040020020010000000F
+:108D000004000000B8010020950400205402002057
+:108D100001000000010000001C0200206B02002086
+:108D20006802002003000000040506001020000077
+:108D3000BC01002085020020800200200500000008
+:108D40000401060104001020303100008C010020D5
+:108D50009F0200209C020020030000000401060086
+:108D6000102000001003002096040020B402002010
+:108D7000010000000400000084010020CA0200205D
+:108D8000C802002002000000020E0010A80100200E
+:108D9000DC020020B40100200300000000101100DC
+:108DA0006C010020F6020020F00200200600000006
+:108DB0001708080C0A08002030405070010000001D
+:108DC000000020050100200100FF0020010000003C
+:108DD00014030020006008010001000000000000F2
+:108DE00000000000000005004D4950000000000098
+:108DF00000040000F80400202005002034050020B5
+:108E0000E4050020E0050020FFFFFFFFFFFFFFFF5C
+:108E1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF62
+:108E2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF52
+:108E3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF42
+:108E4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF32
+:108E5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF22
+:108E6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF12
+:108E7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF02
+:108E8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2
+:108E9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE2
+:108EA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD2
+:108EB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC2
+:108EC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB2
+:108ED000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA2
+:108EE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF92
+:108EF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF82
+:108F0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF71
+:108F1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF61
+:108F2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF51
+:108F3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF41
+:108F4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF31
+:108F5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF21
+:108F6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF11
+:108F7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF01
+:108F8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1
+:108F9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE1
+:108FA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD1
+:108FB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC1
+:108FC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB1
+:108FD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA1
+:108FE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF91
+:108FF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF81
+:10900000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF70
+:10901000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF60
+:10902000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF50
+:10903000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF40
+:10904000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF30
+:10905000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF20
+:10906000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF10
+:10907000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00
+:10908000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0
+:10909000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
+:1090A000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD0
+:1090B000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC0
+:1090C000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB0
+:1090D000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA0
+:1090E000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF90
+:1090F000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF80
+:10910000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6F
+:10911000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5F
+:10912000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4F
+:10913000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3F
+:10914000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2F
+:10915000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1F
+:10916000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0F
+:10917000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
+:10918000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEF
+:10919000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDF
+:1091A000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCF
+:1091B000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBF
+:1091C000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFAF
+:1091D000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9F
+:1091E000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8F
+:1091F000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7F
+:10920000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6E
+:10921000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5E
+:10922000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4E
+:10923000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3E
+:10924000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2E
+:10925000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1E
+:10926000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0E
+:10927000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE
+:10928000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEE
+:10929000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDE
+:1092A000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCE
+:1092B000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBE
+:1092C000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFAE
+:1092D000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9E
+:1092E000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8E
+:1092F000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7E
+:10930000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6D
+:10931000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D
+:10932000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4D
+:10933000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3D
+:10934000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2D
+:10935000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1D
+:10936000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0D
+:10937000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD
+:10938000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFED
+:10939000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDD
+:1093A000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCD
+:1093B000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBD
+:1093C000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFAD
+:1093D000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9D
+:1093E000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8D
+:1093F000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7D
+:10940000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6C
+:10941000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5C
+:10942000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4C
+:10943000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3C
+:10944000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2C
+:10945000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1C
+:10946000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0C
+:10947000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC
+:10948000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEC
+:10949000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDC
+:1094A000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCC
+:1094B000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBC
+:1094C000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFAC
+:1094D000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9C
+:1094E000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8C
+:1094F000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7C
+:10950000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6B
+:10951000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5B
+:10952000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4B
+:10953000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3B
+:10954000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2B
+:10955000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1B
+:10956000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0B
+:10957000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB
+:10958000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEB
+:10959000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDB
+:1095A000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCB
+:1095B000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBB
+:1095C000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFAB
+:1095D000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9B
+:1095E000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8B
+:1095F000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7B
+:10960000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6A
+:10961000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5A
+:10962000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4A
+:10963000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3A
+:10964000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2A
+:10965000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1A
+:10966000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0A
+:10967000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA
+:10968000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEA
+:10969000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDA
+:1096A000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCA
+:1096B000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBA
+:1096C000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFAA
+:1096D000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9A
+:1096E000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8A
+:1096F000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7A
+:10970000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF69
+:10971000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF59
+:10972000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF49
+:10973000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF39
+:10974000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF29
+:10975000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF19
+:10976000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF09
+:10977000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9
+:10978000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE9
+:10979000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD9
+:1097A000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC9
+:1097B000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB9
+:1097C000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA9
+:1097D000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF99
+:1097E000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF89
+:1097F000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF79
+:10980000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF68
+:10981000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF58
+:10982000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF48
+:10983000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF38
+:10984000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF28
+:10985000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF18
+:10986000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF08
+:10987000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8
+:10988000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE8
+:10989000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD8
+:1098A000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC8
+:1098B000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB8
+:1098C000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA8
+:1098D000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF98
+:1098E000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF88
+:1098F000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF78
+:10990000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF67
+:10991000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF57
+:10992000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF47
+:10993000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF37
+:10994000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF27
+:10995000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF17
+:10996000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF07
+:10997000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7
+:10998000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE7
+:10999000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD7
+:1099A000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7
+:1099B000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB7
+:1099C000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA7
+:1099D000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF97
+:1099E000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF87
+:1099F000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF77
+:109A0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF66
+:109A1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF56
+:109A2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF46
+:109A3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF36
+:109A4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF26
+:109A5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF16
+:109A6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF06
+:109A7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6
+:109A8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE6
+:109A9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD6
+:109AA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC6
+:109AB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB6
+:109AC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA6
+:109AD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF96
+:109AE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF86
+:109AF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF76
+:109B0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF65
+:109B1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF55
+:109B2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF45
+:109B3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF35
+:109B4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF25
+:109B5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF15
+:109B6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF05
+:109B7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5
+:109B8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE5
+:109B9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD5
+:109BA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC5
+:109BB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB5
+:109BC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA5
+:109BD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF95
+:109BE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF85
+:109BF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF75
+:109C0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF64
+:109C1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF54
+:109C2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF44
+:109C3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF34
+:109C4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF24
+:109C5000FFFFFFFFFFFFFFFFFFFFFFFF3801660170
+:109C60004D344850435554320000000000000901B3
+:109C700038B50420FBF773FE00F036FAFBF75CFC06
+:109C8000FCF7D6FB3A4C3B4B3B4DA03003602A68B7
+:109C900023683A485A603A4900F00EFA23682D6862
+:109CA0001A68DD6001321A603648374900F004FA5C
+:109CB000236836489A68364901329A6000F0FCF908
+:109CC000236834489A68344901329A6000F0F4F904
+:109CD000236832489A68324901329A6000F0ECF900
+:109CE000236830489A68304901329A6000F0E4F9FC
+:109CF00023682E489A682E4901329A6000F0DCF9F8
+:109D000023682C489A682C4901329A6000F0D4F9F3
+:109D100023682A489A682A4901329A6000F0CCF9EF
+:109D2000236828489A68284901329A6000F0C4F9EB
+:109D3000236826489A68264901329A6000F0BCF9E7
+:109D4000236824489A68244901329A6000F0B4F9E3
+:109D5000236822499A68224801329A6000F0ACF9DF
+:109D600023689A6801329A60FCF762FB38BDC046EE
+:109D700060010020E59F0000F40E00209D6B0000B4
+:109D80001B9E0000950A0000FF9D0000F90B0000DB
+:109D9000859D000021810000F19D0000C965000043
+:109DA000C99F0000BD1800000F9E0000C1120000F6
+:109DB000F39D00000D250000F59D0000DD19000059
+:109DC000F79D00004D5E0000F99D0000117B000032
+:109DD000FD9D000061270000159F0000FB9D000015
+:109DE000FD7C0000174B30B51B6800211A1C9D6BD1
+:109DF000843211700C1CD86C1349202D06DCDD6AEE
+:109E0000952D03DCA04201DA0C6801340C600C686B
+:109E10001E2C03DD0124147000240C609D6C11784D
+:109E200028189033C00F1B6808431070002B07D010
+:109E3000064B1B685B691B78012B01D10023137053
+:109E400030BDC046400000207C03002044000020BC
+:109E5000704770477047704770477047704707B545
+:109E6000002201AB1A800198F9F7D0FF07BD08B5B1
+:109E7000F6F7B2FDFCF7DCFA08BD3A4BF7B51A6805
+:109E8000394C1669394D3278012A5CD12088282155
+:109E9000FEF78CFC726888B20023D35EC0002B50A2
+:109EA000B368281800229B5E4360FCF793FC22886D
+:109EB0002823272A00D8131C2D4D0132002622808A
+:109EC000DBB2371C0195013BDBB2FF2B13D02748D7
+:109ED000D9000A5884460198904200DD01929742C9
+:109EE00000DA171C61444A68954200DD151C964251
+:109EF000E9DA161CE7E7FCF795FA2388272B30D917
+:109F0000019C51303F1BFA17BF185740082F17DC30
+:109F1000751BEB17ED185D400823082D11DD032F8D
+:109F20000EDC104C2268136952695B685268002489
+:109F3000115F00241A5F8A18D10F8A1852101A80F4
+:109F4000012303700DE0FCF76DFAA022061C00212E
+:109F5000281C5200FEF7F6FC002323805136012313
+:109F60003370F7BD440000208C0D0020900D0020C0
+:109F7000FFFF0000F0B589B0F8F7F2FE2649102285
+:109F800004A8FEF79DFCF9F7B7FF244B24491A6893
+:109F9000244C13680E682768013B22D351680D1CBE
+:109FA0005D436C186D00640089000395039D0439BE
+:109FB000AC42F1D0F569023C02942C190194BD69C0
+:109FC000440000946C58009DA44610356C462D5BEF
+:109FD00064462C1BA446019C258865442580029C70
+:109FE000E4E70F4F0F4B12693D681E685300920063
+:109FF000023B043A991C0DD02C6A376AE118BC5810
+:10A000000F883F1B4400BC4610346F46E45B644439
+:10A010000C80EDE709B0F0BD80890000340300201A
+:10A02000440000204000002008B5FBF7DDFA0128BD
+:10A0300005D0034B1B681869596900F071F808BD19
+:10A040004400002038B5041C0D1CFBF75FFB002802
+:10A0500002D001280CD02BE0164B6D001B681B6949
+:10A060001B69EA5AFF23FE2A00D8D3B263711FE0AE
+:10A07000104B69001B681A691269895AFF22FE2970
+:10A0800000D8CAB262711B69AD005969032249192F
+:10A0900002238A56CB560120D31A002208568A562C
+:10A0A000821A934202DDA371E27101E0A271E371B1
+:10A0B00038BDC0464400002038B5051C08200C1CE3
+:10A0C000FBF74DFC0560446038BDC04638B5041C44
+:10A0D000081C002A07D0D118584362434D101018AD
+:10A0E0004019FEF76DFB38BD38B5FCF79BF9041C31
+:10A0F000B820FBF734FC094DB82228600021FEF798
+:10A1000021FC231C52333C341B78207864215843B3
+:10A11000FEF756FB2D68B035286038BD180F0020BB
+:10A12000F0B59DB00F1C041CFCF77CF90A90FCF7FD
+:10A130006DF90F90FBF75AFC0F9B0122F0331B784F
+:10A1400000259A40131C0F9AF13212789B1A0F9A2D
+:10A15000F23212789B1ADBB21593FCF769F9974B30
+:10A160000D901B680E951093954B0B951B681B6A01
+:10A170000C935B00023B9E1C0CD026690E9DF25A8C
+:10A18000954200DA0E92E6680B9DF25E9542F1DA96
+:10A190000B92EFE70C9B0D9D0F339B00EB18079381
+:10A1A0000C9E013E0C9600D210E10C9EE0687600F9
+:10A1B000835F0996002B00D1FCE00A9A0A9B126982
+:10A1C000216952331D78885B0692111C0A9B0A9AFA
+:10A1D00028331432FBF7CEFB061CF6F7F7FBFF30F3
+:10A1E000437A002B05D00A9B3E331B789E4200DA4F
+:10A1F0001E1C744B1B681A6B9269117800291BD1C5
+:10A200005278002A0AD16E4A9B68126892685200FE
+:10A21000D25E0E2A38DC02215B5E30E00F2A33D199
+:10A22000674A9B68126892680F325200D25E0E2A0B
+:10A230002ADC1C215B5E22E01B2925D15278002AF2
+:10A240000BD19B6834201A5E0E2A1DDC5C4A126812
+:10A2500092681B325200D35E11E00F2A14D1584A83
+:10A260001C2112689B689268514359183620095E78
+:10A270000E2909DC1E214A439B1834215B5E0E2BFC
+:10A2800002DCF30F9B195E100A9B53331B78002BE3
+:10A2900002D16422944645E0484BAC461B681D1C25
+:10A2A000B43511952878139000281DD1E168099ADA
+:10A2B00060468D5E64226A437043129212991A1CA2
+:10A2C000AC3281420EDDB5420CDC15680F980135C9
+:10A2D0001560DA300078854206D1119801250570A5
+:10A2E000139900E000211160191CB4310A78002A8A
+:10A2F00014D0E268099D505F1A1CAC32B0420BDDED
+:10A3000010680A9D0130106041352D78A84205D1B2
+:10A3100000200870106001E000211160B4331B7848
+:10A32000002BB6D00D9D0C98E2682B182C33099D9C
+:10A330001B785219002B05D00A995BB2413109787C
+:10A340008B4221DC0020135E654664205843754330
+:10A350002169A84211DB0A98099E48308D5B00787C
+:10A360000E9E70438011854207DB0A980B9DC06CDE
+:10A3700005906843801183421CDA099E079D0023E3
+:10A380008B5313802B6012E00020135E0E4965464C
+:10A3900059430A9B3C331B7873436B43994209DA58
+:10A3A0002669099D00237353079E13803360237829
+:10A3B000013B2370079D043D0795F1E6180F00202F
+:10A3C00034030020440000201027000000232370E5
+:10A3D000904B0D9D1B681B6A0C930C9E013BAA19A8
+:10A3E0002B3209920C225343109D0D9EEB182B36F5
+:10A3F0000E9317960C9D099E013D0C95179DAE423C
+:10A4000000D17FE20C9DE0686E00835F099D002B08
+:10A4100000D13DE22A780A9B0132D2B22A70413340
+:10A420001B7852B2991D8A4201DD04332B700998C2
+:10A4300000254557012D00DCC0E1A81C0321FEF7D3
+:10A4400015FA7B680891BA68022D38D10D98995F8A
+:10A450000069925B0D9D0490401094466A690D1A44
+:10A46000EB17ED185D40401B7F281BDC65462BB2C7
+:10A470005210981AC51740196840121A7F2A11DC29
+:10A480006268A568905F401AA95FC91AFDF728FAAB
+:10A490000B2807D978686168835BBA688B53935B34
+:10A4A000A568AB530323013B11D360680E9D815B0C
+:10A4B0005A00A068A952815BAA18D180F3E7089DD1
+:10A4C000995B6B000E9DEB181980925BDA800998FE
+:10A4D00000254557032D00DC5EE108990E9A4B00DC
+:10A4E000D3180793081C1B88043003210B93FEF735
+:10A4F000BDF90E984900079B41180A88DB88C98876
+:10A500009446129110936168A268042D0FD1885F60
+:10A5100079688B5FC31ADD175B196B40BD68905F6C
+:10A52000AA5F801AC11740184840181814E03A4B27
+:10A53000885F1B68925F9B19191C82310025495F57
+:10A540009633411AC817091841400025585F101A60
+:10A55000C2178018504008182F4B61681B688D5B2C
+:10A560009A19111C82310D80A5689632A95B0C9D49
+:10A5700011805B191A1C78321178002906D00F99C6
+:10A58000F8310988884208DC002105E00F99FA318A
+:10A590000988884201DB0121117078331B78002B78
+:10A5A0003CD10F9A0F9BF63212888021F4331B881E
+:10A5B00000924A00FBF7C2F965680B90AD190020C4
+:10A5C000295E0895079DA2680020285E95190B1A40
+:10A5D000DA179B18534010930022AB5E9C46079BF2
+:10A5E00006229A5E63469A1AD317D2185A40109BD5
+:10A5F0009A181092109B0B9AFFF768FD0899079A1A
+:10A6000008800620105E0023E95E0B9A109BFFF77E
+:10A610005DFD9AE034030020180F00200B9D109A76
+:10A6200028B265462BB2C31A11B2DA0FD318129AA8
+:10A630005B1015B24D1B1193EB0F5D196D10139547
+:10A640006568AD1916950022AD5E1095A568AD1927
+:10A6500012950022AD5E1495119D2B18109DEB1ADA
+:10A66000139DD8176918149D1B18691A4340C81701
+:10A670000918414000255B180B95802B01DD803BBC
+:10A680000B93089803210530FEF7F0F80E9D0F9B01
+:10A6900049006918079D0291F1331B780621695E14
+:10A6A000159D08934D430F9B0298F2331B780621AA
+:10A6B000415EAC46089D039314986943039D0F9B2C
+:10A6C0004543F0331B788C440F9A65441D41F332A7
+:10A6D0001278AC46139D0B985543291C19416144CF
+:10A6E00014918021C9004518079968101390002023
+:10A6F000095E15984843844602980021415E0898F7
+:10A70000414303988C4410994843119960444A434B
+:10A7100018411A4180180B99109A139B51438002DB
+:10A720004018C018291CFEF74BF816990880149A97
+:10A73000129993020020085E0B9A291C50431818A6
+:10A74000139BC018FEF73CF8129D2880E568F96855
+:10A75000AD19885F08950022A95E0A9D0835079506
+:10A760003E23EA5E431ADD175B196B40FFF7AEFC30
+:10A77000089D396928802569885BAD192988089565
+:10A78000079D431A3E22AA5EDD175B196B40FFF757
+:10A790009DFC089D288011E060687D688319002277
+:10A7A000995EAA5FA0688A185210BD681A80831942
+:10A7B0000022995EAA5F8A1852101A800A9B099D8E
+:10A7C0000021413369561A7891423DDC6068A168E6
+:10A7D000835F1AA81A938B5F1B93FBF7FBFF002381
+:10A7E000EB56012B02D1804B00221A701B9ADC23FE
+:10A7F000C83A9B009A4204D81A9AB4239B009A4202
+:10A8000002D90C9D002D0AD0784B1B78002B16D056
+:10A810000A9B41331A78744B1B789A420FDB734BB7
+:10A8200001221A70704B60681A78058870485100D0
+:10A830000D52A068013205886E481A700D5201232E
+:10A84000E1685B428B531FE0227801322270674A35
+:10A850001278002A18D00D9A1B782C321278013306
+:10A8600052B29A420DD1644A012318A913700020F4
+:10A870000B704B708B70CB70F12388800B71FAF7E3
+:10A88000A3FF5A4B00221A70099D0023AB7232E0DD
+:10A890000A9A0021413269561278914223DDF86804
+:10A8A000825F002A27D0AA7A0A990132D2B2AA720C
+:10A8B0004231097852B28A4201DD2B701BE079687F
+:10A8C00062688B5BBD689353AB5BA068F968835388
+:10A8D0008B5BE2683D699353AB5B206983532378BC
+:10A8E0000133237007E0454A0C9E1268099D9219B6
+:10A8F00078322B701370099D0E9E013D0C3E099518
+:10A900000E9677E50D9B002272331A703C4B0D9E1C
+:10A910001B681D69741937356D00751989368934BE
+:10A9200004350796079EB4425BD02B88002B0ED0CF
+:10A930000C27EA5F1BB2002A02DC0A9A3F3201E0D0
+:10A940000A9A40321278934201DA00232B80298838
+:10A95000002927D023787F2B01D0013323700026D4
+:10A96000A657022E0DDD0A9B0C22A85E09B2083301
+:10A970003E27DA5F431ADF17DB197B40FFF7A6FBA0
+:10A9800028800A9B43331B789E4203DC01235B42F1
+:10A990002B8004E00D9B72331A7801321A70002369
+:10A9A00063711BE00A9B00224333A2561B789A4234
+:10A9B00013DDAB89002B11D062790A980132D2B233
+:10A9C00062714430007852B2824206DC2B800D9BCB
+:10A9D00072331A7801321A7000E02170013C023D96
+:10A9E000A0E71DB0F0BDC046F4040020F60400202E
+:10A9F000E0040020CC040020F5040020180F002003
+:10AA000034030020FFFFFFFFFFFFFFFFFFFFFFFFFB
+:10AA1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF46
+:10AA2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF36
+:10AA3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF26
+:10AA4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF16
+:10AA5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF06
+:10AA6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6
+:10AA7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE6
+:10AA8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD6
+:10AA9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC6
+:10AAA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB6
+:10AAB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA6
+:10AAC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF96
+:10AAD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF86
+:10AAE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF76
+:10AAF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF66
+:10AB0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF55
+:10AB1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF45
+:10AB2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF35
+:10AB3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF25
+:10AB4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF15
+:10AB5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF05
+:10AB6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5
+:10AB7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE5
+:10AB8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD5
+:10AB9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC5
+:10ABA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB5
+:10ABB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA5
+:10ABC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF95
+:10ABD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF85
+:10ABE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF75
+:10ABF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF65
+:10AC0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF54
+:10AC1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF44
+:10AC2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF34
+:10AC3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF24
+:10AC4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF14
+:10AC5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF04
+:10AC6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4
+:10AC7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE4
+:10AC8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD4
+:10AC9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC4
+:10ACA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB4
+:10ACB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA4
+:10ACC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF94
+:10ACD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF84
+:10ACE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF74
+:10ACF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF64
+:10AD0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF53
+:10AD1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF43
+:10AD2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF33
+:10AD3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF23
+:10AD4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF13
+:10AD5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF03
+:10AD6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3
+:10AD7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE3
+:10AD8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD3
+:10AD9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC3
+:10ADA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB3
+:10ADB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA3
+:10ADC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF93
+:10ADD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF83
+:10ADE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF73
+:10ADF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF63
+:10AE0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF52
+:10AE1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF42
+:10AE2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF32
+:10AE3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF22
+:10AE4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF12
+:10AE5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF02
+:10AE6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2
+:10AE7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE2
+:10AE8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD2
+:10AE9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC2
+:10AEA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB2
+:10AEB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA2
+:10AEC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF92
+:10AED000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF82
+:10AEE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF72
+:10AEF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF62
+:10AF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF51
+:10AF1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF41
+:10AF2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF31
+:10AF3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF21
+:10AF4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF11
+:10AF5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF01
+:10AF6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1
+:10AF7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE1
+:10AF8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD1
+:10AF9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC1
+:10AFA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB1
+:10AFB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA1
+:10AFC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF91
+:10AFD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF81
+:10AFE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF71
+:10AFF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF61
+:10B00000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF50
+:10B01000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF40
+:10B02000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF30
+:10B03000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF20
+:10B04000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF10
+:10B05000FFFFFFFFFFFFFFFFFFFFFFFF660109018B
+:10B060004D344850504154320000000000000901A6
+:10B070000A000000011C100001000004050607087A
+:10B08000090A0B0C0D0E0F101112333231302F2E16
+:10B090002D2C2B2A29282700000000000000002367
+:10B0A0002221201F1E1D1C1B1A191817161514000B
+:10B0B0000000000000000000000000000000000090
+:10B0C000000000000000000000000000003F1F061C
+:10B0D00000BF000F000000000000000000000000A2
+:10B0E0000000000000000000000000000000000060
+:10B0F00000000000000000F0000000000000000060
+:10B10000000000000000000000000000000000003F
+:10B1100000000000830000000001E1A10800000918
+:10B1200003030000434B545F3464393700000000D0
+:10B1300000000000057878010000FFFFFFFFFFFF1F
+:10B14000FFFFFFFF0A05C800DC057300FA00780066
+:10B150000005641E1E0A0305100F3C000A0A3C008D
+:10B1600000800000D002000000050000C8000000C0
+:10B1700020030000C8000000E80300006400000095
+:10B1800001000000010000000100000001000000BB
+:10B1900005000000000040008000C400FF006E00B9
+:10B1A000640055004B0046006E00640055004B00E3
+:10B1B00046006E00640055004B0046006E006400BF
+:10B1C00055004B0046000000000000000000000099
+:10B1D000000000000000000000000000000000006F
+:10B1E000000000000000000000000000000000005F
+:10B1F000000000000000000000000000000000004F
+:10B2000002000000000040008000C400FF00800039
+:10B2100080000000000000008000800000000000AE
+:10B22000000080008000000000000000800080001E
+:10B2300000000000000000000000760256043C0000
+:10B24000C8001E00B0045E01F4010100DC056400CA
+:10B25000230018010613133D800200014000C000C6
+:10B26000000000000100000000BF000F000000000F
+:10B2700000000000000000000000000000000000CE
+:10B28000000000000000000000000000000000F0CE
+:10B2900000000000000000000000000000000000AE
+:10B2A00000000000000000000000000000BF000FD0
+:10B2B000000000000000000000000000000000008E
+:10B2C000000000000000000000000000000000007E
+:10B2D000000000F00000000000000000000000007E
+:10B2E000000000000000000000000000000000005E
+:10B2F0008000000000037B1ED10000710A48F61F89
+:10B300000000003F1F063F1D003F1D06000000001B
+:10B31000000000000000000000000000000000002D
+:10B32000000000000000000000000000000000001D
+:10B33000000000000000000000000000000000000D
+:10B3400000000000000000000000000000000000FD
+:10B350000000000000000000000000000000FFFFEF
+:10B360000A14380703000000FFFF0A14380703001F
+:10B370000000FFFF0A1438070300000000BF000FA1
+:10B3800000000000000000000000000000000000BD
+:10B3900000000000000000000000000000000000AD
+:10B3A000000000F0000000000000000000000000AD
+:10B3B000000000000000000000000000000000008D
+:10B3C00000BF000F000000000000000000000000AF
+:10B3D000000000000000000000000000000000006D
+:10B3E00000000000000000F000000000000000006D
+:10B3F000000000000000000000000000000000004D
+:10B40000000000008000000000036B1CD1000071F0
+:10B410000A48B61B010000380F05380F00380F0529
+:10B42000000000000000000000000000000000001C
+:10B43000000000000000000000000000000000000C
+:10B4400000000000000000000000010101010101F6
+:10B4500001010101010101010101010101010202DA
+:10B4600002020202030000000000000000000000D1
+:10B47000641E96001400000007000000FF7F00809B
+:10B48000FF7F00800103570100005A030F00008076
+:10B490000A0F0F0A0DF14000D00280022602FA00C6
+:10B4A0003000000050000000050000000000140003
+:10B4B0001E00230028000000000000000000000023
+:10B4C0003C003C00460050005A0000000000000014
+:10B4D000000000004B3C3C2314020102020000006B
+:10B4E000010000000100000001011400000106112C
+:10B4F00001001E00550014460A1400002C01E80348
+:10B500001000000000BF000D00000000000000005F
+:10B51000000000000000000000000000000000002B
+:10B520000000000000000000000000F0000000002B
+:10B53000000000000000000000000000000000000B
+:10B540000000000000000000009E000F000000004E
+:10B5500000000000000000000000000000000000EB
+:10B56000000000000000000000000000000000F0EB
+:10B5700000000000000000000000000000000000CB
+:10B58000000000000000000000000000800000003B
+:10B590004003331CD10000710A48F61F0000003F31
+:10B5A0001F063F1F003F1F060000000000000000B4
+:10B5B000000000000000000000000000000000008B
+:10B5C000000000000000000000000000000000007B
+:10B5D000000000000000000000000000000000006B
+:10B5E000000000000000000000000000000000005B
+:10B5F0000000000000000000781E2C011400000074
+:10B6000007000000FF7F0080FF7F00800103000033
+:10B6100000005A030800008007070F070FF94000D9
+:10B6200026025E015E01FA003000000032000000D8
+:10B63000060000002B002C0034003A0056006E007B
+:10B6400000000000000000004600500096002C01A1
+:10B650000502050200000000000000004B3CA01E97
+:10B660000F02010202000000070000000F000000AE
+:10B670000101140000000A0D01002C01E80323233E
+:10B68000232301002C01E8031000000000BF000D7F
+:10B6900000000000000000000000000000000000AA
+:10B6A000000000000000000000000000000000009A
+:10B6B000000000F00000000000000000000000009A
+:10B6C000000000000000000000000000000000007A
+:10B6D000009E000F000000000000000000000000BD
+:10B6E000000000000000000000000000000000005A
+:10B6F00000000000000000F000000000000000005A
+:10B700000000000000000000000000000000000039
+:10B71000000000004000000040033B18D100007111
+:10B720000A48F61F000001380F053F1D00230F05D2
+:10B730000000000000000000000000000000000009
+:10B7400000000000000000000000000000000000F9
+:10B7500000000000000000000000000000000000E9
+:10B7600000000000000000000000000000000000D9
+:10B7700000000000000000000000000000000000C9
+:10B78000781EFFFF1400000007000000FF7F00800C
+:10B79000FF7F00800003000000005A0308000080C3
+:10B7A00007070F0A0FF64000B003520326025E019E
+:10B7B0003000000032000000060000002B002C00CA
+:10B7C00034003A0056006E00000000000000000047
+:10B7D0004600500096002C01050205020000000002
+:10B7E000000000004B3CA01E0F02010202000000FE
+:10B7F000070000000F0000000101140101000A0D04
+:10B8000001002C01E8030F3C0F3C00002C01E80371
+:10B8100010000000090909090909090909090909AC
+:10B8200009080808080707070707060606050505AB
+:10B8300009090909090A0909090A09090909090976
+:10B84000090908090807070707070606090909097A
+:10B850000909090909090909090909090909080959
+:10B8600008070707070706060A09090A090A090A55
+:10B870000A0A090A090A0909090909090808080739
+:10B88000070706070A0A090A090A090A0A0A090A29
+:10B89000090A090909090909080908070707070723
+:10B8A0000B0A090A0A0A090A0B0A0A0A0A0A0909FA
+:10B8B0000909090908090807070707070A0A090A01
+:10B8C0000A0A0A0A0B0A0A0A0A0A0A0909090909DC
+:10B8D00009090807070707070B0A0A0A0A0A0A0ADA
+:10B8E0000B0A0B0A0B0A0A090A09090909090808BF
+:10B8F000080707070B0A0B0B0B0B0B0B0B0B0B0BA8
+:10B900000B0B0B0A0A0A0A090909090908070707A4
+:10B910000B0A0B0B0B0B0B0B0B0B0B0B0B0B0A0A7A
+:10B920000A0A0A0909090909080807070B0A0B0B83
+:10B930000B0A0B0A0B0B0B0B0B0B0A0A0A0A0A0960
+:10B9400009090909080808070B0A0B0B0B0B0B0B5D
+:10B950000B0B0B0B0B0B0B0B0A0A0A090A09090943
+:10B96000080708070B0B0B0B0B0B0B0B0B0B0B0B35
+:10B970000B0B0B0A0A0B0A0A0A090909090908082C
+:10B980000B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B07
+:10B990000A0B0A0A0A090909090808080B0B0B0B0C
+:10B9A0000B0B0B0B0B0B0B0B0B0B0B0B0A0B0A0AEA
+:10B9B0000A090909090908070B0B0B0B0B0B0B0BE9
+:10B9C0000B0B0B0B0B0B0B0B0B0B0A0B0A090909CF
+:10B9D0000909080800000000000000000000000045
+:10B9E0000000000000000000000000000000000057
+:10B9F0000000000000000000000000000000000047
+:10BA00000000000000000000000000000000000036
+:10BA10000000000000000000000000000000000026
+:10BA20000000000000000000000000000000000016
+:10BA30000000000000000000000000000000000006
+:10BA400000000000000000000000000000000000F6
+:10BA500000000000000000000000000000000000E6
+:10BA600000000000000000000000000000000000D6
+:10BA700000000000000000000000000000000000C6
+:10BA800000000000000000000000000000000000B6
+:10BA900000000000000000000000000000000000A6
+:10BAA0000000000000000000000000000000000096
+:10BAB0000000000000000000000000000000000086
+:10BAC0000000000000000000000000000000000076
+:10BAD0000000000000000000000000000000000066
+:10BAE0000000000000000000000000000000000056
+:10BAF0000000000000000000000000000000000046
+:10BB00000000000000000000000000000000000035
+:10BB10000000000000000000000000000000000025
+:10BB20000000000000000000000000000000000015
+:10BB30000000000000000000000000000000000005
+:10BB400000000000000000000000000000000000F5
+:10BB500000000000000000000000000000000000E5
+:10BB600000000000000000000000000000000000D5
+:10BB700000000000000000000000000000000000C5
+:10BB800000000000000000000000000000000000B5
+:10BB900000000000000000000000000000000000A5
+:10BBA0000000000000000000000000000000000095
+:10BBB0000000000000000000000000000000000085
+:10BBC0000000000000000000000000000000000075
+:10BBD0000000000000000000004E4C4D4A4B4C4A53
+:10BBE00049484848474948474545454444444241F7
+:10BBF0003E3D3B383B4D4C4B474748454443424212
+:10BC00004243434040404040403E3D3C3A38363459
+:10BC1000384E4B4B484748434442414241414340E0
+:10BC2000404040403F3E3C3B39373634374E4D4C28
+:10BC30004748484544434343434242403F404040D5
+:10BC4000403F3C3B3937363438504D4C47484745E8
+:10BC5000454443424143414040403F3F403F3D3BDC
+:10BC60003937353438534C4C4846474543434242B4
+:10BC70004242414040404040403F3D3A39373533F1
+:10BC800038534C4C47474744434443414242434066
+:10BC900040403F3F403F3D3B3937353337524C4CB6
+:10BCA0004847474543434343434443404040404063
+:10BCB00040403C3B3937353438524C4C4847494575
+:10BCC000454444424243434040414040403F3C3B66
+:10BCD0003937363338524D4C494748444444434140
+:10BCE0004342424040414140403F3C3B393735337D
+:10BCF00037524D4C494748444443434242434240F3
+:10BD000040424140403E3B3B3937353337534C4C42
+:10BD100048484845444443424242424040434140EF
+:10BD2000403F3C3B3836343337534D4C4848484508
+:10BD300044444343424242404041403F40403D3BF7
+:10BD40003836353236544D4D4949484645444344CA
+:10BD5000424243404042403F403E3D3B393734330E
+:10BD600037554E4D4B4B4A4646454444424343406B
+:10BD70004142414140403D3C39373533365A5557B1
+:10BD80005454514F4F4D4C4B4B4C4B4748484A48ED
+:10BD9000474643423D3C3936390000000000000070
+:10BDA0000000000000000000000000000000000093
+:10BDB0000000000000000000000000000000000083
+:10BDC0000000000000000000000000000000000073
+:10BDD0000000000000000000000000000000000063
+:10BDE0000000000000000000000000000000000053
+:10BDF0000000000000000000000000000000000043
+:10BE00000000000000000000000000000000000032
+:10BE10000000000000000000000000000000000022
+:10BE20000000000000000000000000000000000012
+:10BE30000000000000000000000000000000000002
+:10BE400000000000000000000000000000000000F2
+:10BE500000000000000000000000000000000000E2
+:10BE600000000000000000000000000000000000D2
+:10BE700000000000000000000000000000000000C2
+:10BE800000000000000000000000000000000000B2
+:10BE900000000000000000000000000000000000A2
+:10BEA0000000000000000000000000000000000092
+:10BEB0000000000000000000000000000000000082
+:10BEC0000000000000000000000000000000000072
+:10BED0000000000000000000000000000000000062
+:10BEE0000000000000000000000000000000000052
+:10BEF0000000000000000000000000000000000042
+:10BF00000000000000000000000000000000000031
+:10BF10000000000000000000000000000000000021
+:10BF20000000000000000000000000000000000011
+:10BF30000000000000000000000000000000000001
+:10BF400000000000000000000000000000000000F1
+:10BF500000000000000000000000000000000000E1
+:10BF600000000000000000000000000000000000D1
+:10BF700000000000000000000000000000000000C1
+:10BF800000000000000000000000000000000000B1
+:10BF90000000000000000000000000000000FFFFA3
+:10BFA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA1
+:10BFB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF91
+:10BFC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF81
+:10BFD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF71
+:10BFE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF61
+:10BFF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF51
+:10C00000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF40
+:10C01000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF30
+:10C02000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF20
+:10C03000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF10
+:10C04000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF22DD
+:10C0500009121520F5B26756322D0000660109015C
+:00000001FF
diff --git a/firmware/melfas/testplus_melfas_mip4.bin.ihex b/firmware/melfas/testplus_melfas_mip4.bin.ihex
new file mode 100755
index 00000000000..3d84246acca
--- /dev/null
+++ b/firmware/melfas/testplus_melfas_mip4.bin.ihex
@@ -0,0 +1,3079 @@
+:100000004D424E014D344850630104000100000090
+:100010006000000000C000000000000000000000C0
+:100020000000380100000000000000000004000093
+:100030000100630101002600000400000098000098
+:100040000200090127002B00009C000000140000A2
+:10005000030009012C002F0000B000000010000078
+:100060000038002035020000000000000000000001
+:100070000000000000000000000000000000000080
+:100080000000000000000000000000000000000070
+:10009000000000000000000000000000550000000B
+:1000A0005700000051010000790000008D000000A1
+:1000B00000000000FEE708B5044B01221A70044B53
+:1000C0000022DA77034B1B68984708BD0000002028
+:1000D0000800005034000020034B01225A70A02376
+:1000E0000022DB051A70704700000020034B01223C
+:1000F0009A70A0230022DB059A7070470000002050
+:100100008D23013B002B01D0C046FAE7044B10229F
+:100110001B78DBB21807C00F134018437047C04666
+:100120002B0000500F4BF7B518261E700E4BA02762
+:100130001E70FFF7E5FFFF050B4B01AC00252C37C8
+:1001400060701D703E70FFF7DBFF064B20703D7046
+:100150001D7023786278181C504040001340034300
+:10016000D8B2FEBD2A0000502D00005000230360CD
+:1001700030B50B601312012B13D10423013B10D3B4
+:10018000084DD4B25D5D641BF8D4074A9D00126827
+:10019000AA58002A05D012190260044AD35C1C1B1D
+:1001A0000C6030BDE0030000DC030000E40300004D
+:1001B00070B58022D2051379DBB2002B19D12B4CFC
+:1001C0006360A3602A4B1289261C251C1B6892B20F
+:1001D00010361435E260301C291C002B06D09847DD
+:1001E0002169002937D1E268301C291CFFF7BEFFC6
+:1001F00031E0012B0CD11D4B186900282BD09968D8
+:100200005C69A14227DA4C1C9C60137A435422E0BB
+:10021000022B1BD1154C2369002B12D06068616939
+:1002200088420EDA1B5C1BBAD360124B1B68002B92
+:1002300003D0E268101880B29847636801336360A6
+:1002400009E080230022DB05DA6004E0032B02D101
+:10025000064B00229A60C0468023DB0501221A70FB
+:10026000C04602221A7000221A7070BD00000020E1
+:100270003C0000203800002080230222DB05FF32F2
+:100280001A600421024AFF31118000221A7070475F
+:1002900006000040F0B5A023DB059B68534A1F21F0
+:1002A0008DB0DBB21160D12B0BD0D02B01D8013334
+:1002B000DBB2A022D2059168FF20814319439160EF
+:1002C000F1E74B4B4B4A191D043B934203D20022EA
+:1002D0001A600B1CF6E7FFF7CFFF474A8023DB02CB
+:1002E0001A80464A0027093A92B25A809F80C04637
+:1002F000434ADE88434D10685268434C0A922A886C
+:1003000009ABB6B21A8123625E810990FFF70AFF3A
+:10031000A023DB05DA7C03AB1A7034214D225A701E
+:1003200099705A7148214522D9709A7150219C22A6
+:100330001971D8716362520005AB0597A3611A80E9
+:1003400007AB01220797E3615A70304B0697DA89B1
+:100350002F4B08975F882F4B211C1B8828310B706F
+:10036000211C1B0A29310B702B4901235B420B70A6
+:100370002A482B4903700B702A48211C2E312F3438
+:1003800003700B7023702B889E4229D1264B9A4212
+:1003900026D0BA4224D1254EF7899F4220D0F68933
+:1003A000B446234E7788BC451AD1224FF88998422B
+:1003B00016D0FF89EB889F4212D1174B17481A704D
+:1003C000120A73880270164A9BB2164813701B0AF1
+:1003D0000370EB889BB20B701B0A237000F048F887
+:1003E000154B02221A6062B6FEE7C0462800005094
+:1003F00004000020400000200004000000C00000B5
+:10040000F0BF0000F8BF0000000000200004000062
+:10041000FC9B0000FE0300002A0000202B000020AF
+:100420002C0000202D000020FFFF0000009C000099
+:10043000FCAF000000B0000000E100E01800002068
+:100440002030407008080C08FFFFFFFFFFFFFFFF90
+:10045000FFFFFFFFFFFFFFFFFFFFFFFFFFFF380171
+:100460004D344850434F54320000000000006301F7
+:10047000F0B5D9B002AF03F05AFE05F0FFFAF86309
+:1004800008F078FF08F0A6FF09F0F2FB00F06EFE1E
+:10049000CA4ACB4B1A60CB4ACB4B1A60CB4ACC4BE7
+:1004A0001A6005F0EBFA7864052800D146E316D807
+:1004B000022800D1FFE207D8002827D0012800D168
+:1004C000ECE27C6CFC63ECE77D6C032D00D127E350
+:1004D000042DF6D105F058FB02F0B6FB29E37C6C45
+:1004E000092C00D152E307D8072C00D13AE3082C9D
+:1004F000E7D105F049FB3FE37D6C0A2D00D157E3BE
+:100500000B2DDED105F040FB00F0FDFB05F0CCFA31
+:10051000041E1AD00128D4D1AE4B02221B68391C0C
+:100520001D6A7031BD611D691A627D617D6C261C7A
+:100530001D61281C3F232A1C8D803D670B7105F02F
+:10054000A3FBBD637D6C3D64B8E00124012C02D0A7
+:10055000022C0AD098E0002002F060F803F01EFAA6
+:10056000C0B205F0DFFB02F03FF89A4B6C461B6807
+:10057000BC635D681E681B696E43F3189B000A33F9
+:10058000DB08DB00E01A8546862502AC6D003C6482
+:100590007C19201C0021142209F06EF89E204000D6
+:1005A0003B1C9021BC333A1849005A607A189A6073
+:1005B000391C283A1A61B031143A874D4A60143A0E
+:1005C0008A602A688548DC60F03200241470026872
+:1005D000386C5361824BB6001B68861910609161BC
+:1005E00056602D331A7869465200131C0833DB0815
+:1005F000DB00C91A8D4602AB181C211C7B6309F075
+:100600003BF805F041FC3A6C4178331C201C00F0AB
+:1006100099FEF86BA04201D005F0B6FA2B689C60F9
+:1006200005F07AFB041C03F0B9F9A04204D0201CA9
+:1006300003F0B9F902241DE07C6B3A1C00943B1CCA
+:10064000311CBC32B033386C01F058FC624B654A47
+:100650001B68041C9968914202D09A6801329A6022
+:10066000002807D105F020FA002803D105F006FA8A
+:100670000028D5D0594D00232A6813605360536178
+:100680009361BD6BFB63AD4605F00EFA002803D005
+:10069000002001F0E7F814E705F0F0F9002800D198
+:1006A00054E7F5E7022E0DD005F0FEF9012800D041
+:1006B000EDE105F0E3F9002800D0E8E1012EF1D1E9
+:1006C00001F092FF434D6C462B683C6158681C68F2
+:1006D0001B694443E3189B000A33DB08DB006946CF
+:1006E000C91A8D4602AA7A6302F0B8FD862000235B
+:1006F00040003A1CFB6564323B185A60043A9A6029
+:10070000043ADA60391C043A1A61E431043A4A6066
+:10071000043A8A602A686D4690695269A40042438F
+:1007200092000A32D208D200AD1AAD4602ADAAB08C
+:1007300002A8BD62AAB0F825E85102AAFC20C25165
+:10074000264A7D6B12682C191560546053619161C3
+:10075000FC6205F099FB041C04F016F86178052092
+:100760007A6BFB6A00F0EEFD04F056FB1A4BB86A98
+:100770001B680024596900F01BFCFD6BA54201D0E9
+:1007800005F002FA0020391C7831A223021C8C806B
+:10079000BC670B7105F078FA0F4B1B689C60002456
+:1007A00005F0BAFAF86303F0F9F8FD6BA8421BD024
+:1007B000281C03F0F8F8022659E1C046E95C000065
+:1007C0003C000020655D000038000020E1100000C2
+:1007D000340000201C0300204000002044000020C2
+:1007E000680D0020FFFFFF7F002C74D1D84B6D46B1
+:1007F0001B687D6298695A69410001324A43131CA3
+:100800000833DB08DB00E91A8D4602AD281C211CE9
+:100810003D6308F031FF386CCE4D082808D104F054
+:10082000FBFA2B68B86A596900F0C2FB3C6450E0DF
+:10083000042003F099FA2B68386B5969BA6A05F0FD
+:100840007BFF051E012D12D103F09EFF052003F052
+:100850008BFA391C80318C800C60A323201C221C55
+:100860002C1C00250B7105F00FFA3D6431E0BA4DE8
+:10087000B86A2B68396B35331A7806F035F82B686F
+:10088000B86B35331B785B0098420ADD03F07CFFC0
+:10089000052001217A6BFB6A00F054FD04F0BCFADC
+:1008A000BC63B96B2B680131B9633433187803F03A
+:1008B0007AF803F08FF82B6800263533187802F0A9
+:1008C0006BFE002002F08AFEF86B03F06CF803F078
+:1008D000A5F87D6AB6E0A04B1B68363318789D4BAF
+:1008E0001B68186002F058FE052003F015FA786BBB
+:1008F000F96A00F0D9FE061E06D086214900781854
+:1009000000F0B0FF01249EE06C4692B002AD92B0C0
+:10091000FC6002AC8AB0FD6302AD90B03C6302ACF7
+:100920008AB07D62311C02AD402288B0F86B3C6217
+:10093000FD6108F0A1FE311C4022386B08F09CFEDE
+:10094000311C2022786A08F097FE311C4022386A58
+:1009500008F092FE02AC311C2022F86908F08CFEEF
+:10096000201C311C202208F087FE902040003D18FA
+:10097000F96B3A6B7B6AAC61784C6960AA60EB609A
+:10098000386A2368F9698622520028616961281C47
+:10099000B9181D63102200F0C1FE9E204000391CD2
+:1009A0003C18BC3161600C39A1604439E160043904
+:1009B00021613B1C6949D03363611E605E603A1C53
+:1009C0000B684C32A2611C6186235B001680FA180A
+:1009D0003B1CE433281C211CFE66BE6600F0D4FEDE
+:1009E0006068A16806F0AEF96068A1680230023163
+:1009F00006F0A8F9381CF830396C07F087FE386427
+:100A0000032804D0072800D083E1182505E0381C0E
+:100A1000F83008F0D7F9051E09D005F053F86B1E21
+:100A200001229A401040D84000D172E188E103F0E1
+:100A300067F903F031F80124484B00221B681A6162
+:100A40001A63FD68AD46434B454A1B68996891425D
+:100A500002D09A6801329A60002E08D105F024F87D
+:100A6000012804D105F00AF8002800D198E603F027
+:100A700047F903F089FE394B1A680023136053606D
+:100A80001361536193613C69FB63A5460CE6304BEF
+:100A9000BD691B687C691D621C6112E505F074F874
+:100AA00004F0ECFF0128FBD008F040FC00F05EFBF6
+:100AB00004F0E8FD05E500F0A9FE284B1B68586925
+:100AC00000F0D0FE04F020FF002003F023FA03F032
+:100AD00087F900F057F901F087FD05F055F805F0AA
+:100AE0006DF803280DD004D801280AD0022808D0B8
+:100AF0000FE005280BD007D306280AD102F01EFD0F
+:100B000007E002F0D9F804E004F0E6FB01E002F0AF
+:100B100003FD04F0B3FF0228E1D000F089FED0E429
+:100B200005F032F801F060FD04F0A8FF0328FBD0C7
+:100B3000C7E404F0A3FF0428FBD0C2E405F024F8C6
+:100B400003F02AFB04F09AFF0528FBD0B9E4C04665
+:100B50001C03002040000020680D002044000020FD
+:100B6000FFFFFF7F05F010F8012001F057FD04F0B2
+:100B700085FF0728FBD0A4E4002003F0F5F803F07C
+:100B8000D7F904F07BFF0828F6D09AE404F0FCFFC4
+:100B9000002002F0CCFB002003F0E6F803F0C8F9D7
+:100BA00004F06CFF0928F6D0012002F0C0FB88E4B5
+:100BB0006C4600207C6308F043FC08F00BFC00202E
+:100BC00003F0A8F96D4D2B685E6818681B694643F1
+:100BD000F3180733DB08DB00E11A8D4602ACA619D7
+:100BE000FC6202F01DFB02F033FB02F025FBF86A09
+:100BF000311CFE6303F082FB2B686D465A681B694B
+:100C0000D3189B000A33DB08DB00ED1AAD4602ACBB
+:100C10003C6404F0B9FF594D391C2B6898311868B1
+:100C20001A7908704A708A705A1DD27F1B69FC6A53
+:100C3000CA700B71002201234B710420131C009415
+:100C400004F0E8FFF96BF86A04F066FA002003F09C
+:100C50008BF82B684A495D680E68BD630022B86B4B
+:100C6000824208DA90008446B069644600593D6CBF
+:100C700001322851F3E73C6C8200A4181D690E680C
+:100C8000A4460022AA4206DA306A9100405864461F
+:100C900060500132F6E7BA6B391CA03118684A700F
+:100CA0009A6808708A700533DB7F0132CB70344B51
+:100CB00092001B680D715B6904259A184D710092B2
+:100CC0000022131C022004F0A5FF391CA8310123C7
+:100CD0000B702A4B3C6C1B6805201A794A708A708D
+:100CE0005A1DD27F1B69CA7000220B714D71131CF3
+:100CF000009404F08FFF04F0C1FE0A288BD07D6BB6
+:100D0000AD46FFF7DEFB04F0B9FE0B28FBD0FFF782
+:100D1000D8FB3C6C082C00D089E602F0F1FF0120E2
+:100D200002F02FFC0024391C8831A223201C221C35
+:100D30008C800C600B7104F0A7FF04F06DF87BE66B
+:100D400002214820C155381C49224830D55504F0AD
+:100D500021FE02F0D5FF012002F013FC0024391C13
+:100D60009031A223201C221C08258C800C600B7162
+:100D700004F08AFF04F050F83D645DE61C03002097
+:100D800040000020F8B5184D7146281C764603F047
+:100D900019FB164C276802F095FE7862276802F06E
+:100DA00095FEB862276802F095FE7861276802F028
+:100DB00095FEF861276802F0E3FEB861276802F04B
+:100DC000F5FE0B4B0B491B68096838621878097CE3
+:100DD0002268414302331161E832281C311C136040
+:100DE00003F008FBF8BDC046250D000040000020C0
+:100DF000B00E0020680D0020014B18607047C046FF
+:100E0000680D0020014B18687047C046680D00202F
+:100E1000014B18607047C046B00E0020014B1868A7
+:100E20007047C046B00E0020014B18687047C0469E
+:100E300040000020014B58687047C0464000002029
+:100E400082B0F0B589B0109C151C0F9306930294E4
+:100E500007900E1C119C02F0E3F947793A4B049776
+:100E60008279964206D11B680021DA69AB00D05A1C
+:100E700003910BE01A68354B52691968731C896835
+:100E800003964B43EB1801339B00D05A04997143EE
+:100E900049194A00A4182388069E0193019F7318DC
+:100EA000874203D8C61B029FBE521CE0029EB618A2
+:100EB00005960027F65F013610D01F787EB2B44643
+:100EC000013601DA013703E06646002E06DD013FF8
+:100ED0001F7002235B42238001202FE0069F7918B8
+:100EE0000F78002F01D120800CE07FB27C1C05D14F
+:100EF000019E059F301A3880002002E0012F01D1A9
+:100F0000FF2008701978039C049E079F48B2744321
+:100F10007D19002805DC029EB25E013208D000294E
+:100F200006D12A5700203E2A08DC0131197005E05D
+:100F30002A57002A01DD01391970002009B0F0BCE0
+:100F400008BC02B01847C046400000201C03002027
+:100F500070B5154C7146201C754603F033FA134BDF
+:100F600000221B68191C88310A601E1C01219C3656
+:100F70004942181C3160B2600830083EF18232608C
+:100F80007283C26790300160826008380183191C47
+:100F9000AC31026004330A8020390A60201C291C0D
+:100FA000DA6703F027FA70BDF10E00004000002060
+:100FB000F0B5754685B00395294D01900F1C281C8E
+:100FC000714603F0FFF9274B00211B680198DA698D
+:100FD000920008F051FB04F057FF02904478214D35
+:100FE000002C21D0042002F0BFFE28684269561E62
+:100FF000009617D383690099019E5943C918890047
+:1010000071180439013B0BD3866856439E1901368B
+:10101000B600F5590E68AC46B44465460D60F0E77D
+:10102000009AE4E7013CDAE72F687D69013D11D3BE
+:10103000BC69019A261C6E433619B6009619043E07
+:10104000013CF3D3029B3068597808F005FA00049C
+:101050003060F4E70248039903F0CCF905B0F0BD25
+:10106000510F00001C03002038B5054C7546714631
+:10107000201C03F0A7F9291C201C03F0BBF938BD84
+:1010800009100000F0B52C4F72468BB07146381C29
+:10109000019203F097F9294D2B681A1CCC32117874
+:1010A000583A002904D1191CB0310978002901D01F
+:1010B000002111701478002C21D0996F0024079121
+:1010C0005A6B03A90892DB6A07AA099303234B70A2
+:1010D0008B707C235B42CB7001261023201C8C80FC
+:1010E0000E700B7104F0D0FD2B689A6FD96F8A4295
+:1010F00002DC92199A6718E09C67341C15E05A6B61
+:1011000005A90792DB6A0920089301230B700223CB
+:101110004B708B707C235B42CB7007AA64238C805E
+:101120000B7104F0B1FD2B689C67381C019903F02A
+:1011300061F9201C0BB0F0BD25100000400000201C
+:1011400038B5094C7146201C754603F03BF904F094
+:10115000ABFC002802D1022002F0DEFD291C201C7D
+:1011600003F048F938BDC046E110000037B5114C16
+:101170007146201C754603F025F905F02FFC02F09E
+:1011800067FE021E07D16946A923888000900B7173
+:1011900004F07AFDFEE7084B1B6803CB02F0D4F89D
+:1011A00005F034FCFFF7EEFD291C201C03F022F9AA
+:1011B00037BDC0460D1100001C030020F0B587B0FC
+:1011C00000AF7546786039615C487146FD6003F098
+:1011D000F9F803F03DF883000A33DB08DB006E46C4
+:1011E000F61AB546041C684603F03AF86300083363
+:1011F000DB08DB00F61A301C6D46B546BE6003F016
+:101200004BF84F4B1B68191C88310868632807DDB1
+:101210000120002240420A604861CA61191DCA6764
+:101220001A1C88321068191C013008311060CA6F0E
+:10123000632A09DD00220120CA67404290318A609A
+:1012400008601A1D0121D1671A1C0832D16F0131C3
+:10125000D167191C94310E68012E07DD0120002290
+:1012600040420A60C8824A8308390A601A1C9432D4
+:10127000116801311160191C90310868012809DDDD
+:10128000002201200A608A8340421A1C08838C32A3
+:10129000012111601A1C9032116801311160002285
+:1012A000101C013C08D3A1006958BE6840186100B9
+:1012B000715A521892B2F4E7191CAA310024A426DC
+:1012C0001D19B446AC447D6165462D68854201D246
+:1012D000664630607E699C363568854200D930604C
+:1012E0008E88964200D28A800E88964200D90A8063
+:1012F000043C261C02390836E1D11A1DD26F7D68E4
+:1013000092009A18111CA0319832096812683E693F
+:101310008A1A2A801A1C8C321268084852009B18BC
+:101320001A1CAC32A83312881B88F968D31A338090
+:1013300003F060F8BD4607B0F0BDC0465D11000087
+:1013400040000020F0B5284E85B075460191041C80
+:101350007146301C1F1C0395009203F033F8234D97
+:1013600000212B680098DA68920008F085F92B6854
+:10137000381C1A690021920008F07EF9019D002DA9
+:101380000CD0201C02F0F0FC194B00981B68391C93
+:101390005A69DB6905F096F9013DF0E7002C0FD1A1
+:1013A000134B1B685D699E69029502F07AFB051C70
+:1013B00002F080FB311C031C2A1C029804F07CFD07
+:1013C0000098391C019A04F0DFFE002C06D1084B6E
+:1013D000201C1D6802F07CFEEC3528600248039951
+:1013E00003F008F805B0F0BDE51200001C03002072
+:1013F00040000020F0B595B004AF754678613961C2
+:10140000A3487146FA61BB61FD6002F0DBFF04F0A6
+:101410003BFDA04B6C461B68BC601C6878620434C2
+:101420006400221C0832D2086846D200851A5A6825
+:10143000AD4604325200131C0833DB08DB0068465B
+:10144000C01A04AD854604AE301C00213D6208F090
+:1014500013F9221C0021386A08F00EF98E4C7D69C0
+:1014600023685A69191C9B690095386A2C3104302D
+:101470000190301D0290F86904F028FF2368874D21
+:10148000191C68313960796A78602A68097B586963
+:1014900092680091396A029601912C33396807F0FD
+:1014A00009FDBA68236838699546191CDA691B6A10
+:1014B00000902C31B86905F069F87E680643F6B2F1
+:1014C0003E6204F0F3FC0679012E0BD12B685B69B8
+:1014D0001B78002B06D104F0E7FA012802D0301C5B
+:1014E00002F04FF82568281C291C68312C3004F0C4
+:1014F000B3FE6B4A23681268E8660C24115F9D6D89
+:101500008D420EDC0E20115EDC6D8C4209DB102555
+:10151000515F186E884204DC1221525E5B6E93426A
+:1015200021DA00233B8738220123D35504F0D8FA6F
+:10153000002818D104F038F9002814D0564B1A6846
+:10154000FF239168FE2901DC9368DBB2381C02217D
+:1015500039243830E35504F01DFA524802F086FF72
+:1015600001F010FFE2E74B4E2921336828255A6825
+:101570001868CA559A682A23DA558023E8555B42D1
+:1015800002252B432B200024C3552C215323BC853B
+:101590000132CB55FB695200391C9A1801202831C1
+:1015A00004F072FB32680121137C3020C1553120D8
+:1015B0003221C355CB5580235B422B433322D35575
+:1015C00034206D23391CBC863031C355BA690120E3
+:1015D00004F05AFB336838211A683920CA55596813
+:1015E000C1559A683A20C255591DC97F3B20C15543
+:1015F0001B693D203C21CB55C35D7F218B4380215E
+:1016000049422B430B430132F96952008A18391CB5
+:10161000C35538310120231C0092221C04F0FAFA31
+:10162000FFF722FDFFF72EFDA04227D11A4C2368B9
+:10163000586902F0C7FC2368D86E02F0BDFB02F0C7
+:1016400089F93D6A002D0DD12368F9691A1C2C32E5
+:101650001B68786904F0ACFC236838691A68B969BA
+:1016600004F002FD022001F0B9FFB86905F096FA16
+:1016700020680024703006F03DFE00E02C1C044879
+:10168000F96802F0B7FE201CBD4611B0F0BDC0469F
+:10169000951300001C03002040000020440000209F
+:1016A000B00E002010270000F7B5194C00AF7346AC
+:1016B0007960061C7146201C3B6002F083FE154BCE
+:1016C00068461B68144D19689B688A1C5B005A4366
+:1016D00001315B084B430832D208D200801A85469C
+:1016E000013329686A465B00D3188A60CB60301CDE
+:1016F0007968FFF77FFE2B680022061C3968201CE2
+:101700009A60DA6002F076FEBD46301CFEBDC0462F
+:10171000491600001C03002044000020F0B585B0ED
+:1017200002AF7446051C3C607960141C7146144875
+:1017300002F048FEA200131C0A33DB08DB006946F6
+:10174000C91A8D4602AC201C002107F095FF0D4EF2
+:10175000281C3268516A936A68320092221C06F093
+:10176000EBFD33687A68596A281C9B6A0092221C38
+:1017700006F0A6F93968024802F03CFEBD46F7BD06
+:10178000BD16000040000020F7B51E4F75460C1C2A
+:10179000161C7146019500901D1C381C02F012FEAB
+:1017A000211C2B1C321C009806F0BAFB201C05F0F3
+:1017B00053FC154B201C1B68596A9A6A06F0C6FC3C
+:1017C000201C05F079FB2A1C201C311C05F014FAA2
+:1017D00004F06CFB051C05F013F9963003783C1CF3
+:1017E000002B09D12B79002B06D004F05DF90128DC
+:1017F00002D0012001F0C5FE201C019902F0FAFD83
+:10180000F7BDC046291700004000002038B5074C3E
+:101810007146201C754602F0D5FD07F057FD01F01A
+:1018200005FD291C201C02F0E5FD38BDAD170000A8
+:1018300038B50B4C7146201C754602F0C3FD07F00D
+:1018400005FE07F04BFD01F0F1FC002002F062FB09
+:1018500001F074FE291C201C02F0CCFD38BDC046EE
+:10186000D1170000F0B5C5B000AF73467146041C37
+:1018700038487B603E1C02F0A5FD381C2C36002148
+:10188000142240303D1C07F0F7FEE835301C0021E3
+:10189000142207F0F1FE00212822281C07F0ECFE9C
+:1018A000381C0A220C30002107F0E6FE3B1C68338E
+:1018B000D022D351143BD422D3514023DB19D82258
+:1018C000D351DC23DE51E0220C23D551DB19E42275
+:1018D000D351204E002C2AD16A46583D3A60281C2C
+:1018E000211C142207F0C8FE3B1CB833FB61143BDB
+:1018F0003B62283BBB62184B7D621B681B6A5B0026
+:10190000023B9A1C02D0FF22EA52F9E7381C391C2C
+:10191000CC30183105F0BAF905F0EAF9381C391C59
+:10192000CC30183105F058FC3B689D460BE0381C64
+:10193000CC30211C05F0AAF905F0DAF9381CCC30BE
+:10194000211C05F049FC301C796802F053FDBD46AE
+:1019500045B0F0BD051800001C030020F7B5304E5F
+:101960007146301C754602F02DFD05F049F82D4CEE
+:101970009630236801781A79002902D151B2481CA7
+:1019800004D10027DF60BA420DD118E0D8681A6987
+:10199000904202DAD8680130D86001290FD0DB68A4
+:1019A00093420CDB012700223B1C69460E33101CBE
+:1019B0008A8000920B7104F067F923681F71236815
+:1019C0001A79002A03D1184A1268127804E0012A11
+:1019D00003D1154A126852781A60186802F022FD85
+:1019E0002368071CEC33186802F040FD3F1A002FF3
+:1019F0000BDD2368186802F015FD2368071CEC3323
+:101A0000186802F033FD381A00E0012001F0B9FD3A
+:101A100001F0D8FD301C291C02F0ECFCF7BDC046DB
+:101A2000FD18000040000020B00E0020F0B5734605
+:101A300091B0041C0E1CAF487146059302F0C2FC25
+:101A400004F034FA049004F0DBFF2278AA4B002A59
+:101A500008D172300278511E8A41D2B20292002A15
+:101A600006D001E0012002901A680021B83205E09A
+:101A70001A68B8321168FE2901DC013111601B6857
+:101A800000211A1CB43211700299002904D09B491C
+:101A90000968097D00295FD0181CB3300178C9B2EC
+:101AA000002908D003785BB2022B00D00123137009
+:101AB0000023037084E11D1CB0352C78002C09D064
+:101AC000012414701A1CB132BC33017029701170DA
+:101AD000196076E1029800283ED1191CBC310C68CF
+:101AE000002C09DD013C012C01D00C6034E0029B8C
+:101AF0000B600323137064E11A1CE832126811882A
+:101B00007F4A914228D01A1CC83211887D4A126837
+:101B100052888A4220D8794C2068427C181CB83000
+:101B20000068904218DB0EAA1180CA331B8806A9F0
+:101B30005380029B02988B8001230B7002234B7011
+:101B40008B70CB7015230B7104F09EF86A4B2268E2
+:101B50001B68927CBC331A60684C2768F87C0028AC
+:101B600000D02DE10299644D002900D08AE02C6854
+:101B7000231CE7331B78002B5CD03B1C2C331B78D9
+:101B8000002B57D0231C0E91DC331B680393231CBE
+:101B9000C83303981A8843009A533B1C2D33197895
+:101BA00002984B00F618031C994206D05A00B21A4C
+:101BB000023A128801338018F6E707F09BFC0E907A
+:101BC000FA8B231CE033904202DA1A68013200E0FB
+:101BD00000221A603B1C221C2E33E0321B78126854
+:101BE0009A4219DD7C2308A900265B420124CB70B0
+:101BF000301C16230EAA8E800C700B714C708C70EA
+:101C000004F042F82B68301C1A1CDC32E0331660FA
+:101C10001E6004F07BF8D4E03B1C2D331A78039946
+:101C2000231C013ADC33914202DA0A1C013200E043
+:101C300000221A60C4340137FB7F22689A4219DB04
+:101C400000240AA91223201C221C8C800A940B71E8
+:101C500004F01AF82A682948131CC0331968006870
+:101C6000013119600230C07F814203DB1C60B43255
+:101C7000022313702A680023111CB231C4320B7086
+:101C8000136049E02B681A1CBC3210602A321278AB
+:101C9000002A41D0191CC83109880EAA1180CA3304
+:101CA0001B880CA9538001230B7002234B708B708F
+:101CB000CB70192388800B7103F0E6FF2B68226834
+:101CC000191CC8310C88D08B163984421CD2181CC0
+:101CD000CA300488508D844216D2097800291BD15D
+:101CE000C43301321968D27F914215DA013119608B
+:101CF00012E0C046CD19000040000020680D002011
+:101D0000FFFF0000B00E002001220A70191C002203
+:101D1000C431C0330A601A602D4D2B681A1CE6329C
+:101D20001278002A4CD104980279002A46D01A1C55
+:101D3000B0321478002C43D1264ED86A3768798B9C
+:101D4000BA8BFB8A3F8B009704F058F836682B68F3
+:101D5000718CB28C071CD86AF38C368D009604F017
+:101D60004DF82B681A1CC8321188CA33B94202DAFE
+:101D70001A88824214DB08AA11801B880EA953809E
+:101D80000223002001254B708B70CB7017238880B5
+:101D90000D700B7103F078FF0D4B1B68B1331D7094
+:101DA0000B4B1B681A1CB1321278002A08D002991A
+:101DB000002905D0B03301221A7002E0B1331A7045
+:101DC00001240548059902F015FB201C11B0F0BD57
+:101DD00040000020680D0020CD190000F7B57546C1
+:101DE0000195424D7146041C281C02F0EBFA404E4E
+:101DF00033681A1CB1321278002A24D01A1CE63239
+:101E00001278002A1FD11A1CCC32117800291AD15D
+:101E1000B0331B78002B16D10123137001F00CFA9C
+:101E2000071C01F0FDF9334A031C12685D3303CA35
+:101E30003A1C9B3204F05AF901F062FF022001F0D3
+:101E40006BFFFFF785F833681A1CCC321278002A32
+:101E500045D01A1C0020B0321070274A0090176835
+:101E6000011C3A6A013A0BD3E5685600755B002DF8
+:101E7000F8D02EB20131B042F4DA301C0092F1E712
+:101E80001A1CE6321278002A0ED101290CDD01223B
+:101E900022703A6A013A09D300998A42FAD0E56879
+:101EA000510000204853F5E7002903D01A1C0021F7
+:101EB000D43208E01A1C181CD432D03011680068E3
+:101EC000814201DC013111601A1CD4321168043ADC
+:101ED0001268914205DDB03301221A7001E0D4335B
+:101EE0001A600248019902F085FAF7BD7D1D0000D5
+:101EF00040000020440000201C030020F0B5C1B0C9
+:101F000002AF7546F861B961D94871467D603A62A1
+:101F1000BB6002F057FAD74E6C4632683C611368DA
+:101F200092689D1C520055430133291C52085343AB
+:101F30000831C908C900601A8546013302AC5B004C
+:101F4000FC62E318CC4CBB622368FC6A00219C60F5
+:101F5000BC6A3C22DC60C94C20682C3007F08CFB4A
+:101F60002A1C0021F86A07F087FBA62300203821ED
+:101F700000253887CB55391C2A1C281C34317D6339
+:101F800003F082FEFFF7EAFC21683C25081CC830FC
+:101F9000CA31FFF713F9316800234022D3530120DF
+:101FA0000B79E8553D223E25D355EB5540225B2366
+:101FB000D355042123683F20C155391C9A6902205A
+:101FC0003C3103F061FE326800254823DD530121D6
+:101FD000137C4420C15545254620EB55C355482563
+:101FE0006C23EB55042223684721CA55391C1A6A11
+:101FF0000220443103F048FE23683D1C1A1CC832FD
+:102000001288DC352A80CA331B88391C4C310122E6
+:10201000002088800A700A716B800C2002232A1C21
+:102020004B708B70CB7003F02FFE3368391C5A68ED
+:10203000186854314A709A680870581D1B698A7074
+:10204000C07F0B7104234B71236801325B699200DE
+:102050009A18C87000920022131C022003F0DAFDC7
+:10206000F869B969FA6ABB6AFFF7C4F9F86200282F
+:1020700003D0386AFFF7F6FBCEE0684692B002ACB8
+:1020800092B0BC6202AC8AB0FC6102AC90B002AE0D
+:102090008AB0BC6102AC88B0F8607C62F96A02ACBC
+:1020A0004022B86A7C6107F0E7FAF96A4022F869D1
+:1020B00007F0E2FAF96A2022B86907F0DDFA301C6D
+:1020C000F96A402207F0D8FAF96A2022786A07F004
+:1020D000D3FAF96A2022786907F0CEFA3C1CF96934
+:1020E000C034B86A7B6AA1606349BA6960606361A1
+:1020F00078690B68E2601C63A061396A201C1022B9
+:102100002661FFF70BFB3E1C8AB002AA8436BA6236
+:10211000F96A1422301C07F0AFFA381CF96A14224D
+:10212000703007F0A9FAF96A2822B86A07F0A4FA11
+:10213000381CF96A0A22643007F09EFA3B1CAC3363
+:102140006B60143BAB604C4A7023DB192B61B86A9F
+:1021500013686421C9196861A961EE60201C1D61C2
+:10216000291C3A6ABB68FFF70FFB88235B00D9592B
+:10217000281CFFF75BFC424B1B681B7D002B02D128
+:10218000281CFFF72BFE3C1CDC34201C396A05F0B0
+:1021900023F825786C46AB000733DB08DB00E41A34
+:1021A000A54602AC3C622E1C12243B1CDC33D868D2
+:1021B000025F002A09DD3A6A013E5B69B0006100F6
+:1021C00010185918042207F015FA023CA31CECD190
+:1021D000284B391C1B685C311C6858689A680C7065
+:1021E00048708A700533DB7F0132CB707E235B42FF
+:1021F0004B71224B52001B6800249B6A0C719A1889
+:1022000000923B6A03202A1C03F004FD1A4B1B6852
+:102210001C611C63FC68A546174B00221B689A6072
+:10222000DA603D69AD4601F037FC01F069FD01F06F
+:10223000FFF9012001F098FD01F04EFB0F4BB42097
+:102240001B68185600F0F2FB041E00D1FC6A0D4B0F
+:102250001B681A680C4B9A4202D001F09DFFFEE702
+:102260000348796802F0C6F8201CBD463FB0F0BDB7
+:102270009D1E00001C0300204400002040000020A0
+:10228000680D0020D40E0020CDCDCDCDF0B59DB091
+:1022900002AF74467146CF487C6002F093F800F0BC
+:1022A000BFFF061C00F0D4FF386100F0C5FFCA4B29
+:1022B0006D461C68B860E36800211A1C0E32D20813
+:1022C000D200AD1A2269AD460E32D208D20068465D
+:1022D000801A02AD8546FD6102AD7D6272799A1861
+:1022E000131C0E33DB08DB00C01A53000E33DB086F
+:1022F000DB008546C01A02AD8546C01ABD6102AD3D
+:10230000854602A87861B86907F0B6F9E168727984
+:10231000281C521801215200494207F0ADF9E36828
+:102320007279AE49D2185200786907F0A5F9E268CF
+:102330003969F8693D6607F05DF93D69F020800074
+:1023400029182269786A4024002507F053F9FC60B7
+:102350003D62796AF86902F0DFFE032001F004FDB6
+:102360009D4D00202B6838861A6858682C212D2432
+:10237000CA55E0559A6804242F23DC55984C512304
+:102380003020C35523682E21CA555B690132920063
+:10239000391C9A1802202C3103F076FC01233422D8
+:1023A000D3552B6836201B7C3525EB55C3550021B2
+:1023B0005A233825398704223721EB552368CA551B
+:1023C000391CDA690220343103F05EFCB479013C37
+:1023D000631C2CD07579013D6A1CF8D0737978693B
+:1023E0006343EB185B001A5A7E4B9A42F3D0B969EB
+:1023F00060223960F9657866D219694609CA09C14F
+:10240000211C3B68F8692A1CFEF71AFD002803D03E
+:102410003B6A01339BB23B627379BA6963433869A3
+:10242000EB18D15CC25C8A18F969CA54D3E7F47915
+:10243000013C601C30D0B17973797D694B43E3185E
+:102440005B005A5B674B9A42F2D0BD6960203D60E9
+:10245000FD65C0197D6984467D666846624628CA66
+:1024600028C0221C3B68786AFEF7EAFC002803D0EB
+:102470003B6A01339BB23B627379B279BD695A43BF
+:102480002B193D69F0202919800009189A5C0B78F6
+:102490007D6AD3182B55CBE74F4B3C6A1B68DA6833
+:1024A0001B69D3189C4206DAFB68013BDBB2FB6078
+:1024B000002B00D04DE700244025FC63EC53B3799A
+:1024C0003C20C35573793D213E223F25D355CB5542
+:1024D000EB5D7F200125834380212B4349420B4341
+:1024E0003F22D3554020D223391CC3553C3108200C
+:1024F000FA6903F0C9FB391C44317C648C800D708F
+:10250000F3797F224B708B70CB78082093431D4367
+:1025100080235B422B43CB707A6AD3230B7103F089
+:10252000B3FBB379013B0FD37279013AFAD37179D6
+:10253000BD685943FC698918E8186118A4300C7803
+:10254000007820180870F0E7F379013B08D3BC68E5
+:102550007D6AE218C8321178EA5C8A18EA54F4E716
+:10256000F869796A02F0D8FD391C4C310024FC640A
+:102570008C80B3797F200B70737901254B708B7041
+:10258000CB78802283432B4352421343CB70FA69AA
+:102590001D2308200B7103F077FB391C54317C6537
+:1025A0008C800D70F3797F244B708B70CB788026F4
+:1025B000A3431D4376421E237A6A2E4308200B71E3
+:1025C000CE7003F061FB0348796801F013FFBD464C
+:1025D0001BB0F0BD2D2200001C030020FFFF0000F7
+:1025E00040000020FEFF000038B50B4C7146201C57
+:1025F000754601F0E7FE00F01FFE98300378002BCF
+:1026000002D1FFF743FE01E001F0AAFE291C201CC5
+:1026100001F0F0FE38BDC04689250000F0B5A5B038
+:1026200000AF724671467861E1487A6001F0CAFEF7
+:10263000E04C23689B683B625B0001333B6501F023
+:102640009DF92368FF229B68F865D31A984200DD44
+:10265000FB65F86D3B6A0024C31AFB6101F096F933
+:102660003A6D694655002B1C0833DB08DB00C81A9D
+:1026700085466A466423DC53602001237965FA6449
+:1026800061216222C355CB55D3557C235B42632025
+:10269000C3556421B123CB553A1C391C201C603131
+:1026A0005C3203F0F1FA3A6D944206DAF869F96C9B
+:1026B00063002218CA520134F5E700246C23D1B21A
+:1026C000DC530126682069226A23C655D155D955A5
+:1026D000B96402236B20391CC3556831201CFA6C85
+:1026E00003F0D2FA2B1C796D08338D46DB08DB0032
+:1026F0006A46D21A9546D21A69469546F9637A63B4
+:1027000001F0A6FD3861301C00F0CAFF211C2A1C14
+:10271000786B06F0B1FF211CF86B2A1C06F0ACFFA9
+:10272000386D69468000031C0A33DB08DB00C91AD8
+:102730008D46C91A3B69B8619B00684638638D466F
+:10274000F962BB60FC640021BA69386B06F094FF43
+:10275000F86AFF21BA6906F08FFF00207865954B73
+:10276000786D1B685B6898424BDAF9690026C9B23C
+:10277000081CB96301F017F901F0E0F800F086FFDA
+:10278000FC6A3D6B386D0136F217C30F8642534128
+:10279000DBB2BB62002B06D1B96B8819C0B201F065
+:1027A00002F901F0CBF86B46FB60BB686A460A335E
+:1027B000DB08DB00D01A85466A467A6401F050FDDA
+:1027C00000231A1C39698A4205DA786C9100415855
+:1027D00001325B18F6E72A68934200D92B60206823
+:1027E000834200D22360F968BA6A8D460434043506
+:1027F000002A02D100F04AFFC4E77B6D01337B65FC
+:10280000ADE700216C4D79650C1C3A6D944217DAE6
+:102810003A6BF96AA300D058CB58C01A854204DD40
+:10282000FA69051CA2187A623C647B6D834200DA67
+:10283000786500F01FFFF96B6300C8520134E4E7CC
+:10284000786D00F017FF5B4B1B685B88984206DAD7
+:102850007B69012B03D0F86D396A78623964574D72
+:1028600000262C683222231DDE670433DA67396CB8
+:10287000803364221A60022291409A60FA6A012031
+:102880008A58D8605E60101C3A60B96300F0F2FEAE
+:102890009834BB6B396B206058582C6800F0EAFE06
+:1028A0002B6801211A1CAA32A034494220601180F1
+:1028B0007A69AE331E80012A2BD17A6B331C396DB5
+:1028C0008B4209DAF86B5900415A1088884200D2CD
+:1028D000118001330232F2E73A6C786B53001A5AD6
+:1028E000F96C131C8A4200D20B1C9BB27021FB6452
+:1028F0000123CB557422BB6C0020D053722171226E
+:10290000D355CB5573220223391CD35570317A6BC2
+:1029100010E0786D00F0AEFE391C80B278310222F2
+:10292000F864B86C0123CA70FA6B487088708E80A6
+:102930000B70301C03F0A8F9386C8823D8537A6ADE
+:10294000FB6B8A214400CA531C19FA6C23888E2120
+:10295000CA538C20391C8031C35304234B708B70B5
+:10296000002502233A1CCB708832B2230126281C92
+:102970008D800E700B7103F087F923880F4C22684D
+:10298000111CE83109680988994224D206F05EFDDD
+:10299000051C06F0AFFC03787865002B10D0301CC6
+:1029A00003F0B4F923687E6DE83302361E6023E03D
+:1029B000BD250000B00E0020FFFFFF7F400000207B
+:1029C000002D19D1164B1B68DB7C002B14D1301C59
+:1029D00003F090F910E0E7321278002A0CD0114E83
+:1029E000306842889A4207D9281C03F08FF923687F
+:1029F0003268E83302321A60796900290AD17A6AAA
+:102A0000D0B200F0D0FF0848796801F0F3FCBD4671
+:102A100025B0F0BD03F032F8072800D193E6EEE7C9
+:102A2000680D0020B00E0020BD250000F0B5814DDE
+:102A30008DB0724671460190281C039201F0C2FCD1
+:102A400006F004FD061C03F067F8071C03F072F89B
+:102A5000794C029023681A1CE4321278BA4226D0CC
+:102A6000002F0CD000226B469A8269463B230B75DF
+:102A7000101C04A90492022603F006F912E0029A3F
+:102A80003D1C002A0FD106A93C23381C3A1C8F801C
+:102A900006970B7103F0F8F82368E6331E78731E6F
+:102AA0009E41F6B201252368E4331F701FE01A1C13
+:102AB000E532127802998A4218D0002906D1E6330D
+:102AC0001E78731E9E41F6B23A2301E03923022696
+:102AD000002208A9101C8A8008920B7103F0D4F818
+:102AE0002368029AE5331A70012500E0002502F000
+:102AF000CDFF071C03F002F8019B032B02D0002F2F
+:102B000003D107E00125002F38D0002002F0C6FFD6
+:102B1000012533E02368E4331F88002F2ED101996B
+:102B2000012902D0022904D00EE0019803F0E2F856
+:102B30000AE0381C03F0DEF82368E7331B78002B2B
+:102B400002D0381C03F0E2F803F0CEF82368071C2B
+:102B5000E6331B78834211D0002802D011230126CE
+:102B600001E01223061C00220AA9101C8A800A9286
+:102B70000B7103F089F82368E6331F7006F066FCDA
+:102B8000B04237D006F062FC06F0A8FB071C301CF0
+:102B900006F0A4FB019006F059FC301C06F050FC36
+:102BA00006F018FC254B1B68187D002801D1012D6B
+:102BB0000ED0234B3A1C1B689B3203CB019B9B33EB
+:102BC00003F094FA002001F0CFF8FEF7C1F904E019
+:102BD0002368CC33187001F09DF9002003F096F8BB
+:102BE000236800211A1CE7321170164AE833126874
+:102BF00002321A6006F02AFC06F07CFB0378002BF8
+:102C000008D003F07DF82368E7331A78824201D0B8
+:102C10001870012502F0AAFF041C03F0F1FE0379ED
+:102C2000A34200D004710348039901F0E3FB281C80
+:102C30000DB0F0BDCD29000040000020680D00203F
+:102C400044000020B00E002038B5054C7546714692
+:102C5000201C01F0B7FB291C201C01F0CBFB38BD68
+:102C6000E92B000038B5054C75467146201C01F073
+:102C7000A9FB291C201C01F0BDFB38BD052C000060
+:102C800038B5054C75467146201C01F09BFB291C8C
+:102C9000201C01F0AFFB38BD212C000038B5054CDD
+:102CA00075467146201C01F08DFB291C201C01F08B
+:102CB000A1FB38BD3D2C0000F0B599B000AF7446C3
+:102CC00071467862D2483C6101F07CFBD14D694687
+:102CD0002C6865682068FD63684343195A00083210
+:102CE000D208D200891A9A008D460A326D46D2085F
+:102CF0000733FD62D200FD6BDB08891ADB008D46CD
+:102D0000AD00C91A7D636D468D463D63C91A6D4697
+:102D1000C14B8D46B8633D64386CB96B6D46FD613F
+:102D20001D684618AE62E2686862002106F0A4FCE5
+:102D30002269301C002106F09FFCE6680021321C4D
+:102D4000684606F099FC2469B86B221C002168448F
+:102D500006F092FCFA6BB86B53005B083B62FB6AAF
+:102D6000FA6AEB6143005908D3182B62B961B200CB
+:102D70000021386B06F080FCBD6BA200AB003D6B00
+:102D80009C08EB18181C0021BB627C6106F074FCE7
+:102D9000FEF738F8786400F043FA7C6A022C00D120
+:102DA000A1E0032C00D13BE1012C00D004E27D6BBB
+:102DB0007B6CAD08BD632F331E78002E46D00020FB
+:102DC00000F0D2FF934C9549226809685368013B93
+:102DD00021D39D0014683D64651EFD63F7D33D6CEF
+:102DE00088694059956878636C431C1948690134B7
+:102DF000A4002558786B0024854200DD2C1AF86B5E
+:102E0000BD6B4543386B5D19AD0028580419386B0C
+:102E10002C50FC6BE0E71369804A7C6911685A1EEC
+:102E200012193D6B9200AA18013B0DD38869043832
+:102E30000468486905680020A54200DD281B146865
+:102E4000043A20185060EFE7013EB6E7714D2E6856
+:102E50007468013C16D33568013DFAD33B6A7A6C3D
+:102E60006B43E3185B003B64BB6B2F326B43117801
+:102E7000E3183A6B9B00985806F03CFB3B6CF96AF0
+:102E80005852E9E77A693B6BB8699500F96A5D19B0
+:102E90004300CB1834693B63013C0AD37A6CA3002E
+:102EA0002F321178E85806F025FB3A6B66009053F4
+:102EB000F2E7FFF7D7FE574C492123684A241A79D5
+:102EC00018684825CA55E2555A1D1B69E8554C201B
+:102ED000D27FC3557E234B255B424D21381CEA55DA
+:102EE000CB55483092E07C6B7B6CA408BC633033DC
+:102EF0001B787B637C6B474D002C41D0002000F099
+:102F000033FF2A68454B11681E684B1E3B6424D36F
+:102F10003C6CB86B536860435D1EAC4660443D6BCF
+:102F200084002C19FC63013B15D3906801244843AD
+:102F300084469C44F86BA444006865467469AD00FF
+:102F4000386028593C688446A444F86B654605609F
+:102F50000438F863E7E7396CD7E7304B1269196832
+:102F60009300043B013A07D3BC6ACD69E458E858A2
+:102F70002018BC6AE050F4E77D6B013D7D63B9E742
+:102F80002E687468013C16D33568013DFAD33B6A5C
+:102F90007A6C6B43E3185B003B64BB6B30326B4372
+:102FA0001178E3183A6B9B00985806F0A3FA3B6C33
+:102FB000F96A5852E9E7BA69FB6A550034695D1944
+:102FC000013C0AD37A6CA30030321178BA6A6600E9
+:102FD000D05806F08FFAA853F2E7FFF751FE0D4CD8
+:102FE0005121236852241A7918685025CA55E25590
+:102FF0005A1D1B69E8555420D27FC3557E235325A3
+:103000005B425521381CEA55CB555030F96AD1E066
+:10301000592C00001C030020440000204000002028
+:103020007C6B7B6CA4087C6231331B78FB62FD6A8D
+:10303000684C002D00D1A4E0002000F095FE664A07
+:10304000206815684368AC46013B50D30268511EA6
+:10305000FAD38468654662439A186D69013292001A
+:1030600052593D6B7A637A6A4A439A1892005459CE
+:103070007A6BFF25A41AFF2C02DCE543ED172540EF
+:103080007A6CBD6133321278FD693A62EE18FA6BE0
+:103090003D6A4A43AC420DDDB45C0134E4B2B45441
+:1030A0007E6C64B232363678B44217DB3D6CEC1875
+:1030B000BD6912E07C6CB65632342478A6420DDA33
+:1030C0003D6CEC18A65CBD69B54200DA351CA55410
+:1030D000FC690025E218FC6B4C4315557A6A7C6B41
+:1030E0004A433D6B9A18920054510A1CAFE73A4A82
+:1030F000036916685A1E9200013B3ED3F569BC6A0B
+:10310000AD58A4583D62601BFF2802DDFF257D639A
+:1031100003E0C443E41704407C63796CFC693331F9
+:103120000978BD6B8C46611960450EDDC85C0130C5
+:10313000C0B2C854796C40B232310978884217DB8A
+:103140003C6C61197D6BCD5412E0C8568446786C96
+:103150003230007884450BDA3C6CBD6B6019C45C7E
+:10316000A4467C6B644500DA6446C4540020C8540D
+:10317000386ABD6AA850043ABEE7FC6A013CFC62AA
+:1031800055E7FFF78BFD2368582019681A795924F1
+:103190005A25C155E255EA555A1D1B69D27F5C215B
+:1031A0005B20CB557F23C2555B425D22381C396CB6
+:1031B000D355583002F00EFB084B00221B6808481C
+:1031C0005A629A62DA611A62396901F013F9BD46EE
+:1031D00019B0F0BD1C030020400000204400002076
+:1031E000592C0000014B18607047C0464001002078
+:1031F000014B18687047C04640010020014B5868D9
+:103200007047C04640010020014B98687047C04697
+:1032100040010020014B18607047C046BC0E0020E2
+:10322000014B18687047C046BC0E0020014B186067
+:103230007047C046B80E0020014B18687047C04662
+:10324000B80E0020014B18607047C046B40E002035
+:10325000014B18687047C046B40E0020014B186837
+:103260007047C0464C01002010B50D4B00201B7864
+:10327000AA2B12D10B4B1C780B4B64B218780B4B5A
+:1032800040B219780A4B20181A780A4B49B21B78B9
+:1032900040188018C01A43425841C0B210BDC04601
+:1032A00050000200510002005200020053000200D0
+:1032B00054000200550002008023DB020022188027
+:1032C00059809A80C046024B188880B27047C04629
+:1032D0000600040013B5094A042413780021DBB268
+:1032E0001C4301910198F421FF31884205DC1370E1
+:1032F000C046147001990131F3E713BD0D00005071
+:1033000082B00022019201AB55221A70392252423A
+:103310009A700122DA70019AA023DB059A6102B04B
+:103320007047A023DB059869C001C00F70470122D8
+:10333000A023DB05104002060249986908401043AB
+:1033400098617047FFFFFFFE82B0002201920122C8
+:103350000A40891801303F2201AB1040C9B21870F1
+:10336000481C023102408900D9705A70019AA0238A
+:10337000DB05DA61196A024A0A401A6202B0704734
+:10338000FFCFFFFF0002064B000A01380022586001
+:103390009A6005221A60C0461A68D103FCD57047AE
+:1033A00010E000E0F0B5514F85B03B6894339A7857
+:1033B00019681D78DE780F231407994312092D0729
+:1033C00001922D0F0B1C80222B4352001343484ABD
+:1033D0000395484D1340484A2B4048491340240F59
+:1033E0000B400199220413430A0545493607360F5D
+:1033F0000B40009613433206424E0294334013436F
+:10340000414AA024E4051340E360FFF763FF3B68F3
+:10341000E26895331B781540DB069B0FDB021D43EA
+:10342000E560E26880239B001343E360E268802349
+:103430009B011343E360029C039DFFF715FF0028E7
+:1034400013D0324F882039781E34C9B206F052F8B2
+:1034500039784443C9B2882006F04CF80F3545430B
+:103460001E3C00230F3D9C4203DB231E0F2B00DD7F
+:103470000F230F22954200DD151CA024E4051F49EF
+:103480001A40E36812040B401343E360EB43E26825
+:10349000DB171D400F239A431D401543E560E36889
+:1034A000F022934380221343E360E368144A1848F0
+:1034B0001340E360E3683340E360FFF763FFE268D3
+:1034C00080235B051343E3600099E2680B06164016
+:1034D0001E43E6600F48FFF755FF019B08491A0598
+:1034E000E3680B401343E36005B0F0BDB80E002065
+:1034F000FFF9FFFFFFE7FFFFFFDFFFFFFFFFF0FF29
+:10350000FFFF0FFFFFFFFFF0FFFFFFEF5400020080
+:10351000FF0F0000FF6F0000064A074B12680120F2
+:10352000E832126819789040021C0A43D2B21A702D
+:103530007047C0464C010020290000500549064B49
+:1035400009681A78E83109680120884082431A70B6
+:103550007047C0464C01002029000050044B1878E9
+:10356000044B1B68E8331B6818410123184070475F
+:10357000290000504C010020A0230122DB055A70D5
+:103580007047044B82B0019001AA188092789A701B
+:1035900002B070472400005007B500F043FF064B0F
+:1035A000019001AA188092789A70044B00221A7038
+:1035B000034B0122DA7707BD2400005000000020F1
+:1035C00008000050034B00221A70034B0122DA77E7
+:1035D0007047C046000000200800005072B6084B3B
+:1035E0001B5C002B03D1C04662B630BFF6E762B663
+:1035F000A023DB059968034A0A409A607047C046D9
+:1036000000000020FFFFF9FF72B6074B1B5C002B88
+:1036100002D1C04662B6F7E762B6A023DB0599681F
+:10362000024A0A409A60704700000020FFFFF9FF3D
+:10363000A023DB055A680121120E58689143034A02
+:10364000090602400A435A607047C046FFFFFFFE6A
+:1036500008B5074B1B681A1C9C3212789D331B78E7
+:10366000520001325043994005F044FF08BDC04666
+:10367000B80E002008B5044B1B689F331978490029
+:103680000131FFF7E5FF08BDB80E002008B5A02303
+:103690000120DB055870FFF7A1FFFFF7C9FF08BD48
+:1036A000F7B5A026041CF605042807D1554B1B6866
+:1036B0001A1CA432A83317681B6824E0524B1B68FD
+:1036C0001A1C8C331B68883217687361FDF7ACFBDA
+:1036D000E7300378002B17D005F0B8FE05F00AFE9E
+:1036E00001797F2211408904019171690B1C4749BE
+:1036F0000B400199194371614179444B0A4071694A
+:1037000092040B4013437361A023DB051F611E6904
+:103710001F231E40FFF7A8FD00280AD03C4B88203D
+:1037200019780436C9B205F0E5FE46430023043E8D
+:1037300003D4331E1F2B00DD1F23A022D205108AC5
+:103740001F210B40884303431382022C16D007DC51
+:10375000002C13D0012C2DD12B4B1D689E3529E058
+:10376000042C07D023DB052C24D1264B00241D6814
+:10377000AF351FE0234B1D68AC351BE0FDF754FB54
+:10378000031CCC331B78002B03D01E4B1D685D350A
+:1037900010E0E7300378002B05D005F057FE05F068
+:1037A000A9FD851D06E0184B1D689B3502E0164BF0
+:1037B0001D68A135A023DB05596928783F221040F8
+:1037C00091430143596168781F215D69084011499F
+:1037D000C0022940014359610F49640009680C196E
+:1037E000211C773108785968104091430143596092
+:1037F0007834217858680A401102084A02400A4386
+:103800005A60F7BDBC0E0020B80E0020FFFF03FE7B
+:1038100054000200FF07FFFF4C010020FFC0FFFF24
+:10382000294BF0B51A68294B85B01B689E331B786D
+:103830005B069B0E0193931DD97F00238D005519C4
+:10384000581E5B18002B27D053181B1826331B78E3
+:103850008024D3185E78A023DB055F68E4033C4333
+:103860005C60019CB606240400945F68B60EBC46FA
+:10387000174F64462740009C27435F60C0462436AC
+:1038800076008400F65A2C19983426605E68114C34
+:1038900034405C60031CD3E76F460293BB81012375
+:1038A0003B72931DDB7F7F217B72BB72FB7A983268
+:1038B0008B4304210B43FB720F20B02302A93B73FF
+:1038C00002F0E2F905B0F0BD4C010020B80E002076
+:1038D000FFFFC0FFFFFFBFFFF0B585B0FFF7A0FF00
+:1038E000154B00251E68B31DDC7F631C9B005B42EB
+:1038F0000093A300F3180193009B043D9D4208D060
+:10390000019A0121571998373868FFF7A1FE3860EE
+:10391000F2E76A4600239381012313720423D372D2
+:10392000B023547294721373321C98320F2002A980
+:1039300002F0AAF905B0F0BD4C010020044B0022B2
+:103940005A70A023DB055A7001221A707047C046D6
+:1039500000000020A023DB059968064A0A40802168
+:1039600089020A439A60044A0021917001229A70E8
+:103970007047C046FFFFF9FF00000020024B1B68A4
+:10398000903318687047C0464C010020024B1B68FA
+:10399000903318607047C0464C010020A023DB051F
+:1039A0009868C0B2704730B5A023DB059B68DBB2D6
+:1039B00083420ED001DA013300E0013BA022D205A0
+:1039C0009568FF211C1C8D430C40291C21439160EC
+:1039D000EEE730BDA023DB059968802252020A433E
+:1039E0009A609968094A0A409A609A681201120915
+:1039F0009A60D968064A0A40DA60D968054A0A40DE
+:103A0000DA60D968044A0A40DA607047FFFFFFF0C5
+:103A1000FFFEFFFFFFDFFFFFFFFFFFEF1B4B10B5B8
+:103A20001A680121131C92331878A023DB059C68C7
+:103A300008401749000421400143996093321078EF
+:103A40009C681449000700092140014399601178DE
+:103A50009A6809091201090712090A439A60D9688C
+:103A6000802252000A43DA60D968802292010A4318
+:103A7000DA60D968802252050A43FA20DA608000B1
+:103A800000F0F4FCFFF77EFC10BDC046B80E00202D
+:103A9000FFFFFEFFFFFFFFF008B50020FFF79EFDD0
+:103AA00008BD034B1B689C331878400001307047F9
+:103AB000B80E0020024B1B689D3318787047C04633
+:103AC000B80E0020004870470010005000487047B2
+:103AD000002000500048704700400050074B012074
+:103AE0001B685B799A1C0340D318054A126866323A
+:103AF00010785843034B8000C0187047BC0E00205C
+:103B00004C01002004400050F7B51B4B051C1C68FD
+:103B1000A3795F1E15D36279013A10D36079561CE0
+:103B2000811C01910121084001990818584331185E
+:103B30001248890009180868E8400860ECE73B1C57
+:103B4000E7E7FFF7CBFFA37A002201339C466346E9
+:103B5000013B9C460FD3617A9600019186190023A0
+:103B60000199994205D09F00F1590133E940F15183
+:103B7000F6E75218EBE7F7BDBC0E002000400050FE
+:103B8000074B01201B685B799A1C0340D318054A38
+:103B90001268723210785843034B8000C018704787
+:103BA000BC0E00204C01002004400050094B0121B4
+:103BB0001A685379D0799A1C0B40D318064A013001
+:103BC00012686A3212785343C018044B8000C01840
+:103BD0007047C046BC0E00204C0100200040005041
+:103BE000F7B5434B1D682A7853B2042B1DD1414BC6
+:103BF00019680B1CAE331F7802235E1E77D34A79F7
+:103C0000013A10D34C79551CA01C019001200440AE
+:103C1000019804195C432819374C80000019046886
+:103C2000FC400460ECE7331CE7E7002A45D0022B98
+:103C300021D1FDF7F9F8CC3003782E4C002B02D0BF
+:103C400023685F3302E02D4B1B689D331878FFF724
+:103C50005BFF2568EC79002C2FD0FFF7A7FF061C2F
+:103C6000013C2AD3697A201C05F09AFC89008A5904
+:103C7000A300F250F4E7032B03D1204B1B68A333BE
+:103C800018E0012B11D1FFF77BFF1A4B061C1B68B4
+:103C90005C79013C11D32B193A331B789B0098595E
+:103CA000FFF7E8FCA300F050F3E7052B05D1114B1B
+:103CB0001B68B1331878FFF727FF104B1B689A3346
+:103CC0001B78002B13D00B4B1A685379013B0ED392
+:103CD000517901258C1C294061189479581C614345
+:103CE000401805498000401800210160EEE7F7BD4B
+:103CF0004C010020BC0E002000400050B80E0020F7
+:103D000008B5A0230120DB055870FFF767FCFFF71B
+:103D10008FFCFFF765FF08BD70B5041C104E114DF8
+:103D200011D10120FFF7BCFC336801221A70A023D7
+:103D3000DB056C705C701A70FFF7E2FFFFF778FC30
+:103D4000FFF7CAFD0224201CFFF7AAFC33680022FB
+:103D50001C70A023DB056A705A7001221A7070BDB6
+:103D60004C0100200000002008B5FFF7D5FFFFF749
+:103D7000C7FF08BD08B5A023DB05011C58683F221A
+:103D80001140904308435860596858681140013108
+:103D90000A401102064A02400A4306495A600022BC
+:103DA0004A705A7001221A70FFF7AAFF08BDC04678
+:103DB000FFC0FFFF0000002010B5A023DB051C6A38
+:103DC0000005064A000D010422400A431A621A6ADD
+:103DD000120B12031043186210BDC046FFFF00F023
+:103DE00073B5174BA0221B68D205903391681968F0
+:103DF00091601C78FFF738FA124D002812D0124B50
+:103E0000124A1B7812782E6852B25BB20092201CC4
+:103E10001021D12201F0F2FF2B68943630609433E8
+:103E20001B68E418002C01DA002402E0FF2C00DDFE
+:103E3000FF242B68E0B290331C60FFF7B4FD73BD24
+:103E4000B80E00204C010020530002005200020076
+:103E500008B5FFF7C5FFFFF7A5FAFFF751FA234BA7
+:103E6000C022920098582249014099509958FF2049
+:103E7000814340200143995098581E4901408020B9
+:103E8000000401439950985880210002000A090655
+:103E900001439950012102221A600820196004216F
+:103EA00019601860144B00205860144B18690143C6
+:103EB0001961134B1B68197A124B1B68E8330029F0
+:103EC00000D1032210491A6000230B700F49A02271
+:103ED0000B700F49D2050B709363D36B9B0E9B063F
+:103EE000D36362B600F09CFE08BDC04600E100E06E
+:103EF000FF00FFFFFFFF00FFFCE100E000ED00E03E
+:103F0000BC0E00204C010020290000502800005069
+:103F10002A00005008B5002801D0012801D100F086
+:103F20007FFEFFF75DFFFFF73DFAFFF7E9F908BDF8
+:103F3000F0B5214B13211B680224DA7A0023133ACF
+:103F4000D2B291425B41E41AA023DB0558693F22BB
+:103F5000596810408022D2030A43A3B05A60411E20
+:103F6000A023C9B2DB0502AAFF2910D05F683F2653
+:103F7000124D0E4036043D4035435D60C046251C61
+:103F800024356D005D5B4B00D5520139E8E75C6874
+:103F90000B4921405960694600238B8001230B7037
+:103FA000022348708870CB700320B3230B7101F09B
+:103FB0006BFE23B0F0BDC046BC0E0020FFFFC0FF6B
+:103FC000FFFFBFFFF7B5041C02F008FD124B1A6893
+:103FD00000235068411C0191019D16689D420CDB35
+:103FE000976801367E4399008C469E1900216546EC
+:103FF000B600615101333151EEE701239E420ADBE5
+:10400000956800215D43AF002D180135AD00395191
+:1040100001332951F2E7F7BD1C030020044B054989
+:1040200000221A6059609A6005221A607047C046E3
+:1040300010E000E0FFFFFF0010B5A023DB059C6847
+:1040400099680C4BC9B21B68E40394331B68E40FF6
+:10405000591AFF31E62359430134074BA040C918D0
+:10406000041C064805F046FAC1B2201C05F042FACD
+:1040700010BDC0464C0100205C5D000040420F00B6
+:10408000014B00221A60704710E000E030B50E4D81
+:104090000E48AB6885B0C01A0193FFF7CDFF02A9A7
+:1040A000012300240B704B708B7004230190CB70A4
+:1040B000201C6F2301AA8C800B7101F0E5FD019893
+:1040C0002C6005B030BDC04610E000E0FFFFFF00EF
+:1040D00010B5041CFFF7A2FF201CFFF71DFEA02354
+:1040E000DB0501205870FFF78FFAFFF7A1FAFFF701
+:1040F00077FDFFF7CBFF10BD37B5051C0424291C45
+:10410000221C684605F076FA2919221C01A805F040
+:1041100071FA009980230ABADB05DA6001990ABABC
+:104120001A6137BD40BA80B2704700BA70470023A9
+:10413000114A12499A188A4204D21149C9580433C3
+:104140001160F5E70F4B104A191D043B934203D24F
+:1041500000221A600B1CF6E70C4B0D4A1360EFF3BC
+:1041600008820433191D043B9A4203D90948186098
+:104170000B1CF7E77047C0464000002030030020CA
+:10418000DC97000034030020680D0020F80E0020AA
+:10419000D40E0020CDCDCDCDF0B5294D89B0294824
+:1041A0002C6800F063F9FFF7EDF80026264FBC42BB
+:1041B00022D280373B1B2027832B00DC9F1002A9D3
+:1041C000FAB2012300204A708A70BF10221C0B70C3
+:1041D000CB70888001F058FD231C3A1C013A08D3AB
+:1041E000002E04D119491868884200D01E1C0433DF
+:1041F000F4E7BF00E419D9E72B6804A9F31A0025F6
+:10420000019304230124CB70281CA72301AA8D80CD
+:104210000C704C708C700B71843701F035FD06A961
+:104220000420C870A823BE1B281C01AA8D800196FB
+:104230000C704C708C700B7101F026FD09B0F0BD54
+:10424000D40E0020801A060080370020CDCDCDCDC1
+:10425000024B1B680633D87F7047C0464C010020D4
+:1042600070B5051CFFF78CFC0A4B1C68A31DDB7F97
+:104270009A00AD180022511ED218002A09D0E21867
+:10428000521826321278920016588A00AE500A1C34
+:10429000F1E770BD4C01002030B50B4B1B689A1D37
+:1042A000D27F94001C195300C01800230133D11A87
+:1042B000013107D09D00651B983559002D68494292
+:1042C0004552F3E730BDC0464C010020A02382B028
+:1042D00080B2DB05D88502B07047A023DB05D88DFE
+:1042E00082B002B070470722A023DB0510404201D4
+:1042F000188AE0218843104318827047F8B50C1CD7
+:10430000051CFEF7A5FF144908688379013B11D30A
+:104310000E687279013AF9D30E6870790F4E5843DE
+:1043200036688018F6182818A03607783679BE192E
+:104330000670EFE70B68DB79013B08D3074AE15CC5
+:104340001268D218C83212788A18E254F4E7281C8E
+:10435000211C00F0E1FEF8BDBC0E0020B80E0020CC
+:10436000134BF7B51C686946E26800AF131C0E33A7
+:10437000DB08DB00C91A23698D460E33DB08DB003E
+:10438000C91A0C4B6D461E688D467960281C311C7D
+:1043900005F030F9F0239B00F1182269786805F0E8
+:1043A00029F9281C7968FFF7A9FFBD46F7BDC0466B
+:1043B0001C030020B40E0020A023DB0518690006B2
+:1043C000400F704770B5051CFEF71EFF0468061C01
+:1043D000013C08D37268E300D3181A68AA42F7D1E7
+:1043E0005B689847F4E7024B013D1D6070BDC04615
+:1043F000C00E002070B5051CFEF706FF8468061C81
+:10440000013C08D3F268E300D3181A68AA42F7D136
+:104410005B689847F4E7024B013D1D6070BDC046E4
+:10442000C00E002038B5A023DB0599689D680C4BB1
+:10443000041C1B680B4894331B68ED03C91AC9435D
+:10444000E623C9B25943084BED0FC91805F052F8DD
+:10445000044B01355843211C284105F04BF838BD69
+:104460004C01002040420F005C5D000038B5A023E5
+:10447000DB0599689C680A4B051C1B680948943346
+:104480001B68E403C91AC943E623C9B25943064B62
+:10449000E40FC91805F02EF868430134204138BDF7
+:1044A0004C01002040420F005C5D0000002801D05C
+:1044B000133907E0122902DD262902DD12394910DD
+:1044C00000E000E0081C7047F0B5AA4B00261D680C
+:1044D000041CEB7A1322133BDBB2301C9A4270416E
+:1044E000B1B0C7B2059702273F1A311C142209A8A0
+:1044F00005F0C2F8A04B20681B68882201936B333B
+:104500001870019B61686E3319700EA8311C05F09C
+:10451000B3F8311C142209A805F0AEF8974B0EA889
+:104520001968442205F066F8022F04D11FA80EA9CD
+:10453000442205F05FF800272E1C0497771B039791
+:104540006B7901369F423EDAB77A0598391CFFF73E
+:10455000ADFF09A9095C0EAB0291029A44215143B7
+:1045600009185918721B0A717911069109A90A5C78
+:1045700011214A43069952181F210F40063201218A
+:104580009200B9400F1CD1580F43D7500399019F97
+:104590003F237A185178071C99438C4602991F4093
+:1045A00089010691614603970F431F40069B1F43F5
+:1045B000029B5770013309AFDBB23B54049F9F420B
+:1045C000BCDA0493BAE7019B049D6D3300261D708D
+:1045D0000296684B029E19688F79BE4200DBBEE0EE
+:1045E000029D49190B1C2833DA79644B1E68331C71
+:1045F0009A331B78B446039303980023984204D05F
+:10460000781E854201DA2931CB790120011C9140C5
+:104610000591111C2039051C8D40A9011D1C203D50
+:10462000061CA840049D9E408909069607900195A6
+:10463000019D002D38D0019E4425013E7543019611
+:1046400066680EA82E544519281C002620302E62BC
+:104650004668B60EB606009646601F2A02DC05982C
+:10466000286204E08D01009EAD092E434660039D43
+:10467000002DDDD0029E781E8642D9DA019E4425A7
+:1046800075430EA845191F2B04DC2E6A069830438B
+:104690002862CDE7686A079E0643B601800EB60918
+:1046A000800630436862C3E7029E6046331C45784B
+:1046B0006344C833AD065F79AD0EFEF7D5FD002823
+:1046C00013D02F4E882031780137C9B204F012FF81
+:1046D00031784743C9B2882004F00CFF02354543C6
+:1046E000013F023D019E791C03D03E1E1F2E00DDBE
+:1046F0001F263F2D01DD3F2526E0EB43DB171D4044
+:1047000022E00199442251430EAB59188F781F23A0
+:104710009F43301C18403B1C03434F788B703F2352
+:10472000281C9F4318403B1C034320684B703B28C8
+:104730001CDC5043134FC01904F05CFF2368019F39
+:104740000133013723600197019F04988742D8DB2A
+:10475000029D6368013501330295636039E7064BBA
+:1047600022681B6801206C331A7000E0002031B011
+:10477000F0BDC046BC0E00204C010020B80E002049
+:10478000540002000080005030B585B0FEF760FD97
+:10479000064B01A81B68021C843332CB32C2FFF7E0
+:1047A00093FEFFF7DDFD05B030BDC0464C01002093
+:1047B000F0B5564B9FB01B6800270493DB7A132299
+:1047C000133BDBB2391C9A427941CBB2051C391C30
+:1047D000142208A8079304F04FFF4D4B2A681E6867
+:1047E0000DAC331C6F331A706968023359701F7037
+:1047F000391C4422201C04F03FFF391C142208A855
+:1048000004F03AFF434B201C1B684422191C0693FA
+:1048100004F0F0FEB31DDF77049A53799F4233DA38
+:10482000049A0798D319DB7A191C0593FFF73EFE0B
+:1048300008AB1B5C9C46002B0BD1B31DDA7F511CCF
+:10484000B218D9770732FBB20DA9D37701330A1812
+:1048500013710DAB19180979F2193A320139117037
+:10486000059901374A110632920003921F220A402D
+:1048700001219140039AD2581143039AD1506346C3
+:10488000013308A90B54C7E7069B5E78B606B60E3F
+:10489000FEF7EAFC00280AD01F4B88201978023660
+:1048A000C9B204F027FE46430023023E03D4331E60
+:1048B0003F2B00DD3F23A2781F218A436178A2703D
+:1048C0003F2291431340626A0B4369686370930E01
+:1048D00021709B06002119A814222162636204F052
+:1048E000CBFE2868442250430C4B211CC01804F016
+:1048F00081FE6A682B6801326A60054A01331268DA
+:10490000012070322B6013701FB0F0BDBC0E002070
+:104910004C010020B80E002054000200008000501E
+:10492000F0B5BA4BB1B01B680024039353331B7826
+:10493000071C133BDBB21322201C9A426041C5B214
+:10494000059502252D1A211C142209A804F094FEB5
+:10495000AF4B3E681B68211C049363331E70049B9D
+:1049600078686633187088220EA804F085FE211C32
+:10497000142209A804F080FEA64B0EA81968442250
+:10498000443104F037FE022D04D11FA80EA94422A1
+:1049900004F030FE0025039C0695039E039DA61B94
+:1049A00007966B7A01349E4237DA231C52331D7806
+:1049B0000598291CFFF77AFD09AA115C6E118C4637
+:1049C0000296112166467143029E0EAB89191F267D
+:1049D0003540063101268900AE40351CCE5835439E
+:1049E000CD50079E049D3F23A919051C1D40583139
+:1049F00066460295B6018D790196029E9D432E432F
+:104A00001E40019B069D1E4363460133DBB28E713F
+:104A100013549D42C1DA0693BFE7069E049BF6B28B
+:104A2000653307961E700024784B04941B68049D20
+:104A30009A7A954200DB9BE0049D069C5A195832F5
+:104A400011780122081C2038161C82408E409001EB
+:104A5000B44680090394039C002C1BD0039D442280
+:104A6000013D6A437E680EAC1655A2180395141CCE
+:104A70001F2905DC566A65461562B20E920607E0EC
+:104A800000251562666A8201B50E9209AD062A43B9
+:104A90006262E0E75E4A1168221C587A824210DAAC
+:104AA0008818583084794425A006A4096C43BE6850
+:104AB000800E20180EAD0136281806710132BE6036
+:104AC000EBE7544B1B681A1C4632453316781C78AA
+:104AD000F606A406F60EA40EFEF7C6FB002813D0B9
+:104AE0004D4D882029780136C9B204F003FD29789C
+:104AF0004643C9B2882004F0FDFC02344443013E21
+:104B0000023C0025701C03D0351E1F2D00DD1F2523
+:104B10003F2C01DD3F2402E0E343DB171C40039EF2
+:104B20000698864221DA0399442251430EAB591864
+:104B30008E781F239E43281C1840331C03434E7855
+:104B40008B703F239E43201C1840331C034338685E
+:104B5000324E50434B70801904F04CFD3B68039E6D
+:104B6000013301363B600396D9E7049C01345BE7CF
+:104B7000274A3E681468079D221C64321670386804
+:104B8000D07079680532517015700022597A8A42C6
+:104B900010DAA1185831897944208D0689094843D3
+:104BA000AD0EB96840190EAE0131301801710132F5
+:104BB000B960EBE71AAD03950025069EB5421EDAF3
+:104BC00044236B430EA8C618706A0021820E920619
+:104BD000316272620398142204F04EFD3868442159
+:104BE00048430E4A311C8018442204F003FD3B6800
+:104BF000039E013344363B6001350396DDE73B6895
+:104C000068340120237031B0F0BDC046BC0E0020D6
+:104C10004C010020B80E002054000200008000501B
+:104C2000F0B56B4B00241F681322FB7A211C133B49
+:104C3000DBB28DB09A4261410226CBB20C22761AC9
+:104C400004A8211C019304F017FD142207A8211CBD
+:104C500004F012FD7A793D1C02920299EB1B8B4203
+:104C600013DAE97A0198FFF721FC132801D9002013
+:104C7000ACE007AA135C0135B342F8DA0133DBB2CA
+:104C800013549C42E9DA1C1CE7E701220492B8792C
+:104C9000002181420ADA131C9D1AA54203DA3B2B3C
+:104CA000E5DC0133F8E701311A1CF2E70492FB79E5
+:104CB000002B11D1002304A80493FFF779FD04A869
+:104CC000FFF702FC424B434D1B68DE79002E3ED0BD
+:104CD00004A8FFF725FE50E03B1C53331B7800254A
+:104CE000133BDBB21322291C9A426941CAB20292D9
+:104CF0000222521A019207A8291C142204F0BCFCBB
+:104D00007B7A3E1C0393039AF31B934214DA331C01
+:104D1000533319780298FFF7C9FB1328A7D807AABD
+:104D2000135C019901368B42A1DA0133DBB21354D3
+:104D30009D42E8DA1D1CE6E7EB43DB171D40BB7A1A
+:104D40005D43049B6D00ED183B2DB3DD8FE72868B4
+:104D5000311C0422633004F08FFC2868311C0422CB
+:104D6000673004F089FC2B680499CAB2191C6331BE
+:104D700068330A704A700A711A702D6864002B1C1F
+:104D80006F331A78073BDA73291C1B7878310B7064
+:104D90004A70083909782A1C7A3211700F3A16784D
+:104DA000291C7B31281C0E707D305374022204F0C4
+:104DB00021FC2F1C2B1C7F33083734195C701E70AC
+:104DC0006E35FE672A7801339A6001200DB0F0BD80
+:104DD000BC0E00204C0100200D4B10B51C680D4B83
+:104DE00001681B681A1C673211704168D170191C68
+:104DF000693100220A70617A8A4204DA81680132DC
+:104E000001318160F7E70268683301201A7010BD34
+:104E1000BC0E00204C010020A14BF0B51B68B3B0C4
+:104E20001A1C0832D26F002406929E4A132115687C
+:104E3000201CEA7A069F133AD2B2914260411A1CB2
+:104E4000C6B27332177076330296012202261A70A8
+:104E5000361A211C882210A804F00EFC211C1422F2
+:104E60000BA804F009FC291C603110A8442204F0AE
+:104E7000C1FB022E04D121A810A9442204F0BAFBE0
+:104E80006E790027059603973C1C059FBC422ADAE1
+:104E90002B19DE7A0298311CFFF708FB0BAB195C6B
+:104EA00010AA8C46674644217943091851180134E9
+:104EB0000C711F5C7111049111214F4304997F18EB
+:104EC000B91D1F273E4001278900B7403E1C8F585F
+:104ED0003E438E5062460132039ED2B21A5496422D
+:104EE000D3DA0392D1E7069D00240595039F02972C
+:104EF000029F002F16D0029E4422013E724310AF43
+:104F0000BA180296D66A0021556A11629162B10EF2
+:104F10008906D378A80ED162202180060B43506207
+:104F2000D370E5E75F4B221C1868817984460791AE
+:104F3000079D131BAB4248DA65462B1B9B182F338A
+:104F4000187801231F1C874051100497071C194033
+:104F5000203FE6B20991BB40039908961F1C002927
+:104F600031D0013944234B4310AE651C9D55089D3B
+:104F7000F318099E6DB20195B54210D01F2804DCCC
+:104F80001E6A049D35431D62E9E75D6A2E1C3E439F
+:104F9000B601AD0EB609AD0635435D62DFE71F28E9
+:104FA00004DC9E6A049D35439D62D8E71D1CDB6AC4
+:104FB0003B439B019B090193EB6A9E0E019BB60646
+:104FC0003343EB62CBE70132B2E7374B1B685B1927
+:104FD000C8335F79634661331D78AD06AD0EFEF7C9
+:104FE00043F9002813D0314E882031780137C9B2F7
+:104FF00004F080FA31784743C9B2882004F07AFA85
+:1050000002354543013F023D0026781C03D03E1E79
+:105010001F2E00DD1F263F2D01DD3F2502E0EB4363
+:10502000DB171D40059944274F43214ABF18029AB8
+:10503000039B9A4220DA02994422514310AB59183B
+:10504000301C1F231840049088789843031C049850
+:1050500003438B70281C3F231840049048789843E2
+:10506000031C049803434B70381C04F0C3FA0299E4
+:10507000443701310291DAE7DB43039D059EDB17DC
+:105080002B40F61801340596022C00D02EE7044A76
+:10509000069D1268E918CB187432137033B0F0BD56
+:1050A0004C010020BC0E0020B80E0020540002006D
+:1050B00000800050F8B5164D061C2B6800246333A1
+:1050C0001F782B68E1191A1C64321278013491425E
+:1050D00009DAE319442058430E4B311CC01814223E
+:1050E00004F0CAFAEDE76B331F7800242B68E2194D
+:1050F0006C331B7801349A4209DAE319442058438F
+:10510000044B311CC018142204F0B6FAEEE7F8BDC7
+:105110004C010020EC7F0050F0B5374B85B01B6888
+:1051200002901A1C039163321578344A00201168EA
+:10513000041C8A7A94422BDA021C4F7A161ABE4259
+:105140001FDA9E195836B679B7090096EF1944262A
+:105150007E432B4FB4463E1C009F66440196BE061C
+:10516000039FB60EB446BE5C3F2E00DD3F26F6B26E
+:105170000096019E0132371C6744009E30373E7016
+:10518000DBE7181C6530007801342D18101CD0E7BF
+:105190001A1C6B32147800208A79904229DA002296
+:1051A0004D790195AA421EDA9E187678B709E7195B
+:1051B000039744273D1C039FB6067D43AC46104D24
+:1051C000B60E2F1C019D674445430397029FBF18ED
+:1051D0007D5D3F2D00DD3F25039FEDB2BE193036CA
+:1051E00035700132DCE71A1C6D3212780130A418D8
+:1051F000D2E705B0F0BDC0464C010020BC0E002037
+:105200000080005044235843044B111CC018C2783E
+:105210000F2319409A430A43C27070470080005020
+:1052200038B5051C141CFEF71FF8002808D00A4BDF
+:10523000882019780234C9B204F05CF94443023C76
+:1052400044206843054A3F23801802781C409A4353
+:105250001443047038BDC046540002000180005061
+:1052600010B5041CFEF700F8002808D0084B882071
+:1052700019780434C9B204F03DF94443043CA02336
+:10528000DB05198A1F22144091430C431C8210BD78
+:105290005400020030B50F4B1B689979884203DA3D
+:1052A0001B182833D87914E05A798D18411AA8426E
+:1052B00002DA5B18D87A0CE09C7A8A1A2D19A84277
+:1052C00003DA9B185833187803E0141B1B1950336A
+:1052D000D87830BDBC0E0020F0B5D44DA024E40534
+:1052E000A3682B6897B059799A7900AF8A18597AD0
+:1052F0009B7A5218D3181A1C5A437B62D31DDB08C1
+:10530000DB006846C01A85466B46FF217B6104F0CE
+:10531000B3F9FF20FFF7AAF8C54B69461B1A786A54
+:10532000BB60C000031C0E33DB08DB003861C91A08
+:10533000786A8D466B4680003B62031C0A33DB08AB
+:10534000DB00C91A002200233A637B63F860F9612D
+:10535000E268B84B8D461340E3602B685C79B34B31
+:10536000013C1B68621C14D01B19381CD97A5030C0
+:10537000202204F021F93D6D58207A6DAB00C01950
+:10538000C3180121283B91400A1C19680A431A607E
+:10539000E5E79C79A54B013C1B68621C15D01B19E5
+:1053A0002833381CD9795030202204F005F93D6D9E
+:1053B00058207A6DAB00C019C3180121283B9140D9
+:1053C0000A1C19680A431A60E4E75C7A974B013CAF
+:1053D0001B68621C15D01B195033381CD97850300B
+:1053E000202204F0E9F83D6D58207A6DAB00C01919
+:1053F000C3180121283B91400A1C19680A431A600E
+:10540000E4E79C7A013C621C17D0884B381C1B686F
+:1054100050301B1958331978202204F0CDF83D6D17
+:1054200058207A6DAB00C019C3180121283B914068
+:105430000A1C19680A431A60E4E77D69BD6100250A
+:10544000FD62FD6A786A854200DBDEE000213A6990
+:10545000386A04F011F9A0240021FA68F86904F010
+:105460000BF9E40500232363636B9B0E9B066363C8
+:105470003D6BA563786BB862E36B86019B0EB60942
+:105480009B063343E3636420FEF7F0FFFDF77AFFEA
+:10549000F86AFFF7FFFEC1B2381C4830202204F042
+:1054A0008BF8396B7A6BFB6CB963FA63BA6C0121C8
+:1054B000994058200B1CC01991004118081C203835
+:1054C00002689A430260B86C131C00280AD028397D
+:1054D0000A6853409A01636B92099B0E9B06134323
+:1054E000636301E06B402363A024E405A563E36BE1
+:1054F0000A209B0E9B061E43E663FEF7B7FFFDF7EF
+:1055000041FFE26B8023DB041343E363B96BBA6AA8
+:105510004D40A563FB6B5A40E36B92019B0E9209D1
+:105520009B061343E363FEF779FDFD6BBE6B3B6A9D
+:10553000AC460124404ABD689168A94214DB3F4A49
+:1055400065461068526830402A405D68954203D332
+:10555000F0D11D688542EDD2FD69DA60A200986045
+:10556000A95001340833E5E7FEF78AFDA023DB05E7
+:10557000D96B334A0A40DA63012C3ED0651E386A83
+:10558000ED004519013C002C37D02B1C083B1A6854
+:1055900029685B6891436A687E6A9A43A30039640C
+:1055A0007A64013EBB62FA6A964224D0301CFFF74F
+:1055B00071FE011C381C5030202203F0FDFF7B6D72
+:1055C0000122386D9A405821131CC91982008A188B
+:1055D000183A12681A420CD0BB6AFA691720D258DE
+:1055E00040425043174BC018FEF726FDB969001121
+:1055F0008855013ED7E7083DC4E7FD6A786A013562
+:10560000FD62BD692D18BD611BE7C3B2381C503067
+:105610000370437083700023C370037179690123A1
+:10562000437100F0D7F8BD4617B0F0BDBC0E0020A6
+:10563000FFFFFF00FFFF0FFF10E000E04000005001
+:10564000FFFFFFFBE9FFFF16014B18607047C046E4
+:10565000C80E0020014B18687047C046C80E0020D5
+:10566000014B18607047C046C40E0020014B1868FB
+:105670007047C046C40E0020014B18687047C046F2
+:1056800050010020F7B52F4F73467146381C019327
+:10569000FEF798FEFBF7B6FB009001F09FF9061CA1
+:1056A000FDF7BEFD284D1022041C0099286803F068
+:1056B000A1FF32882B68381C1A74120A5A74B288F7
+:1056C0009A74120ADA74214A12680532D27F002ACB
+:1056D00003D0A2791A75627902E062791A75A2790B
+:1056E0005A75E2799A751A4A6B6812881A70120A0A
+:1056F0005A70184A52889A70120ADA70164A5288FA
+:105700001A71120A5A71154AD2889A71120ADA71FC
+:10571000134AAB68920A1A70124A920AD2B25A70AD
+:105720009A70114A920AD2B2DA701A710F4A920A2A
+:10573000D2B25A719A710E4A920ADA710199FEF741
+:1057400059FEF7BD25560000540100201C0300201F
+:10575000FE030000FC9B0000FCAF0000F8BF00004F
+:105760000000000000040000009C000000B00000E9
+:1057700000C00000F7B50A4C7146061C201C754697
+:10578000FEF720FE074A694681CA81C16B46B60012
+:10579000F658201C291CFEF72DFE301CFEBDC0460D
+:1057A00015570000C496000070B5084C7146201CC7
+:1057B0007646FEF707FE064B201CDB69311C5D7840
+:1057C000EDB2FEF717FE281C70BDC0464957000019
+:1057D00054010020F8B5144D041C0F1C281C714600
+:1057E0007646FEF7EFFD114BFF215A6A1170104902
+:1057F0009C620F60A0782778596B474320793F1847
+:1058000060794006400E784308609869A0210170D5
+:10581000D969281C1378FF2B02D10B78022BF9D001
+:10582000311CFEF7E7FDF8BD75570000540100205C
+:105830006004002038B50D4C7146201C7546FEF7FB
+:10584000C1FD0B4AD1694B780A49DBB20B72012BBF
+:1058500005D0022B05D1936901225A7001E0FDF7B2
+:105860005BFE291C201CFEF7C5FD38BDD557000086
+:10587000540100206004002038B50D4C7146201CF6
+:105880007546FEF79FFD0B4BDB68002B0BD00A4AD9
+:10589000DBB2106C7F2119404832017093700133E4
+:1058A0005370FFF7C7FF291C201CFEF7A3FD38BD6E
+:1058B00019580000600400205401002070B50F4CFE
+:1058C0007146201C7546FEF77DFD0D4B261C1B7A8C
+:1058D0000C4C012B05D0022B05D1A269002353707B
+:1058E00001E0FDF72BFE236C7F211A78301C8A43E0
+:1058F0001A70291CFEF77EFD70BDC0465D58000081
+:105900006004002054010020F7B51E4E7346301C81
+:1059100071460193FEF756FD1B4D00241B4E337A52
+:10592000012B07D0002B18D0022B17D1184B9B69E5
+:105930005C7813E0FDF712FE041C002D0BD1FDF77F
+:10594000FDFD2E23FF33013B002B01D0C046FAE7BB
+:10595000FDF7E2FD0C4D013D00E01C1C0C4FFA6907
+:105960005378327A9A4206D0FFF7A8FFFB69074ABC
+:105970005B78137201E0002CD0D102480199FEF748
+:1059800039FDF7BDA9580000FF2C0100600400207C
+:1059900054010020F7B5164D7346071C0E1C281C39
+:1059A00071460193FEF70EFDFFF7AEFF114C80220A
+:1059B000236C52421978606C0A431A70391C321CED
+:1059C00003F018FE236CF6B218787F229043311C46
+:1059D0001140021C0A431A704834A670FFF72AFFD0
+:1059E000FFF792FF281C0199FEF704FDF7BDC046A2
+:1059F0003559000054010020F8B5FBF703FA00F018
+:105A0000EDFFFDF70DFC1A4C051C666B03F054FC12
+:105A10007060FFF737FE174B1B681888E36B020AAC
+:105A20005A711871FFF7A6FEE26BC6B296712B6829
+:105A3000EF790136FF1801374743381C00F0EFF9C2
+:105A40003A1C0021051C206403F016FE231C483379
+:105A5000013500225E7065649A7003F027FC064BE6
+:105A60005860A023DB059A7CE36C1A70F8BDC04631
+:105A700054010020C80E002060040020024BDB69A6
+:105A80001878C0B27047C04654010020024BDB6951
+:105A90009878C0B27047C04654010020014BDB69C2
+:105AA0009870704754010020024BDB69D878C0B26F
+:105AB0007047C04654010020014BDB69D870704725
+:105AC00054010020014BDB695868704754010020E5
+:105AD000024BDB695A6858607047C0465401002089
+:105AE000024BDB69187AC0B27047C04654010020EF
+:105AF000014BDB691872704754010020024BDB69CF
+:105B0000587AC0B27047C04654010020014BDB698F
+:105B10005872704754010020024BDB69D87AC0B23A
+:105B20007047C04654010020014BDB69D8727047B2
+:105B300054010020024BDB69987AC0B27047C0461E
+:105B400054010020014BDB6998727047540100201A
+:105B5000024BDB69187BC0B27047C046540100207D
+:105B6000014BDB691873704754010020024BDB695D
+:105B7000587BC0B27047C04654010020014BDB691E
+:105B80005873704754010020034BA0229B691A7080
+:105B90001A78A02AFCD0704754010020034BC2B2EF
+:105BA0009B691A701A788242FCD070475401002019
+:105BB000014B5B6A1870704754010020024B5B6A0E
+:105BC0001878C0B27047C04654010020014B1B68D2
+:105BD00018887047C80E002008B5FFF795FE024BE5
+:105BE0000022DA6008BDC0466004002070B5074B93
+:105BF000074CDA6BE668011C9579586C2A1C8019F1
+:105C0000751903F0F7FCE56070BDC0465401002033
+:105C10006004002073B56C46E271194A0734556D73
+:105C20002E7886422AD1FF2028701366131C9433E5
+:105C30001B6820789B6880009165D4651871114BB2
+:105C400006980C7818608878536B60430C79497912
+:105C500000194906490E414319609169A0230B7050
+:105C6000516DD3690A78FF2A02D11A78002AF9D037
+:105C70000A78FF2A02D11A780A2AF3D073BDC046E7
+:105C8000540100206004002070B5144C636B1D7932
+:105C9000EDB2012D21D1854058781E7800023043A5
+:105CA0009E7836043043DE7836063043284214D0DE
+:105CB000FF2018710A48A16302608C780D78C978BA
+:105CC0006C434906490E074A6143506B9269016073
+:105CD000772111701A79FF2AFCD070BDD401002001
+:105CE0006004002054010020014BDB6B18787047E2
+:105CF000D4010020014BDB6B18707047D4010020E9
+:105D0000014BDB6B58787047D4010020014BDB6BF3
+:105D100058707047D4010020014BDB6B98787047B6
+:105D2000D4010020014BDB6B98707047D401002038
+:105D3000014BDB6BD8787047D4010020014BDB6B43
+:105D4000D8707047D4010020002303600B601B4B08
+:105D5000F7B59A4230DC1312194C122B1BD89B005A
+:105D6000E418646E002C27D0E368013B5D1C23D04F
+:105D7000D5B2019565681E1CEF5C019D013BED1BD2
+:105D8000F4D42768B300DB59002B15D05B190360EE
+:105D9000A3689B5D0EE0A36B266B013B0CD35D00FB
+:105DA000755B551BF9D4E66A9B00F25852190260E4
+:105DB000626BD3585D1B0D60F7BDC046FFEF00005E
+:105DC00054010020C02208B5D2000B4B904206D1EE
+:105DD0009B691A78052A0DD005221A700AE01B6CFF
+:105DE00084221B7892005B065B0E9B18984201D1BF
+:105DF000FFF764FD08BDC0465401002038B5051CFE
+:105E00001C1C181C8D4209DB0498954206DAC01A46
+:105E10006D1A6843511A03F06DFB201838BD044A0F
+:105E2000033013688010800018181060181C704729
+:105E3000D40E0020F8B501254E1E6C00B54202DAE2
+:105E4000165FB0420CDAA61E1D5F115F9B5F401A01
+:105E5000EB1A5843935FC91A03F04CFB4019F8BD85
+:105E60000135E9E7014B18607047C046E40E002099
+:105E7000014B18687047C046E40E0020014B1860C3
+:105E80007047C046DC0E0020014B18687047C046C2
+:105E9000DC0E0020014B18607047C046E00E002069
+:105EA000014B18687047C046E00E0020014B18688F
+:105EB0007047C04620030020F0B5394F8BB07546BF
+:105EC00003950E1C051C7146381C00240192029398
+:105ED000FEF778FA6A464F239482201C137504A9B2
+:105EE000221C0494FFF7D0FE2E4B201C1A68536826
+:105EF000013B10D3990074581168A4464C1EF7D387
+:105F00009768794359180131890049596746C91B77
+:105F10004018211CF2E7D16803F0ECFA224B071C71
+:105F20001C68224E6588002D03D1336840229A6098
+:105F30000CE0A1883268681A8001791A009203F097
+:105F4000D9FA6E2800DD6E20009B9860A379642248
+:105F50005343019A5343029A13412278002A04D0F2
+:105F6000124A1268926853439B11326806A9D360A3
+:105F700001230B7002234B708B707C235B4200204B
+:105F8000CB7008AA5023888008950B710997FFF7FA
+:105F90007BFE03480399FEF72DFA0BB0F0BDC04617
+:105FA000595E00001C030020DC0E002020030020AE
+:105FB000F0B5754687B00395274D0291041C7146D4
+:105FC000281C171C1E1CFEF7FDF9244BFA691B68E0
+:105FD000DB799A40131E00DC0123214A311C126830
+:105FE000D068584303F086FA1E4B00901D682F6856
+:105FF000BC463A1C6B68561E16D3191C7143C9184F
+:10600000890061180439013B0CD3AF6802985743EB
+:10601000DF1901377F00385E009F47430868C01BC7
+:106020000860EFE7321CE5E76946DBB24B748B741E
+:106030006023624604200B7510234B750A74C874E4
+:10604000221C04A9FFF720FE03480399FEF7D2F9AA
+:10605000012007B0F0BDC046515F0000DC0E0020FB
+:10606000200300201C030020F0B51D4D85B07446B0
+:1060700001940E1C041C7146281C171CFEF7A2F983
+:10608000184B391C1B68D86803F034FA164B009083
+:106090001B6819698A00A2180B1C043A013B07D33C
+:1060A0005F00F05F009F47431068C01B1060F4E77B
+:1060B0006A4661230126C9B2042013731023537367
+:1060C000167251729172D07202A9221CFFF7DCFD88
+:1060D000281C0199FEF78EF9301C05B0F0BDC046B2
+:1060E00009600000200300201C030020F0B5244CB0
+:1060F00085B07546019500911D1C7146071C201C3A
+:10610000161CFEF75FF96878B378717840000130AB
+:1061100098404900AB7801319940800303F0EAF9D7
+:1061200000226946B4238A81051C0B73101C02A946
+:106130000292FFF7A9FD134B201C1E683268013A3A
+:106140000DD37368191C5143C91889007918043993
+:10615000013BF4D30C68A40B6C430C60F7E7336984
+:10616000009C9A00A218043A013B04D31468A10BC6
+:1061700069431160F7E70199FEF73CF905B0F0BDFE
+:106180008D6000001C030020F0B589B074460690B5
+:1061900002912B48714607940392FEF713F9294B9D
+:1061A0001E68294B34681B6800940493274B1B68B6
+:1061B0000593274B1F68009C013C00941FD3746813
+:1061C0000099244A6143A5186D18069BAD00019102
+:1061D0005D19013CEFD30399286803F03DF9049958
+:1061E0000B78002B07D0059A019953181B5DBA68EC
+:1061F00058435043001300042860043DE9E7124B64
+:1062000034691E68114B1F68013C13D30299A50025
+:106210004859039903F020F93378002B06D0F02277
+:106220003B1992009B181B7858438011029B000475
+:106230005851E9E702480799FEF7DCF809B0F0BDCC
+:10624000296100001C030020DC0E0020E00E00206D
+:1062500020030020FFFFFF3FF0B51A4C071C0E1C67
+:1062600085B07146201C7546FEF7ACF8164B2A37F0
+:106270001B683A78997C4A43316892098A4200DA6D
+:106280000A1C997B4A43921101921B7B9A4200DAC5
+:10629000019302A900228A8001220A704A708A7042
+:1062A0007C225242CA701F220A71062001AAFFF7FF
+:1062B000EBFC201C291C019EFEF79CF8301C05B04D
+:1062C000F0BDC046F9610000DC0E0020F0B599B0C9
+:1062D000754611900C1CA548714612930B921395AC
+:1062E000FEF770F8FAF78EFDFAF798FDA04B1B68E1
+:1062F000F0331B78002B07D19E4B1B681E7A099642
+:106300000A201F5E089706E09B4B1B689D78099545
+:106310000427DE5F0896994E0025336815A81A6891
+:1063200005805127586814A96F440A7038709A681C
+:10633000522153206944042368440A70037015A94C
+:1063400051230B7001320B9B92009A1814A9022062
+:10635000FFF79AFCA31DDD770233DD777F27631DEE
+:10636000DF773168E31DDF774B680A68013BDBB2FA
+:106370000D93804B824F1E68824B013A1B6852B2CC
+:106380000E93814BB4461B6807970F9380231B061F
+:10639000069305950395002A00DAA3E00D985500B1
+:1063A00043B20A95002B00DA9AE08E68551C7543BB
+:1063B0000135ED18A8000B9F0095129D9E00C05955
+:1063C000AE59069F861BB74200DA0696079DB54276
+:1063D00000DD0796664637784E68002F09D0351CD9
+:1063E00055430E9FFF187F5D0F9D7843AD6868434E
+:1063F000001356431E9F9E19B600F659119F360C86
+:10640000301A009E7500E8536646002854DB0F25BD
+:106410007557A84212DB2768451B7D192560656901
+:10642000102701356561F757F67B656876B2B8428B
+:1064300001DC861B00E0BE1BAE196660E568A84261
+:1064400004DDDEB2D7B210960C97E0606646357B6D
+:10645000A8421BDB251C08351F26AE579E4200DADA
+:10646000EB77E51D1F26AE579E4200DDEB77A51D9D
+:106470001F26AE57964200DAEA77651D1F26AE57F3
+:10648000964200DDEA77059F0137059785B2209F88
+:106490005E000195BD5B019F7D192F1C209DAF53B0
+:1064A0001F9D0A9EAF5B019EF5191F9F0A9EBD535B
+:1064B000039F3F18039711E011257557A84206DC8A
+:1064C000A768451B7D19A560A5690135A5612569EA
+:1064D000A84200DA2061039E361A0396013B61E769
+:1064E000013A58E7254B03981B680125D96803F04A
+:1064F00001F87C2316A95B42221CCB70E061762355
+:106500001C320026281C8E800D700B714D708D7012
+:10651000FFF7BAFB059FA21D27621F21631D51567D
+:106520001F229A56184B1B68914201DB1D7100E037
+:106530001E71069D079EE562109F0C9D231C28334B
+:1065400026631F705D70E668099F0125BE4205DA6B
+:106550002369089CDD0FE2179C42554103481399BB
+:10656000FDF748FFE8B219B0F0BDC0466D6200000B
+:1065700040000020DC0E0020E40E00201C03002060
+:10658000FFFFFF7FE00E002020030020F0B589B060
+:1065900075460C1C03907146444804936E4605955D
+:1065A0000027151CFDF70EFFFAF72CFCFAF736FC56
+:1065B000FCF736FE0123B78333763D4E6A463068DA
+:1065C00006A9037C0220537693760423D3765A23BC
+:1065D00013772A1CFFF758FB231C2A331F708023D4
+:1065E0001B066363334BA36333681A69324B196824
+:1065F000324B1E68324BB4461B680193013A44D3B8
+:10660000049F9600BF59A859C31B676B9F4200DACD
+:106610006363A76B9F4200DDA3630B78002B07D059
+:106620006746BB18F027BF00DB191B785843801161
+:106630000E9FBB591B0C1B1A11D4487B834202DBF3
+:10664000019E012030710F200856834212DB27681B
+:10665000181A381820606069013060610AE0112062
+:106660000856834206DCA668181A3018A060A06994
+:106670000130A061039F50003B52201C2A30067855
+:10668000B34200DA331C0370B8E70B4B2A341B68A3
+:1066900022781B7A00209A424041C4B205990348EF
+:1066A000FDF7A8FE201C09B0F0BDC0462D65000016
+:1066B0001C030020FFFFFF7FDC0E0020E00E002007
+:1066C00020030020F0B585B003931A4B00901C689E
+:1066D0000291256801926F1E1BD3636800981E1CEF
+:1066E0007E43F618B6008619043E013B0FD3A1681D
+:1066F000012269438C469C44944460460199800081
+:10670000425830689446844461463160ECE73D1C51
+:10671000E1E72269039D029C9300E118E818002339
+:10672000043B013A04D3CE58C5587419CC50F7E74E
+:1067300005B0F0BD1C030020F0B574468FB007947F
+:1067400003900C1C6448714606926D46FDF73AFEB4
+:106750000023AB84614D08AE2B6821205F699969E5
+:106760009A6822236B4437701A70232601326844DA
+:1067700004236E449200017033700220A02308A904
+:1067800009AFA2183B70FFF77FFA286841698C4671
+:1067900083694F1E02972ED3029A66465A435E4380
+:1067A0000192039DF2187600019F76425200AA18CA
+:1067B0000596069D019EBF00ED1976000495019691
+:1067C000023A013B15D38668049F4E439E199D00F3
+:1067D00001367D59B6003659059F2D0CAD1BBE18EC
+:1067E000019FF553EE17AD1975401688AD19158048
+:1067F000E6E70299CCE70AA9DBB262464B708B70E0
+:106800007E2301325B420A70CB700026A123012057
+:10681000039A8E800B71FFF737FA314B2F4C1A68B1
+:106820002168304B88691D681660AC46031CFF2543
+:10683000013B13D34C69039F4443E41864003C5F5D
+:1068400067463F78BC42F3DB9E4200DADEB29D42EF
+:1068500000DDDDB217683C191460E9E70CA90124DA
+:106860000423CB7000276423201C8F800C700B71D5
+:106870004C708C70FFF708FA194B1A68194B1268A4
+:106880001B685B789A4220D9144F69B23B68039F1A
+:106890009A695B695A4373B25B1AD90FCB182341CB
+:1068A000EB18AD18A540DBB2E95F9B18039DA34030
+:1068B000EB5E271C994208DDB218039EA240925F4E
+:1068C000D917D70F93424F41FFB203480799FDF7FD
+:1068D00091FD381C0FB0F0BDD96600001C030020EC
+:1068E00020030020E40E0020F0B58BB07446039026
+:1068F0000E1C3348714607940292FDF763FD314B3D
+:106900001D68314B28681C68A769391C02F0A4FD7A
+:106910002E4B1B68DB799840002800DC0120EB68D7
+:106920000299584302F0E6FD6169BB005B424A1ED2
+:106930008446381C029350437B005C425343C01989
+:10694000039D8000F31804942818059300910024F7
+:10695000009D013D009515D3059E021CA6190696C3
+:106960003B1C043A013B08D3069E5D00765F6546FA
+:1069700075431668761B1660F3E7029A049B80182D
+:10698000E418E5E721242225FBB208AA6C446D44F3
+:10699000117023702B7009AA60232326252404205C
+:1069A000137008A91023039A6E446C44307023704E
+:1069B000FFF76AF902480799FDF71CFD0BB0F0BD1F
+:1069C00089680000200300201C030020DC0E00204A
+:1069D000014B18607047C046EC0E0020014B186850
+:1069E0007047C046EC0E0020014B18607047C0464F
+:1069F000E80E0020014B18687047C046E80E0020E2
+:106A0000014B18687047C04624030020F0B5724659
+:106A100087B071465D480592FDF7D4FC5C4C0021BF
+:106A200020680A222C3002F027FE206800210A226A
+:106A3000363002F021FE206800212822403002F08A
+:106A40001BFE206800210A22683002F015FE206833
+:106A500000210C22723002F00FFE206800210C226F
+:106A60007E3002F009FE2068002105228A3002F003
+:106A700003FE2068052200218F3002F0FDFD454B0A
+:106A800025681E68F369346A5B00181B6100000208
+:106A9000019302F02FFD0490A860B06A726A009022
+:106AA0005200009B101A59000002029202F022FDCF
+:106AB000394B0390E86001981F68414202987B1DA2
+:106AC000DA7F4042331CD633019018886043401867
+:106AD000002A0ED039680139614302F00BFD331CE6
+:106AE000D833041C009A1888019B50437968C01859
+:106AF0000DE079680139614302F0FCFC331CD833A6
+:106B0000041C009A1888019B50433968C018013949
+:106B1000514302F0EFFC844200DA041CE30F1C191D
+:106B200079686410AC6104983C680139039A4300A9
+:106B30000902013C5918240253001C1929616C6197
+:106B40000537FB7F371CD83600962E1CD637A43667
+:106B5000A835002B07D0009B1888000402F0CAFC5F
+:106B60003060388806E03888000402F0C3FC009AE0
+:106B700030601088211C000402F0BCFC05992860DC
+:106B80000248FDF737FC07B0F0BDC046AD69000014
+:106B900024030020EC0E00201C030020F8B5134C49
+:106BA0007146061C201C7546FDF70CFC104B00219D
+:106BB0001A68201C131C723319700E4B1B681B7C47
+:106BC000013BDBB2FF2B0DD059008F5B191C383114
+:106BD00049003CB25118002C01DD8F80F0E7002401
+:106BE0008C80EDE7291CFDF705FCF8BD3D6B00002E
+:106BF000240300201C030020F0B5744685B00294E5
+:106C00000E1C041C71461F48151CFDF7DBFB1E4BB8
+:106C10001B681A6AD2B2013AD2B2FF2A2AD0F768A8
+:106C20005300FF5E696860680191002F1AD0E76821
+:106C3000FF5E002F16D0C05A716807B20397C95E75
+:106C4000039F7F1A7F10BC4601996044A768C85211
+:106C5000F95AB76808B28446F85E6746381A401099
+:106C6000411804E00199C05AA768C852F95AA868A7
+:106C7000C152D0E7237803482B700299FDF7BAFB85
+:106C800005B0F0BD996B00001C030020F7B57546F8
+:106C90000195144D041C0F1C281C7146FDF792FB36
+:106CA000114E0A2230680021683002F0E5FC0F4BDB
+:106CB00036681B68281C1A6AD2B2013AD2B2002385
+:106CC000FF2A09D0E56851004B53B1180D1C283537
+:106CD00030312B718B71F0E7237001993B70FDF718
+:106CE00089FBF7BD2D6C0000240300201C0300204D
+:106CF000F7B5124E73467146301C0193FDF762FBE7
+:106D00000F4D002428680527031C72331C703A1CA1
+:106D1000211C8A3002F0B0FC28683A1C211C8F30FC
+:106D200002F0AAFC2868211C0A22743002F0A4FC9C
+:106D3000301C0199FDF75EFBF7BDC046916C000069
+:106D400024030020F8B5154E041C0D1C301C7146A0
+:106D50007746FDF737FB124B301C1B685A1DD17F5D
+:106D60009A1D00290CD021882E8826802980D27F68
+:106D7000002A0ED01A680733DB7F013AD31A04E0E9
+:106D8000D27F002A05D05B68013B22881B029B1A38
+:106D90002380391CFDF72EFBF8BDC046E56C0000D2
+:106DA0001C030020F0B5714689B07746061C3E48AA
+:106DB0000597FDF707FB3068726807AC69461E311E
+:106DC0002080201C0A80FFF7BDFF384B1B685A1D2E
+:106DD000D17FDD1D364A81CB00290CD01268013FDE
+:106DE000EB7F3F02411E03979768C91ADB01DB194D
+:106DF0000902D7680BE0791E1268EF7F0138C01BCB
+:106E00009368D2680002FF0109020390BF18294A63
+:106E10001568286801900022A05E019AC0185B00E6
+:106E2000C918504302F066FB80B204902080686865
+:106E3000694602901E20085E029A039BC0197F00DB
+:106E4000D919504302F056FB6F4680B22B1CF883D1
+:106E5000D433049F1B783AB29A4206DD019FF91A97
+:106E60008A4203DB3A1C0132D31A23802B1CD53310
+:106E70001B7800B2984206DD029FFA1A904204DBAA
+:106E80003A1C0132D31A6846C38307AB00215B5E0C
+:106E90006A4633601E23D35E034873600599FDF78D
+:106EA000A9FA09B0F0BDC046456D00001C030020E2
+:106EB00024030020EC0E0020F0B572468BB0714622
+:106EC000041C61480592FDF77DFA604B00201B68A9
+:106ED00002905A681D6A013A120203921A68013D33
+:106EE000013A1202AB0004926E000193681C00D1BB
+:106EF00092E0574B1B681A1CE6321778012F1AD103
+:106F0000E168885F5188A269884212DD2069EA330E
+:106F1000815B1B7899420CD9575569460022B523ED
+:106F20008A830E200B7706A90692FEF7ADFE029724
+:106F300001E000235355464B1F683B1CEB331B7885
+:106F4000012B63D1E3689A5F3B1CEE331B889A42A6
+:106F50005CDD6068825FFF2A09DDA1688B5FFF2B23
+:106F600005DD0398824202DC04998B424EDA374BEE
+:106F700062691B680533D97F364B002915D001980B
+:106F800001211218186800235156D356CB1A011C40
+:106F9000A83109681B024B430321515692781B14F8
+:106FA00052B2891A0902A43014E0019918685218E3
+:106FB000022303215156D356CB1A011CA431096870
+:106FC0001B024B430121515612781B1452B2891AED
+:106FD0000902A83002680A20514309148B4201DBE0
+:106FE000584301E04843191C02F084FAEC373B781F
+:106FF00098420BDDA2690123535508A90022B6234C
+:107000000E208A8008920B71FEF73EFE019B013D27
+:10701000043B023E019369E70299002905D10A4821
+:107020000599FDF7E7F90BB0F0BD084B1B681B6A2B
+:10703000013BF4D3E0685A00125E002AF8DDA16932
+:107040000122CA54F4E7C046596E00001C03002018
+:10705000EC0E002024030020F0B5724693B0714678
+:10706000041C59480392FDF7ADF9584A584B126871
+:107070001B6811793822514359182C3104A802F0A9
+:10708000B9FA544B00261B685A681F68013A12026D
+:1070900002920733DB7F013FFF1A3F024D4B1B6813
+:1070A0001A6A964200DB88E0E16875004A5F002AB0
+:1070B00000DC80E0454A12681279012A7BD06268C0
+:1070C000505FFF2819DC0533DB7F049905AA002BEC
+:1070D00002D06B46323301E06B461E33FEF7AAFE48
+:1070E000616800B24B1900215A5E013AFF3A5043E1
+:1070F00080110130FF30188020E0029A101AFF281A
+:107100001CDC0533DB7F049905AA002B01D00FABF3
+:1071100000E00AABFEF78EFE029A6168013AFF3A80
+:107120004B1901920022995E029A00B2511A01395C
+:10713000FF394843019A8011121A1A80A368585FD8
+:10714000244BFF2819DC1B6804990533DB7F05AA53
+:10715000002B01D00AAB01E06B463233FEF76AFE2A
+:10716000A16800B24D190022AB5E013BFF3B5843C2
+:1071700080110130FF3028801DE0381AFF281ADC0A
+:107180001B6804990533DB7F05AA002B02D06B46F0
+:107190001E3300E00FABFEF74DFEA36800B25D1991
+:1071A00000216A5E7B1EBA1A013AFF3A5043FF3B48
+:1071B00080111B1A2B80013670E703480399FDF7F5
+:1071C00019F913B0F0BDC046F96F00002403002088
+:1071D000EC0E00201C030020F0B5764697B0041C8E
+:1071E0000D1CD24871460796FDF7ECF8D04B1B6892
+:1071F0009E680696DE6803961E6901965E699B6925
+:1072000005960293FEF7E8FCCA4B01261B68E4339F
+:107210001B780496002B54D000260496C64B1B689E
+:107220001B6A9E424DDA68687700C35FA9680C93B9
+:10723000CB5F0CA80D93FFF7B5FDE268D35F002B81
+:107240003DDD6068A168C35F0AA80A93CB5F0B931A
+:10725000FFF7A8FD0A9B069A9A4209DA039898421A
+:1072600006DD0B9A0199914202DA0598904221DCE1
+:10727000E968CA5F002A19DDB04A126892192832FB
+:10728000127952B2012A11DD06980299421A9A42E5
+:107290000CDA039842189A4208DD01980B9B421AB7
+:1072A0009A4203DA059842189A4206DCE168002304
+:1072B000CB5304E00122049201E001230493013640
+:1072C000ACE79F4B1B78002B00D18DE02378012B7E
+:1072D00000D089E000206E4608A9B0840B702122FE
+:1072E000222623216A446E446944137033700B7064
+:1072F00009AAF323137008A9924AFEF7C5FC924B22
+:1073000000269B5F0E93914B00201B5E0EA80F93EF
+:10731000FFF748FD6168A2680023CB5E10A81093B8
+:107320000023D35E1193FFF73DFD119B0F9A991A2D
+:107330000A2901DD322B0CDCD21A0A2A02DD844A2A
+:10734000934206DD109B0E9A991A0A2903DD322B0F
+:1073500001DD00260CE0D21A0A2A05DC784A002357
+:107360001370784A13703FE07A4A9342F1DDF5E7F3
+:10737000744B02961B78029E9E42EFDA029E724A7E
+:107380007300D25E12A81292704AD35E1393FFF775
+:1073900009FD14A80378802252421A43DF231A40C1
+:1073A00040231A4310239A430F239A4301210A438F
+:1073B00046780270129A13991712321C9A431F4092
+:1073C00017430E121F40129B360183703E43322337
+:1073D0004670C1700371FEF709FCFEF74DFAFEF727
+:1073E000FBFB029E0136C3E70126534B02961B6846
+:1073F000029E186A013E0196864200DBE5E0029E8D
+:107400005548696833185F00CB5FAA680C93D35F57
+:107410000CA80D93FFF7C6FCE668F35F002B00DCB9
+:10742000A3E06068A168C35F0AA80A93CB5F0B93CF
+:10743000FFF7B8FC0C9B0B9E9C46404B03961B68C9
+:10744000019E06939B1968331E78444B0A9A0D9847
+:107450001B68002E01D1503300E05133E9681B78DE
+:10746000CE5F002E0EDD039E301AC1174018484033
+:10747000984207DA6646911BC8170918414099429D
+:1074800000DA8FE0049E002E00D18BE014AE31783C
+:1074900080235B420B43DF210B4040210B433370C1
+:1074A000A169019BC85C01233178184010239943DE
+:1074B0008C4602990F23194005910001614608434B
+:1074C0000599984301431012184031707178059066
+:1074D000039899438C460112090105980091614671
+:1074E000084300991840B270039AE3680143717031
+:1074F000F270DA5B131C12B2FF2A00DDFF23337136
+:10750000069B301CA0331B6801999847301CFEF77E
+:107510006DFBEE68094BF25F1B68019E9B19002A08
+:107520001EDD1A1C683201231DE0C046797100007F
+:10753000EC0E0020400000201C030020240300204B
+:10754000D9040020D8040020C4040020B004002086
+:107550004D07000005040000FFFFFF7FE80E00203C
+:107560001A1C6832002313701CE0E868C35F002B0C
+:1075700018DD14A800234360029B0F210B4040221A
+:1075800013430C9A037013129C460D9B82701E12BB
+:107590003601019666463140019EC3700E43467027
+:1075A000FEF724FBE068E968C35B6268CB53D35BFA
+:1075B0006E68A068F353C35BA9682269CB532E6938
+:1075C000D35BF353029E01360FE71B695E1E0296E2
+:1075D0000F2602981E40284F013034D00298396897
+:1075E00040000B181A1C803201900020125E743388
+:1075F000002A0FDC1B881AB2002A16DD002114A80D
+:1076000014914160802131430170FF2A00DDFF2386
+:10761000037108E000215B5E002B06DC14A8002348
+:10762000149343600670FEF7E1FA019A3B68013E4D
+:107630009B181A1C74331B8880321380029B013BF9
+:1076400002930F23C5E723782B703B681A1C723214
+:107650001178117328780122002802D10A1C511ECA
+:107660008A4196331A70FEF707F904480799FCF728
+:10767000C1FE17B0F0BDC0462403002079710000A0
+:1076800010B502248B7804575AB2944200DD8370FF
+:10769000CB78032404575AB2944200DAC3700B78B3
+:1076A000002404575AB2944200DD03704B78012144
+:1076B00041565AB2914200DA437010BDF0B58FB016
+:1076C0000A910A9C0893C36864001D5F0C94069598
+:1076D00054000494069E1C5F0A9D43683619AD0051
+:1076E00005960131960009955D19071C0D91985971
+:1076F00006992B6860434B430599C0180B9201F023
+:10770000F9FEBB6800B22860099A98599D182B6849
+:107710004443069805994343E01801F0EBFE3969AC
+:10772000099C00B2286004220819089901F062FF40
+:10773000FB680C9D049C5A191B1910881988411864
+:10774000118000221A807B695A191B5B0025505F4B
+:1077500019B288420ADA1380BB69049D1A190C9C7D
+:1077600052781B195A70BB695A5D1A550B9B01332D
+:1077700001240F2B09DC159D0998A9592A181568B1
+:107780009C400C402C431460F1E7159D0023AB5145
+:107790000A9D0B9E211CB140AC40159AA446CD43D6
+:1077A0000B9EB3421ADA1068014214D00A9EB3420B
+:1077B00003DA6446204310600AE00A9EB34207DD04
+:1077C000159C099EA019046801269E402643066068
+:1077D00010682840106001330432E1E7089C2478E7
+:1077E00064B20794089D0123EB56079E9E4200DD7C
+:1077F000ACE0089DAD786DB2089E04950323079A0E
+:10780000F356049C01329C4200DD9DE0624B049CD7
+:107810001B68149D9E68724301321219AA181178D0
+:10782000B4460139112900DC8BE0012005234042D8
+:107830000024013B002B29D0584EF5180126764232
+:10784000AE57079DAE19013665467543534E0595F3
+:10785000F518ED79049E6DB20295149DAD19059E43
+:10786000AD19029EAD1905956D78013D0F2DE0D83B
+:107870000A9EB54202D00B9EB542DAD1461C03D017
+:10788000A842D6D00124D4E7281CD2E7002C58D037
+:10789000122955D10D9C052514700695069C013CB6
+:1078A0000694002C4DD03D4B069E07249A19131CBC
+:1078B000013B1B78079E5BB2F618374B14571A68CA
+:1078C000331C926801335343049D01332C19149DDA
+:1078D0001B19EA181178B4460029DFD1169E5B0007
+:1078E0009B5B002BDAD0122111707868099D461934
+:1078F000F8680C9D3268401902900088099D01903B
+:1079000001B2181C60434A4300021018BA685419A7
+:10791000654622685D4351432D02AC4661440591A2
+:107920000199029A5D18ADB215802DB2291C01F0A3
+:10793000E1FD291C3060059801F0DCFD2060ADE719
+:107940001170049D013557E707924BE70022AA56B4
+:10795000089E0123F3569A421BDC089C0223E3563F
+:10796000089D03202856511C834210DC0A48149DB0
+:1079700000680B9E806841430131C9186918087876
+:107980000138B04201D10D9C0C700133E8E70A1CAC
+:10799000DEE70FB0F0BDC0461C030020CC9600000F
+:1079A000F0B591B075460B91061C714641480D9596
+:1079B0000C920793FCF706FD0024F7686300FA5E5B
+:1079C000002A6DD0B0690125C3185D571B78099551
+:1079D0005BB20893013D0695099F069D01370A9702
+:1079E000BD425DDC089F013F0597089B059F013361
+:1079F0009F4252DC304B06991B6801319A68059D05
+:107A000051430B9F481C40193D5C013D0F2D40D850
+:107A1000AC423ED077696300DB5F284F40003F688F
+:107A20003F89BC46079FC05B834232DC089F6046AB
+:107A3000C91943430131079F4900C95B9B118B4220
+:107A400027DA0A9F7A43059FBA180132079F52002E
+:107A5000D25B93421DDAA54202DB2B1C251C1C1CA9
+:107A60003769A100791804220FA801F0C3FDA9000D
+:107A700079180FA8FFF704FE0B9F221C00970C9F9C
+:107A8000301C0197079F291C02970FABFFF716FECA
+:107A90002C1C059D02350595A7E7069D02359AE742
+:107AA00001340F2C89DD03480D99FCF7A3FC11B0BC
+:107AB000F0BDC046417900001C030020E80E002004
+:107AC000F0B5A7B07546071C0C91C84871461392D3
+:107AD0000D931A95FCF776FC139A0D9B381C0C99A4
+:107AE000FFF75EFF2C9EC24B3278012A07D13A780D
+:107AF000012A04D91B689C881494DB8803E01B6866
+:107B00001D8814955B880F2615930696069B069C88
+:107B1000013B002C00D171E1139C9A00069D125983
+:107B20000795EA400F9206930F9D002DEED0079E19
+:107B3000102EEBD00F9E0120064200D14FE1079D91
+:107B4000069C7B68A400AE001959BA689B5908943A
+:107B5000C91A14599359CD17E31A4C196C40DD1703
+:107B600010945C196C40109D0B94A54202DD11909D
+:107B7000180203E0002408021194191C01F0BAFC59
+:107B80003C691CADA11904221290281C01F032FDA1
+:107B900008982118281CFFF773FD7968089CFB687A
+:107BA0000859079C20906100CC5E09947C68A45918
+:107BB0000A94069C6200D45E099B099A58430A9B6A
+:107BC000A2186343111CC0180E9201F093FC21907F
+:107BD0000A98BB68089922905858099A23909E5990
+:107BE000504374430E99001901F084FC0024249042
+:107BF00000211DA80C22259601F03EFD2C570126E0
+:107C00000994AE57022416962C577A4B1794ED78A8
+:107C10001B686DB218951993099C169DAC4200DD46
+:107C20009FE0099D179E2D020E9508960999089DC3
+:107C3000189E0131B54200DD91E0199C089EA068B4
+:107C40000C9C414301318919645C8446231C013B2F
+:107C50000A940F2B44DD0020012205235242041C0C
+:107C6000013B002B2BD0644EF51801267642AE570F
+:107C7000099DAE190136654675435F4E0595F518A9
+:107C8000ED79089E6DB204950C9DAD19059EAD1958
+:107C9000049EAD191B956D78013D0F2DE0D8069E11
+:107CA000B54202D0079EB54205D1561C05D0AA4266
+:107CB000D6D00124D4E70120D2E72A1CD0E7013234
+:107CC00049D04900002C01D1002802D10D9C605AF6
+:107CD00011E00D9D685A0A99113901F00BFC0AE078
+:107CE0005E1C38D0069CA34202D0079DAB4232D125
+:107CF0000D9E4900885B00282DD0089C032321029B
+:107D0000013B28D3119D20AC23AA9E00002D09D051
+:107D100095590E9A551B129A5543A2592D12551B6F
+:107D20006D1A08E0A559129C4D1B654392592D12FE
+:107D30000E9E551BAD1BEA17AD185540FF2DDFDC1D
+:107D400080267600751B45439C001DAAA6582D125F
+:107D50007519A550D4E7089C0134089466E7099189
+:107D60005AE71F9B1D9C9C4200DD1C1C119E002E8F
+:107D700006D10B9D331C002D0DD0109E10950B9637
+:107D80000B9D1099A80101F0B5FB3F2800DD3F20B5
+:107D9000194B1818037C2D21149E159DC81A704389
+:107DA0006B43C01801F0A6FB44431E9BA412A342E0
+:107DB00015DD079E069CA64201DB079406960C9DE6
+:107DC000139E0D9C00951CAB01960294381C0799DC
+:107DD000069AFFF773FC069B079D07930695079E7F
+:107DE0000F9C0136640807960F949DE6617A0000A7
+:107DF000E80E00201C030020CC9600002C4B3C70A9
+:107E0000186801211C304942102201F035FC069C03
+:107E1000251CF8686600825FE3B2002A24DD3A7808
+:107E200001323A70224A1268121915779D4219D010
+:107E30007A68A300D158A8001150BA680790D158A9
+:107E40001150FA686800925B011C101CFA68885295
+:107E50003969079A8818C918042201F0CBFBF86821
+:107E6000002383530135EDB20134102CD1D123A965
+:107E7000002323938B800F4B7F201B680C9D1A6877
+:107E80000A705C684C709A68CB788A7083430120D2
+:107E900003431218CB70AA18302306200B71FDF78C
+:107EA000F3FE05481A99FCF7A5FA27B0F0BDC046C5
+:107EB000240300201C030020617A0000164BC21727
+:107EC0001B68801850401A1CA43270B5A83314687F
+:107ED000CA1789181D68514044434D4324142D147A
+:107EE000AC4202DB231C2C1C1D1CA001291C01F030
+:107EF00001FB0A4E3018037C281C002B0BD05A22A1
+:107F0000D21A52365200955B5B0068439D5B0014A9
+:107F10006C432414001970BD24030020CC9600008B
+:107F2000F0B575469BB0041C0F1C844871460D9536
+:107F300008921E1CFCF746FA814B1D6823782A6ABA
+:107F4000934200DD131C01213B70494210220EA810
+:107F500001F092FB12A8FF21202201F08DFB794B4A
+:107F60002D6A1B6809950A93774B00251B680495B9
+:107F70000B93049D0998854257DA0898049DC068C0
+:107F80006D00435F0795002B4AD0049B0A9D103378
+:107F90009B000B985B592578C0689B000C950025C9
+:107FA0001B180595012506936D4205980C99C3B2DF
+:107FB0008B421FD20598E16843005B5E002B15D011
+:107FC000830007997068425E6168C8580799801AF3
+:107FD000B268525E9446A268D1586346C91AFFF748
+:107FE0006DFF0699884201DA059D0690059A0132D7
+:107FF0000592DAE76A1C13D00EAB59576A0012AB30
+:10800000013108D0995A0698814209D99852049BA7
+:108010000EAA535504E006980EA99852049A4A55A0
+:10802000049B0133DBB20493A3E700252378AB4222
+:1080300028D90EA94E5D73B2013320D06068A90023
+:108040004258F6B278687300C252A0684258B868C5
+:10805000C252E0686A00105A0492FA68D0527A69F3
+:108060002369B00010185918042201F0C3FA354BE7
+:10807000049812AA1B681036825AB600F2500135D5
+:10808000EDB2D3E700252378AB423ED90EA94B577A
+:10809000013337D1E3686A009A180026935F04928F
+:1080A000002B2FD0264B00201B681B6A0593059ED2
+:1080B000B04227DA08994300C968CE5E002E1ED16F
+:1080C000FE68F6180022B15E0696002917D1626894
+:1080D0000EAE7055A90056587A688000D652A26834
+:1080E0005658BA68D652049A069E13887A69338025
+:1080F000236910185918042201F07CFA02E00130BB
+:10810000C0B2D4E70135EDB2BDE70D4B00221868CF
+:108110000C4B1B68197F046AA14202DA0EAD695C40
+:1081200000E0FF210132D2B219770133102AF1D1D8
+:1081300002480D99FCF75EF91BB0F0BDC17E00004E
+:108140001C03002024030020E80E0020F0B59BB0A3
+:1081500074460B91051C7146624812940C92FCF710
+:1081600031F9FEF74DFC604B0D901B681C6A013C19
+:10817000611C00D1B0E0EF686600BF190596089752
+:108180000026BE5F0796002EF1DD6969A300C918BD
+:10819000554B02201B68032208568A561093534BF6
+:1081A00000261B688C460E920A93039606960E993B
+:1081B000884263DC67460121795600220302BA56E1
+:1081C0000F9111930F9F431CBA4255DC109E571C10
+:1081D000B668391C714304960B9EC918735C0997E5
+:1081E000102B23DD0523013B002B2BD0404EF7182D
+:1081F000F618013EFF7936787FB276B2029796196B
+:10820000049F013677430B9E0197029F3618F7199A
+:10821000019EBE1913967678002EE4D00A9F76B29E
+:10822000BE19F67E76B2A642DDD108E0002B09D059
+:108230000D9F1B26FB189E570023A64202D10C9EC1
+:1082400049008B5B6F68059E1202B95F119E891B06
+:10825000CF17C91979405943069EAF68761806961C
+:10826000059EB95F039E8A1AD11752184A4053439C
+:10827000F6180396099AA5E7181C98E70799069837
+:1082800001F038F90799061C039801F033F9011C35
+:10829000301CFFF713FE0A9EB369984200DA181CDF
+:1082A0002F69059E15A9B853089F80B20023FB5E75
+:1082B0001890199300238B8001230B7003234B70BC
+:1082C0008B707C235B42CB701220B02317AA1794CB
+:1082D0000B71FDF7D9FC4AE702481299FCF78AF8BE
+:1082E0001BB0F0BDED8000001C0300202403002023
+:1082F000CC9600000F4AC378126810B551685CB282
+:1083000001398C4201DA0133C370837859B20029F4
+:1083100001DD013B83704378126859B2013A914202
+:1083200001DA0133437003785AB2002A01DD013BC0
+:10833000037010BD1C030020F0B593B07546059185
+:10834000071C7146CD48089209930B95FCF73AF843
+:108350000EA900238B80CA4B059C1B689A6858683D
+:108360001E688A70012301324870CB70A21808235E
+:1083700006200B710E70FDF787FC1023013BDBB26A
+:10838000FF2B0BD03D699A00A9187F2008708870D8
+:108390003E69FF21B2185170D170EFE7B94B00224E
+:1083A0001B68189C1A600923E356189D0822AA56D8
+:1083B000934269DB189D0B22AA56189C0A2161562C
+:1083C0008A425FDBAE49059E0868591C80684143BC
+:1083D0000131891870180478251C113D2D2D02D803
+:1083E000002101704CE0013CE4B20F2C48D8099DFB
+:1083F0004900485BA3497E6809680D6801350D6036
+:10840000A1007518061C5643B4462E686400B44497
+:1084100066462E60BE687518061C5E43B4462E681C
+:10842000B44466462E60FE6835192E8886192E8063
+:108430003E6975180226AE57B24200DAAA703E694C
+:1084400075180326AE57B24200DDEA703E69751812
+:108450000026AE57B34200DA2B703D69691801253A
+:108460004D57AB4200DD4B707E69311900268D5FA0
+:10847000854205DA0880B86901194B70B9690A5557
+:10848000013A9AE7013B90E700260496F868049CBD
+:10849000035F002B01D10024F8E0049C3D696400D7
+:1084A00028190694FFF726FF3E69331901269E57C7
+:1084B0003869069C002203199A56964200DAD6E0E3
+:1084C000DB785BB202933D69069C2B199B78029D79
+:1084D0005BB29D4200DAC8E0694B029C1B68059DB7
+:1084E0009B6801930198731C434301331B19ED18DA
+:1084F0002A780395002A02D03F2A00D0B1E0099DD6
+:108500005B005C5B002C00D1ABE000230D930523E6
+:10851000013B002B21D05C4A0725D1180A1C4D577E
+:10852000012149425156019871180131484305997A
+:10853000844602980A185219624451784A1E0F2A3A
+:10854000E6D800220DA8855C002D01D18154DFE71B
+:108550008D42FBD00132D2B2F4E70DAA9A5CDDB2B3
+:108560000195002A04D00133042BF6D1019302E0D7
+:10857000019D002D75D00199201C00F0BBFF019DCD
+:10858000039911350D700795029D311C45434143F8
+:1085900003950A91002301997D688C460121494287
+:1085A0008C440DAA63451CDAD25C241A013A91006E
+:1085B0006D1800922A6801339446039A94446246E7
+:1085C0002A60BD6869180A6894460A9A9444654608
+:1085D0000D600099FD684A00AA18118809181180D9
+:1085E000D9E7D35C5B1802999A006143AD182868FB
+:1085F0005B0041182960B968F8688A18211C71432A
+:108600001568C318691811601A88079914191C8015
+:108610000023122925D0634523DA01331A1C019D5A
+:10862000AA42F8DA0DA8C11801390978105C01399D
+:108630000138C9B2C0B20124814208D2089D890024
+:1086400069188440201C0C682043086007E0089DDE
+:10865000800028188C40211C0468214301600132ED
+:10866000DDE7029C013C02942DE7013E20E7049DDA
+:1086700002350495202D00D008E70CE7D9820000D0
+:108680001C03002024030020CC960000FE6862003A
+:10869000925BE3B2002A19D07868A500461911B29E
+:1086A00032680291100200F025FFBB6830605E194D
+:1086B000316801340802029900F01CFF3A69306009
+:1086C0005019FFF717FE102CE0D1231C10A93B70A6
+:1086D00000238B800B4B059E1B6806209A681C6844
+:1086E0005D688A7001230132CB70B2182D230B71A3
+:1086F0000C704D70FDF7C8FA03480B99FBF77AFE32
+:1087000013B0F0BD1C030020D9820000F0B57746FD
+:1087100087B0051C0E1C704871460597FBF752FE8A
+:10872000F8F788FB6D4B071C1B68287A697A019063
+:108730001C68FA20800003914843211C00F0DAFEF7
+:108740003A6900901778002F16D0012F16D1644B8C
+:108750001B681B6A013B0DD3D7685900795E00295D
+:10876000F8DD604F3F68E0373F88BC460127614530
+:1087700007DB04E0012704E0012301E001273B1CA3
+:108780005B42516892685800095A125A0291049249
+:10879000022E17D004D8002E0AD0012E0DD08FE063
+:1087A000052E30D0062E53D0042E00D088E027E0CE
+:1087B000002B64DA012F2FD184E0002B68DA012F1F
+:1087C00075D17FE0002B03DB019F4F2F60D979E04B
+:1087D0000199FA2080004843211C00F08BFE414B98
+:1087E00003241B681A1CE2321288904205DCE43331
+:1087F0001B880024984200DA0524012F39D161E05A
+:10880000012F09D160E0002F08D1364B009A1B6878
+:10881000E4331B889A424ADB082456E0002BFBDB3A
+:108820002968029F0023CB5E6A6838B2049FC01A91
+:108830000023D35E39B2C91AFFF740FB294B1B68EE
+:10884000DE331B789842E7DC00236B7206243CE0A1
+:108850000724002F39D00424002B36DB214B009F46
+:108860001B68E4331B889F422FDA6B7A01336B72EB
+:108870002AE0022C0CD0052C19D0012C25D1286817
+:10888000029F01240780049F686807802C721CE007
+:10889000019F28687B00029F02241F522B7A049FAD
+:1088A00068685B001F522B7A01332B720DE0013E8A
+:1088B0000023012E01D9039B01336B72052404E0D0
+:1088C000002402E0042400E0341C03480599FBF76F
+:1088D00091FD201C07B0F0BDAD86000040000020D7
+:1088E0001C030020EC0E0020F0B52C4D85B0744622
+:1088F0000394071C0C1C281C7146161CFBF762FD18
+:108900000422A35E0622A05E0025C01A64235843F9
+:108910000223E15E0022A35EC91A00F0EBFD76237C
+:10892000021C1A3AFF3301909A4230D80295002275
+:10893000BB5E64205843019900F0DCFD029B81B2CC
+:108940003980012B0DDDB31E00229B5E0022B05E3C
+:1089500009B2C01ABB1E00229B5EC91AFFF7AEFA0D
+:108960002D18029B0237013302930236162BDED1FB
+:108970000422A05E64260199704300F0BBFDA08034
+:108980000623E05E0199704300F0B4FDE0800348E7
+:108990000399FBF72FFD281C05B0F0BD8988000066
+:1089A000F0B52F4F95B07546039501901D1C0291AF
+:1089B000381C7146141CFBF705FD0422AE5E06222E
+:1089C000AB5E03219B1B181C009300F093FD282233
+:1089D000A35E82190124934200DC002441008E1919
+:1089E000E4B2B34201DD02231C43029E2823F35E5E
+:1089F0000026AA5F8018834201DD042004438A1800
+:108A0000934201DD08231C4304A80021402200F00A
+:108A100033FE0323059306230793012308930423BE
+:108A2000099307230B930223109305231193A400AA
+:108A300008236A4613931034A358019C009963706D
+:108A40000020FFF73BFA1A9D011C0A20684300F042
+:108A500051FD03992070381CFBF7CCFC15B0F0BD1C
+:108A600041890000F0B5744695B0039402900E1C45
+:108A70002F4871460024171C0125FBF7A3FC019425
+:108A8000152D09D10021735E2820325ED21A2823C9
+:108A9000F95E00243B5F07E0019C6B00F15E325FF2
+:108AA000019C8A1AF95E3B5FCB1AA821FF31514322
+:108AB000012489128B4200DC00241E48424392129A
+:108AC000934201DD022004435242934201DA042220
+:108AD000144349428B4201DA08231C4300214022FF
+:108AE00004A800F0C9FD0123049302230593032386
+:108AF000079304230B9308230C9307231093062357
+:108B00001293A40005231393103402986946625807
+:108B1000019C4319013B023401351A700194162D52
+:108B2000AED103480399FBF765FC15B0F0BDC04614
+:108B3000058A0000A7090000F8B5104F051C0C1CA1
+:108B4000381C71467646FBF73DFC381C0C4BA542A1
+:108B500007DD2C1BA412032C00DD032464001C5B26
+:108B600006E0651BAD12032D00DD03256D005D5B86
+:108B70006419311CFBF73EFC201CF8BDD98A0000AB
+:108B8000D4970000F0B57546D5B003950091051C4B
+:108B900071464448161C0193FBF714FC002401277E
+:108BA000019B0234013B9F4221DA2B199A1E0021BE
+:108BB000505E2A5F0321801802229B5E0137C01895
+:108BC00000F098FC009A102369461B19585213199B
+:108BD0009A1E0021505E00990A5F0321801802222C
+:108BE0009B5EC01800F086FC2CABE052D8E7019FDA
+:108BF000AC1C023F7F0069463A1C201C12310294D3
+:108C000000F0F8FC009C694602343A1CB231201C8A
+:108C100000F0F0FC009900220B880092F3800B8892
+:108C20000127B3802B8873802B88029D3380019BA2
+:108C30009F4230DA0023E85EAB1E00215B5E00221B
+:108C4000A15EC01AA31E00229B5EC91AFFF736F967
+:108C5000009B0222B15E1B1800932B881AB291422E
+:108C600000DA73802B880022B15E1AB2914200DDD7
+:108C7000338023880622B15E1AB2914200DAF38073
+:108C800023880422B15E1AB2914200DDB38001371D
+:108C900002340235CBE703480399FBF7ABFB00989E
+:108CA00055B0F0BD258B0000F0B5A3B07546141C7F
+:108CB00002900391414871460B950A93FBF782FBA2
+:108CC000201C152100F016FC0124069001940025BB
+:108CD00001990A9A91424EDA0199029A4F00D219EB
+:108CE0000792039A0299BB1ED719C9180897D7187B
+:108CF000079B04910020185E089A0023CB5E002198
+:108D0000515EC01A0022BB5EC91AFFF7D7F8069958
+:108D10002B1805908B4229DB049A4D1B0023D25E51
+:108D200000217E5E0992089A05990020105E801B42
+:108D3000684300F0DFFB079B361809990020185E96
+:108D4000B6B2401A6843059900F0D4FB099D630050
+:108D50002818302180B2C9186A46049D885217AA83
+:108D60009E52288001343E80002302E0019D01359F
+:108D700001951D1CACE7152C0BD1114C029D13194C
+:108D80005B00EA5A5A21039C69440A80E25A17ABF5
+:108D90005A850298694632312C22023000F02AFCB2
+:108DA000039869462C225E31023000F023FC034810
+:108DB0000B99FBF71FFB23B0F0BDC046498C0000A8
+:108DC000FFFFFF7FF0B5244F8FB07346051C71463F
+:108DD000381C0393FBF7F6FA2B7A06AA2868696811
+:108DE000FFF7D0FE1D4B021C1B680024DC331B88E0
+:108DF000984229DD2B7A28686968FFF755FF2A68B1
+:108E0000686806A9FFF770FD009006AB05A8296801
+:108E10006A68FFF7C5FD06CD08A8FFF723FE104ED0
+:108E20006D463368EC74983313351B68281C08A909
+:108E300098472B78041C002B06D1336808A89C3374
+:108E40001B6805A99847041C381C0399FBF7D2FA44
+:108E5000201C0FB0F0BDC046658D0000EC0E002058
+:108E60002403002070B5074C061C7146201C754673
+:108E7000FBF7A8FA044B291C201C1E60FBF7BAFA6A
+:108E800070BDC046058E0000F00E002070B5074C86
+:108E90007146201C7646FBF795FA054B201C1D6891
+:108EA000311CFBF7A7FA281C70BDC0462D8E0000B0
+:108EB000F00E0020F0B595B009931AAB1B787546FB
+:108EC0000C900691C5487146109311950A92FBF7D4
+:108ED00079FA069EC24C00237372F37220687F23D6
+:108EE0003372B3720379002B07D1BD4B1B689A7B99
+:108EF000002A00D005E107921AE10323C356202778
+:108F0000FF1A0223C3567F00FF1A7F10FFB2079794
+:108F1000099F7F6805970622815E0823C25E0A23A7
+:108F2000C356C07A40B20090381CFCF767FFAD4BC7
+:108F300080021D68296800F0DDFA24686A682378D9
+:108F4000002B00D16EE01C9D911CEB8849006B80CA
+:108F50002B892E1C2B800B1FEB181D887552991E18
+:108F60000988D9806178002903D0079D6FB27F00FE
+:108F700039E0023B013A39D35E88DD88032161562E
+:108F80007519079E4D431F8871B21E89BE194E4345
+:108F90000221AD1961569E887143691889114143B8
+:108FA00009141981E5E7032565575988DE886D00A6
+:108FB000AC460D1CB14200D2351CADB266466E43C4
+:108FC0001D89B4461E88311CAE4200D2291C0225E0
+:108FD000655789B29E887943754361444D19AD1137
+:108FE00045432D141D81023B013ADCD2099F0D201F
+:108FF0007F68049720560622A15E0823E25E0C23B8
+:10900000E3560090381CFCF7F9FE764B80021C6892
+:10901000616800F06FFA724B226819680B78002BB8
+:109020000CD161E0531C1C9F5B00FB18013ADDD39F
+:109030001988023B41430914D980F7E71B9CE38858
+:10904000251C63802389261C2380941C6400231F15
+:10905000EB181D8835539C1E2488DC804C78002C2E
+:1090600003D0079C67B27F003AE0023B013A00D28E
+:109070003BE75E88DD8803240C577519079E65431E
+:109080001F8874B21E89BE1966430224AD190C579D
+:109090009E8874432C19A411444324141C81E4E7D2
+:1090A00003254D575C88DE886D00AC46251CB44214
+:1090B00000D2351CADB264466C431E881D89A4469F
+:1090C000341CAE4200D22C1C02254D57A4B29E88FF
+:1090D0007C43754364446519AD1145432D141D81CE
+:1090E000023B013ADCD200E7531C1B9D5B00EB18EE
+:1090F000013A00D2F9E61988023B41430914D980AC
+:10910000F6E7099E1027D95F70680024079488420B
+:109110000EDD12255A5F1B7D01265BB20093231CD6
+:10912000FCF76CFE10231B1A9B000B900D93079607
+:109130002C4B002118682A4B07681B68BC460E930D
+:10914000099167464368791E00D28FE01B9C4A0054
+:10915000A2180F92013B00D286E0079D8468002D83
+:1091600042D0664666430896F6180A9F0136760096
+:10917000BD5B5F1C2AB2D243D2172A408D1C6543C7
+:1091800002967D190A9E6D00AE5F12B2039696425A
+:1091900000DA0392089E341B3C190A9F6400E45FC6
+:1091A000944200DA141C039E0A9F3519029C3E1952
+:1091B0000224375F141EBC4200DA3C1C023E2D190B
+:1091C0000027F45F161EA64200DA261CAD190B9C80
+:1091D0000D9E65437243AA1892110CE0558E000053
+:1091E000F00E00201C03002067467C431C1901344C
+:1091F0000A9D6400625F0E9E3479002C07D01C9F8C
+:109200005C003C1924890F9D121B2C89121B109E97
+:10921000B24218DD069F0B243C579C4200DAFB72D9
+:10922000069D0A242C579C4200DDAB72069E092441
+:1092300034578C4200DA7172069F08243C578C42E6
+:1092400003DD397201E0002A04DD099C944202DA50
+:10925000099200E00022846865466C431C190134C1
+:109260000C9EA400A25175E78C466AE70999069CFA
+:109270000022216012A98A80826805680C9E4B70CA
+:109280008A707C2301325B429200CB70B218832338
+:1092900005200B710D70FCF7F7FC03481199FBF7E3
+:1092A000A9F815B0F0BDC046558E0000014B1868F6
+:1092B0007047C0462803002000487047A4070000FC
+:1092C000014B18687047C04628030020024B1868FD
+:1092D000F930FF307047C04628030020C4235B00EC
+:1092E0005843034B1B681818C3239B00C0187047D2
+:1092F000280300200A235843034B1B681818BB237C
+:109300009B00C0187047C04628030020014B18601E
+:109310007047C046F40E0020014B18687047C046E5
+:10932000F40E002000487047B4B7000038B5F9F7D4
+:1093300077FF0F4B41791B68012559604279941CD6
+:109340002A40A2189A6082791A604A43DA60427908
+:1093500002219A61AA40DA61026859611A62C279EF
+:109360001A6101795A1DD17702790633DA7738BD4F
+:109370001C03002010B5124C1249134A206800F05B
+:1093800039F92068F9F746FF2068B430F7F734FD63
+:109390002068EC30FCF766FD2068F430FDF718FB20
+:1093A0002068F530FF30FCF74FF9FFF7BFFF074C9F
+:1093B000201CF9F747FF064BE018FCF76BFD10BDCA
+:1093C0002803002010B00000A4070000B4B700007C
+:1093D000C503000038B5174BC424596864000A78E7
+:1093E0001B685443C2229200A4181C19124B201D62
+:1093F0001860F9F71BFFBA235B00E518281CFFF77C
+:1094000031FD201CF830F7F703FD86214900601874
+:10941000FCF734FD90225200A018FDF7E5FA281C55
+:10942000FCF71EF9054B9E341B6822780733DA7768
+:1094300038BDC04628030020F40E00201C03002085
+:10944000014B5B681870704728030020014B5B6874
+:109450001878704728030020002934D00123002207
+:1094600010B488422CD301242407A14204D28142A3
+:1094700002D209011B01F8E7E400A14204D28142B3
+:1094800002D249005B00F8E7884201D3401A1A4330
+:109490004C08A04202D3001B5C0822438C08A04267
+:1094A00002D3001B9C082243CC08A04202D3001B1D
+:1094B000DC082243002803D01B0901D00909E3E797
+:1094C000101C10BC7047002801D00020C04307B416
+:1094D000024802A14018029003BDC046D900000016
+:1094E0000029F0D003B5FFF7B9FF0EBC4243891A3B
+:1094F0001847C046002941D010B4041C4C40A44673
+:1095000001230022002900D54942002800D540420D
+:1095100088422CD301242407A14204D2814202D2E2
+:1095200009011B01F8E7E400A14204D2814202D202
+:1095300049005B00F8E7884201D3401A1A434C08FF
+:10954000A04202D3001B5C0822438C08A04202D335
+:10955000001B9C082243CC08A04202D3001BDC085D
+:109560002243002803D01B0901D00909E3E7101C9E
+:109570006446002C00D5404210BC7047002806D03D
+:1095800003DB0020C043400801E08020000607B450
+:10959000024802A14018029003BDC0461900000015
+:1095A0000029EBD003B5FFF7A7FF0EBC4243891A91
+:1095B0001847C0467047C046F8B50D1C041C081C6F
+:1095C000111C161CFFF796FF311C071C281CFFF707
+:1095D000E7FF002D05DB002908DB2760201C616008
+:1095E000F8BD0029F9DD013F8919F6E70137891B2C
+:1095F000F3E7C046F0B50F2A35D9031C0B439C078F
+:1096000035D1161C103E36093501451910350C1C94
+:10961000031C27681F6067685F60A7689F60E76832
+:109620001034DF601033AB42F3D1731C1B01C5183B
+:10963000C9180F231340032B1BD91C1FA408013486
+:10964000A4000023CE58EE500433A342FAD1ED1803
+:10965000C91803231A4005D00023CC5CEC54013315
+:109660009342FAD1F0BD051C002AF5D1FAE7051C9A
+:10967000F2E71A1CF8E7C046F0B5830746D0541E3F
+:10968000002A42D0CEB2031C032503E0621E002C48
+:109690003BD0141C01335A1E16702B42F6D1032CFA
+:1096A0002BD9FF250D402A0215432A0415430F2C00
+:1096B00015D9271C103F3F091E1C3A011036B61859
+:1096C0001A1C156055609560D5601032B242F8D111
+:1096D00001373F010F22DB191440032C0DD9271F3E
+:1096E000BF08BA001E1DB6181A1C20C2B242FCD117
+:1096F0000137BF000322DB191440002C05D01C19D0
+:10970000C9B219700133A342FBD1F0BD141C031C74
+:10971000C5E7C046AE0174033B050207CD08940AB5
+:10972000590C1F0E0600000008000000FF00000199
+:10973000FF01FF0100FF0100FFFF01010001020323
+:10974000040405060708090A0B0B0C0D0E0F101177
+:1097500011121314151516171818191A1B1B1C1D96
+:109760001D1E1F1F202121222323242425252627D7
+:1097700027282829292A2A2B2B2C2C2D2D000000C4
+:109780007804EF08660DDB115016C21A331FA123AF
+:109790000C28742CD93039359639EE3D424290462A
+:1097A000D94A1B4F58538E57BE5BE65F07641F684C
+:1097B000306C397038742F781C7CFF7FD983A88770
+:1097C0006D8B278FD5927996109A9B9D1BA18DA4A6
+:1097D000F3A74BAB97AED4B104B526B839BB3EBEA8
+:1097E00034C11BC4F2C6BAC973CC1BCFB3D13BD4AE
+:1097F000B2D619D96EDBB3DDE6DF08E218E416E66F
+:1098000003E8DDE9A5EB5BEDFEEE8FF00DF277F3FB
+:10981000CFF414F646F764F86FF967FA4BFB1BFCBC
+:10982000D8FC81FD17FE98FE06FF5FFFA5FFD7FF5E
+:10983000F5FFFFFFB50239017E000000480000205F
+:109840003003002000000000FF00000000000000C6
+:109850000000000000000000000000000000000008
+:1098600000000000000000000000000000000000F8
+:1098700000000000000000000000000000000000E8
+:1098800000000000000000000000000000000000D8
+:1098900000000000000000000000000000000000C8
+:1098A00000000000000000000000000000000000B8
+:1098B00000000000000000000000000000000000A8
+:1098C0000200000000000000000000000000000096
+:1098D0000000000000000000000000000000000088
+:1098E0000000000000000000000000000000000078
+:1098F0000000000000000000000000000000000068
+:109900000000000000000000000000000000000057
+:109910000000000003000000000000000000000044
+:109920000000000000000000000000000000000037
+:109930000000000000000000000000007403002090
+:1099400074030020640300207403002060040020DE
+:109950009104002089040020810400200000000000
+:1099600010030020000000000E0300200003002070
+:10997000F2020020F102002000000000600400203C
+:10998000140200207004002002000000CC0E002011
+:109990000000000000000000070000007F0400201D
+:1099A000ED02002080040020000000000000000004
+:1099B0000000000000000000C8020020B4020020E7
+:1099C000000000000000000000000000A0020020D5
+:1099D000000000008C020020000000007402002043
+:1099E00000000000580200200000000000000000FD
+:1099F00000000000400200202C020020180200207D
+:109A0000E9020020E4020020000000007B040020A6
+:109A100000200060100200207804002028020020AE
+:109A20000100000004000000A001002079040020D3
+:109A30003C020020010000000100000004020020A0
+:109A4000530200205002002003000000040506001D
+:109A500010200000A40100206D02002068020020F8
+:109A60000500000004010601040010203031000050
+:109A700074010020870200208402002003000000FF
+:109A80000401060010200000F80200207A040020E3
+:109A90009C02002001000000040000006C01002076
+:109AA000B2020020B002002002000000020E0010EE
+:109AB00090010020C40200209C010020030000004F
+:109AC0000010110054010020DE020020D802002006
+:109AD000060000001708080C0A08002030405070EB
+:109AE00001000000000020050100200100FF00200F
+:109AF00001000000FC0200200060080100010000DD
+:109B00000000000000000000000005004D4950006A
+:109B10000000000000040000DC0400200405002018
+:109B200014050020C4050020C0050020FFFFFFFF32
+:109B3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF35
+:109B4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF25
+:109B5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF15
+:109B6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF05
+:109B7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5
+:109B8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE5
+:109B9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD5
+:109BA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC5
+:109BB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB5
+:109BC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA5
+:109BD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF95
+:109BE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF85
+:109BF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF75
+:109C0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF64
+:109C1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF54
+:109C2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF44
+:109C3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF34
+:109C4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF24
+:109C5000FFFFFFFFFFFFFFFFFFFFFFFF3801630173
+:109C60004D344850435554320000000000000901B3
+:109C700038B50420FCF7D3F800F04CFAFBF7BCFE33
+:109C8000FCF7BEFE3A4C3B4B3B4DA03003602A68CC
+:109C900023683A485A603A4900F024FA23682D684C
+:109CA0001A68DD6001321A603648374900F01AFA46
+:109CB000236836489A68364901329A6000F012FAF1
+:109CC000236834489A68344901329A6000F00AFAED
+:109CD000236832489A68324901329A6000F002FAE9
+:109CE000236830489A68304901329A6000F0FAF9E6
+:109CF00023682E489A682E4901329A6000F0F2F9E2
+:109D000023682C489A682C4901329A6000F0EAF9DD
+:109D100023682A489A682A4901329A6000F0E2F9D9
+:109D2000236828489A68284901329A6000F0DAF9D5
+:109D3000236826489A68264901329A6000F0D2F9D1
+:109D4000236824489A68244901329A6000F0CAF9CD
+:109D5000236822499A68224801329A6000F0C2F9C9
+:109D600023689A6801329A60FCF74AFE38BDC04603
+:109D70004801002011A00000D40E002079710000DD
+:109D8000DD9D00000D110000919D000009100000F4
+:109D9000A99D0000558E0000859D0000996B000074
+:109DA000F59F00007D1D0000D19D0000AD17000053
+:109DB000879D0000CD290000899D00009D1E0000A8
+:109DC0008B9D0000F96100008D9D0000ED8000007A
+:109DD0008F9D0000212C0000D99E00008D9F000067
+:109DE000D9820000704770477047704770477047CE
+:109DF00007B5002201AB1A800198FAF767FA8020B4
+:109E00000004FBF765FE07BD08B5FCF7E7FD074B4F
+:109E10001B68DA6A002A04DB586B11180122323100
+:109E200000DB002274331A7008BDC04640000020D9
+:109E300008B5F6F7FFFFFCF7E3FD08BD3A4BF7B5B1
+:109E40001A683A4C16693A4D3278012A5CD120885A
+:109E50002821FFF745FB726888B20023D35EC0005B
+:109E60002B50B368281800229B5E4360FCF79AFFD2
+:109E700022882823272A00D8131C2E4D01320026C1
+:109E80002280DBB2371C0195013BDBB2FF2B13D0E4
+:109E90002748D9000A5884460198904200DD019273
+:109EA000974200DA171C61444A68954200DD151C90
+:109EB0009642E9DA161CE7E7FCF79CFD2388272B7E
+:109EC00030D9019C51303F1BFA17BF185740082F5B
+:109ED00017DC751BEB17ED185D400823082D11DD0D
+:109EE000032F0EDC104C2268136952695B685268BC
+:109EF0000024115F00241A5F8A18D10F8A185210AB
+:109F00001A80012303700DE0FCF774FDA022061CEB
+:109F10000021281C5200FFF7AFFB0023238051369D
+:109F200001233370F7BDC046440000206C0D0020B3
+:109F3000700D0020FFFF0000F0B589B0F9F770F94F
+:109F40002649102204A8FFF755FBFAF735FA244BEF
+:109F500024491A68244C13680E682768013B22D3F1
+:109F600051680D1C5D436C186D00640089000395F9
+:109F7000039D0439AC42F1D0F569023C02942C19DE
+:109F80000194BD69440000946C58009DA4461035AE
+:109F90006C462D5B64462C1BA446019C25886544B9
+:109FA0002580029CE4E70F4F0F4B12693D681E6845
+:109FB00053009200023B043A991C0DD02C6A376A78
+:109FC000E118BC580F883F1B4400BC4610346F4654
+:109FD000E45B64440C80EDE709B0F0BDB49600008A
+:109FE0001C030020440000204000002038B5F6F794
+:109FF0001BFF041CFCF7F2FC201CF0300378002B44
+:10A0000023D0124B00221C681E23216BC968C95E35
+:10A01000002900D10122023B991CF6D10C4B1B6890
+:10A02000DD6A002D11D1596B00290ED1F433002ABD
+:10A030000AD01A68FE2A01DC01321A601B68052B5F
+:10A0400003DD0023037000E01A6038BD44000020E7
+:10A050004000002008B5FBF727FD012805D0034B81
+:10A060001B681869596900F071F808BD44000020A8
+:10A0700038B5041C0D1CFBF7A9FD002802D00128EF
+:10A080000CD02BE0164B6D001B681B691B69EA5A4C
+:10A09000FF23FE2A00D8D3B263711FE0104B690082
+:10A0A0001B681A691269895AFF22FE2900D8CAB2B0
+:10A0B00062711B69AD0059690322491902238A564E
+:10A0C000CB560120D31A002208568A56821A934290
+:10A0D00002DDA371E27101E0A271E37138BDC046F7
+:10A0E0004400002038B5051C08200C1CFBF797FE27
+:10A0F0000560446038BDC04638B5041C081C002A01
+:10A1000007D0D118584362434D1010184019FFF77B
+:10A11000F1F938BD38B5FCF76DFC041CB820FBF72D
+:10A120007EFE094DB82228600021FFF7A5FA231C06
+:10A1300052333C341B78207864215843FFF7DAF916
+:10A140002D68B035286038BDF80E0020F0B59DB000
+:10A150000F1C041CFCF74EFC0A90FCF73FFC0F9010
+:10A16000FBF7A4FE0F9B0122F0331B7800259A40D9
+:10A17000131C0F9AF13212789B1A0F9AF23212784E
+:10A180009B1ADBB21593FCF73BFC974B0D901B68B9
+:10A190000E951093954B0B951B681B6A0C935B00F7
+:10A1A000023B9E1C0CD026690E9DF25A954200DAA5
+:10A1B0000E92E6680B9DF25E9542F1DA0B92EFE7A4
+:10A1C0000C9B0D9D0F339B00EB1807930C9E013EDB
+:10A1D0000C9600D210E10C9EE0687600835F099631
+:10A1E000002B00D1FBE00A9A0A9B126921695233C5
+:10A1F0001D78885B0692111C0A9B0A9A2833143238
+:10A20000FBF718FE061CF6F70FFEF0300378002B64
+:10A2100005D00A9B3E331B789E4200DA1E1C744B0D
+:10A220001B681A6B9269117800291BD15278002A99
+:10A230000AD16E4A9B68126892685200D25E0E2A5A
+:10A2400037DC02215B5E2FE0102A32D1674A9B681F
+:10A250001268926810325200D25E0E2A29DC1E214A
+:10A260005B5E21E049B21E2923D15278002A0BD12E
+:10A270009B683A201A5E0E2A1BDC5C4A12689268C0
+:10A280001E325200D35E0FE0102A12D1574A9B684B
+:10A2900012689268514359183C20095E0E2908DC67
+:10A2A00052019B183A215B5E0E2B02DCF30F9B19C7
+:10A2B0005E100A9B53331B78002B02D16422944614
+:10A2C00045E0494BAC461B681D1CB43511952878F8
+:10A2D000139000281DD1E168099A60468D5E6422C2
+:10A2E0006A437043129212991A1CAC3281420EDDFD
+:10A2F000B5420CDC15680F9801351560DA3000782E
+:10A30000854206D1119801250570139900E00021BE
+:10A310001160191CB4310A78002A14D0E268099D32
+:10A32000505F1A1CAC32B0420BDD10680A9D013040
+:10A33000106041352D78A84205D1002008701060CA
+:10A3400001E000211160B4331B78002BB6D00D9DC5
+:10A350000C98E2682B182C33099D1B785219002B9E
+:10A3600005D00A995BB2413109788B4221DC00208B
+:10A37000135E65466420584375432169A84211DB8A
+:10A380000A98099E48308D5B00780E9E70438011BC
+:10A39000854207DB0A980B9DC06C059068438011CD
+:10A3A00083421CDA099E079D00238B5313802B6088
+:10A3B00012E00020135E0F49654659430A9B3C3367
+:10A3C0001B7873436B43994209DA2669099D002380
+:10A3D0007353079E138033602378013B2370079DDE
+:10A3E000043D0795F2E6C046F80E00201C0300204D
+:10A3F000440000201027000000232370904B0D9D87
+:10A400001B681B6A0C930C9E013BAA192B32099204
+:10A410000C225343109D0D9EEB182B360E9317966E
+:10A420000C9D099E013D0C95179DAE4200D17FE227
+:10A430000C9DE0686E00835F099D002B00D13DE21A
+:10A440002A780A9B0132D2B22A7041331B7852B269
+:10A45000991D8A4201DD04332B7009980025455768
+:10A46000012D00DCC0E1A81C0321FFF799F87B68EF
+:10A470000891BA68022D38D10D98995F0069925BF6
+:10A480000D9D0490401094466A690D1AEB17ED1863
+:10A490005D40401B7F281BDC65462BB25210981A8A
+:10A4A000C51740196840121A7F2A11DC6268A56836
+:10A4B000905F401AA95FC91AFDF700FD0B2807D964
+:10A4C00078686168835BBA688B53935BA568AB530C
+:10A4D0000323013B11D360680E9D815B5A00A06885
+:10A4E000A952815BAA18D180F3E7089D995B6B00A4
+:10A4F0000E9DEB181980925BDA800998002545576C
+:10A50000032D00DC5EE108990E9A4B00D3180793E7
+:10A51000081C1B88043003210B93FFF741F80E98A9
+:10A520004900079B41180A88DB88C9889446129124
+:10A5300010936168A268042D0FD1885F79688B5FE2
+:10A54000C31ADD175B196B40BD68905FAA5F801A64
+:10A55000C11740184840181814E03A4B885F1B6830
+:10A56000925F9B19191C82310025495F9633411A6D
+:10A57000C817091841400025585F101AC2178018E3
+:10A58000504008182F4B61681B688D5B9A19111C8D
+:10A5900082310D80A5689632A95B0C9D11805B19F4
+:10A5A0001A1C78321178002906D00F99F8310988E1
+:10A5B000884208DC002105E00F99FA3109888842B9
+:10A5C00001DB0121117078331B78002B3CD10F9AED
+:10A5D0000F9BF63212888021F4331B8800924A00C8
+:10A5E000FBF70CFC65680B90AD190020295E0895FF
+:10A5F000079DA2680020285E95190B1ADA179B1890
+:10A60000534010930022AB5E9C46079B06229A5E45
+:10A6100063469A1AD317D2185A40109B9A18109270
+:10A62000109B0B9AFFF768FD0899079A088006208F
+:10A63000105E0023E95E0B9A109BFFF75DFD9AE028
+:10A640001C030020F80E00200B9D109A28B26546CE
+:10A650002BB2C31A11B2DA0FD318129A5B1015B2CB
+:10A660004D1B1193EB0F5D196D1013956568AD19B6
+:10A6700016950022AD5E1095A568AD1912950022C1
+:10A68000AD5E1495119D2B18109DEB1A139DD817D4
+:10A690006918149D1B18691A4340C81709184140CE
+:10A6A00000255B180B95802B01DD803B0B930898F0
+:10A6B00003210530FEF774FF0E9D0F9B49006918BA
+:10A6C000079D0291F1331B780621695E159D089361
+:10A6D0004D430F9B0298F2331B780621415EAC4636
+:10A6E000089D039314986943039D0F9B4543F033E2
+:10A6F0001B788C440F9A65441D41F3321278AC46A6
+:10A70000139D0B985543291C1941614414918021D4
+:10A71000C90045180799681013900020095E159824
+:10A720004843844602980021415E089841430398BB
+:10A730008C4410994843119960444A4318411A4186
+:10A7400080180B99109A139B514380024018C0182F
+:10A75000291CFEF7CFFE16990880149A12999302CD
+:10A760000020085E0B9A291C50431818139BC01830
+:10A77000FEF7C0FE129D2880E568F968AD19885F74
+:10A7800008950022A95E0A9D083507953E23EA5EDA
+:10A79000431ADD175B196B40FFF7AEFC089D396962
+:10A7A00028802569885BAD1929880895079D431A7B
+:10A7B0003E22AA5EDD175B196B40FFF79DFC089DEA
+:10A7C000288011E060687D6883190022995EAA5F85
+:10A7D000A0688A185210BD681A8083190022995EF9
+:10A7E000AA5F8A1852101A800A9B099D00214133E2
+:10A7F00069561A7891423DDC6068A168835F1AA8A7
+:10A800001A938B5F1B93FCF7CDFA0023EB56012BB9
+:10A8100002D1804B00221A701B9ADC23C83A9B009D
+:10A820009A4204D81A9AB4239B009A4202D90C9DEA
+:10A83000002D0AD0784B1B78002B16D00A9B413391
+:10A840001A78744B1B789A420FDB734B01221A70F3
+:10A85000704B60681A780588704851000D52A068E6
+:10A86000013205886E481A700D520123E1685B427F
+:10A870008B531FE0227801322270674A1278002A37
+:10A8800018D00D9A1B782C321278013352B29A42AA
+:10A890000DD1644A012318A9137000200B704B706E
+:10A8A0008B70CB70F12388800B71FBF7EDF95A4B5D
+:10A8B00000221A70099D0023AB7232E00A9A00212F
+:10A8C000413269561278914223DDF868825F002A8E
+:10A8D00027D0AA7A0A990132D2B2AA7242310978F3
+:10A8E00052B28A4201DD2B701BE0796862688B5B93
+:10A8F000BD689353AB5BA068F96883538B5BE268D8
+:10A900003D699353AB5B20698353237801332370F4
+:10A9100007E0454A0C9E1268099D921978322B7007
+:10A920001370099D0E9E013D0C3E09950E9677E52C
+:10A930000D9B002272331A703C4B0D9E1B681D69E3
+:10A94000741937356D0075198936893404350796C1
+:10A95000079EB4425BD02B88002B0ED00C27EA5FF9
+:10A960001BB2002A02DC0A9A3F3201E00A9A403206
+:10A970001278934201DA00232B802988002927D0FE
+:10A9800023787F2B01D0013323700026A657022E97
+:10A990000DDD0A9B0C22A85E09B208333E27DA5F60
+:10A9A000431ADF17DB197B40FFF7A6FB28800A9BC1
+:10A9B00043331B789E4203DC01235B422B8004E07F
+:10A9C0000D9B72331A7801321A70002363711BE0F9
+:10A9D0000A9B00224333A2561B789A4213DDAB89AF
+:10A9E000002B11D062790A980132D2B262714430E0
+:10A9F000007852B2824206DC2B800D9B72331A78AB
+:10AA000001321A7000E02170013C023DA0E71DB048
+:10AA1000F0BDC046D8040020DA040020C4040020A1
+:10AA2000B0040020D9040020F80E00201C030020F0
+:10AA3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF26
+:10AA4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF16
+:10AA5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF06
+:10AA6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6
+:10AA7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE6
+:10AA8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD6
+:10AA9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC6
+:10AAA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB6
+:10AAB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA6
+:10AAC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF96
+:10AAD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF86
+:10AAE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF76
+:10AAF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF66
+:10AB0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF55
+:10AB1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF45
+:10AB2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF35
+:10AB3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF25
+:10AB4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF15
+:10AB5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF05
+:10AB6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5
+:10AB7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE5
+:10AB8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD5
+:10AB9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC5
+:10ABA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB5
+:10ABB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA5
+:10ABC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF95
+:10ABD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF85
+:10ABE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF75
+:10ABF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF65
+:10AC0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF54
+:10AC1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF44
+:10AC2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF34
+:10AC3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF24
+:10AC4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF14
+:10AC5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF04
+:10AC6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4
+:10AC7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE4
+:10AC8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD4
+:10AC9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC4
+:10ACA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB4
+:10ACB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA4
+:10ACC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF94
+:10ACD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF84
+:10ACE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF74
+:10ACF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF64
+:10AD0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF53
+:10AD1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF43
+:10AD2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF33
+:10AD3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF23
+:10AD4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF13
+:10AD5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF03
+:10AD6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3
+:10AD7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE3
+:10AD8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD3
+:10AD9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC3
+:10ADA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB3
+:10ADB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA3
+:10ADC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF93
+:10ADD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF83
+:10ADE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF73
+:10ADF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF63
+:10AE0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF52
+:10AE1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF42
+:10AE2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF32
+:10AE3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF22
+:10AE4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF12
+:10AE5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF02
+:10AE6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2
+:10AE7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE2
+:10AE8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD2
+:10AE9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC2
+:10AEA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB2
+:10AEB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA2
+:10AEC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF92
+:10AED000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF82
+:10AEE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF72
+:10AEF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF62
+:10AF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF51
+:10AF1000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF41
+:10AF2000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF31
+:10AF3000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF21
+:10AF4000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF11
+:10AF5000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF01
+:10AF6000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1
+:10AF7000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE1
+:10AF8000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD1
+:10AF9000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC1
+:10AFA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB1
+:10AFB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA1
+:10AFC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF91
+:10AFD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF81
+:10AFE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF71
+:10AFF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF61
+:10B00000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF50
+:10B01000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF40
+:10B02000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF30
+:10B03000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF20
+:10B04000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF10
+:10B05000FFFFFFFFFFFFFFFFFFFFFFFF630109018E
+:10B060004D344850504154320000000000000901A6
+:10B070000A000000011F1100010000020304050680
+:10B080000708090A0B0C0D0E0F101112353332315F
+:10B09000302F2E2D2C2B2A292827000000000024D9
+:10B0A0001415161718191A1B1C1D1E1F20212223E8
+:10B0B0000000000000000000000000000000000090
+:10B0C000000000000000000000000000003F1F061C
+:10B0D00000BF000F000000000000000000000000A2
+:10B0E0000000000000000000000000000000000060
+:10B0F00000000000000000F0000000000000000060
+:10B10000000000000000000000000000000000003F
+:10B1100000000000830000000001E1A10800000918
+:10B1200003030000434B545F3564343900000000D2
+:10B1300000000000057878010000FFFFFFFFFFFF1F
+:10B14000FFFFFFFF0A05C800DC057300FA00780066
+:10B150000005641E1E0A0305103C3C000A0A00009C
+:10B16000000000003804000080070000C800000054
+:10B1700020030000C8000000E80300006400000095
+:10B1800001000000010000000100000001000000BB
+:10B1900005000000000040008000C400FF006E00B9
+:10B1A000640055004B0046006E00640055004B00E3
+:10B1B00046006E00640055004B0046006E006400BF
+:10B1C00055004B0046000000000000000000000099
+:10B1D000000000000000000000000000000000006F
+:10B1E000000000000000000000000000000000005F
+:10B1F000000000000000000000000000000000004F
+:10B2000002000000000040008000C400FF00800039
+:10B2100080000000000000008000800000000000AE
+:10B22000000080008000000000000000800080001E
+:10B2300000000000000000000000A802BF043C0065
+:10B24000C8001E00B0045E01F4010100B0045A0001
+:10B25000230018010613133D800200014000C000C6
+:10B26000F401F40101000000009E000F0000000046
+:10B2700000000000000000000000000000000000CE
+:10B28000000000000000000000000000000000F0CE
+:10B2900000000000000000000000000000000000AE
+:10B2A000000000000000000000000000009E000FF1
+:10B2B000000000000000000000000000000000008E
+:10B2C000000000000000000000000000000000007E
+:10B2D000000000F00000000000000000000000007E
+:10B2E000000000000000000000000000000000005E
+:10B2F0008000000000037B1ED10000710A48F61F89
+:10B300000000003F1F063F1D003F1D06000000001B
+:10B31000000000000000000000000000000000002D
+:10B32000000000000000000000000000000000001D
+:10B33000000000000000000000000000000000000D
+:10B3400000000000000000000000000000000000FD
+:10B350000000000000000000000000000000FFFFEF
+:10B360000A14380703000000FFFF0A14380703001F
+:10B370000000FFFF0A1438070300000000BF000DA3
+:10B3800000000000000000000000000000000000BD
+:10B3900000000000000000000000000000000000AD
+:10B3A000000000F0000000000000000000000000AD
+:10B3B000000000000000000000000000000000008D
+:10B3C000009E000F000000000000000000000000D0
+:10B3D000000000000000000000000000000000006D
+:10B3E00000000000000000F000000000000000006D
+:10B3F000000000000000000000000000000000004D
+:10B40000000000008000000040032B1CD1000071F0
+:10B410000A48B61B010000370F05370F00370F052C
+:10B42000000000000000000000000000000000001C
+:10B43000000000000000000000000000000000000C
+:10B4400000000000000000000000000000000000FC
+:10B4500000000000000000000000000000000000EC
+:10B4600000000000000000000000000000000000DC
+:10B47000641E2C011400000007000000FF7F008004
+:10B48000FF7F008001035A0200005A03120000806F
+:10B490000A070F0A0DF14000D00280022602FA00CE
+:10B4A0003000000050000000050000000000150002
+:10B4B0001E00230028000000000000000000000023
+:10B4C0003700370050007800A000000000000000A6
+:10B4D000000000004BC83C1E0F02010202000000E9
+:10B4E000070000000F000000010114000101061117
+:10B4F00001001E00500014410A1400002C01E80352
+:10B500001000000000BF000D00000000000000005F
+:10B51000000000000000000000000000000000002B
+:10B520000000000000000000000000F0000000002B
+:10B53000000000000000000000000000000000000B
+:10B540000000000000000000009E000F000000004E
+:10B5500000000000000000000000000000000000EB
+:10B56000000000000000000000000000000000F0EB
+:10B5700000000000000000000000000000000000CB
+:10B58000000000000000000000000000800000003B
+:10B590004003331CD10000710A48F61F0000003F31
+:10B5A0001F063F1F003F1F060000000000000000B4
+:10B5B000000000000000000000000000000000008B
+:10B5C000000000000000000000000000000000007B
+:10B5D000000000000000000000000000000000006B
+:10B5E000000000000000000000000000000000005B
+:10B5F0000000000000000000781E2C011400000074
+:10B6000007000000FF7F0080FF7F00800103000033
+:10B6100000005A030800008007070F070FF94000D9
+:10B6200026025E015E01FA003000000032000000D8
+:10B63000060000002B002C0034003A0056006E007B
+:10B6400000000000000000004600500096002C01A1
+:10B650000502050200000000000000004B3CA01E97
+:10B660000F02010202000000070000000F000000AE
+:10B670000101140000000A0D01002C01E80323233E
+:10B68000232301002C01E8031000000000BF000D7F
+:10B6900000000000000000000000000000000000AA
+:10B6A000000000000000000000000000000000009A
+:10B6B000000000F00000000000000000000000009A
+:10B6C000000000000000000000000000000000007A
+:10B6D000009E000F000000000000000000000000BD
+:10B6E000000000000000000000000000000000005A
+:10B6F00000000000000000F000000000000000005A
+:10B700000000000000000000000000000000000039
+:10B71000000000004000000040033B18D100007111
+:10B720000A48F61F000001380F053F1D00230F05D2
+:10B730000000000000000000000000000000000009
+:10B7400000000000000000000000000000000000F9
+:10B7500000000000000000000000000000000000E9
+:10B7600000000000000000000000000000000000D9
+:10B7700000000000000000000000000000000000C9
+:10B78000781EFFFF1400000007000000FF7F00800C
+:10B79000FF7F00800003000000005A0308000080C3
+:10B7A00007070F0A0FF64000B003520326025E019E
+:10B7B0003000000032000000060000002B002C00CA
+:10B7C00034003A0056006E00000000000000000047
+:10B7D0004600500096002C01050205020000000002
+:10B7E000000000004B3CA01E0F02010202000000FE
+:10B7F000070000000F0000000101140101000A0D04
+:10B8000001002C01E8030F3C0F3C00002C01E80371
+:10B81000100000000A0A0A0A0A0A0A0A0A0A0A0AA0
+:10B820000A0A090909090808080808070707070696
+:10B830000605050A09090909090A0A090A0909097F
+:10B84000090909090808080808070707070606067E
+:10B8500005050A0A0A0A0A0A0A0A0A0A0A0A0A0A52
+:10B86000090909090909080808080707070606065B
+:10B87000050A0A0A0A0A0A0A0A0A0A0A0A0A0A0A2D
+:10B880000A0909090909080808070707070606053C
+:10B890000B0B0B0B0B0B0B0B0B0B0B0B0B0A0B0AFA
+:10B8A0000A09090909090908080807070706060B14
+:10B8B0000A0A0A0A0A0B0B0B0B0B0A0A0A0A0A0AE3
+:10B8C00009090909090808080807070706060B0BF4
+:10B8D0000B0B0B0B0B0B0B0B0B0B0B0B0B0B0A0ABA
+:10B8E0000A0A09090909080807070707060C0B0BCC
+:10B8F0000B0B0B0B0C0B0B0B0B0B0B0B0B0B0A0A99
+:10B900000A0A0A0909090808080707070B0B0B0BA5
+:10B910000B0B0B0C0B0C0B0B0B0B0B0B0B0A0A0A78
+:10B920000A0A0909090808080707070C0C0C0C0C7F
+:10B930000C0C0C0C0C0C0C0C0C0B0B0B0B0B0B0A4F
+:10B940000A0A09090909080707070C0B0B0B0B0C5E
+:10B950000C0C0C0C0C0C0B0C0B0B0B0B0B0A0A0A33
+:10B960000A09090909080707070C0C0B0C0C0C0C39
+:10B970000C0C0C0C0C0C0C0B0B0B0B0B0B0B0A0A12
+:10B980000A090909080807070C0C0C0C0C0C0C0C14
+:10B990000C0C0C0C0C0C0C0C0B0B0B0B0B0A0A0AF2
+:10B9A000090909090808070C0C0C0C0C0C0C0C0CF0
+:10B9B0000C0C0C0C0C0C0C0B0B0B0B0B0A0A0A09D5
+:10B9C0000909080808070C0C0C0C0C0C0C0C0D0CCD
+:10B9D0000D0C0D0C0C0C0B0B0B0B0B0B0A0A0A09B4
+:10B9E00009090808080C0C0C0C0C0C0C0C0D0C0DA7
+:10B9F0000C0D0C0C0C0B0B0B0B0B0B0A0A0A090998
+:10BA0000090908080D0C0C0C0D0D0D0D0D0D0D0D7B
+:10BA10000D0D0D0C0C0B0B0B0B0B0B0A0A0A090975
+:10BA200009080800000000000000000000000000FD
+:10BA30000000000000000000000000000000000006
+:10BA400000000000000000000000000000000000F6
+:10BA500000000000000000000000000000000000E6
+:10BA600000000000000000000000000000000000D6
+:10BA700000000000000000000000000000000000C6
+:10BA800000000000000000000000000000000000B6
+:10BA900000000000000000000000000000000000A6
+:10BAA0000000000000000000000000000000000096
+:10BAB0000000000000000000000000000000000086
+:10BAC0000000000000000000000000000000000076
+:10BAD0000000000000000000000000000000000066
+:10BAE0000000000000000000000000000000000056
+:10BAF0000000000000000000000000000000000046
+:10BB00000000000000000000000000000000000035
+:10BB10000000000000000000000000000000000025
+:10BB20000000000000000000000000000000000015
+:10BB30000000000000000000000000000000000005
+:10BB400000000000000000000000000000000000F5
+:10BB500000000000000000000000000000000000E5
+:10BB600000000000000000000000000000000000D5
+:10BB700000000000000000000000000000000000C5
+:10BB800000000000000000000000000000000000B5
+:10BB900000000000000000000000000000000000A5
+:10BBA0000000000000000000000000000000000095
+:10BBB0000000000000000000000000000000000085
+:10BBC0000000000000000000000000000000000075
+:10BBD0000000000000000000003C393B3C3D3D3DC2
+:10BBE0003D3D3D3E3D3D3D3C3C3A393A3A393937A1
+:10BBF0003431302C2B2825263A2B2B2C2E2C2D2D76
+:10BC00002D2D2D2C2C2C2B2A292929292828262496
+:10BC100022201E1C1A18233B2A2A2C2C2C2C2C2CBC
+:10BC20002C2C2C2C2B2B2B28282929282826232286
+:10BC3000211F1D1A19233B2B2B2D2D2D2C2C2C2C89
+:10BC40002C2C2C2C2B2A2928282928272524222073
+:10BC50001F1D1B19243C2C2E2E2D2C2C2C2C2C2D56
+:10BC60002D2C2B2B2A2A2829282827252422211F5E
+:10BC70001D1B19243C2B2D2D2D2C2C2B2B2B2C2B31
+:10BC80002B2B2A29282828272625242222201F1D5D
+:10BC90001B19243C2C2D2D2C2C2C2C2B2B2B2C2B02
+:10BCA0002A2A2A292828282625252322211E1D1B49
+:10BCB0001A243D2D2D2C2D2D2D2D2C2C2C2C2B2BC9
+:10BCC0002A2A282827272726242322201E1D1C1A3B
+:10BCD000253D2D2D2C2C2C2D2C2C2C2C2C2B2A299D
+:10BCE000292B2727272625242221201E1D1B1A2425
+:10BCF0003E2E2E2C2C2C2D2C2B2B2C2B2A2A29297A
+:10BD0000282728282625232322201F1D1C1A2540EA
+:10BD1000352D2C2C2C2C2C2B2B2B2A2A292929286D
+:10BD20002728282525232221201F1D1B19243F2ECB
+:10BD30002E2C2C2C2C2C2B2B2B2B2A2A292A282757
+:10BD400028282625242321201E1D1B19243E2D2DA5
+:10BD50002D2C2C2C2C2B2B2B2B2A2A29292827283D
+:10BD6000272726242322211E1D1B19233E2D2C2C80
+:10BD70002C2C2C2C2A2B2C2B2D2B2A29282727281E
+:10BD80002726242322201E1C1A19233F2D2D2C2D5B
+:10BD90002C2C2B2B2B2B2B2A2A2A2A292828282704
+:10BDA00027252423221F1D1B19233F2D2E2D2D2D2A
+:10BDB0002D2C2B2C2C2B2B2B2A2A282829292827E1
+:10BDC000262423221F1E1C1A23483E3E3E3E3E3E92
+:10BDD0003E3D3D3D3D3C3C3C3C3A393B3A393736B3
+:10BDE0003533312E2C2A27260000000000000000E9
+:10BDF0000000000000000000000000000000000043
+:10BE00000000000000000000000000000000000032
+:10BE10000000000000000000000000000000000022
+:10BE20000000000000000000000000000000000012
+:10BE30000000000000000000000000000000000002
+:10BE400000000000000000000000000000000000F2
+:10BE500000000000000000000000000000000000E2
+:10BE600000000000000000000000000000000000D2
+:10BE700000000000000000000000000000000000C2
+:10BE800000000000000000000000000000000000B2
+:10BE900000000000000000000000000000000000A2
+:10BEA0000000000000000000000000000000000092
+:10BEB0000000000000000000000000000000000082
+:10BEC0000000000000000000000000000000000072
+:10BED0000000000000000000000000000000000062
+:10BEE0000000000000000000000000000000000052
+:10BEF0000000000000000000000000000000000042
+:10BF00000000000000000000000000000000000031
+:10BF10000000000000000000000000000000000021
+:10BF20000000000000000000000000000000000011
+:10BF30000000000000000000000000000000000001
+:10BF400000000000000000000000000000000000F1
+:10BF500000000000000000000000000000000000E1
+:10BF600000000000000000000000000000000000D1
+:10BF700000000000000000000000000000000000C1
+:10BF800000000000000000000000000000000000B1
+:10BF90000000000000000000000000000000FFFFA3
+:10BFA000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA1
+:10BFB000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF91
+:10BFC000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF81
+:10BFD000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF71
+:10BFE000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF61
+:10BFF000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF51
+:10C00000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF40
+:10C01000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF30
+:10C02000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF20
+:10C03000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF10
+:10C04000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF22DD
+:10C0500019101520B9B32456BD9E000063010901D3
+:00000001FF
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 52eb36f7bb6..947f8c99beb 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -2749,8 +2749,8 @@ static const struct pid_entry tgid_base_stuff[] = {
 	REG("cgroup",  S_IRUGO, proc_cgroup_operations),
 #endif
 	INF("oom_score",  S_IRUGO, proc_oom_score),
-	ANDROID("oom_adj", S_IRUGO|S_IWUSR, oom_adj),
-	REG("oom_score_adj", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),
+	ANDROID("oom_adj", S_IRUSR, oom_adj),
+	REG("oom_score_adj", S_IRUSR, proc_oom_score_adj_operations),
 #ifdef CONFIG_AUDITSYSCALL
 	REG("loginuid",   S_IWUSR|S_IRUGO, proc_loginuid_operations),
 	REG("sessionid",  S_IRUGO, proc_sessionid_operations),
diff --git a/include/linux/i2c/st480.h b/include/linux/i2c/st480.h
new file mode 100755
index 00000000000..f2f17c5ce3c
--- /dev/null
+++ b/include/linux/i2c/st480.h
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2012 Senodia.
+ *
+ * Author: Tori Xu <xuezhi_xu@senodia.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*
+ * Definitions for senodia compass chip.
+ */
+#ifndef MAGNETIC_H
+#define MAGNETIC_H
+
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/miscdevice.h>
+#include <linux/gpio.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/freezer.h>
+#include <linux/ioctl.h>
+#include <linux/module.h>
+
+/*
+ * ABS(min~max)
+ */
+#define ABSMIN_MAG	-32768
+#define ABSMAX_MAG	32767
+
+/*
+ * device id
+ */
+#define ST480_DEVICE_ID 0x7C
+#define IC_CHECK 0
+
+/*
+ *
+ */
+#define ST480_I2C_ADDRESS 0x0c
+
+/*
+ * I2C name
+ */
+#define ST480_I2C_NAME "st480"
+
+/*
+ * IC Package size(choose your ic size)
+ */
+#define ST480_SIZE_3X3_QFN	0
+#define ST480_SIZE_2X2_BGA	0
+#define ST480_SIZE_1_6X1_6_LGA	0
+#define ST480_SIZE_1_6X1_6_BGA	1
+
+/*
+ * register shift
+ */
+#define ST480_REG_DRR_SHIFT 2
+
+/*
+ * BURST MODE(INT)
+ */
+#define ST480_BURST_MODE 0
+#define BURST_MODE_CMD 0x1F
+#define BURST_MODE_DATA_LOW 0x01
+
+/*
+ * SINGLE MODE
+ */
+#define ST480_SINGLE_MODE 1
+#define SINGLE_MEASUREMENT_MODE_CMD 0x3F
+
+/*
+ * register
+ */
+#define READ_MEASUREMENT_CMD 0x4F
+#define WRITE_REGISTER_CMD 0x60
+#define READ_REGISTER_CMD 0x50
+#define EXIT_REGISTER_CMD 0x80
+#define MEMORY_RECALL_CMD 0xD0
+#define MEMORY_STORE_CMD 0xE0
+#define RESET_CMD 0xF0
+
+#define CALIBRATION_REG (0x02 << ST480_REG_DRR_SHIFT)
+#define CALIBRATION_DATA_LOW 0x1C
+#define CALIBRATION_DATA_HIGH 0x00
+
+#define ONE_INIT_DATA_LOW 0x7C
+#define ONE_INIT_DATA_HIGH 0x00
+#define ONE_INIT_REG (0x00 << ST480_REG_DRR_SHIFT)
+
+#define TWO_INIT_DATA_LOW 0x00
+#define TWO_INIT_DATA_HIGH 0x00
+#define TWO_INIT_REG (0x02 << ST480_REG_DRR_SHIFT)
+
+#define TEMP_DATA_LOW 0x00
+#define TEMP_DATA_HIGH 0x00
+#define TEMP_REG (0x01 << ST480_REG_DRR_SHIFT)
+
+/*
+ * Miscellaneous set.
+ */
+#define MAX_FAILURE_COUNT 3
+#define ST480_DEFAULT_DELAY   40
+#define ST480_AUTO_TEST 0
+#define OLD_KERNEL_VERSION 0
+
+#if ST480_AUTO_TEST
+#include <linux/kthread.h>
+#endif
+
+/*
+ * Debug
+ */
+#define SENODIA_DEBUG_MSG       0
+#define SENODIA_DEBUG_FUNC      0
+
+#if SENODIA_DEBUG_MSG
+#define SENODIADBG(format, ...) printk(KERN_INFO "SENODIA " format "\n", ## __VA_ARGS__)
+#else
+#define SENODIADBG(format, ...)
+#endif
+
+#if SENODIA_DEBUG_FUNC
+#define SENODIAFUNC(func) printk(KERN_INFO "SENODIA " func " is called\n")
+#else
+#define SENODIAFUNC(func)
+#endif
+/*******************************************************************/
+
+#define ST480IO                   0xA1
+
+/* IOCTLs for hal */
+#define MSENSOR_IOCTL_ST480_SET_MFLAG   _IOW(ST480IO, 0x10, short)
+#define MSENSOR_IOCTL_ST480_GET_MFLAG   _IOR(ST480IO, 0x11, short)
+#define MSENSOR_IOCTL_ST480_SET_DELAY   _IOW(ST480IO, 0x12, short)
+#define MSENSOR_IOCTL_ST480_GET_DELAY   _IOR(ST480IO, 0x13, short)
+#define MSENSOR_IOCTL_ST480_SET_MVFLAG  _IOW(ST480IO, 0x14, short)
+#define MSENSOR_IOCTL_ST480_GET_MVFLAG  _IOR(ST480IO, 0x15, short)
+#define MSENSOR_IOCTL_ST480_SET_RMFLAG  _IOW(ST480IO, 0x16, short)
+#define MSENSOR_IOCTL_ST480_GET_RMFLAG  _IOR(ST480IO, 0x17, short)
+#define MSENSOR_IOCTL_ST480_SET_MRVFLAG _IOW(ST480IO, 0x18, short)
+#define MSENSOR_IOCTL_ST480_GET_MRVFLAG _IOR(ST480IO, 0x19, short)
+
+
+struct platform_data_st480 {
+	u32 axis_map_x;
+	u32 axis_map_y;
+	u32 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+};
+
+#endif
diff --git a/include/linux/input/lsm6dx0.h b/include/linux/input/lsm6dx0.h
new file mode 100755
index 00000000000..e8a19f422dc
--- /dev/null
+++ b/include/linux/input/lsm6dx0.h
@@ -0,0 +1,182 @@
+/******************** (C) COPYRIGHT 2013 STMicroelectronics ******************
+*
+* File Name		: lsm6dx0.h
+* Author		: AMS - Motion Mems Division - Application Team
+*			: Giuseppe Barba (giuseppe.barba@st.com)
+* Version		: V.1.1.0
+* Date			: 2014/Apr/18
+*
+******************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*****************************************************************************/
+
+#ifndef	__LSM6DX0_H__
+#define	__LSM6DX0_H__
+
+#define CONFIG_INPUT_LSM6DX0_S_MODEL
+
+#ifdef CONFIG_INPUT_LSM6DX0_S_MODEL
+/** LSM6DS0 model */
+#define LSM6DX0_ACC_GYR_DEV_NAME	"lsm6ds0"
+
+#define LSM6DX0_ACC_DEV_NAME		"accelerometer"
+#define LSM6DX0_GYR_DEV_NAME    	"gyroscope"
+#define LSM6DX0_MOD_DESCRIPTION	"lsm6ds0 driver"
+#else
+/** LSM6DL0 model */
+#define LSM6DX0_ACC_GYR_DEV_NAME	"lsm6dl0"
+#define LSM6DX0_ACC_DEV_NAME		"accelerometer"
+#define LSM6DX0_GYR_DEV_NAME    	"gyroscope"
+#define LSM6DX0_MOD_DESCRIPTION	"lsm6dl0 driver"
+#endif
+
+/**********************************************/
+/* 	Accelerometer section defines	 	*/
+/**********************************************/
+
+/* Accelerometer Sensor Full Scale */
+#define LSM6DX0_ACC_FS_MASK		(0x18)
+#define LSM6DX0_ACC_FS_2G 		(0x00)	/* Full scale 2g */
+#define LSM6DX0_ACC_FS_4G 		(0x08)	/* Full scale 4g */
+#define LSM6DX0_ACC_FS_8G 		(0x10)	/* Full scale 8g */
+
+/* Accelerometer Anti-Aliasing Filter */
+#define LSM6DX0_ACC_BW_400		(0X00)
+#define LSM6DX0_ACC_BW_200		(0X01)
+#define LSM6DX0_ACC_BW_100		(0X02)
+#define LSM6DX0_ACC_BW_50		(0X03)
+#define LSM6DX0_ACC_BW_MASK		(0X03)
+
+#define LSM6DX0_INT1_GPIO_DEF		(-EINVAL)
+#define LSM6DX0_INT2_GPIO_DEF		(-EINVAL)
+
+#define LSM6DX0_ACC_ODR_OFF		(0x00)
+#define LSM6DX0_ACC_ODR_MASK		(0xE0)
+#define LSM6DX0_ACC_ODR_14_9		(0x20)
+#define LSM6DX0_ACC_ODR_59_5		(0x40)
+#define LSM6DX0_ACC_ODR_119		(0x60)
+#define LSM6DX0_ACC_ODR_238		(0x80)
+#define LSM6DX0_ACC_ODR_476		(0xA0)
+#define LSM6DX0_ACC_ODR_952		(0xC0)
+
+#define LSM6DL0_ACC_ODR_20		(0x20)
+#define LSM6DL0_ACC_ODR_80		(0x40)
+#define LSM6DL0_ACC_ODR_160		(0x60)
+#define LSM6DL0_ACC_ODR_320		(0x80)
+#define LSM6DL0_ACC_ODR_640		(0xA0)
+#define LSM6DL0_ACC_ODR_1280		(0xC0)
+
+/**********************************************/
+/* 	Gyroscope section defines	 	*/
+/**********************************************/
+
+
+#define LSM6DX0_GYR_FS_MASK		(0x18)
+#define LSM6DX0_GYR_FS_245DPS		(0x00)
+#define LSM6DX0_GYR_FS_500DPS		(0x08)
+#define LSM6DX0_GYR_FS_2000DPS		(0x18)
+
+#define LSM6DX0_GYR_ODR_OFF		(0x00)
+#define LSM6DX0_GYR_ODR_MASK		(0xE0)
+#define LSM6DX0_GYR_ODR_MASK_SHIFT	(5)
+#define LSM6DX0_GYR_ODR_001		(1 << LSM6DX0_GYR_ODR_MASK_SHIFT)
+#define LSM6DX0_GYR_ODR_010		(2 << LSM6DX0_GYR_ODR_MASK_SHIFT)
+#define LSM6DX0_GYR_ODR_011		(3 << LSM6DX0_GYR_ODR_MASK_SHIFT)
+#define LSM6DX0_GYR_ODR_100		(4 << LSM6DX0_GYR_ODR_MASK_SHIFT)
+#define LSM6DX0_GYR_ODR_101		(5 << LSM6DX0_GYR_ODR_MASK_SHIFT)
+#define LSM6DX0_GYR_ODR_110		(6 << LSM6DX0_GYR_ODR_MASK_SHIFT)
+
+#ifdef CONFIG_INPUT_LSM6DX0_LP
+#define LSM6DX0_GYR_MAX_LP_ODR_US	(8)
+#endif
+
+#define LSM6DX0_GYR_BW_00		(0x00)
+#define LSM6DX0_GYR_BW_01		(0x01)
+#define LSM6DX0_GYR_BW_10		(0x02)
+#define LSM6DX0_GYR_BW_11		(0x03)
+
+/** ODR periods in msec */
+#ifdef CONFIG_INPUT_LSM6DX0_S_MODEL
+/** LSM6DS0 model */
+#define LSM6DS0_ODR_14_9_US		(67115)
+#define LSM6DS0_ODR_59_5_US		(16807)
+#define LSM6DS0_ODR_119_US		 (8404)
+#define LSM6DS0_ODR_238_US		 (4202)
+#define LSM6DS0_ODR_476_US		 (2101)
+#define LSM6DS0_ODR_952_US		 (1051)
+
+#define LSM6DX0_ODR_US_001		(LSM6DS0_ODR_14_9_US)
+#define LSM6DX0_ODR_US_010		(LSM6DS0_ODR_59_5_US)
+#define LSM6DX0_ODR_US_011		(LSM6DS0_ODR_119_US)
+#define LSM6DX0_ODR_US_100		(LSM6DS0_ODR_238_US)
+#define LSM6DX0_ODR_US_101		(LSM6DS0_ODR_476_US)
+#define LSM6DX0_ODR_US_110		(LSM6DS0_ODR_952_US)
+#else
+/** LSM6DL0 model */
+#define LSM6DL0_ODR_20_US		(50000)
+#define LSM6DL0_ODR_80_US		(12500)
+#define LSM6DL0_ODR_160_US		 (6250)
+#define LSM6DL0_ODR_320_US		 (3125)
+#define LSM6DL0_ODR_640_US		 (1563)
+#define LSM6DL0_ODR_1280_US		  (782)
+
+#define LSM6DX0_ODR_US_001		(LSM6DL0_ODR_20_US)
+#define LSM6DX0_ODR_US_010		(LSM6DL0_ODR_80_US)
+#define LSM6DX0_ODR_US_011		(LSM6DL0_ODR_160_US)
+#define LSM6DX0_ODR_US_100		(LSM6DL0_ODR_320_US)
+#define LSM6DX0_ODR_US_101		(LSM6DL0_ODR_640_US)
+#define LSM6DX0_ODR_US_110		(LSM6DL0_ODR_1280_US)
+#endif
+
+#define LSM6DX0_GYR_MIN_POLL_PERIOD_US	(LSM6DX0_ODR_US_110)
+#define LSM6DX0_ACC_MIN_POLL_PERIOD_US	(LSM6DX0_ODR_US_110)
+#define LSM6DX0_GYR_POLL_INTERVAL_DEF	(LSM6DX0_ODR_US_001)
+#define LSM6DX0_ACC_POLL_INTERVAL_DEF	(LSM6DX0_ODR_US_001)
+
+struct lsm6dx0_acc_platform_data {
+	uint32_t poll_interval;
+	uint32_t min_interval;
+	uint8_t fs_range;
+	uint8_t aa_filter_bandwidth;
+
+	int32_t (*init)(void);
+	void (*exit)(void);
+	int32_t (*power_on)(void);
+	int32_t (*power_off)(void);
+};
+
+struct lsm6dx0_gyr_platform_data {
+	uint32_t poll_interval;
+	uint32_t min_interval;
+	uint8_t fs_range;
+
+	int32_t (*init)(void);
+	void (*exit)(void);
+	int32_t (*power_on)(void);
+	int32_t (*power_off)(void);
+};
+
+struct lsm6dx0_main_platform_data {
+	int32_t gpio_int1;
+	int32_t gpio_int2;
+	short rot_matrix[3][3];
+	struct lsm6dx0_acc_platform_data *pdata_acc;
+	struct lsm6dx0_gyr_platform_data *pdata_gyr;
+#ifdef CONFIG_OF
+	struct device_node	*of_node;
+#endif
+};
+
+#endif	/* __LSM6DX0_H__ */
diff --git a/include/linux/leds.h b/include/linux/leds.h
index 0287ab29668..37476fc3158 100644
--- a/include/linux/leds.h
+++ b/include/linux/leds.h
@@ -26,6 +26,7 @@ struct device;
 enum led_brightness {
 	LED_OFF		= 0,
 	LED_HALF	= 127,
+	LED_PRE 	= 200,
 	LED_FULL	= 255,
 };
 
diff --git a/include/linux/platform_data/lsm6ds3.h b/include/linux/platform_data/lsm6ds3.h
new file mode 100755
index 00000000000..e4d89f79f44
--- /dev/null
+++ b/include/linux/platform_data/lsm6ds3.h
@@ -0,0 +1,22 @@
+/*
+ * STMicroelectronics lsm6ds3 driver
+ *
+ * Copyright 2014 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * v 1.1.0
+ * Licensed under the GPL-2.
+ */
+
+#ifndef __LSM6DS3_H__
+#define __LSM6DS3_H__
+
+#define LSM6DS3_ACC_GYR_DEV_NAME		"lsm6ds3"
+#define LSM6DS3_ACC_INPUT_DEV_NAME	"lsm6ds3_acc"
+#define LSM6DS3_GYR_INPUT_DEV_NAME	"lsm6ds3_gyr"
+
+struct lsm6ds3_platform_data {
+	u8 drdy_int_pin;
+};
+
+#endif /* __LSM6DS3_H__ */
diff --git a/include/linux/platform_data/melfas_mip4.h b/include/linux/platform_data/melfas_mip4.h
new file mode 100755
index 00000000000..55afc712d77
--- /dev/null
+++ b/include/linux/platform_data/melfas_mip4.h
@@ -0,0 +1,53 @@
+/*
+ * MELFAS MIP4 Touchscreen
+ *
+ * Copyright (C) 2015 MELFAS Inc.
+ *
+ *
+ * melfas_mip4.h : Platform data
+ *
+ *
+ * Default path : linux/platform_data/melfas_mip.h
+ *
+ */
+
+//#ifndef _LINUX_MIP_TOUCH_H
+//#define _LINUX_MIP_TOUCH_H
+
+#ifdef CONFIG_OF
+#define MIP_USE_DEVICETREE		1
+#else
+#define MIP_USE_DEVICETREE		0
+#endif
+
+#define MIP_USE_CALLBACK	0	// 0 or 1 : Callback for inform charger, display, power, etc...
+
+#define MIP_DEVICE_NAME	"mip4_ts"
+
+/**
+* Platform Data
+*/
+struct melfas_platform_data {
+	unsigned int max_x;
+	unsigned int max_y;
+
+	int gpio_intr;			//Required (interrupt signal)
+	
+	int gpio_vdd_en;		//Optional (power control)
+	
+	int vdd_supply;
+	const char* fw_name;
+	struct pinctrl *melfas_pinctrl;
+	struct pinctrl_state *pinctrl_default;
+
+	//int gpio_ce;			//Optional (chip enable)
+	//int gpio_sda;			//Optional
+	//int gpio_scl;			//Optional
+
+#if MIP_USE_CALLBACK
+	void (*register_callback) (void *);
+#endif
+};
+
+//#endif
+
diff --git a/include/media/msm_cam_sensor.h b/include/media/msm_cam_sensor.h
index 5d438cf548b..9e60d6cd106 100644
--- a/include/media/msm_cam_sensor.h
+++ b/include/media/msm_cam_sensor.h
@@ -412,6 +412,9 @@ enum msm_actuator_cfg_type_t {
 	CFG_ACTUATOR_POWERDOWN,
 	CFG_ACTUATOR_POWERUP,
 	CFG_ACTUATOR_INIT,
+/// ALTEK_actuator >>>
+	CFG_ACTUATOR_SET_BOUNDARY,
+/// ALTEK_actuator >>>
 };
 
 enum msm_ois_cfg_type_t {
@@ -531,7 +534,12 @@ struct msm_actuator_set_position_t {
 	uint16_t pos[MAX_NUMBER_OF_STEPS];
 	uint16_t delay[MAX_NUMBER_OF_STEPS];
 };
-
+/// ALTEK_actuator >>>
+struct msm_actuator_boundary_t {
+	uint16_t hall_min;
+	uint16_t hall_max;
+};
+/// ALTEK_actuator <<<
 struct msm_actuator_cfg_data {
 	int cfgtype;
 	uint8_t is_af_supported;
@@ -541,6 +549,9 @@ struct msm_actuator_cfg_data {
 		struct msm_actuator_get_info_t get_info;
 		struct msm_actuator_set_position_t setpos;
 		enum af_camera_name cam_name;
+/// ALTEK_actuator >>>
+		struct msm_actuator_boundary_t set_boundary;
+/// ALTEK_actuator >>>
 	} cfg;
 };
 
@@ -550,6 +561,7 @@ enum msm_camera_led_config_t {
 	MSM_CAMERA_LED_HIGH,
 	MSM_CAMERA_LED_INIT,
 	MSM_CAMERA_LED_RELEASE,
+	MSM_CAMERA_LED_PRE,
 };
 
 struct msm_camera_led_cfg_t {
@@ -692,6 +704,9 @@ struct msm_actuator_cfg_data32 {
 		struct msm_actuator_get_info_t get_info;
 		struct msm_actuator_set_position_t setpos;
 		enum af_camera_name cam_name;
+/// ALTEK_actuator >>>
+		struct msm_actuator_boundary_t set_boundary;
+/// ALTEK_actuator <<<
 	} cfg;
 };
 
diff --git a/include/media/msm_camsensor_sdk.h b/include/media/msm_camsensor_sdk.h
index cf9588905f4..a55e1648654 100644
--- a/include/media/msm_camsensor_sdk.h
+++ b/include/media/msm_camsensor_sdk.h
@@ -164,6 +164,7 @@ enum actuator_type {
 	ACTUATOR_VCM,
 	ACTUATOR_PIEZO,
 	ACTUATOR_HVCM,
+       ACTUATOR_CLOSE_LOOP,
 };
 
 enum msm_flash_driver_type {
diff --git a/include/soc/qcom/camera2.h b/include/soc/qcom/camera2.h
index eec97daa0ec..3da4ad176ac 100644
--- a/include/soc/qcom/camera2.h
+++ b/include/soc/qcom/camera2.h
@@ -147,6 +147,13 @@ struct msm_camera_sensor_board_info {
 	const char *eeprom_name;
 	const char *actuator_name;
 	const char *ois_name;
+	//Jelly add for s5k5e2 compatibale
+	#ifdef CONFIG_TEST_ONLY
+    int32_t eeprom_mid_addr[30];
+    uint16_t eeprom_mid_addr_cnt;
+    uint16_t eeprom_mid;
+	#endif
+	//end
 	const char *special_support_sensors[MAX_SPECIAL_SUPPORT_SIZE];
 	int32_t special_support_size;
 	struct msm_camera_slave_info *slave_info;
diff --git a/sound/soc/codecs/msm8x16-wcd.c b/sound/soc/codecs/msm8x16-wcd.c
index 486bad7500a..030097f5598 100644
--- a/sound/soc/codecs/msm8x16-wcd.c
+++ b/sound/soc/codecs/msm8x16-wcd.c
@@ -128,6 +128,15 @@ enum {
 	RX_MIX1_INP_SEL_RX3,
 };
 
+enum{
+	MODE_1 = 0,
+	MODE_2,
+	MODE_3,
+	MODE_4,
+};
+
+static int test_spk_pa_mode = 0;
+
 static const DECLARE_TLV_DB_SCALE(digital_gain, 0, 1, 0);
 static const DECLARE_TLV_DB_SCALE(analog_gain, 0, 25, 1);
 static struct snd_soc_dai_driver msm8x16_wcd_i2s_dai[];
@@ -2041,6 +2050,58 @@ static int msm8x16_wcd_pa_gain_put(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
+static int test_spk_pa_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	if (test_spk_pa_mode == MODE_1) {
+		ucontrol->value.integer.value[0] = 0;
+	} else if (test_spk_pa_mode == MODE_2) {
+		ucontrol->value.integer.value[0] = 1;
+	} else if (test_spk_pa_mode == MODE_3) {
+		ucontrol->value.integer.value[0] = 2;
+	} else if (test_spk_pa_mode == MODE_4) {
+		ucontrol->value.integer.value[0] = 3;
+	} else  {
+		dev_err(codec->dev, "%s: ERROR: Unsupported Boost option= %d\n",
+			__func__, test_spk_pa_mode);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int test_spk_pa_set(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	dev_dbg(codec->dev, "%s: ucontrol->value.integer.value[0] = %ld\n",
+		__func__, ucontrol->value.integer.value[0]);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case 0:
+		test_spk_pa_mode = MODE_1;
+		break;
+	case 1:
+		test_spk_pa_mode = MODE_2;
+		break;
+	case 2:
+		test_spk_pa_mode = MODE_3;
+		break;
+	case 3:
+		test_spk_pa_mode = MODE_4;
+		break;
+	default:
+		pr_err("%s: test_spk_pa_mode: %d\n", __func__,
+					test_spk_pa_mode);
+		return -EINVAL;
+	}
+	dev_dbg(codec->dev, "%s: test_spk_pa_mode = %d\n",
+		__func__, test_spk_pa_mode);
+	return 0;
+}
 
 static int msm8x16_wcd_boost_option_get(struct snd_kcontrol *kcontrol,
 				struct snd_ctl_elem_value *ucontrol)
@@ -2412,6 +2473,13 @@ static const struct soc_enum msm8x16_wcd_spk_boost_ctl_enum[] = {
 		SOC_ENUM_SINGLE_EXT(2, msm8x16_wcd_spk_boost_ctrl_text),
 };
 
+static const char * const test_spk_pa_ctrl_text[] = {
+		"MODE_1", "MODE_2", "MODE_3",
+		"MODE_4"};
+static const struct soc_enum test_spk_pa_ctl_enum[] = {
+		SOC_ENUM_SINGLE_EXT(4, test_spk_pa_ctrl_text),
+};
+
 static const char * const msm8x16_wcd_ext_spk_boost_ctrl_text[] = {
 		"DISABLE", "ENABLE"};
 static const struct soc_enum msm8x16_wcd_ext_spk_boost_ctl_enum[] = {
@@ -2440,6 +2508,9 @@ static const struct soc_enum cf_rxmix3_enum =
 
 static const struct snd_kcontrol_new msm8x16_wcd_snd_controls[] = {
 
+	SOC_ENUM_EXT("Mobee Spk PA Mode", test_spk_pa_ctl_enum[0],
+		test_spk_pa_get, test_spk_pa_set),
+
 	SOC_ENUM_EXT("Boost Option", msm8x16_wcd_boost_option_ctl_enum[0],
 		msm8x16_wcd_boost_option_get, msm8x16_wcd_boost_option_set),
 
@@ -4561,14 +4632,21 @@ static int msm8x16_wcd_codec_enable_spk_ext_pa(struct snd_soc_dapm_widget *w,
 {
 	struct snd_soc_codec *codec = w->codec;
 	struct msm8x16_wcd_priv *msm8x16_wcd = snd_soc_codec_get_drvdata(codec);
-
+	int i=0;
 	dev_dbg(codec->dev, "%s: %s event = %d\n", __func__, w->name, event);
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
 		dev_dbg(w->codec->dev,
 			"%s: enable external speaker PA\n", __func__);
 		if (msm8x16_wcd->codec_spk_ext_pa_cb)
+			for(i = 0;i<test_spk_pa_mode;i++){
+				msm8x16_wcd->codec_spk_ext_pa_cb(codec, 1);
+				udelay(2);
+				msm8x16_wcd->codec_spk_ext_pa_cb(codec, 0);
+				udelay(2);
+			}
 			msm8x16_wcd->codec_spk_ext_pa_cb(codec, 1);
+			mdelay(20);
 		break;
 	case SND_SOC_DAPM_PRE_PMD:
 		dev_dbg(w->codec->dev,
diff --git a/sound/soc/codecs/wcd-mbhc-v2.c b/sound/soc/codecs/wcd-mbhc-v2.c
index 13d62d10be4..4277f58f62c 100644
--- a/sound/soc/codecs/wcd-mbhc-v2.c
+++ b/sound/soc/codecs/wcd-mbhc-v2.c
@@ -30,6 +30,10 @@
 #include <sound/jack.h>
 #include "wcd-mbhc-v2.h"
 #include "wcdcal-hwdep.h"
+/*
+ *2016.03.23 add for FM test item of FFBM.
+ */
+#include <linux/switch.h>
 
 #define WCD_MBHC_JACK_MASK (SND_JACK_HEADSET | SND_JACK_OC_HPHL | \
 			   SND_JACK_OC_HPHR | SND_JACK_LINEOUT | \
@@ -51,6 +55,19 @@
 #define MAX_IMPED 60000
 
 #define WCD_MBHC_BTN_PRESS_COMPL_TIMEOUT_MS  50
+/*
+ *2016.03.23 add for FM test item of FFBM.
+ */
+struct headset_switch_t {
+	struct switch_dev sdev;
+};
+
+static struct headset_switch_t headset_switch = {
+	.sdev = {
+		.name = "h2w",
+		.state = 0,
+	},
+};
 
 static int det_extn_cable_en;
 module_param(det_extn_cable_en, int,
@@ -68,6 +85,16 @@ static void wcd_mbhc_jack_report(struct wcd_mbhc *mbhc,
 				struct snd_soc_jack *jack, int status, int mask)
 {
 	snd_soc_jack_report(jack, status, mask);
+	/*
+	 *2016.03.23 add for FM test item of FFBM.
+	 */
+	pr_debug("%s: switch set status as %x\n",__func__, status);
+	if(status & SND_JACK_HEADPHONE || status & SND_JACK_LINEOUT) {
+		switch_set_state(&headset_switch.sdev, !!status);
+	}
+	else if (status == 0) {
+		switch_set_state(&headset_switch.sdev, 0);
+	}
 }
 
 static void __hphocp_off_report(struct wcd_mbhc *mbhc, u32 jack_status,
@@ -566,7 +593,7 @@ static void wcd_mbhc_report_plug(struct wcd_mbhc *mbhc, int insertion,
 			 jack_type, mbhc->hph_status);
 		wcd_mbhc_jack_report(mbhc, &mbhc->headset_jack,
 				mbhc->hph_status, WCD_MBHC_JACK_MASK);
-		wcd_mbhc_set_and_turnoff_hph_padac(mbhc);
+		//wcd_mbhc_set_and_turnoff_hph_padac(mbhc);
 		hphrocp_off_report(mbhc, SND_JACK_OC_HPHR);
 		hphlocp_off_report(mbhc, SND_JACK_OC_HPHL);
 		mbhc->current_plug = MBHC_PLUG_TYPE_NONE;
@@ -581,7 +608,7 @@ static void wcd_mbhc_report_plug(struct wcd_mbhc *mbhc, int insertion,
 		    jack_type == SND_JACK_LINEOUT) &&
 		    (mbhc->hph_status && mbhc->hph_status != jack_type)) {
 
-			if (mbhc->micbias_enable) {
+			if (mbhc->micbias_enable && mbhc->current_plug == MBHC_PLUG_TYPE_HEADSET) {
 				if (mbhc->mbhc_cb->mbhc_micbias_control)
 					mbhc->mbhc_cb->mbhc_micbias_control(
 							mbhc->codec,
@@ -2288,6 +2315,15 @@ int wcd_mbhc_init(struct wcd_mbhc *mbhc, struct snd_soc_codec *codec,
 		goto err_hphr_ocp_irq;
 	}
 
+	/*
+	 *2016.03.23 add for FM test item of FFBM.
+	 */
+	ret = switch_dev_register(&headset_switch.sdev);
+	if(ret) {
+		pr_err("%s: Failed to register switch\n", __func__);
+		goto err_hphr_ocp_irq;
+	}
+
 	pr_debug("%s: leave ret %d\n", __func__, ret);
 	return ret;
 
@@ -2319,6 +2355,8 @@ void wcd_mbhc_deinit(struct wcd_mbhc *mbhc)
 {
 	struct snd_soc_codec *codec = mbhc->codec;
 
+    switch_dev_unregister(&headset_switch.sdev);
+	
 	mbhc->mbhc_cb->free_irq(codec, mbhc->intr_ids->mbhc_sw_intr, mbhc);
 	mbhc->mbhc_cb->free_irq(codec, mbhc->intr_ids->mbhc_btn_press_intr,
 				mbhc);
diff --git a/sound/soc/msm/msm8x16.c b/sound/soc/msm/msm8x16.c
index 52f34e9c978..eb5c149ea3e 100644
--- a/sound/soc/msm/msm8x16.c
+++ b/sound/soc/msm/msm8x16.c
@@ -1600,7 +1600,7 @@ static void *def_msm8x16_wcd_mbhc_cal(void)
 	}
 
 #define S(X, Y) ((WCD_MBHC_CAL_PLUG_TYPE_PTR(msm8x16_wcd_cal)->X) = (Y))
-	S(v_hs_max, 1500);
+	S(v_hs_max, 1600);
 #undef S
 #define S(X, Y) ((WCD_MBHC_CAL_BTN_DET_PTR(msm8x16_wcd_cal)->X) = (Y))
 	S(num_btn, WCD_MBHC_DEF_BUTTONS);
@@ -1623,16 +1623,30 @@ static void *def_msm8x16_wcd_mbhc_cal(void)
 	 * 210-290 == Button 2
 	 * 360-680 == Button 3
 	 */
-	btn_low[0] = 75;
-	btn_high[0] = 75;
-	btn_low[1] = 150;
-	btn_high[1] = 150;
-	btn_low[2] = 237;
-	btn_high[2] = 237;
-	btn_low[3] = 450;
-	btn_high[3] = 450;
-	btn_low[4] = 500;
-	btn_high[4] = 500;
+#ifdef CONFIG_TESTPLUS_ONLY    
+	btn_low[0] = 100;
+	btn_high[0] = 100;
+	btn_low[1] = 101;
+	btn_high[1] = 101;
+	btn_low[2] = 251;
+	btn_high[2] = 251;
+	btn_low[3] = 500;
+	btn_high[3] = 500;
+	btn_low[4] = 501;
+	btn_high[4] = 501;
+#else
+	btn_low[0] = 100;
+	btn_high[0] = 100;
+	btn_low[1] = 101;
+	btn_high[1] = 101;
+	btn_low[2] = 240;
+	btn_high[2] = 240;
+	btn_low[3] = 500;
+	btn_high[3] = 500;
+	btn_low[4] = 501;
+	btn_high[4] = 501;
+#endif
+	
 
 	return msm8x16_wcd_cal;
 }
diff --git a/sound/soc/msm/qdsp6v2/msm-compr-q6-v2.c b/sound/soc/msm/qdsp6v2/msm-compr-q6-v2.c
new file mode 100644
index 00000000000..931f473bc84
--- /dev/null
+++ b/sound/soc/msm/qdsp6v2/msm-compr-q6-v2.c
@@ -0,0 +1,1704 @@
+/* Copyright (c) 2012-2014, 2016, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/time.h>
+#include <linux/wait.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+#include <sound/q6asm-v2.h>
+#include <sound/pcm_params.h>
+#include <asm/dma.h>
+#include <linux/dma-mapping.h>
+#include <linux/msm_audio_ion.h>
+
+#include <sound/timer.h>
+
+#include "msm-compr-q6-v2.h"
+#include "msm-pcm-routing-v2.h"
+#include "audio_ocmem.h"
+#include <sound/tlv.h>
+
+#define COMPRE_CAPTURE_NUM_PERIODS	16
+/* Allocate the worst case frame size for compressed audio */
+#define COMPRE_CAPTURE_HEADER_SIZE	(sizeof(struct snd_compr_audio_info))
+/* Changing period size to 4032. 4032 will make sure COMPRE_CAPTURE_PERIOD_SIZE
+ * is 4096 with meta data size of 64 and MAX_NUM_FRAMES_PER_BUFFER 1
+ */
+#define COMPRE_CAPTURE_MAX_FRAME_SIZE	(4032)
+#define COMPRE_CAPTURE_PERIOD_SIZE	((COMPRE_CAPTURE_MAX_FRAME_SIZE + \
+					  COMPRE_CAPTURE_HEADER_SIZE) * \
+					  MAX_NUM_FRAMES_PER_BUFFER)
+#define COMPRE_OUTPUT_METADATA_SIZE	(sizeof(struct output_meta_data_st))
+#define COMPRESSED_LR_VOL_MAX_STEPS	0x20002000
+
+#define MAX_AC3_PARAM_SIZE		(18*2*sizeof(int))
+#define AMR_WB_BAND_MODE 8
+#define AMR_WB_DTX_MODE 0
+
+
+const DECLARE_TLV_DB_LINEAR(compr_rx_vol_gain, 0,
+			    COMPRESSED_LR_VOL_MAX_STEPS);
+struct snd_msm {
+	atomic_t audio_ocmem_req;
+};
+static struct snd_msm compressed_audio;
+
+static struct audio_locks the_locks;
+
+static struct snd_pcm_hardware msm_compr_hardware_capture = {
+	.info =		 (SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats =	      SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_8000_48000,
+	.rate_min =	     8000,
+	.rate_max =	     48000,
+	.channels_min =	 1,
+	.channels_max =	 8,
+	.buffer_bytes_max =
+		COMPRE_CAPTURE_PERIOD_SIZE * COMPRE_CAPTURE_NUM_PERIODS ,
+	.period_bytes_min =	COMPRE_CAPTURE_PERIOD_SIZE,
+	.period_bytes_max = COMPRE_CAPTURE_PERIOD_SIZE,
+	.periods_min =	  COMPRE_CAPTURE_NUM_PERIODS,
+	.periods_max =	  COMPRE_CAPTURE_NUM_PERIODS,
+	.fifo_size =	    0,
+};
+
+static struct snd_pcm_hardware msm_compr_hardware_playback = {
+	.info =		 (SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats =	      SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+	.rates =		SNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_KNOT,
+	.rate_min =	     8000,
+	.rate_max =	     48000,
+	.channels_min =	 1,
+	.channels_max =	 8,
+	.buffer_bytes_max =     1024 * 1024,
+	.period_bytes_min =	128 * 1024,
+	.period_bytes_max =     256 * 1024,
+	.periods_min =	  4,
+	.periods_max =	  8,
+	.fifo_size =	    0,
+};
+
+/* Conventional and unconventional sample rate supported */
+static unsigned int supported_sample_rates[] = {
+	8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000
+};
+
+/* Add supported codecs for compress capture path */
+static uint32_t supported_compr_capture_codecs[] = {
+	SND_AUDIOCODEC_AMRWB
+};
+
+static struct snd_pcm_hw_constraint_list constraints_sample_rates = {
+	.count = ARRAY_SIZE(supported_sample_rates),
+	.list = supported_sample_rates,
+	.mask = 0,
+};
+
+static bool msm_compr_capture_codecs(uint32_t req_codec)
+{
+	int i;
+	pr_debug("%s req_codec:%d\n", __func__, req_codec);
+	if (req_codec == 0)
+		return false;
+	for (i = 0; i < ARRAY_SIZE(supported_compr_capture_codecs); i++) {
+		if (req_codec == supported_compr_capture_codecs[i])
+			return true;
+	}
+	return false;
+}
+
+static void compr_event_handler(uint32_t opcode,
+		uint32_t token, uint32_t *payload, void *priv)
+{
+	struct compr_audio *compr = priv;
+	struct msm_audio *prtd = &compr->prtd;
+	struct snd_pcm_substream *substream = prtd->substream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct audio_aio_write_param param;
+	struct audio_aio_read_param read_param;
+	struct audio_buffer *buf = NULL;
+	phys_addr_t temp;
+	struct output_meta_data_st output_meta_data;
+	uint32_t *ptrmem = (uint32_t *)payload;
+	int i = 0;
+	int time_stamp_flag = 0;
+	int buffer_length = 0;
+	int stop_playback = 0;
+
+	pr_debug("%s opcode =%08x\n", __func__, opcode);
+	switch (opcode) {
+	case ASM_DATA_EVENT_WRITE_DONE_V2: {
+		uint32_t *ptrmem = (uint32_t *)&param;
+		pr_debug("ASM_DATA_EVENT_WRITE_DONE\n");
+		pr_debug("Buffer Consumed = 0x%08x\n", *ptrmem);
+		prtd->pcm_irq_pos += prtd->pcm_count;
+		if (atomic_read(&prtd->start))
+			snd_pcm_period_elapsed(substream);
+		else
+			if (substream->timer_running)
+				snd_timer_interrupt(substream->timer, 1);
+		atomic_inc(&prtd->out_count);
+		wake_up(&the_locks.write_wait);
+		if (!atomic_read(&prtd->start)) {
+			atomic_set(&prtd->pending_buffer, 1);
+			break;
+		} else
+			atomic_set(&prtd->pending_buffer, 0);
+
+		/*
+		 * check for underrun
+		 */
+		snd_pcm_stream_lock_irq(substream);
+		if (runtime->status->hw_ptr >= runtime->control->appl_ptr) {
+			runtime->render_flag |= SNDRV_RENDER_STOPPED;
+			stop_playback = 1;
+		}
+		snd_pcm_stream_unlock_irq(substream);
+
+		if (stop_playback) {
+			pr_err("underrun! render stopped\n");
+			break;
+		}
+
+		buf = prtd->audio_client->port[IN].buf;
+		pr_debug("%s:writing %d bytes of buffer[%d] to dsp 2\n",
+				__func__, prtd->pcm_count, prtd->out_head);
+		temp = buf[0].phys + (prtd->out_head * prtd->pcm_count);
+		pr_debug("%s:writing buffer[%d] from 0x%pK\n",
+			__func__, prtd->out_head, &temp);
+
+		if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
+			time_stamp_flag = SET_TIMESTAMP;
+		else
+			time_stamp_flag = NO_TIMESTAMP;
+		memcpy(&output_meta_data, (char *)(buf->data +
+			prtd->out_head * prtd->pcm_count),
+			COMPRE_OUTPUT_METADATA_SIZE);
+
+		buffer_length = output_meta_data.frame_size;
+		pr_debug("meta_data_length: %d, frame_length: %d\n",
+			 output_meta_data.meta_data_length,
+			 output_meta_data.frame_size);
+		pr_debug("timestamp_msw: %d, timestamp_lsw: %d\n",
+			 output_meta_data.timestamp_msw,
+			 output_meta_data.timestamp_lsw);
+		if (buffer_length == 0) {
+			pr_debug("Recieved a zero length buffer-break out");
+			break;
+		}
+		param.paddr = temp + output_meta_data.meta_data_length;
+		param.len = buffer_length;
+		param.msw_ts = output_meta_data.timestamp_msw;
+		param.lsw_ts = output_meta_data.timestamp_lsw;
+		param.flags = time_stamp_flag;
+		param.uid = prtd->session_id;
+		for (i = 0; i < sizeof(struct audio_aio_write_param)/4;
+					i++, ++ptrmem)
+			pr_debug("cmd[%d]=0x%08x\n", i, *ptrmem);
+		if (q6asm_async_write(prtd->audio_client,
+					&param) < 0)
+			pr_err("%s:q6asm_async_write failed\n",
+				__func__);
+		else
+			prtd->out_head =
+				(prtd->out_head + 1) & (runtime->periods - 1);
+		break;
+	}
+	case ASM_DATA_EVENT_RENDERED_EOS:
+		pr_debug("ASM_DATA_CMDRSP_EOS\n");
+		if (atomic_read(&prtd->eos)) {
+			pr_debug("ASM_DATA_CMDRSP_EOS wake up\n");
+			prtd->cmd_ack = 1;
+			wake_up(&the_locks.eos_wait);
+			atomic_set(&prtd->eos, 0);
+		}
+		break;
+	case ASM_DATA_EVENT_READ_DONE_V2: {
+		pr_debug("ASM_DATA_EVENT_READ_DONE\n");
+		pr_debug("buf = %pK, data = 0x%X, *data = %pK,\n"
+			 "prtd->pcm_irq_pos = %d\n",
+				prtd->audio_client->port[OUT].buf,
+			 *(uint32_t *)prtd->audio_client->port[OUT].buf->data,
+				prtd->audio_client->port[OUT].buf->data,
+				prtd->pcm_irq_pos);
+
+		memcpy(prtd->audio_client->port[OUT].buf->data +
+			   prtd->pcm_irq_pos, (ptrmem + READDONE_IDX_SIZE),
+			   COMPRE_CAPTURE_HEADER_SIZE);
+		pr_debug("buf = %pK, updated data = 0x%X, *data = %pK\n",
+				prtd->audio_client->port[OUT].buf,
+			*(uint32_t *)(prtd->audio_client->port[OUT].buf->data +
+				prtd->pcm_irq_pos),
+				prtd->audio_client->port[OUT].buf->data);
+		if (!atomic_read(&prtd->start))
+			break;
+		pr_debug("frame size=%d, buffer = 0x%X\n",
+				ptrmem[READDONE_IDX_SIZE],
+				ptrmem[READDONE_IDX_BUFADD_LSW]);
+		if (ptrmem[READDONE_IDX_SIZE] > COMPRE_CAPTURE_MAX_FRAME_SIZE) {
+			pr_err("Frame length exceeded the max length");
+			break;
+		}
+		buf = prtd->audio_client->port[OUT].buf;
+
+		pr_debug("pcm_irq_pos=%d, buf[0].phys = 0x%pK\n",
+				prtd->pcm_irq_pos, &buf[0].phys);
+		read_param.len = prtd->pcm_count - COMPRE_CAPTURE_HEADER_SIZE;
+		read_param.paddr = buf[0].phys +
+			prtd->pcm_irq_pos + COMPRE_CAPTURE_HEADER_SIZE;
+		prtd->pcm_irq_pos += prtd->pcm_count;
+
+		if (atomic_read(&prtd->start))
+			snd_pcm_period_elapsed(substream);
+
+		q6asm_async_read(prtd->audio_client, &read_param);
+		break;
+	}
+	case APR_BASIC_RSP_RESULT: {
+		switch (payload[0]) {
+		case ASM_SESSION_CMD_RUN_V2: {
+			if (substream->stream
+				!= SNDRV_PCM_STREAM_PLAYBACK) {
+				atomic_set(&prtd->start, 1);
+				break;
+			}
+			if (!atomic_read(&prtd->pending_buffer))
+				break;
+			pr_debug("%s: writing %d bytes of buffer[%d] to dsp\n",
+				__func__, prtd->pcm_count, prtd->out_head);
+			buf = prtd->audio_client->port[IN].buf;
+			pr_debug("%s: writing buffer[%d] from 0x%pK head %d count %d\n",
+				__func__, prtd->out_head, &buf[0].phys,
+				prtd->pcm_count, prtd->out_head);
+			if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
+				time_stamp_flag = SET_TIMESTAMP;
+			else
+				time_stamp_flag = NO_TIMESTAMP;
+			memcpy(&output_meta_data, (char *)(buf->data +
+				prtd->out_head * prtd->pcm_count),
+				COMPRE_OUTPUT_METADATA_SIZE);
+			buffer_length = output_meta_data.frame_size;
+			pr_debug("meta_data_length: %d, frame_length: %d\n",
+				 output_meta_data.meta_data_length,
+				 output_meta_data.frame_size);
+			pr_debug("timestamp_msw: %d, timestamp_lsw: %d\n",
+				 output_meta_data.timestamp_msw,
+				 output_meta_data.timestamp_lsw);
+			param.paddr = buf[prtd->out_head].phys
+					+ output_meta_data.meta_data_length;
+			param.len = buffer_length;
+			param.msw_ts = output_meta_data.timestamp_msw;
+			param.lsw_ts = output_meta_data.timestamp_lsw;
+			param.flags = time_stamp_flag;
+			param.uid = prtd->session_id;
+			param.metadata_len = COMPRE_OUTPUT_METADATA_SIZE;
+			if (q6asm_async_write(prtd->audio_client,
+						&param) < 0)
+				pr_err("%s:q6asm_async_write failed\n",
+					__func__);
+			else
+				prtd->out_head =
+					(prtd->out_head + 1)
+					& (runtime->periods - 1);
+			atomic_set(&prtd->pending_buffer, 0);
+		}
+			break;
+		case ASM_STREAM_CMD_FLUSH:
+			pr_debug("ASM_STREAM_CMD_FLUSH\n");
+			prtd->cmd_ack = 1;
+			wake_up(&the_locks.flush_wait);
+			break;
+		default:
+			break;
+		}
+		break;
+	}
+	default:
+		pr_debug("Not Supported Event opcode[0x%x]\n", opcode);
+		break;
+	}
+}
+
+static int msm_compr_send_ddp_cfg(struct audio_client *ac,
+					struct snd_dec_ddp *ddp)
+{
+	int i, rc;
+	pr_debug("%s\n", __func__);
+	for (i = 0; i < ddp->params_length/2; i++) {
+		rc = q6asm_ds1_set_endp_params(ac, ddp->params_id[i],
+						ddp->params_value[i]);
+		if (rc) {
+			pr_err("sending params_id: %d failed\n",
+				ddp->params_id[i]);
+			return rc;
+		}
+	}
+	return 0;
+}
+
+static int msm_compr_playback_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct compr_audio *compr = runtime->private_data;
+	struct snd_soc_pcm_runtime *soc_prtd = substream->private_data;
+	struct msm_audio *prtd = &compr->prtd;
+	struct snd_pcm_hw_params *params;
+	struct asm_aac_cfg aac_cfg;
+	uint16_t bits_per_sample = 16;
+	int ret;
+
+	struct asm_softpause_params softpause = {
+		.enable = SOFT_PAUSE_ENABLE,
+		.period = SOFT_PAUSE_PERIOD,
+		.step = SOFT_PAUSE_STEP,
+		.rampingcurve = SOFT_PAUSE_CURVE_LINEAR,
+	};
+	struct asm_softvolume_params softvol = {
+		.period = SOFT_VOLUME_PERIOD,
+		.step = SOFT_VOLUME_STEP,
+		.rampingcurve = SOFT_VOLUME_CURVE_LINEAR,
+	};
+
+	pr_debug("%s\n", __func__);
+
+	params = &soc_prtd->dpcm[substream->stream].hw_params;
+	if (runtime->format == SNDRV_PCM_FORMAT_S24_LE)
+		bits_per_sample = 24;
+
+	ret = q6asm_open_write_v2(prtd->audio_client,
+			compr->codec, bits_per_sample);
+	if (ret < 0) {
+		pr_err("%s: Session out open failed\n",
+				__func__);
+		return -ENOMEM;
+	}
+	msm_pcm_routing_reg_phy_stream(
+			soc_prtd->dai_link->be_id,
+			prtd->audio_client->perf_mode,
+			prtd->session_id,
+			substream->stream);
+	/*
+	 * the number of channels are required to call volume api
+	 * accoridngly. So, get channels from hw params
+	 */
+	if ((params_channels(params) > 0) &&
+			(params_periods(params) <= runtime->hw.channels_max))
+		prtd->channel_mode = params_channels(params);
+
+	ret = q6asm_set_softpause(prtd->audio_client, &softpause);
+	if (ret < 0)
+		pr_err("%s: Send SoftPause Param failed ret=%d\n",
+				__func__, ret);
+	ret = q6asm_set_softvolume(prtd->audio_client, &softvol);
+	if (ret < 0)
+		pr_err("%s: Send SoftVolume Param failed ret=%d\n",
+				__func__, ret);
+
+	ret = q6asm_set_io_mode(prtd->audio_client,
+			(COMPRESSED_IO | ASYNC_IO_MODE));
+	if (ret < 0) {
+		pr_err("%s: Set IO mode failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	prtd->pcm_size = snd_pcm_lib_buffer_bytes(substream);
+	prtd->pcm_count = snd_pcm_lib_period_bytes(substream);
+	prtd->pcm_irq_pos = 0;
+	/* rate and channels are sent to audio driver */
+	prtd->samp_rate = runtime->rate;
+	prtd->channel_mode = runtime->channels;
+	prtd->out_head = 0;
+	atomic_set(&prtd->out_count, runtime->periods);
+
+	if (prtd->enabled)
+		return 0;
+
+	switch (compr->info.codec_param.codec.id) {
+	case SND_AUDIOCODEC_MP3:
+		/* No media format block for mp3 */
+		break;
+	case SND_AUDIOCODEC_AAC:
+		pr_debug("%s: SND_AUDIOCODEC_AAC\n", __func__);
+		memset(&aac_cfg, 0x0, sizeof(struct asm_aac_cfg));
+		aac_cfg.aot = AAC_ENC_MODE_EAAC_P;
+		aac_cfg.format = 0x03;
+		aac_cfg.ch_cfg = runtime->channels;
+		aac_cfg.sample_rate =  runtime->rate;
+		ret = q6asm_media_format_block_aac(prtd->audio_client,
+					&aac_cfg);
+		if (ret < 0)
+			pr_err("%s: CMD Format block failed\n", __func__);
+		break;
+	case SND_AUDIOCODEC_AC3: {
+		struct snd_dec_ddp *ddp =
+				&compr->info.codec_param.codec.options.ddp;
+		pr_debug("%s: SND_AUDIOCODEC_AC3\n", __func__);
+		ret = msm_compr_send_ddp_cfg(prtd->audio_client, ddp);
+		if (ret < 0)
+			pr_err("%s: DDP CMD CFG failed\n", __func__);
+		break;
+	}
+	case SND_AUDIOCODEC_EAC3: {
+		struct snd_dec_ddp *ddp =
+				&compr->info.codec_param.codec.options.ddp;
+		pr_debug("%s: SND_AUDIOCODEC_EAC3\n", __func__);
+		ret = msm_compr_send_ddp_cfg(prtd->audio_client, ddp);
+		if (ret < 0)
+			pr_err("%s: DDP CMD CFG failed\n", __func__);
+		break;
+	}
+	default:
+		return -EINVAL;
+	}
+
+	prtd->enabled = 1;
+	prtd->cmd_ack = 0;
+	prtd->cmd_interrupt = 0;
+
+	return 0;
+}
+
+static int msm_compr_capture_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct compr_audio *compr = runtime->private_data;
+	struct msm_audio *prtd = &compr->prtd;
+	struct audio_buffer *buf = prtd->audio_client->port[OUT].buf;
+	struct snd_codec *codec = &compr->info.codec_param.codec;
+	struct snd_soc_pcm_runtime *soc_prtd = substream->private_data;
+	struct audio_aio_read_param read_param;
+	uint16_t bits_per_sample = 16;
+	int ret = 0;
+	int i;
+
+	prtd->pcm_size = snd_pcm_lib_buffer_bytes(substream);
+	prtd->pcm_count = snd_pcm_lib_period_bytes(substream);
+	prtd->pcm_irq_pos = 0;
+
+	if (runtime->format == SNDRV_PCM_FORMAT_S24_LE)
+		bits_per_sample = 24;
+
+	if (!msm_compr_capture_codecs(
+				compr->info.codec_param.codec.id)) {
+		/*
+		 * request codec invalid or not supported,
+		 * use default compress format
+		 */
+		compr->info.codec_param.codec.id =
+			SND_AUDIOCODEC_AMRWB;
+	}
+	switch (compr->info.codec_param.codec.id) {
+	case SND_AUDIOCODEC_AMRWB:
+		pr_debug("q6asm_open_read(FORMAT_AMRWB)\n");
+		ret = q6asm_open_read(prtd->audio_client,
+				FORMAT_AMRWB);
+		if (ret < 0) {
+			pr_err("%s: compressed Session out open failed\n",
+					__func__);
+			return -ENOMEM;
+		}
+		pr_debug("msm_pcm_routing_reg_phy_stream\n");
+		msm_pcm_routing_reg_phy_stream(
+				soc_prtd->dai_link->be_id,
+				prtd->audio_client->perf_mode,
+				prtd->session_id, substream->stream);
+		break;
+	default:
+		pr_debug("q6asm_open_read_compressed(COMPRESSED_META_DATA_MODE)\n");
+		/*
+		   ret = q6asm_open_read_compressed(prtd->audio_client,
+		   MAX_NUM_FRAMES_PER_BUFFER,
+		   COMPRESSED_META_DATA_MODE);
+		 */
+			ret = -EINVAL;
+			break;
+	}
+
+	if (ret < 0) {
+		pr_err("%s: compressed Session out open failed\n",
+				__func__);
+		return -ENOMEM;
+	}
+
+	ret = q6asm_set_io_mode(prtd->audio_client,
+		(COMPRESSED_IO | ASYNC_IO_MODE));
+		if (ret < 0) {
+			pr_err("%s: Set IO mode failed\n", __func__);
+				return -ENOMEM;
+		}
+
+	if (!msm_compr_capture_codecs(codec->id)) {
+		/*
+		 * request codec invalid or not supported,
+		 * use default compress format
+		 */
+		codec->id = SND_AUDIOCODEC_AMRWB;
+	}
+	/* rate and channels are sent to audio driver */
+	prtd->samp_rate = runtime->rate;
+	prtd->channel_mode = runtime->channels;
+
+	if (prtd->enabled)
+		return ret;
+	read_param.len = prtd->pcm_count;
+
+	switch (codec->id) {
+	case SND_AUDIOCODEC_AMRWB:
+		pr_debug("SND_AUDIOCODEC_AMRWB\n");
+		ret = q6asm_enc_cfg_blk_amrwb(prtd->audio_client,
+			MAX_NUM_FRAMES_PER_BUFFER,
+			/*
+			 * use fixed band mode and dtx mode
+			 * band mode - 23.85 kbps
+			 */
+			AMR_WB_BAND_MODE,
+			/* dtx mode - disable */
+			AMR_WB_DTX_MODE);
+		if (ret < 0)
+			pr_err("%s: CMD Format block failed: %d\n",
+				__func__, ret);
+		break;
+	default:
+		pr_debug("No config for codec %d\n", codec->id);
+	}
+	pr_debug("%s: Samp_rate = %d, Channel = %d, pcm_size = %d,\n"
+			 "pcm_count = %d, periods = %d\n",
+			 __func__, prtd->samp_rate, prtd->channel_mode,
+			 prtd->pcm_size, prtd->pcm_count, runtime->periods);
+
+	for (i = 0; i < runtime->periods; i++) {
+		read_param.uid = i;
+		switch (codec->id) {
+		case SND_AUDIOCODEC_AMRWB:
+			read_param.len = prtd->pcm_count
+					- COMPRE_CAPTURE_HEADER_SIZE;
+			read_param.paddr = buf[i].phys
+					+ COMPRE_CAPTURE_HEADER_SIZE;
+			pr_debug("Push buffer [%d] to DSP, paddr: %pK, vaddr: %pK\n",
+					i, &read_param.paddr,
+					buf[i].data);
+			q6asm_async_read(prtd->audio_client, &read_param);
+			break;
+		default:
+			read_param.paddr = buf[i].phys;
+			/*q6asm_async_read_compressed(prtd->audio_client,
+				&read_param);*/
+			pr_debug("%s: To add support for read compressed\n",
+								__func__);
+			ret = -EINVAL;
+			break;
+		}
+	}
+	prtd->periods = runtime->periods;
+
+	prtd->enabled = 1;
+
+	return ret;
+}
+
+static int msm_compr_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	int ret = 0;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *soc_prtd = substream->private_data;
+	struct compr_audio *compr = runtime->private_data;
+	struct msm_audio *prtd = &compr->prtd;
+
+	pr_debug("%s\n", __func__);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		prtd->pcm_irq_pos = 0;
+
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+			if (!msm_compr_capture_codecs(
+				compr->info.codec_param.codec.id)) {
+				/*
+				 * request codec invalid or not supported,
+				 * use default compress format
+				 */
+				compr->info.codec_param.codec.id =
+				SND_AUDIOCODEC_AMRWB;
+			}
+			switch (compr->info.codec_param.codec.id) {
+			case SND_AUDIOCODEC_AMRWB:
+				break;
+			default:
+				msm_pcm_routing_reg_psthr_stream(
+					soc_prtd->dai_link->be_id,
+					prtd->session_id, substream->stream);
+				break;
+			}
+		}
+		atomic_set(&prtd->pending_buffer, 1);
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		pr_debug("%s: Trigger start\n", __func__);
+		q6asm_run_nowait(prtd->audio_client, 0, 0, 0);
+		atomic_set(&prtd->start, 1);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		pr_debug("SNDRV_PCM_TRIGGER_STOP\n");
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+			switch (compr->info.codec_param.codec.id) {
+			case SND_AUDIOCODEC_AMRWB:
+				break;
+			default:
+				msm_pcm_routing_reg_psthr_stream(
+					soc_prtd->dai_link->be_id,
+					prtd->session_id, substream->stream);
+				break;
+			}
+		}
+		atomic_set(&prtd->start, 0);
+		runtime->render_flag &= ~SNDRV_RENDER_STOPPED;
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		pr_debug("SNDRV_PCM_TRIGGER_PAUSE\n");
+		q6asm_cmd_nowait(prtd->audio_client, CMD_PAUSE);
+		atomic_set(&prtd->start, 0);
+		runtime->render_flag &= ~SNDRV_RENDER_STOPPED;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static void populate_codec_list(struct compr_audio *compr,
+		struct snd_pcm_runtime *runtime)
+{
+	pr_debug("%s\n", __func__);
+	/* MP3 Block */
+	compr->info.compr_cap.num_codecs = 5;
+	compr->info.compr_cap.min_fragment_size = runtime->hw.period_bytes_min;
+	compr->info.compr_cap.max_fragment_size = runtime->hw.period_bytes_max;
+	compr->info.compr_cap.min_fragments = runtime->hw.periods_min;
+	compr->info.compr_cap.max_fragments = runtime->hw.periods_max;
+	compr->info.compr_cap.codecs[0] = SND_AUDIOCODEC_MP3;
+	compr->info.compr_cap.codecs[1] = SND_AUDIOCODEC_AAC;
+	compr->info.compr_cap.codecs[2] = SND_AUDIOCODEC_AC3;
+	compr->info.compr_cap.codecs[3] = SND_AUDIOCODEC_EAC3;
+	compr->info.compr_cap.codecs[4] = SND_AUDIOCODEC_AMRWB;
+	/* Add new codecs here */
+}
+
+static int msm_compr_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct compr_audio *compr;
+	struct msm_audio *prtd;
+	int ret = 0;
+
+	pr_debug("%s\n", __func__);
+	compr = kzalloc(sizeof(struct compr_audio), GFP_KERNEL);
+	if (compr == NULL) {
+		pr_err("Failed to allocate memory for msm_audio\n");
+		return -ENOMEM;
+	}
+	prtd = &compr->prtd;
+	prtd->substream = substream;
+	runtime->render_flag = SNDRV_DMA_MODE;
+	prtd->audio_client = q6asm_audio_client_alloc(
+				(app_cb)compr_event_handler, compr);
+	if (!prtd->audio_client) {
+		pr_info("%s: Could not allocate memory\n", __func__);
+		kfree(prtd);
+		return -ENOMEM;
+	}
+
+	prtd->audio_client->perf_mode = false;
+	pr_info("%s: session ID %d\n", __func__, prtd->audio_client->session);
+
+	prtd->session_id = prtd->audio_client->session;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		runtime->hw = msm_compr_hardware_playback;
+		prtd->cmd_ack = 1;
+	} else {
+		runtime->hw = msm_compr_hardware_capture;
+	}
+
+
+	ret = snd_pcm_hw_constraint_list(runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE,
+			&constraints_sample_rates);
+	if (ret < 0)
+		pr_info("snd_pcm_hw_constraint_list failed\n");
+	/* Ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime,
+			    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		pr_info("snd_pcm_hw_constraint_integer failed\n");
+
+	prtd->dsp_cnt = 0;
+	atomic_set(&prtd->pending_buffer, 1);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		compr->codec = FORMAT_MP3;
+	populate_codec_list(compr, runtime);
+	runtime->private_data = compr;
+	atomic_set(&prtd->eos, 0);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (!atomic_cmpxchg(&compressed_audio.audio_ocmem_req, 0, 1))
+			audio_ocmem_process_req(AUDIO, true);
+		else
+			atomic_inc(&compressed_audio.audio_ocmem_req);
+		pr_debug("%s: req: %d\n", __func__,
+			atomic_read(&compressed_audio.audio_ocmem_req));
+	}
+	return 0;
+}
+
+static int compressed_set_volume(struct msm_audio *prtd, uint32_t volume)
+{
+	int rc = 0;
+	int avg_vol = 0;
+	int lgain = (volume >> 16) & 0xFFFF;
+	int rgain = volume & 0xFFFF;
+	if (prtd && prtd->audio_client) {
+		pr_debug("%s: channels %d volume 0x%x\n", __func__,
+			prtd->channel_mode, volume);
+		if ((prtd->channel_mode == 2) &&
+			(lgain != rgain)) {
+			pr_debug("%s: call q6asm_set_lrgain\n", __func__);
+			rc = q6asm_set_lrgain(prtd->audio_client, lgain, rgain);
+		} else {
+			avg_vol = (lgain + rgain)/2;
+			pr_debug("%s: call q6asm_set_volume\n", __func__);
+			rc = q6asm_set_volume(prtd->audio_client, avg_vol);
+		}
+		if (rc < 0) {
+			pr_err("%s: Send Volume command failed rc=%d\n",
+				__func__, rc);
+		}
+	}
+	return rc;
+}
+
+static int msm_compr_playback_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *soc_prtd = substream->private_data;
+	struct compr_audio *compr = runtime->private_data;
+	struct msm_audio *prtd = &compr->prtd;
+	int dir = 0;
+
+	pr_debug("%s\n", __func__);
+
+	dir = IN;
+	atomic_set(&prtd->pending_buffer, 0);
+
+	if (atomic_read(&compressed_audio.audio_ocmem_req) > 1)
+		atomic_dec(&compressed_audio.audio_ocmem_req);
+	else if (atomic_cmpxchg(&compressed_audio.audio_ocmem_req, 1, 0))
+		audio_ocmem_process_req(AUDIO, false);
+
+	pr_debug("%s: req: %d\n", __func__,
+		atomic_read(&compressed_audio.audio_ocmem_req));
+	prtd->pcm_irq_pos = 0;
+	q6asm_cmd(prtd->audio_client, CMD_CLOSE);
+	q6asm_audio_client_buf_free_contiguous(dir,
+				prtd->audio_client);
+		msm_pcm_routing_dereg_phy_stream(
+			soc_prtd->dai_link->be_id,
+			SNDRV_PCM_STREAM_PLAYBACK);
+	q6asm_audio_client_free(prtd->audio_client);
+	kfree(prtd);
+	return 0;
+}
+
+static int msm_compr_capture_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *soc_prtd = substream->private_data;
+	struct compr_audio *compr = runtime->private_data;
+	struct msm_audio *prtd = &compr->prtd;
+	int dir = OUT;
+
+	pr_debug("%s\n", __func__);
+	atomic_set(&prtd->pending_buffer, 0);
+	q6asm_cmd(prtd->audio_client, CMD_CLOSE);
+	q6asm_audio_client_buf_free_contiguous(dir,
+				prtd->audio_client);
+	msm_pcm_routing_dereg_phy_stream(soc_prtd->dai_link->be_id,
+				SNDRV_PCM_STREAM_CAPTURE);
+	q6asm_audio_client_free(prtd->audio_client);
+	kfree(prtd);
+	return 0;
+}
+
+static int msm_compr_close(struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		ret = msm_compr_playback_close(substream);
+	else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		ret = msm_compr_capture_close(substream);
+	return ret;
+}
+
+static int msm_compr_prepare(struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		ret = msm_compr_playback_prepare(substream);
+	else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		ret = msm_compr_capture_prepare(substream);
+	return ret;
+}
+
+static snd_pcm_uframes_t msm_compr_pointer(struct snd_pcm_substream *substream)
+{
+
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct compr_audio *compr = runtime->private_data;
+	struct msm_audio *prtd = &compr->prtd;
+
+	if (prtd->pcm_irq_pos >= prtd->pcm_size)
+		prtd->pcm_irq_pos = 0;
+
+	pr_debug("%s: pcm_irq_pos = %d, pcm_size = %d, sample_bits = %d,\n"
+			 "frame_bits = %d\n", __func__, prtd->pcm_irq_pos,
+			 prtd->pcm_size, runtime->sample_bits,
+			 runtime->frame_bits);
+	return bytes_to_frames(runtime, (prtd->pcm_irq_pos));
+}
+
+static int msm_compr_mmap(struct snd_pcm_substream *substream,
+				struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct msm_audio *prtd = runtime->private_data;
+	struct audio_client *ac = prtd->audio_client;
+	struct audio_port_data *apd = ac->port;
+	struct audio_buffer *ab;
+	int dir = -1;
+
+	prtd->mmap_flag = 1;
+	runtime->render_flag = SNDRV_NON_DMA_MODE;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dir = IN;
+	else
+		dir = OUT;
+	ab = &(apd[dir].buf[0]);
+
+	return msm_audio_ion_mmap(ab, vma);
+}
+
+static int msm_compr_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct compr_audio *compr = runtime->private_data;
+	struct msm_audio *prtd = &compr->prtd;
+	struct snd_dma_buffer *dma_buf = &substream->dma_buffer;
+	struct audio_buffer *buf;
+	int dir, ret;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dir = IN;
+	else
+		dir = OUT;
+	/* Modifying kernel hardware params based on userspace config */
+	if (params_periods(params) > 0 &&
+		(params_periods(params) != runtime->hw.periods_max)) {
+		runtime->hw.periods_max = params_periods(params);
+	}
+	if (params_period_bytes(params) > 0 &&
+		(params_period_bytes(params) != runtime->hw.period_bytes_min)) {
+		runtime->hw.period_bytes_min = params_period_bytes(params);
+	}
+	runtime->hw.buffer_bytes_max =
+			runtime->hw.period_bytes_min * runtime->hw.periods_max;
+	pr_debug("allocate %zd buffers each of size %d\n",
+		runtime->hw.period_bytes_min,
+		runtime->hw.periods_max);
+	ret = q6asm_audio_client_buf_alloc_contiguous(dir,
+			prtd->audio_client,
+			runtime->hw.period_bytes_min,
+			runtime->hw.periods_max);
+	if (ret < 0) {
+		pr_err("Audio Start: Buffer Allocation failed rc = %d\n",
+						ret);
+		return -ENOMEM;
+	}
+	buf = prtd->audio_client->port[dir].buf;
+
+	dma_buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	dma_buf->dev.dev = substream->pcm->card->dev;
+	dma_buf->private_data = NULL;
+	dma_buf->area = buf[0].data;
+	dma_buf->addr =  buf[0].phys;
+	dma_buf->bytes = runtime->hw.buffer_bytes_max;
+
+	pr_debug("%s: buf[%pK]dma_buf->area[%pK]dma_buf->addr[%pK]\n"
+		 "dma_buf->bytes[%zd]\n", __func__,
+		 (void *)buf, (void *)dma_buf->area,
+		 &dma_buf->addr, dma_buf->bytes);
+	if (!dma_buf->area)
+		return -ENOMEM;
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	return 0;
+}
+
+static int msm_compr_ioctl_shared(struct snd_pcm_substream *substream,
+		unsigned int cmd, void *arg)
+{
+	int rc = 0;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct compr_audio *compr = runtime->private_data;
+	struct msm_audio *prtd = &compr->prtd;
+	uint64_t timestamp;
+	uint64_t temp;
+
+	switch (cmd) {
+	case SNDRV_COMPRESS_TSTAMP: {
+		struct snd_compr_tstamp *tstamp;
+		pr_debug("SNDRV_COMPRESS_TSTAMP\n");
+		tstamp = arg;
+		memset(tstamp, 0x0, sizeof(*tstamp));
+		rc = q6asm_get_session_time(prtd->audio_client, &timestamp);
+		if (rc < 0) {
+			pr_err("%s: Get Session Time return value =%lld\n",
+				__func__, timestamp);
+			return -EAGAIN;
+		}
+		temp = (timestamp * 2 * runtime->channels);
+		temp = temp * (runtime->rate/1000);
+		temp = div_u64(temp, 1000);
+		tstamp->sampling_rate = runtime->rate;
+		tstamp->timestamp = timestamp;
+		pr_debug("%s: bytes_consumed:,timestamp = %lld,\n",
+						__func__,
+			tstamp->timestamp);
+		return 0;
+	}
+	case SNDRV_COMPRESS_GET_CAPS: {
+		struct snd_compr_caps *caps;
+		caps = arg;
+		memset(caps, 0, sizeof(*caps));
+		pr_debug("SNDRV_COMPRESS_GET_CAPS\n");
+		memcpy(caps, &compr->info.compr_cap, sizeof(*caps));
+		return 0;
+	}
+	case SNDRV_COMPRESS_SET_PARAMS:
+		pr_debug("SNDRV_COMPRESS_SET_PARAMS:\n");
+		memcpy(&compr->info.codec_param, (void *) arg,
+			sizeof(struct snd_compr_params));
+		switch (compr->info.codec_param.codec.id) {
+		case SND_AUDIOCODEC_MP3:
+			/* For MP3 we dont need any other parameter */
+			pr_debug("SND_AUDIOCODEC_MP3\n");
+			compr->codec = FORMAT_MP3;
+			break;
+		case SND_AUDIOCODEC_AAC:
+			pr_debug("SND_AUDIOCODEC_AAC\n");
+			compr->codec = FORMAT_MPEG4_AAC;
+			break;
+		case SND_AUDIOCODEC_AC3: {
+			char params_value[MAX_AC3_PARAM_SIZE];
+			int *params_value_data = (int *)params_value;
+			/* 36 is the max param length for ddp */
+			int i;
+			struct snd_dec_ddp *ddp =
+				&compr->info.codec_param.codec.options.ddp;
+			uint32_t params_length = 0;
+			/* check integer overflow */
+			if (ddp->params_length > UINT_MAX/sizeof(int)) {
+				pr_err("%s: Integer overflow ddp->params_length %d\n",
+				__func__, ddp->params_length);
+				return -EINVAL;
+			}
+			params_length = ddp->params_length*sizeof(int);
+			if (params_length > MAX_AC3_PARAM_SIZE) {
+				/*MAX is 36*sizeof(int) this should not happen*/
+				pr_err("%s: params_length(%d) is greater than %zd\n",
+				__func__, params_length, MAX_AC3_PARAM_SIZE);
+				return -EINVAL;
+			}
+			pr_debug("SND_AUDIOCODEC_AC3\n");
+			compr->codec = FORMAT_AC3;
+			pr_debug("params_length: %d\n", ddp->params_length);
+			for (i = 0; i < params_length/sizeof(int); i++)
+				pr_debug("params_value[%d]: %x\n", i,
+					params_value_data[i]);
+			for (i = 0; i < ddp->params_length/2; i++) {
+				ddp->params_id[i] = params_value_data[2*i];
+				ddp->params_value[i] = params_value_data[2*i+1];
+			}
+			if (atomic_read(&prtd->start)) {
+				rc = msm_compr_send_ddp_cfg(prtd->audio_client,
+								ddp);
+				if (rc < 0)
+					pr_err("%s: DDP CMD CFG failed\n",
+						__func__);
+			}
+			break;
+		}
+		case SND_AUDIOCODEC_EAC3: {
+			char params_value[MAX_AC3_PARAM_SIZE];
+			int *params_value_data = (int *)params_value;
+			/* 36 is the max param length for ddp */
+			int i;
+			struct snd_dec_ddp *ddp =
+				&compr->info.codec_param.codec.options.ddp;
+			uint32_t params_length = 0;
+			/* check integer overflow */
+			if (ddp->params_length > UINT_MAX/sizeof(int)) {
+				pr_err("%s: Integer overflow ddp->params_length %d\n",
+				__func__, ddp->params_length);
+				return -EINVAL;
+			}
+			if (params_length > MAX_AC3_PARAM_SIZE) {
+				/*MAX is 36*sizeof(int) this should not happen*/
+				pr_err("%s: params_length(%d) is greater than %zd\n",
+				__func__, params_length, MAX_AC3_PARAM_SIZE);
+				return -EINVAL;
+			}
+			pr_debug("SND_AUDIOCODEC_EAC3\n");
+			compr->codec = FORMAT_EAC3;
+			pr_debug("params_length: %d\n", ddp->params_length);
+			for (i = 0; i < ddp->params_length; i++)
+				pr_debug("params_value[%d]: %x\n", i,
+					params_value_data[i]);
+			for (i = 0; i < ddp->params_length/2; i++) {
+				ddp->params_id[i] = params_value_data[2*i];
+				ddp->params_value[i] = params_value_data[2*i+1];
+			}
+			if (atomic_read(&prtd->start)) {
+				rc = msm_compr_send_ddp_cfg(prtd->audio_client,
+								ddp);
+				if (rc < 0)
+					pr_err("%s: DDP CMD CFG failed\n",
+						__func__);
+			}
+			break;
+		}
+		default:
+			pr_debug("FORMAT_LINEAR_PCM\n");
+			compr->codec = FORMAT_LINEAR_PCM;
+			break;
+		}
+		return 0;
+	case SNDRV_PCM_IOCTL1_RESET:
+		pr_debug("SNDRV_PCM_IOCTL1_RESET\n");
+		/* Flush only when session is started during CAPTURE,
+		   while PLAYBACK has no such restriction. */
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ||
+			  (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&
+						atomic_read(&prtd->start))) {
+			if (atomic_read(&prtd->eos)) {
+				prtd->cmd_interrupt = 1;
+				wake_up(&the_locks.eos_wait);
+				atomic_set(&prtd->eos, 0);
+			}
+
+			/* A unlikely race condition possible with FLUSH
+			   DRAIN if ack is set by flush and reset by drain */
+			prtd->cmd_ack = 0;
+			rc = q6asm_cmd(prtd->audio_client, CMD_FLUSH);
+			if (rc < 0) {
+				pr_err("%s: flush cmd failed rc=%d\n",
+					__func__, rc);
+				return rc;
+			}
+			rc = wait_event_timeout(the_locks.flush_wait,
+				prtd->cmd_ack, 5 * HZ);
+			if (!rc)
+				pr_err("Flush cmd timeout\n");
+			prtd->pcm_irq_pos = 0;
+		}
+		break;
+	case SNDRV_COMPRESS_DRAIN:
+		pr_debug("%s: SNDRV_COMPRESS_DRAIN\n", __func__);
+		if (atomic_read(&prtd->pending_buffer)) {
+			pr_debug("%s: no pending writes, drain would block\n",
+			 __func__);
+			return -EWOULDBLOCK;
+		}
+
+		atomic_set(&prtd->eos, 1);
+		atomic_set(&prtd->pending_buffer, 0);
+		prtd->cmd_ack = 0;
+		q6asm_cmd_nowait(prtd->audio_client, CMD_EOS);
+		/* Wait indefinitely for  DRAIN. Flush can also signal this*/
+		rc = wait_event_interruptible(the_locks.eos_wait,
+			(prtd->cmd_ack || prtd->cmd_interrupt));
+
+		if (rc < 0)
+			pr_err("EOS cmd interrupted\n");
+		pr_debug("%s: SNDRV_COMPRESS_DRAIN  out of wait\n", __func__);
+
+		if (prtd->cmd_interrupt)
+			rc = -EINTR;
+
+		prtd->cmd_interrupt = 0;
+		return rc;
+	default:
+		break;
+	}
+	return snd_pcm_lib_ioctl(substream, cmd, arg);
+}
+#ifdef CONFIG_COMPAT
+struct snd_enc_wma32 {
+	u32 super_block_align; /* WMA Type-specific data */
+	u32 encodeopt1;
+	u32 encodeopt2;
+};
+
+struct snd_enc_vorbis32 {
+	s32 quality;
+	u32 managed;
+	u32 max_bit_rate;
+	u32 min_bit_rate;
+	u32 downmix;
+};
+
+struct snd_enc_real32 {
+	u32 quant_bits;
+	u32 start_region;
+	u32 num_regions;
+};
+
+struct snd_enc_flac32 {
+	u32 num;
+	u32 gain;
+};
+
+struct snd_enc_generic32 {
+	u32 bw;	/* encoder bandwidth */
+	s32 reserved[15];
+};
+struct snd_dec_ddp32 {
+	u32 params_length;
+	u32 params_id[18];
+	u32 params_value[18];
+};
+
+union snd_codec_options32 {
+	struct snd_enc_wma32 wma;
+	struct snd_enc_vorbis32 vorbis;
+	struct snd_enc_real32 real;
+	struct snd_enc_flac32 flac;
+	struct snd_enc_generic32 generic;
+	struct snd_dec_ddp32 ddp;
+};
+
+struct snd_codec32 {
+	u32 id;
+	u32 ch_in;
+	u32 ch_out;
+	u32 sample_rate;
+	u32 bit_rate;
+	u32 rate_control;
+	u32 profile;
+	u32 level;
+	u32 ch_mode;
+	u32 format;
+	u32 align;
+	union snd_codec_options32 options;
+	u32 reserved[3];
+};
+
+struct snd_compressed_buffer32 {
+	u32 fragment_size;
+	u32 fragments;
+};
+
+struct snd_compr_params32 {
+	struct snd_compressed_buffer32 buffer;
+	struct snd_codec32 codec;
+	u8 no_wake_mode;
+};
+
+struct snd_compr_caps32 {
+	u32 num_codecs;
+	u32 direction;
+	u32 min_fragment_size;
+	u32 max_fragment_size;
+	u32 min_fragments;
+	u32 max_fragments;
+	u32 codecs[MAX_NUM_CODECS];
+	u32 reserved[11];
+};
+struct snd_compr_tstamp32 {
+	u32 byte_offset;
+	u32 copied_total;
+	compat_ulong_t pcm_frames;
+	compat_ulong_t pcm_io_frames;
+	u32 sampling_rate;
+	compat_u64 timestamp;
+};
+enum {
+	SNDRV_COMPRESS_TSTAMP32 = _IOR('C', 0x20, struct snd_compr_tstamp32),
+	SNDRV_COMPRESS_GET_CAPS32 = _IOWR('C', 0x10, struct snd_compr_caps32),
+	SNDRV_COMPRESS_SET_PARAMS32 =
+	_IOW('C', 0x12, struct snd_compr_params32),
+};
+static int msm_compr_compat_ioctl(struct snd_pcm_substream *substream,
+		unsigned int cmd, void *arg)
+{
+	int err = 0;
+	switch (cmd) {
+	case SNDRV_COMPRESS_TSTAMP32: {
+		struct snd_compr_tstamp tstamp;
+		struct snd_compr_tstamp32 tstamp32;
+		memset(&tstamp, 0, sizeof(tstamp));
+		memset(&tstamp32, 0, sizeof(tstamp32));
+		cmd = SNDRV_COMPRESS_TSTAMP;
+		err = msm_compr_ioctl_shared(substream, cmd, &tstamp);
+		if (err) {
+			pr_err("%s: COMPRESS_TSTAMP failed rc %d\n",
+			__func__, err);
+			goto bail_out;
+		}
+		tstamp32.byte_offset = tstamp.byte_offset;
+		tstamp32.copied_total = tstamp.copied_total;
+		tstamp32.pcm_frames = tstamp.pcm_frames;
+		tstamp32.pcm_io_frames = tstamp.pcm_io_frames;
+		tstamp32.sampling_rate = tstamp.sampling_rate;
+		tstamp32.timestamp = tstamp.timestamp;
+		if (copy_to_user(arg, &tstamp32, sizeof(tstamp32))) {
+			pr_err("%s: copytouser failed COMPRESS_TSTAMP32\n",
+			__func__);
+			err = -EFAULT;
+		}
+		break;
+	}
+	case SNDRV_COMPRESS_GET_CAPS32: {
+		struct snd_compr_caps caps;
+		struct snd_compr_caps32 caps32;
+		u32 i;
+		memset(&caps, 0, sizeof(caps));
+		memset(&caps32, 0, sizeof(caps32));
+		cmd = SNDRV_COMPRESS_GET_CAPS;
+		err = msm_compr_ioctl_shared(substream, cmd, &caps);
+		if (err) {
+			pr_err("%s: GET_CAPS failed rc %d\n",
+			__func__, err);
+			goto bail_out;
+		}
+		pr_debug("SNDRV_COMPRESS_GET_CAPS_32\n");
+		if (!err && caps.num_codecs >= MAX_NUM_CODECS) {
+			pr_err("%s: Invalid number of codecs\n", __func__);
+			err = -EINVAL;
+			goto bail_out;
+		}
+		caps32.direction = caps.direction;
+		caps32.max_fragment_size = caps.max_fragment_size;
+		caps32.max_fragments = caps.max_fragments;
+		caps32.min_fragment_size = caps.min_fragment_size;
+		caps32.num_codecs = caps.num_codecs;
+		for (i = 0; i < caps.num_codecs; i++)
+			caps32.codecs[i] = caps.codecs[i];
+		if (copy_to_user(arg, &caps32, sizeof(caps32))) {
+			pr_err("%s: copytouser failed COMPRESS_GETCAPS32\n",
+			__func__);
+			err = -EFAULT;
+		}
+		break;
+	}
+	case SNDRV_COMPRESS_SET_PARAMS32: {
+		struct snd_compr_params32 params32;
+		struct snd_compr_params params;
+		memset(&params32, 0 , sizeof(params32));
+		memset(&params, 0 , sizeof(params));
+		cmd = SNDRV_COMPRESS_SET_PARAMS;
+		if (copy_from_user(&params32, arg, sizeof(params32))) {
+			pr_err("%s: copyfromuser failed SET_PARAMS32\n",
+			__func__);
+			err = -EFAULT;
+			goto bail_out;
+		}
+		params.no_wake_mode = params32.no_wake_mode;
+		params.codec.id = params32.codec.id;
+		params.codec.ch_in = params32.codec.ch_in;
+		params.codec.ch_out = params32.codec.ch_out;
+		params.codec.sample_rate = params32.codec.sample_rate;
+		params.codec.bit_rate = params32.codec.bit_rate;
+		params.codec.rate_control = params32.codec.rate_control;
+		params.codec.profile = params32.codec.profile;
+		params.codec.level = params32.codec.level;
+		params.codec.ch_mode = params32.codec.ch_mode;
+		params.codec.format = params32.codec.format;
+		params.codec.align = params32.codec.align;
+
+		switch (params.codec.id) {
+		case SND_AUDIOCODEC_WMA:
+		case SND_AUDIOCODEC_WMA_PRO:
+			params.codec.options.wma.encodeopt1 =
+			params32.codec.options.wma.encodeopt1;
+			params.codec.options.wma.encodeopt2 =
+			params32.codec.options.wma.encodeopt2;
+			params.codec.options.wma.super_block_align =
+			params32.codec.options.wma.super_block_align;
+		break;
+		case SND_AUDIOCODEC_VORBIS:
+			params.codec.options.vorbis.downmix =
+			params32.codec.options.vorbis.downmix;
+			params.codec.options.vorbis.managed =
+			params32.codec.options.vorbis.managed;
+			params.codec.options.vorbis.max_bit_rate =
+			params32.codec.options.vorbis.max_bit_rate;
+			params.codec.options.vorbis.min_bit_rate =
+			params32.codec.options.vorbis.min_bit_rate;
+			params.codec.options.vorbis.quality =
+			params32.codec.options.vorbis.quality;
+		break;
+		case SND_AUDIOCODEC_REAL:
+			params.codec.options.real.num_regions =
+			params32.codec.options.real.num_regions;
+			params.codec.options.real.quant_bits =
+			params32.codec.options.real.quant_bits;
+			params.codec.options.real.start_region =
+			params32.codec.options.real.start_region;
+		break;
+		case SND_AUDIOCODEC_FLAC:
+			params.codec.options.flac.gain =
+			params32.codec.options.flac.gain;
+			params.codec.options.flac.num =
+			params32.codec.options.flac.num;
+		break;
+		case SND_AUDIOCODEC_DTS:
+		case SND_AUDIOCODEC_DTS_PASS_THROUGH:
+		case SND_AUDIOCODEC_DTS_LBR:
+		case SND_AUDIOCODEC_DTS_LBR_PASS_THROUGH:
+		case SND_AUDIOCODEC_DTS_TRANSCODE_LOOPBACK:
+		break;
+		case SND_AUDIOCODEC_AC3:
+		case SND_AUDIOCODEC_EAC3:
+			params.codec.options.ddp.params_length =
+			params32.codec.options.ddp.params_length;
+			memcpy(params.codec.options.ddp.params_value,
+			params32.codec.options.ddp.params_value,
+			sizeof(params32.codec.options.ddp.params_value));
+			memcpy(params.codec.options.ddp.params_id,
+			params32.codec.options.ddp.params_id,
+			sizeof(params32.codec.options.ddp.params_id));
+		break;
+		default:
+			params.codec.options.generic.bw =
+			params32.codec.options.generic.bw;
+		break;
+		}
+		if (!err)
+			err = msm_compr_ioctl_shared(substream, cmd, &params);
+		break;
+	}
+	default:
+		err = msm_compr_ioctl_shared(substream, cmd, arg);
+	}
+bail_out:
+	return err;
+
+}
+#endif
+static int msm_compr_ioctl(struct snd_pcm_substream *substream,
+		unsigned int cmd, void *arg)
+{
+	int err = 0;
+	if (!substream) {
+		pr_err("%s: Invalid params\n", __func__);
+		return -EINVAL;
+	}
+	pr_debug("%s called with cmd = %d\n", __func__, cmd);
+	switch (cmd) {
+	case SNDRV_COMPRESS_TSTAMP: {
+		struct snd_compr_tstamp tstamp;
+		if (!arg) {
+			pr_err("%s: Invalid params Tstamp\n", __func__);
+			return -EINVAL;
+		}
+		err = msm_compr_ioctl_shared(substream, cmd, &tstamp);
+		if (err)
+			pr_err("%s: COMPRESS_TSTAMP failed rc %d\n",
+			__func__, err);
+		if (!err && copy_to_user(arg, &tstamp, sizeof(tstamp))) {
+			pr_err("%s: copytouser failed COMPRESS_TSTAMP\n",
+			__func__);
+			err = -EFAULT;
+		}
+		break;
+	}
+	case SNDRV_COMPRESS_GET_CAPS: {
+		struct snd_compr_caps cap;
+		if (!arg) {
+			pr_err("%s: Invalid params getcaps\n", __func__);
+			return -EINVAL;
+		}
+		pr_debug("SNDRV_COMPRESS_GET_CAPS\n");
+		err = msm_compr_ioctl_shared(substream, cmd, &cap);
+		if (err)
+			pr_err("%s: GET_CAPS failed rc %d\n",
+			__func__, err);
+		if (!err && copy_to_user(arg, &cap, sizeof(cap))) {
+			pr_err("%s: copytouser failed GET_CAPS\n",
+			__func__);
+			err = -EFAULT;
+		}
+		break;
+	}
+	case SNDRV_COMPRESS_SET_PARAMS: {
+		struct snd_compr_params params;
+		if (!arg) {
+			pr_err("%s: Invalid params setparam\n", __func__);
+			return -EINVAL;
+		}
+		if (copy_from_user(&params, arg,
+			sizeof(struct snd_compr_params))) {
+			pr_err("%s: SET_PARAMS\n", __func__);
+			return -EFAULT;
+		}
+		err = msm_compr_ioctl_shared(substream, cmd, &params);
+		if (err)
+			pr_err("%s: SET_PARAMS failed rc %d\n",
+			__func__, err);
+		break;
+	}
+	default:
+		err = msm_compr_ioctl_shared(substream, cmd, arg);
+	}
+	return err;
+}
+
+static int msm_compr_restart(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct compr_audio *compr = runtime->private_data;
+	struct msm_audio *prtd = &compr->prtd;
+	struct audio_aio_write_param param;
+	struct audio_buffer *buf = NULL;
+	struct output_meta_data_st output_meta_data;
+	int time_stamp_flag = 0;
+	int buffer_length = 0;
+
+	pr_debug("%s, trigger restart\n", __func__);
+
+	if (runtime->render_flag & SNDRV_RENDER_STOPPED) {
+		buf = prtd->audio_client->port[IN].buf;
+		pr_debug("%s:writing %d bytes of buffer[%d] to dsp 2\n",
+				__func__, prtd->pcm_count, prtd->out_head);
+		pr_debug("%s:writing buffer[%d] from 0x%08x\n",
+				__func__, prtd->out_head,
+				((unsigned int)buf[0].phys
+				+ (prtd->out_head * prtd->pcm_count)));
+
+		if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
+			time_stamp_flag = SET_TIMESTAMP;
+		else
+			time_stamp_flag = NO_TIMESTAMP;
+		memcpy(&output_meta_data, (char *)(buf->data +
+			prtd->out_head * prtd->pcm_count),
+			COMPRE_OUTPUT_METADATA_SIZE);
+
+		buffer_length = output_meta_data.frame_size;
+		pr_debug("meta_data_length: %d, frame_length: %d\n",
+			 output_meta_data.meta_data_length,
+			 output_meta_data.frame_size);
+		pr_debug("timestamp_msw: %d, timestamp_lsw: %d\n",
+			 output_meta_data.timestamp_msw,
+			 output_meta_data.timestamp_lsw);
+
+		param.paddr = (unsigned long)buf[0].phys
+				+ (prtd->out_head * prtd->pcm_count)
+				+ output_meta_data.meta_data_length;
+		param.len = buffer_length;
+		param.msw_ts = output_meta_data.timestamp_msw;
+		param.lsw_ts = output_meta_data.timestamp_lsw;
+		param.flags = time_stamp_flag;
+		param.uid = prtd->session_id;
+		if (q6asm_async_write(prtd->audio_client,
+					&param) < 0)
+			pr_err("%s:q6asm_async_write failed\n",
+				__func__);
+		else
+			prtd->out_head =
+				(prtd->out_head + 1) & (runtime->periods - 1);
+
+		runtime->render_flag &= ~SNDRV_RENDER_STOPPED;
+		return 0;
+	}
+	return 0;
+}
+
+static int msm_compr_volume_ctl_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	int rc = 0;
+	struct snd_pcm_volume *vol = snd_kcontrol_chip(kcontrol);
+	struct snd_pcm_substream *substream =
+			 vol->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;
+	struct msm_audio *prtd;
+	int volume = ucontrol->value.integer.value[0];
+
+	pr_debug("%s: volume : %x\n", __func__, volume);
+	if (!substream)
+		return -ENODEV;
+	if (!substream->runtime)
+		return 0;
+	prtd = substream->runtime->private_data;
+	if (prtd)
+		rc = compressed_set_volume(prtd, volume);
+
+	return rc;
+}
+
+static int msm_compr_volume_ctl_get(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_pcm_volume *vol = snd_kcontrol_chip(kcontrol);
+	struct snd_pcm_substream *substream =
+			 vol->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;
+	struct msm_audio *prtd;
+
+	pr_debug("%s\n", __func__);
+	if (!substream)
+		return -ENODEV;
+	if (!substream->runtime)
+		return 0;
+	prtd = substream->runtime->private_data;
+	if (prtd)
+		ucontrol->value.integer.value[0] = prtd->volume;
+	return 0;
+}
+
+static int msm_compr_add_controls(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret = 0;
+	struct snd_pcm *pcm = rtd->pcm;
+	struct snd_pcm_volume *volume_info;
+	struct snd_kcontrol *kctl;
+
+	dev_dbg(rtd->dev, "%s, Volume cntrl add\n", __func__);
+	ret = snd_pcm_add_volume_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				      NULL, 1, rtd->dai_link->be_id,
+				      &volume_info);
+	if (ret < 0)
+		return ret;
+	kctl = volume_info->kctl;
+	kctl->put = msm_compr_volume_ctl_put;
+	kctl->get = msm_compr_volume_ctl_get;
+	kctl->tlv.p = compr_rx_vol_gain;
+	return 0;
+}
+
+static struct snd_pcm_ops msm_compr_ops = {
+	.open	   = msm_compr_open,
+	.hw_params	= msm_compr_hw_params,
+	.close	  = msm_compr_close,
+	.ioctl	  = msm_compr_ioctl,
+	.prepare	= msm_compr_prepare,
+	.trigger	= msm_compr_trigger,
+	.pointer	= msm_compr_pointer,
+	.mmap		= msm_compr_mmap,
+	.restart	= msm_compr_restart,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl   = msm_compr_compat_ioctl,
+#endif
+};
+
+static int msm_asoc_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_card *card = rtd->card->snd_card;
+	int ret = 0;
+
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	ret = msm_compr_add_controls(rtd);
+	if (ret)
+		pr_err("%s, kctl add failed\n", __func__);
+	return ret;
+}
+
+static struct snd_soc_platform_driver msm_soc_platform = {
+	.ops		= &msm_compr_ops,
+	.pcm_new	= msm_asoc_pcm_new,
+};
+
+static int msm_compr_probe(struct platform_device *pdev)
+{
+
+	dev_info(&pdev->dev, "%s: dev name %s\n",
+			 __func__, dev_name(&pdev->dev));
+
+	atomic_set(&compressed_audio.audio_ocmem_req, 0);
+	return snd_soc_register_platform(&pdev->dev,
+				   &msm_soc_platform);
+}
+
+static int msm_compr_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+static const struct of_device_id msm_compr_dt_match[] = {
+	{.compatible = "qcom,msm-compr-dsp"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, msm_compr_dt_match);
+
+static struct platform_driver msm_compr_driver = {
+	.driver = {
+		.name = "msm-compr-dsp",
+		.owner = THIS_MODULE,
+		.of_match_table = msm_compr_dt_match,
+	},
+	.probe = msm_compr_probe,
+	.remove = msm_compr_remove,
+};
+
+static int __init msm_soc_platform_init(void)
+{
+	init_waitqueue_head(&the_locks.enable_wait);
+	init_waitqueue_head(&the_locks.eos_wait);
+	init_waitqueue_head(&the_locks.write_wait);
+	init_waitqueue_head(&the_locks.read_wait);
+	init_waitqueue_head(&the_locks.flush_wait);
+
+	return platform_driver_register(&msm_compr_driver);
+}
+module_init(msm_soc_platform_init);
+
+static void __exit msm_soc_platform_exit(void)
+{
+	platform_driver_unregister(&msm_compr_driver);
+}
+module_exit(msm_soc_platform_exit);
+
+MODULE_DESCRIPTION("PCM module platform driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/msm/qdsp6v2/msm-dts-eagle.c b/sound/soc/msm/qdsp6v2/msm-dts-eagle.c
new file mode 100644
index 00000000000..359cdc96ca2
--- /dev/null
+++ b/sound/soc/msm/qdsp6v2/msm-dts-eagle.c
@@ -0,0 +1,1036 @@
+/* Copyright (c) 2014, 2016 The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/msm_ion.h>
+#include <linux/mm.h>
+#include <linux/msm_audio_ion.h>
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/q6adm-v2.h>
+#include <sound/q6asm-v2.h>
+#include <sound/apr_audio-v2.h>
+#include <sound/q6audio-v2.h>
+#include <sound/audio_effects.h>
+#include <sound/hwdep.h>
+
+#include "msm-pcm-routing-v2.h"
+#include "msm-dts-eagle.h"
+#include "q6core.h"
+
+#define ION_MEM_SIZE  131072
+#define DEPC_MAX_SIZE 524288
+
+enum {
+	AUDIO_DEVICE_OUT_EARPIECE = 0,
+	AUDIO_DEVICE_OUT_SPEAKER,
+	AUDIO_DEVICE_OUT_WIRED_HEADSET,
+	AUDIO_DEVICE_OUT_WIRED_HEADPHONE,
+	AUDIO_DEVICE_OUT_BLUETOOTH_SCO,
+	AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET,
+	AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT,
+	AUDIO_DEVICE_OUT_BLUETOOTH_A2DP,
+	AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES,
+	AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER,
+	AUDIO_DEVICE_OUT_AUX_DIGITAL,
+	AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET,
+	AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET,
+	AUDIO_DEVICE_OUT_USB_ACCESSORY,
+	AUDIO_DEVICE_OUT_USB_DEVICE,
+	AUDIO_DEVICE_OUT_REMOTE_SUBMIX,
+	AUDIO_DEVICE_OUT_ANC_HEADSET,
+	AUDIO_DEVICE_OUT_ANC_HEADPHONE,
+	AUDIO_DEVICE_OUT_PROXY,
+	AUDIO_DEVICE_OUT_FM,
+	AUDIO_DEVICE_OUT_FM_TX,
+
+	AUDIO_DEVICE_OUT_COUNT
+};
+
+#define AUDIO_DEVICE_COMBO 0x400000 /* bit 23 */
+
+enum { /* cache block */
+	CB_0 = 0,
+	CB_1,
+	CB_2,
+	CB_3,
+	CB_4,
+	CB_5,
+	CB_6,
+	CB_7,
+
+	CB_COUNT
+};
+
+enum { /* cache block description */
+	CBD_DEV_MASK = 0,
+	CBD_OFFSG,
+	CBD_CMD0,
+	CBD_SZ0,
+	CBD_OFFS1,
+	CBD_CMD1,
+	CBD_SZ1,
+	CBD_OFFS2,
+	CBD_CMD2,
+	CBD_SZ2,
+	CBD_OFFS3,
+	CBD_CMD3,
+	CBD_SZ3,
+
+	CBD_COUNT,
+};
+
+static __s32 fx_logN(__s32 x)
+{
+	__s32 t, y = 0xa65af;
+	if (x < 0x00008000) {
+		x <<= 16; y -= 0xb1721; }
+	if (x < 0x00800000) {
+		x <<= 8; y -= 0x58b91; }
+	if (x < 0x08000000) {
+		x <<= 4; y -= 0x2c5c8; }
+	if (x < 0x20000000) {
+		x <<= 2; y -= 0x162e4; }
+	if (x < 0x40000000) {
+		x <<= 1; y -= 0x0b172; }
+	t = x + (x >> 1);
+	if ((t & 0x80000000) == 0) {
+		x = t; y -= 0x067cd; }
+	t = x + (x >> 2);
+	if ((t & 0x80000000) == 0) {
+		x = t; y -= 0x03920; }
+	t = x + (x >> 3);
+	if ((t & 0x80000000) == 0) {
+		x = t; y -= 0x01e27; }
+	t = x + (x >> 4);
+	if ((t & 0x80000000) == 0) {
+		x = t; y -= 0x00f85; }
+	t = x + (x >> 5);
+	if ((t & 0x80000000) == 0) {
+		x = t; y -= 0x007e1; }
+	t = x + (x >> 6);
+	if ((t & 0x80000000) == 0) {
+		x = t; y -= 0x003f8; }
+	t = x + (x >> 7);
+	if ((t & 0x80000000) == 0) {
+		x = t; y -= 0x001fe; }
+	x = 0x80000000 - x;
+	y -= x >> 15;
+	return y;
+}
+
+static inline void *getd(struct dts_eagle_param_desc *depd)
+{
+	return (void *)(((char *)depd) + sizeof(struct dts_eagle_param_desc));
+}
+
+
+static int ref_cnt;
+/* dts eagle parameter cache */
+static char *_depc;
+static __s32 _depc_size;
+static __s32 _c_bl[CB_COUNT][CBD_COUNT];
+static __u32 _device_primary;
+static __u32 _device_all;
+/* ION states */
+static struct ion_client *ion_client;
+static struct ion_handle *ion_handle;
+static phys_addr_t paddr;
+static size_t pa_len;
+static void *vaddr;
+
+#define SEC_BLOB_MAX_CNT 10
+#define SEC_BLOB_MAX_SIZE 0x4004 /*extra 4 for size*/
+static char *sec_blob[SEC_BLOB_MAX_CNT];
+
+#define MAX_INBAND_PAYLOAD_SIZE 4000
+
+/* multi-copp support */
+static int _cidx[AFE_MAX_PORTS] = {-1};
+
+/* volume controls */
+#define VOL_CMD_CNT_MAX 10
+static __s32 vol_cmd_cnt;
+static __s32 **vol_cmds;
+struct vol_cmds_d_ {
+	__s32 d[4];
+};
+static struct vol_cmds_d_ *vol_cmds_d;
+
+static void volume_cmds_free(void)
+{
+	int i;
+	for (i = 0; i < vol_cmd_cnt; i++)
+		kfree(vol_cmds[i]);
+	vol_cmd_cnt = 0;
+	kfree(vol_cmds);
+	kfree(vol_cmds_d);
+	vol_cmds = NULL;
+	vol_cmds_d = NULL;
+}
+
+static __s32 volume_cmds_alloc1(__s32 size)
+{
+	volume_cmds_free();
+	vol_cmd_cnt = size;
+	vol_cmds = kzalloc(vol_cmd_cnt * sizeof(int *), GFP_KERNEL);
+	if (vol_cmds) {
+		vol_cmds_d = kzalloc(vol_cmd_cnt * sizeof(struct vol_cmds_d_),
+					GFP_KERNEL);
+	}
+	if (vol_cmds_d)
+		return 0;
+	volume_cmds_free();
+	return -ENOMEM;
+}
+
+/* assumes size is equal or less than 0xFFF */
+static __s32 volume_cmds_alloc2(__s32 idx, __s32 size)
+{
+	kfree(vol_cmds[idx]);
+	vol_cmds[idx] = kzalloc(size, GFP_KERNEL);
+	if (vol_cmds[idx])
+		return 0;
+	vol_cmds_d[idx].d[0] = 0;
+	return -ENOMEM;
+}
+
+static void _init_cb_descs(void)
+{
+	int i;
+	for (i = 0; i < CB_COUNT; i++) {
+		_c_bl[i][CBD_DEV_MASK] = 0;
+		_c_bl[i][CBD_OFFSG] = _c_bl[i][CBD_OFFS1] =
+		_c_bl[i][CBD_OFFS2] = _c_bl[i][CBD_OFFS3] =
+		0xFFFFFFFF;
+		_c_bl[i][CBD_CMD0] = _c_bl[i][CBD_SZ0] =
+		_c_bl[i][CBD_CMD1] = _c_bl[i][CBD_SZ1] =
+		_c_bl[i][CBD_CMD2] = _c_bl[i][CBD_SZ2] =
+		_c_bl[i][CBD_CMD3] = _c_bl[i][CBD_SZ3] = 0;
+	}
+}
+
+static __u32 _get_dev_mask_for_pid(int pid)
+{
+	switch (pid) {
+	case SLIMBUS_0_RX:
+		return (1 << AUDIO_DEVICE_OUT_EARPIECE) |
+			(1 << AUDIO_DEVICE_OUT_SPEAKER) |
+			(1 << AUDIO_DEVICE_OUT_WIRED_HEADSET) |
+			(1 << AUDIO_DEVICE_OUT_WIRED_HEADPHONE) |
+			(1 << AUDIO_DEVICE_OUT_ANC_HEADSET) |
+			(1 << AUDIO_DEVICE_OUT_ANC_HEADPHONE);
+	case INT_BT_SCO_RX:
+		return (1 << AUDIO_DEVICE_OUT_BLUETOOTH_SCO) |
+			(1 << AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET) |
+			(1 << AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT);
+	case RT_PROXY_PORT_001_RX:
+		return (1 << AUDIO_DEVICE_OUT_BLUETOOTH_A2DP) |
+			(1 << AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES) |
+			(1 << AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER) |
+			(1 << AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET) |
+			(1 << AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET) |
+			(1 << AUDIO_DEVICE_OUT_USB_ACCESSORY) |
+			(1 << AUDIO_DEVICE_OUT_USB_DEVICE) |
+			(1 << AUDIO_DEVICE_OUT_PROXY);
+	case HDMI_RX:
+		return 1 << AUDIO_DEVICE_OUT_AUX_DIGITAL;
+	case INT_FM_RX:
+		return 1 << AUDIO_DEVICE_OUT_FM;
+	case INT_FM_TX:
+		return 1 << AUDIO_DEVICE_OUT_FM_TX;
+	default:
+		return 0;
+	}
+}
+
+static int _get_pid_from_dev(__u32 device)
+{
+	if (device & (1 << AUDIO_DEVICE_OUT_EARPIECE) ||
+	    device & (1 << AUDIO_DEVICE_OUT_SPEAKER) ||
+	    device & (1 << AUDIO_DEVICE_OUT_WIRED_HEADSET) ||
+	    device & (1 << AUDIO_DEVICE_OUT_WIRED_HEADPHONE) ||
+	    device & (1 << AUDIO_DEVICE_OUT_ANC_HEADSET) ||
+	    device & (1 << AUDIO_DEVICE_OUT_ANC_HEADPHONE)) {
+		return SLIMBUS_0_RX;
+	} else if (device & (1 << AUDIO_DEVICE_OUT_BLUETOOTH_SCO) ||
+		   device & (1 << AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET) ||
+		   device & (1 << AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT)) {
+		return INT_BT_SCO_RX;
+	} else if (device & (1 << AUDIO_DEVICE_OUT_BLUETOOTH_A2DP) ||
+		   device & (1 << AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES) ||
+		   device & (1 << AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER) ||
+		   device & (1 << AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET) ||
+		   device & (1 << AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET) ||
+		   device & (1 << AUDIO_DEVICE_OUT_USB_ACCESSORY) ||
+		   device & (1 << AUDIO_DEVICE_OUT_USB_DEVICE) ||
+		   device & (1 << AUDIO_DEVICE_OUT_PROXY)) {
+		return RT_PROXY_PORT_001_RX;
+	} else if (device & (1 << AUDIO_DEVICE_OUT_AUX_DIGITAL)) {
+		return HDMI_RX;
+	} else if (device & (1 << AUDIO_DEVICE_OUT_FM)) {
+		return INT_FM_RX;
+	} else if (device & (1 << AUDIO_DEVICE_OUT_FM_TX)) {
+		return INT_FM_TX;
+	}
+	return 0;
+}
+
+static __u32 _get_cb_for_dev(int device)
+{
+	__u32 i;
+	if (device & AUDIO_DEVICE_COMBO) {
+		for (i = 0; i < CB_COUNT; i++) {
+			if ((_c_bl[i][CBD_DEV_MASK] & device) == device)
+				return i;
+		}
+	} else {
+		for (i = 0; i < CB_COUNT; i++) {
+			if ((_c_bl[i][CBD_DEV_MASK] & device) &&
+			    !(_c_bl[i][CBD_DEV_MASK] & AUDIO_DEVICE_COMBO))
+				return i;
+		}
+	}
+	pr_err("DTS_EAGLE_DRIVER: %s - device %i not found, returning 0\n",
+		   __func__, device);
+	return 0;
+}
+
+static int _is_port_open_and_eagle(int pid)
+{
+	return 1; /*
+	if (msm_routing_check_backend_enabled(pid))
+		return 1;
+	return 0;*/
+}
+
+static void reg_ion_mem(void)
+{
+	msm_audio_ion_alloc("DTS_EAGLE", &ion_client, &ion_handle, ION_MEM_SIZE,
+				 &paddr, &pa_len, &vaddr);
+}
+
+void msm_dts_ion_memmap(struct param_outband *po)
+{
+	po->size = ION_MEM_SIZE;
+	po->kvaddr = vaddr;
+	po->paddr = paddr;
+}
+
+static void unreg_ion_mem(void)
+{
+	msm_audio_ion_free(ion_client, ion_handle);
+}
+
+int msm_dts_eagle_handler_pre(struct audio_client *ac, long *arg)
+{
+	struct dts_eagle_param_desc depd_s, *depd = &depd_s;
+	__s32 offset, ret = 0;
+
+	pr_info("DTS_EAGLE_DRIVER_PRE: %s called (set pre-param)\n", __func__);
+
+	depd->id = (__u32) *arg++;
+	depd->size = (__s32) *arg++;
+	depd->offset = (__s32) *arg++;
+	depd->device = (__u32) *arg++;
+
+	if (depd->device & 0x80000000) {
+		void *buf, *buf_m = NULL;
+		pr_debug("DTS_EAGLE_DRIVER_PRE: get requested\n");
+		depd->device &= 0x7FFFFFFF;
+		if (depd->offset == -1) {
+			pr_debug("DTS_EAGLE_DRIVER_PRE: get from dsp requested\n");
+			if (depd->size > MAX_INBAND_PAYLOAD_SIZE) {
+				pr_err("DTS_EAGLE_DRIVER_PRE: param size for inband get too big (size is %d, max inband size is %d)\n",
+				depd->size, MAX_INBAND_PAYLOAD_SIZE);
+				return -EINVAL;
+			}
+			buf = buf_m = kzalloc(depd->size, GFP_KERNEL);
+			if (!buf_m) {
+				pr_err("DTS_EAGLE_DRIVER_PRE: out of memory\n");
+				return -ENOMEM;
+			} else if (q6asm_dts_eagle_get(ac, depd->id,
+							depd->size, buf) < 0) {
+				pr_info("DTS_EAGLE_DRIVER_PRE: asm failed, trying core\n");
+				if (core_dts_eagle_get(depd->id, depd->size,
+						       buf) < 0) {
+					pr_err("DTS_EAGLE_DRIVER_PRE: get from qdsp failed (topology not eagle or closed)\n");
+					ret = -EFAULT;
+					goto DTS_EAGLE_IOCTL_GET_PARAM_PRE_EXIT;
+				}
+			}
+		} else {
+			__u32 tgt = _get_cb_for_dev(depd->device);
+			offset = _c_bl[tgt][CBD_OFFSG] + depd->offset;
+			if ((offset + depd->size) > _depc_size) {
+				pr_err("DTS_EAGLE_DRIVER_PRE: invalid size %d and/or offset %d\n",
+					depd->size, offset);
+				return -EINVAL;
+			}
+			buf = (void *)&_depc[offset];
+		}
+DTS_EAGLE_IOCTL_GET_PARAM_PRE_EXIT:
+		kfree(buf_m);
+		return (int)ret;
+	} else {
+		__u32 tgt = _get_cb_for_dev(depd->device), i, *p_depc;
+		offset = _c_bl[tgt][CBD_OFFSG] + depd->offset;
+		if ((offset + depd->size) > _depc_size) {
+			pr_err("DTS_EAGLE_DRIVER_PRE: invalid size %i and/or offset %i for parameter (cache is size %u)\n",
+					depd->size, offset, _depc_size);
+			return -EINVAL;
+		}
+		p_depc = (__u32 *)(&_depc[offset]);
+		for (i = 0; i < depd->size; i++)
+			*p_depc++ = (__u32)*arg++;
+		pr_debug("DTS_EAGLE_DRIVER_PRE: param info: param = 0x%X, size = %i, offset = %i, device = %i, cache block %i, global offset = %i, first bytes as integer = %i.\n",
+			  depd->id, depd->size, depd->offset, depd->device,
+			  tgt, offset, *(int *)&_depc[offset]);
+		if (q6asm_dts_eagle_set(ac, depd->id, depd->size,
+					(void *)&_depc[offset])) {
+			pr_err("DTS_EAGLE_DRIVER_PRE: q6asm_dts_eagle_set failed with id = 0x%X, size = %d, offset = %d\n",
+				depd->id, depd->size, depd->offset);
+		} else {
+			pr_debug("DTS_EAGLE_DRIVER_PRE: q6asm_dts_eagle_set succeeded with id = 0x%X, size = %d, offset = %d\n",
+				 depd->id, depd->size, depd->offset);
+		}
+	}
+	return (int)ret;
+}
+
+static const __s32 log10_10_inv_x20 = 0x0008af84;
+int msm_dts_eagle_set_volume(struct audio_client *ac, int lgain, int rgain)
+{
+	__s32 i, val;
+	__u32 idx;
+
+	pr_debug("DTS_EAGLE_DRIVER_VOLUME: entry: vol_cmd_cnt = %i, lgain = %i, rgain = %i",
+		 vol_cmd_cnt, lgain, rgain);
+
+	if (_depc_size == 0) {
+		pr_err("DTS_EAGLE_DRIVER_VOLUME: driver cache not initialized.\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < vol_cmd_cnt; i++) {
+		if (vol_cmds_d[i].d[0] & 0x8000) {
+			idx = (sizeof(struct dts_eagle_param_desc)/sizeof(int))
+				+ (vol_cmds_d[i].d[0] & 0x3FF);
+			val = fx_logN(((__s32)(lgain+rgain)) << 2);
+			val = ((long long)val * log10_10_inv_x20) >> 16;
+			vol_cmds[i][idx] = (__s32)clamp((int)(((long long)val *
+						     vol_cmds_d[i].d[1]) >> 16),
+						     vol_cmds_d[i].d[2],
+						     vol_cmds_d[i].d[3]);
+			pr_debug("DTS_EAGLE_DRIVER_VOLUME: loop %i cmd desc found %i, idx = %i. volume info: lgain = %i, rgain = %i, volume = %i (scale %i, min %i, max %i)\n",
+				 i, vol_cmds_d[i].d[0], idx, lgain,
+				 rgain, vol_cmds[i][idx], vol_cmds_d[i].d[1],
+				 vol_cmds_d[i].d[2], vol_cmds_d[i].d[3]);
+		}
+		idx = _get_cb_for_dev(_device_primary);
+		val = _c_bl[idx][CBD_OFFSG] + vol_cmds[i][2];
+		if ((val + vol_cmds[i][1]) > _depc_size) {
+			pr_err("DTS_EAGLE_DRIVER_VOLUME: volume size (%i) + offset (%i) out of bounds %i.\n",
+				val, vol_cmds[i][1], _depc_size);
+			return -EINVAL;
+		}
+		memcpy((void *)&_depc[val], &vol_cmds[i][4], vol_cmds[i][1]);
+		if (q6asm_dts_eagle_set(ac, vol_cmds[i][0],
+			vol_cmds[i][1], (void *)&_depc[val])) {
+			pr_err("DTS_EAGLE_DRIVER_VOLUME: loop %i - volume set failed with id 0x%X, size %i, offset %i, cmd_desc %i, scale %i, min %i, max %i, data(...) %i\n",
+				i, vol_cmds[i][0], vol_cmds[i][1],
+				vol_cmds[i][2], vol_cmds_d[i].d[0],
+				vol_cmds_d[i].d[1], vol_cmds_d[i].d[2],
+				vol_cmds_d[i].d[3], vol_cmds[i][4]);
+		} else {
+			pr_debug("DTS_EAGLE_DRIVER_VOLUME: loop %i - volume set succeeded with id 0x%X, size %i, offset %i, cmd_desc %i, scale %i, min %i, max %i, data(...) %i\n",
+				 i, vol_cmds[i][0], vol_cmds[i][1],
+				 vol_cmds[i][2], vol_cmds_d[i].d[0],
+				 vol_cmds_d[i].d[1], vol_cmds_d[i].d[2],
+				 vol_cmds_d[i].d[3], vol_cmds[i][4]);
+		}
+	}
+	return 0;
+}
+
+int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
+{
+	__s32 ret = 0;
+	switch (cmd) {
+	case DTS_EAGLE_IOCTL_GET_CACHE_SIZE: {
+		pr_info("DTS_EAGLE_DRIVER_POST: %s called with control 0x%X (get param cache size)\n",
+			__func__, cmd);
+		if (copy_to_user((void *)arg, &_depc_size,
+				 sizeof(_depc_size))) {
+			pr_err("DTS_EAGLE_DRIVER_POST: error writing size\n");
+			return -EFAULT;
+		}
+		break;
+	}
+	case DTS_EAGLE_IOCTL_SET_CACHE_SIZE: {
+		__s32 size = 0;
+		pr_info("DTS_EAGLE_DRIVER_POST: %s called with control 0x%X (allocate param cache)\n",
+			__func__, cmd);
+		if (copy_from_user((void *)&size, (void *)arg, sizeof(size))) {
+			pr_err("DTS_EAGLE_DRIVER_POST: error copying size (src:%pK, tgt:%pK, size:%zu)\n",
+				(void *)arg, &size, sizeof(size));
+			return -EFAULT;
+		} else if (size < 0 || size > DEPC_MAX_SIZE) {
+			pr_err("DTS_EAGLE_DRIVER_POST: cache size %d not allowed (min 0, max %d)\n",
+				size, DEPC_MAX_SIZE);
+			return -EINVAL;
+		}
+		if (_depc) {
+			pr_info("DTS_EAGLE_DRIVER_POST: previous param cache of size %u freed\n",
+				_depc_size);
+			_depc_size = 0;
+			kfree(_depc);
+			_depc = NULL;
+		}
+		if (size) {
+			_depc = kzalloc(size, GFP_KERNEL);
+		} else {
+			pr_info("DTS_EAGLE_DRIVER_POST: %d bytes requested for param cache, nothing allocated\n",
+				size);
+		}
+		if (_depc) {
+			pr_info("DTS_EAGLE_DRIVER_POST: %d bytes allocated for param cache\n",
+				size);
+			_depc_size = size;
+		} else {
+			pr_err("DTS_EAGLE_DRIVER_POST: error allocating param cache (kzalloc failed on %d bytes)\n",
+				size);
+			_depc_size = 0;
+			return -ENOMEM;
+		}
+		break;
+	}
+	case DTS_EAGLE_IOCTL_GET_PARAM: {
+		struct dts_eagle_param_desc depd;
+		__s32 offset = 0;
+		void *buf, *buf_m = NULL;
+		pr_info("DTS_EAGLE_DRIVER_POST: %s called, control 0x%X (get param)\n",
+			__func__, cmd);
+		if (copy_from_user((void *)&depd, (void *)arg, sizeof(depd))) {
+			pr_err("DTS_EAGLE_DRIVER_POST: error copying dts_eagle_param_desc (src:%pK, tgt:%pK, size:%zu)\n",
+				(void *)arg, &depd, sizeof(depd));
+			return -EFAULT;
+		}
+		if (depd.offset == -1) {
+			__u32 pid = _get_pid_from_dev(depd.device), cidx;
+			cidx = adm_validate_and_get_port_index(pid);
+			pr_info("DTS_EAGLE_DRIVER_POST: get from qdsp requested (port id 0x%X)\n",
+				pid);
+			if (depd.size > MAX_INBAND_PAYLOAD_SIZE) {
+				pr_err("DTS_EAGLE_DRIVER_POST: param size for inband get too big (size is %d, max inband size is %d)\n",
+				depd.size, MAX_INBAND_PAYLOAD_SIZE);
+				return -EINVAL;
+			}
+			buf = buf_m = kzalloc(depd.size, GFP_KERNEL);
+			if (!buf_m) {
+				pr_err("DTS_EAGLE_DRIVER_POST: out of memory\n");
+				return -ENOMEM;
+			} else if (adm_dts_eagle_get(pid, _cidx[cidx], depd.id,
+						     buf, depd.size) < 0) {
+				pr_info("DTS_EAGLE_DRIVER_POST: get from qdsp via adm with port id 0x%X failed, trying core\n",
+					pid);
+				if (core_dts_eagle_get(depd.id, depd.size,
+							buf) < 0) {
+					pr_err("DTS_EAGLE_DRIVER_POST: get from qdsp failed\n");
+					ret = -EFAULT;
+					goto DTS_EAGLE_IOCTL_GET_PARAM_EXIT;
+				}
+			}
+		} else {
+			__u32 cb = _get_cb_for_dev(depd.device);
+			offset = _c_bl[cb][CBD_OFFSG] + depd.offset;
+			if ((offset + depd.size) > _depc_size) {
+				pr_err("DTS_EAGLE_DRIVER_POST: invalid size %d and/or offset %d\n",
+					depd.size, offset);
+				return -EINVAL;
+			}
+			buf = (void *)&_depc[offset];
+		}
+		if (copy_to_user((void *)(((char *)arg)+sizeof(depd)),
+						  buf, depd.size)) {
+			pr_err("DTS_EAGLE_DRIVER_POST: error getting param\n");
+			ret = -EFAULT;
+			goto DTS_EAGLE_IOCTL_GET_PARAM_EXIT;
+		}
+DTS_EAGLE_IOCTL_GET_PARAM_EXIT:
+		kfree(buf_m);
+		break;
+	}
+	case DTS_EAGLE_IOCTL_SET_PARAM: {
+		struct dts_eagle_param_desc depd;
+		__s32 offset = 0, just_set_cache = 0;
+		__u32 tgt;
+		pr_info("DTS_EAGLE_DRIVER_POST: %s called, control 0x%X (set param)\n",
+			__func__, cmd);
+		if (copy_from_user((void *)&depd, (void *)arg, sizeof(depd))) {
+			pr_err("DTS_EAGLE_DRIVER_POST: error copying dts_eagle_param_desc (src:%pK, tgt:%pK, size:%zu)\n",
+				(void *)arg, &depd, sizeof(depd));
+			return -EFAULT;
+		}
+		if (depd.device & (1<<31)) {
+			pr_info("DTS_EAGLE_DRIVER_POST: 'just set cache' requested.\n");
+			just_set_cache = 1;
+			depd.device &= 0x7FFFFFFF;
+		}
+		tgt = _get_cb_for_dev(depd.device);
+		offset = _c_bl[tgt][CBD_OFFSG] + depd.offset;
+		if ((offset + depd.size) > _depc_size) {
+			pr_err("DTS_EAGLE_DRIVER_POST: invalid size %i and/or offset %i for parameter (target cache block %i with offset %i, global cache is size %u)\n",
+				depd.size, offset, tgt,
+				_c_bl[tgt][CBD_OFFSG], _depc_size);
+			return -EINVAL;
+		}
+		if (copy_from_user((void *)&_depc[offset],
+				   (void *)(((char *)arg)+sizeof(depd)),
+					depd.size)) {
+			pr_err("DTS_EAGLE_DRIVER_POST: error copying param to cache (src:%pK, tgt:%pK, size:%i)\n",
+				((char *)arg)+sizeof(depd),
+				&_depc[offset], depd.size);
+			return -EFAULT;
+		}
+		pr_debug("DTS_EAGLE_DRIVER_POST: param info: param = 0x%X, size = %i, offset = %i, device = %i, cache block %i, global offset = %i, first bytes as integer = %i.\n",
+			  depd.id, depd.size, depd.offset, depd.device,
+			  tgt, offset, *(int *)&_depc[offset]);
+		if (!just_set_cache) {
+			__u32 pid = _get_pid_from_dev(depd.device), cidx;
+			cidx = adm_validate_and_get_port_index(pid);
+			pr_debug("DTS_EAGLE_DRIVER_POST: checking for active Eagle for device %i (port id 0x%X)\n",
+				depd.device, pid);
+			if (_is_port_open_and_eagle(pid)) {
+				if (adm_dts_eagle_set(pid, _cidx[cidx], depd.id,
+				    (void *)&_depc[offset], depd.size) < 0) {
+					pr_err("DTS_EAGLE_DRIVER_POST: adm_dts_eagle_set failed with id = 0x%X, size = %i, offset = %i, device = %i, global offset = %i\n",
+						depd.id, depd.size, depd.offset,
+						depd.device, offset);
+				} else {
+					pr_debug("DTS_EAGLE_DRIVER_POST: adm_dts_eagle_set succeeded with id = 0x%X, size = %i, offset = %i, device = %i, global offset = %i\n",
+						depd.id, depd.size, depd.offset,
+						depd.device, offset);
+				}
+			} else {
+				pr_debug("DTS_EAGLE_DRIVER_POST: port id 0x%X not active or not Eagle\n",
+					 pid);
+			}
+		}
+		break;
+	}
+	case DTS_EAGLE_IOCTL_SET_CACHE_BLOCK: {
+		__u32 b_[CBD_COUNT+1], *b = &b_[1], cb;
+		pr_info("DTS_EAGLE_DRIVER_POST: %s called with control 0x%X (set param cache block)\n",
+			__func__, cmd);
+		if (copy_from_user((void *)b_, (void *)arg, sizeof(b_))) {
+			pr_err("DTS_EAGLE_DRIVER_POST: error copying cache block data (src:%pK, tgt:%pK, size:%zu)\n",
+				(void *)arg, b_, sizeof(b_));
+			return -EFAULT;
+		}
+		cb = b_[0];
+		if (cb >= CB_COUNT) {
+			pr_err("DTS_EAGLE_DRIVER_POST: cache block %u out of range (max %u)\n",
+			cb, CB_COUNT-1);
+			return -EINVAL;
+		}
+		if ((b[CBD_OFFSG]+b[CBD_OFFS1]+b[CBD_SZ1]) >= _depc_size ||
+			(b[CBD_OFFSG]+b[CBD_OFFS2]+b[CBD_SZ2]) >= _depc_size ||
+			(b[CBD_OFFSG]+b[CBD_OFFS3]+b[CBD_SZ3]) >= _depc_size) {
+			pr_err("DTS_EAGLE_DRIVER_POST: cache block bounds out of range\n");
+			return -EINVAL;
+		}
+		memcpy(_c_bl[cb], b, sizeof(_c_bl[cb]));
+		pr_debug("DTS_EAGLE_DRIVER_POST: cache block %i set: devices 0x%X, global offset %u, offsets 1:%u 2:%u 3:%u, cmds/sizes 0:0x%X %u 1:0x%X %u 2:0x%X %u 3:0x%X %u\n",
+		cb, _c_bl[cb][CBD_DEV_MASK], _c_bl[cb][CBD_OFFSG],
+		_c_bl[cb][CBD_OFFS1], _c_bl[cb][CBD_OFFS2],
+		_c_bl[cb][CBD_OFFS3], _c_bl[cb][CBD_CMD0], _c_bl[cb][CBD_SZ0],
+		_c_bl[cb][CBD_CMD1], _c_bl[cb][CBD_SZ1], _c_bl[cb][CBD_CMD2],
+		_c_bl[cb][CBD_SZ2], _c_bl[cb][CBD_CMD3], _c_bl[cb][CBD_SZ3]);
+		break;
+	}
+	case DTS_EAGLE_IOCTL_SET_ACTIVE_DEVICE: {
+		__u32 data[2];
+		pr_info("DTS_EAGLE_DRIVER_POST: %s called with control 0x%X (set active device)\n",
+			__func__, cmd);
+		if (copy_from_user((void *)data, (void *)arg, sizeof(data))) {
+			pr_err("DTS_EAGLE_DRIVER_POST: error copying active device data (src:%pK, tgt:%pK, size:%zu)\n",
+				(void *)arg, data, sizeof(data));
+			return -EFAULT;
+		}
+		if (data[1] != 0) {
+			_device_primary = data[0];
+			pr_debug("DTS_EAGLE_DRIVER_POST: primary device %i\n",
+				 data[0]);
+		} else {
+			_device_all = data[0];
+			pr_debug("DTS_EAGLE_DRIVER_POST: all devices 0x%X\n",
+				 data[0]);
+		}
+		break;
+	}
+	case DTS_EAGLE_IOCTL_GET_LICENSE: {
+		__u32 target = 0;
+		__s32 size = 0, size_only;
+		pr_info("DTS_EAGLE_DRIVER_POST: %s called with control 0x%X (get license)\n",
+			__func__, cmd);
+		if (copy_from_user((void *)&target, (void *)arg,
+				   sizeof(target))) {
+			pr_err("DTS_EAGLE_DRIVER_POST: error reading license index. (src:%pK, tgt:%pK, size:%zu)\n",
+				(void *)arg, &target, sizeof(target));
+			return -EFAULT;
+		}
+		size_only = target & (1<<31) ? 1 : 0;
+		target &= 0x7FFFFFFF;
+		if (target < 0 || target >= SEC_BLOB_MAX_CNT) {
+			pr_err("DTS_EAGLE_DRIVER_POST: license index %i out of bounds (max index is %i)\n",
+				   target, SEC_BLOB_MAX_CNT);
+			return -EINVAL;
+		}
+		if (sec_blob[target] == NULL) {
+			pr_err("DTS_EAGLE_DRIVER_POST: license index %i never initialized.\n",
+				   target);
+			return -EINVAL;
+		}
+		size = ((__s32 *)sec_blob[target])[0];
+		if (size <= 0 || size > SEC_BLOB_MAX_SIZE) {
+			pr_err("DTS_EAGLE_DRIVER_POST: license size %i for index %i invalid (min size is 1, max size is %i).\n",
+				   size, target, SEC_BLOB_MAX_SIZE);
+			return -EINVAL;
+		}
+		if (size_only) {
+			pr_info("DTS_EAGLE_DRIVER_POST: reporting size of license data only\n");
+			if (copy_to_user((void *)(((char *)arg)+sizeof(target)),
+				 (void *)&size, sizeof(size))) {
+				pr_err("DTS_EAGLE_DRIVER_POST: error copying license size.\n");
+				return -EFAULT;
+			}
+		} else if (copy_to_user((void *)(((char *)arg)+sizeof(target)),
+			   (void *)&(((__s32 *)sec_blob[target])[1]), size)) {
+			pr_err("DTS_EAGLE_DRIVER_POST: error copying license data.\n");
+			return -EFAULT;
+		} else {
+			pr_debug("DTS_EAGLE_DRIVER_POST: license file %i bytes long from license index %i returned to user.\n",
+				  size, target);
+		}
+		break;
+	}
+	case DTS_EAGLE_IOCTL_SET_LICENSE: {
+		__s32 target[2] = {0, 0};
+		pr_info("DTS_EAGLE_DRIVER_POST: %s called with control 0x%X (set license)\n",
+			__func__, cmd);
+		if (copy_from_user((void *)target, (void *)arg,
+				   sizeof(target))) {
+			pr_err("DTS_EAGLE_DRIVER_POST: error reading license index (src:%pK, tgt:%pK, size:%zu)\n",
+				(void *)arg, target, sizeof(target));
+			return -EFAULT;
+		}
+		if (target[0] < 0 || target[0] >= SEC_BLOB_MAX_CNT) {
+			pr_err("DTS_EAGLE_DRIVER_POST: license index %i out of bounds (max index is %i)\n",
+				   target[0], SEC_BLOB_MAX_CNT-1);
+			return -EINVAL;
+		}
+		if (target[1] == 0) {
+			pr_info("DTS_EAGLE_DRIVER_POST: request to free license index %i\n",
+				 target[0]);
+			kfree(sec_blob[target[0]]);
+			sec_blob[target[0]] = NULL;
+			break;
+		}
+		if (target[1] <= 0 || target[1] >= SEC_BLOB_MAX_SIZE) {
+			pr_err("DTS_EAGLE_DRIVER_POST: license size %i for index %i invalid (min size is 1, max size is %i).\n",
+				   target[1], target[0], SEC_BLOB_MAX_SIZE);
+			return -EINVAL;
+		}
+		if (sec_blob[target[0]] != NULL) {
+			if (((__s32 *)sec_blob[target[0]])[1] != target[1]) {
+				pr_info("DTS_EAGLE_DRIVER_POST: request new size for already allocated license index %i\n",
+						target[0]);
+				kfree(sec_blob[target[0]]);
+				sec_blob[target[0]] = NULL;
+			}
+		}
+		pr_debug("DTS_EAGLE_DRIVER_POST: allocating %i bytes for license index %i\n",
+				  target[1], target[0]);
+		sec_blob[target[0]] = kzalloc(target[1] + 4, GFP_KERNEL);
+		if (!sec_blob[target[0]]) {
+			pr_err("DTS_EAGLE_DRIVER_POST: error allocating license index %i (kzalloc failed on %i bytes)\n",
+					target[0], target[1]);
+			return -ENOMEM;
+		}
+		((__s32 *)sec_blob[target[0]])[0] = target[1];
+		if (copy_from_user((void *)&(((__s32 *)sec_blob[target[0]])[1]),
+				(void *)(((char *)arg)+sizeof(target)),
+				target[1])) {
+			pr_err("DTS_EAGLE_DRIVER_POST: error copying license to index %i, size %i (src:%pK, tgt:%pK, size:%i)\n",
+					target[0], target[1],
+					((char *)arg)+sizeof(target),
+					&(((__s32 *)sec_blob[target[0]])[1]),
+					target[1]);
+			return -EFAULT;
+		} else {
+			pr_debug("DTS_EAGLE_DRIVER_POST: license file %i bytes long copied to index license index %i\n",
+				  target[1], target[0]);
+		}
+		break;
+	}
+	case DTS_EAGLE_IOCTL_SEND_LICENSE: {
+		__s32 target = 0;
+		pr_info("DTS_EAGLE_DRIVER_POST: %s called with control 0x%X (send license)\n",
+			__func__, cmd);
+		if (copy_from_user((void *)&target, (void *)arg,
+				   sizeof(target))) {
+			pr_err("DTS_EAGLE_DRIVER_POST: error reading license index (src:%pK, tgt:%pK, size:%zu)\n",
+				(void *)arg, &target, sizeof(target));
+			return -EFAULT;
+		}
+		if (target >= SEC_BLOB_MAX_CNT) {
+			pr_err("DTS_EAGLE_DRIVER_POST: license index %i out of bounds (max index is %i)\n",
+					target, SEC_BLOB_MAX_CNT-1);
+			return -EINVAL;
+		}
+		if (!sec_blob[target] || ((__s32 *)sec_blob[target])[0] <= 0) {
+			pr_err("DTS_EAGLE_DRIVER_POST: license index %i is invalid\n",
+				target);
+			return -EINVAL;
+		}
+		if (core_dts_eagle_set(((__s32 *)sec_blob[target])[0],
+				(char *)&((__s32 *)sec_blob[target])[1]) < 0) {
+			pr_err("DTS_EAGLE_DRIVER_POST: core_dts_eagle_set failed with id = %i\n",
+				target);
+		} else {
+			pr_debug("DTS_EAGLE_DRIVER_POST: core_dts_eagle_set succeeded with id = %i\n",
+				 target);
+		}
+		break;
+	}
+	case DTS_EAGLE_IOCTL_SET_VOLUME_COMMANDS: {
+		__s32 spec = 0;
+		pr_info("DTS_EAGLE_DRIVER_POST: %s called with control 0x%X (set volume commands)\n",
+			__func__, cmd);
+		if (copy_from_user((void *)&spec, (void *)arg,
+					sizeof(spec))) {
+			pr_err("DTS_EAGLE_DRIVER_POST: error reading volume command specifier (src:%pK, tgt:%pK, size:%zu)\n",
+				(void *)arg, &spec, sizeof(spec));
+			return -EFAULT;
+		}
+		if (spec & 0x80000000) {
+			__u32 idx = (spec & 0x0000F000) >> 12;
+			__s32 size = spec & 0x00000FFF;
+			pr_debug("DTS_EAGLE_DRIVER_POST: setting volume command %i size: %i\n",
+				 idx, size);
+			if (idx >= vol_cmd_cnt) {
+				pr_err("DTS_EAGLE_DRIVER_POST: volume command index %i out of bounds (only %i allocated).\n",
+					idx, vol_cmd_cnt);
+				return -EINVAL;
+			}
+			if (volume_cmds_alloc2(idx, size) < 0) {
+				pr_err("DTS_EAGLE_DRIVER_POST: error allocating memory for volume controls.\n");
+				return -ENOMEM;
+			}
+			if (copy_from_user((void *)&vol_cmds_d[idx],
+					(void *)(((char *)arg) + sizeof(int)),
+					sizeof(struct vol_cmds_d_))) {
+				pr_err("DTS_EAGLE_DRIVER_POST: error reading volume command descriptor (src:%pK, tgt:%pK, size:%zu)\n",
+					((char *)arg) + sizeof(int),
+					&vol_cmds_d[idx],
+					sizeof(struct vol_cmds_d_));
+				return -EFAULT;
+			}
+			pr_debug("DTS_EAGLE_DRIVER_POST: setting volume command %i spec (size %zu): %i %i %i %i\n",
+				  idx, sizeof(struct vol_cmds_d_),
+				  vol_cmds_d[idx].d[0], vol_cmds_d[idx].d[1],
+				  vol_cmds_d[idx].d[2], vol_cmds_d[idx].d[3]);
+			if (copy_from_user((void *)vol_cmds[idx],
+					(void *)(((char *)arg) + (sizeof(int) +
+					sizeof(struct vol_cmds_d_))), size)) {
+				pr_err("DTS_EAGLE_DRIVER_POST: error reading volume command string (src:%pK, tgt:%pK, size:%i)\n",
+					((char *)arg) + (sizeof(int) +
+					sizeof(struct vol_cmds_d_)),
+					vol_cmds[idx], size);
+				return -EFAULT;
+			}
+		} else {
+			pr_debug("DTS_EAGLE_DRIVER_POST: setting volume command size\n");
+			if (spec < 0 || spec > VOL_CMD_CNT_MAX) {
+				pr_err("DTS_EAGLE_DRIVER_POST: volume command count %i out of bounds (min 0, max %i).\n",
+				spec, VOL_CMD_CNT_MAX);
+				return -EINVAL;
+			} else if (spec == 0) {
+				pr_info("DTS_EAGLE_DRIVER_POST: request to free volume commands.\n");
+				volume_cmds_free();
+				break;
+			}
+			pr_debug("DTS_EAGLE_DRIVER_POST: setting volume command size requested = %i\n",
+				  spec);
+			if (volume_cmds_alloc1(spec) < 0) {
+				pr_err("DTS_EAGLE_DRIVER_POST: error allocating memory for volume controls.\n");
+				return -ENOMEM;
+			}
+		}
+		break;
+	}
+	default: {
+		pr_info("DTS_EAGLE_DRIVER_POST: %s called, control 0x%X (invalid control)\n",
+			__func__, cmd);
+		ret = -EINVAL;
+	}
+	}
+	return (int)ret;
+}
+
+int msm_dts_eagle_init_pre(struct audio_client *ac)
+{
+	int offset, cidx, size, cmd;
+	cidx = _get_cb_for_dev(_device_primary);
+	if (cidx < 0) {
+		pr_err("DTS_EAGLE_DRIVER_SENDCACHE_PRE: in %s, no cache for primary device %i found.\n",
+			__func__, _device_primary);
+		return -EINVAL;
+	}
+	offset = _c_bl[cidx][CBD_OFFSG];
+	cmd = _c_bl[cidx][CBD_CMD0];
+	size = _c_bl[cidx][CBD_SZ0];
+
+	if (_depc_size == 0 || !_depc || offset < 0 || size <= 0 || cmd == 0 ||
+	    (offset + size) > _depc_size) {
+		pr_err("DTS_EAGLE_DRIVER_SENDCACHE_PRE: in %s, primary device %i cache index %i general error - cache size = %u, cache ptr = %pK, offset = %i, size = %i, cmd = %i\n",
+			__func__, _device_primary, cidx, _depc_size, _depc,
+			offset, size, cmd);
+		return -EINVAL;
+	}
+
+	pr_debug("DTS_EAGLE_DRIVER_SENDCACHE_PRE: first 6 integers %i %i %i %i %i %i (30th %i)\n",
+		  *((int *)&_depc[offset]), *((int *)&_depc[offset+4]),
+		  *((int *)&_depc[offset+8]), *((int *)&_depc[offset+12]),
+		  *((int *)&_depc[offset+16]), *((int *)&_depc[offset+20]),
+		  *((int *)&_depc[offset+120]));
+	pr_debug("DTS_EAGLE_DRIVER_SENDCACHE_PRE: sending full data block to port, with cache index = %d device mask 0x%X, param = 0x%X, offset = %d, and size = %d\n",
+		  cidx, _c_bl[cidx][CBD_DEV_MASK], cmd, offset, size);
+
+	if (q6asm_dts_eagle_set(ac, cmd, size, (void *)&_depc[offset])) {
+		pr_err("DTS_EAGLE_DRIVER_SENDCACHE_PRE: in %s, q6asm_dts_eagle_set failed with id = %d and size = %d\n",
+			__func__, cmd, size);
+	} else {
+		pr_debug("DTS_EAGLE_DRIVER_SENDCACHE_PRE: in %s, q6asm_dts_eagle_set succeeded with id = %d and size = %d\n",
+			 __func__, cmd, size);
+	}
+	return 0;
+}
+
+int msm_dts_eagle_deinit_pre(struct audio_client *ac)
+{
+	return 1;
+}
+
+int msm_dts_eagle_init_post(int port_id, int copp_idx, int topology)
+{
+	int offset, cidx = -1, size, cmd, mask;
+
+
+	{
+	int index = adm_validate_and_get_port_index(port_id);
+	if (index < 0) {
+		pr_err("DTS_EAGLE_DRIVER_SENDCACHE_POST :%s: Invalid port idx %d port_id %#x\n",
+			__func__, index, port_id);
+	} else {
+		pr_debug("DTS_EAGLE_DRIVER_SENDCACHE_POST : %s valid port idx %d for port_id %#x set to %i",
+			 __func__, index, port_id, copp_idx);
+	}
+	_cidx[index] = copp_idx;
+	}
+
+
+
+
+	mask = _get_dev_mask_for_pid(port_id);
+	if (mask & _device_primary) {
+		cidx = _get_cb_for_dev(_device_primary);
+		if (cidx < 0) {
+			pr_err("DTS_EAGLE_DRIVER_SENDCACHE_POST: in %s, no cache for primary device %i found. Port id was 0x%X.\n",
+				__func__, _device_primary, port_id);
+			return -EINVAL;
+		}
+	} else if (mask & _device_all) {
+		cidx = _get_cb_for_dev(_device_all);
+		if (cidx < 0) {
+			pr_err("DTS_EAGLE_DRIVER_SENDCACHE_POST: in %s, no cache for combo device %i found. Port id was 0x%X.\n",
+				__func__, _device_primary, port_id);
+			return -EINVAL;
+		}
+	} else {
+		pr_err("DTS_EAGLE_DRIVER_SENDCACHE_POST: in %s, port id 0x%X not for primary or combo device %i.\n",
+			__func__, port_id, _device_primary);
+		return -EINVAL;
+	}
+	offset = _c_bl[cidx][CBD_OFFSG] + _c_bl[cidx][CBD_OFFS2];
+	cmd = _c_bl[cidx][CBD_CMD2];
+	size = _c_bl[cidx][CBD_SZ2];
+
+	if (_depc_size == 0 || !_depc || offset < 0 || size <= 0 || cmd == 0 ||
+		(offset + size) > _depc_size) {
+		pr_err("DTS_EAGLE_DRIVER_SENDCACHE_POST: in %s, primary device %i cache index %i port_id 0x%X general error - cache size = %u, cache ptr = %pK, offset = %i, size = %i, cmd = %i\n",
+			__func__, _device_primary, cidx, port_id,
+			_depc_size, _depc, offset, size, cmd);
+		return -EINVAL;
+	}
+
+	pr_debug("DTS_EAGLE_DRIVER_SENDCACHE_POST: first 6 integers %i %i %i %i %i %i\n",
+		  *((int *)&_depc[offset]), *((int *)&_depc[offset+4]),
+		  *((int *)&_depc[offset+8]), *((int *)&_depc[offset+12]),
+		  *((int *)&_depc[offset+16]), *((int *)&_depc[offset+20]));
+	pr_debug("DTS_EAGLE_DRIVER_SENDCACHE_POST: sending full data block to port, with cache index = %d device mask 0x%X, port_id = 0x%X, param = 0x%X, offset = %d, and size = %d\n",
+		  cidx, _c_bl[cidx][CBD_DEV_MASK], port_id, cmd, offset, size);
+
+	if (adm_dts_eagle_set(port_id, copp_idx, cmd,
+			      (void *)&_depc[offset], size) < 0) {
+		pr_err("DTS_EAGLE_DRIVER_SENDCACHE_POST: in %s, adm_dts_eagle_set failed with id = 0x%X and size = %d\n",
+			__func__, cmd, size);
+	} else {
+		pr_debug("DTS_EAGLE_DRIVER_SENDCACHE_POST: in %s, adm_dts_eagle_set succeeded with id = 0x%X and size = %d\n",
+			 __func__, cmd, size);
+	}
+	return 0;
+}
+
+int msm_dts_eagle_deinit_post(int port_id, int topology)
+{
+	return 1;
+}
+
+int msm_dts_eagle_pcm_new(struct snd_soc_pcm_runtime *runtime)
+{
+	if (!ref_cnt) {
+		_init_cb_descs();
+		reg_ion_mem();
+	}
+	ref_cnt++;
+
+	return 0;
+}
+
+void msm_dts_eagle_pcm_free(struct snd_pcm *pcm)
+{
+	/* TODO: Remove hwdep interface */
+	ref_cnt--;
+	if (!ref_cnt)
+		unreg_ion_mem();
+}
+
+MODULE_DESCRIPTION("DTS EAGLE platform driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/msm/qdsp6v2/q6adm.c b/sound/soc/msm/qdsp6v2/q6adm.c
index 756fb844bed..c3d9642ec74 100644
--- a/sound/soc/msm/qdsp6v2/q6adm.c
+++ b/sound/soc/msm/qdsp6v2/q6adm.c
@@ -233,7 +233,6 @@ static int adm_get_next_available_copp(int port_idx)
 	}
 	return idx;
 }
-
 int srs_trumedia_open(int port_id, int copp_idx, __s32 srs_tech_id,
 		      void *srs_params)
 {
diff --git a/sound/soc/msm/qdsp6v2/q6asm.c b/sound/soc/msm/qdsp6v2/q6asm.c
index 857d3553842..6dc1dd662c6 100644
--- a/sound/soc/msm/qdsp6v2/q6asm.c
+++ b/sound/soc/msm/qdsp6v2/q6asm.c
@@ -4405,7 +4405,6 @@ int q6asm_set_mute(struct audio_client *ac, int muteflag)
 fail_cmd:
 	return rc;
 }
-
 static int __q6asm_set_volume(struct audio_client *ac, int volume, int instance)
 {
 	struct asm_volume_ctrl_master_gain vol;
diff --git a/sound/soc/msm/qdsp6v2/q6core.c b/sound/soc/msm/qdsp6v2/q6core.c
index bad2ad616a7..3f85752c5b1 100644
--- a/sound/soc/msm/qdsp6v2/q6core.c
+++ b/sound/soc/msm/qdsp6v2/q6core.c
@@ -340,6 +340,116 @@ int32_t core_get_license_status(uint32_t module_id)
 	return ret;
 }
 
+/**int core_dts_eagle_set(int size, char *data)
+{
+	struct adsp_dts_eagle *payload = NULL;
+	int rc = 0, size_aligned4byte;
+
+	pr_debug("DTS_EAGLE_CORE - %s\n", __func__);
+	if (size <= 0 || !data) {
+		pr_err("DTS_EAGLE_CORE - %s: invalid size %i or pointer %pK.\n",
+			__func__, size, data);
+		return -EINVAL;
+	}
+
+	size_aligned4byte = (size+3) & 0xFFFFFFFC;
+	ocm_core_open();
+	if (q6core_lcl.core_handle_q) {
+		payload = kzalloc(sizeof(struct adsp_dts_eagle) +
+				  size_aligned4byte, GFP_KERNEL);
+		if (!payload) {
+			pr_err("DTS_EAGLE_CORE - %s: out of memory (aligned size %i).\n",
+				__func__, size_aligned4byte);
+			return -ENOMEM;
+		}
+		payload->hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_EVENT,
+						APR_HDR_LEN(APR_HDR_SIZE),
+						APR_PKT_VER);
+		payload->hdr.pkt_size = sizeof(struct adsp_dts_eagle) +
+					       size_aligned4byte;
+		payload->hdr.src_port = 0;
+		payload->hdr.dest_port = 0;
+		payload->hdr.token = 0;
+		payload->hdr.opcode = ADSP_CMD_SET_DTS_EAGLE_DATA_ID;
+		payload->id = DTS_EAGLE_LICENSE_ID;
+		payload->overwrite = 1;
+		payload->size = size;
+		memcpy(payload->data, data, size);
+		rc = apr_send_pkt(q6core_lcl.core_handle_q,
+				(uint32_t *)payload);
+		if (rc < 0) {
+			pr_err("DTS_EAGLE_CORE - %s: failed op[0x%x]rc[%d]\n",
+				__func__, payload->hdr.opcode, rc);
+		}
+		kfree(payload);
+	}
+	return rc;
+}
+
+int core_dts_eagle_get(int id, int size, char *data)
+{
+	struct apr_hdr ah;
+	int rc = 0;
+
+	pr_debug("DTS_EAGLE_CORE - %s\n", __func__);
+	if (size <= 0 || !data) {
+		pr_err("DTS_EAGLE_CORE - %s: invalid size %i or pointer %pK.\n",
+			__func__, size, data);
+		return -EINVAL;
+	}
+	ocm_core_open();
+	if (q6core_lcl.core_handle_q) {
+		ah.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_EVENT,
+				APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
+		ah.pkt_size = sizeof(struct apr_hdr);
+		ah.src_port = 0;
+		ah.dest_port = 0;
+		ah.token = 0;
+		ah.opcode = id;
+
+		q6core_lcl.bus_bw_resp_received = 0;
+		generic_get_data = kzalloc(sizeof(struct generic_get_data_)
+					   + size, GFP_KERNEL);
+		if (!generic_get_data) {
+			pr_err("DTS_EAGLE_CORE - %s: error allocating memory of size %i\n",
+				__func__, size);
+			return -ENOMEM;
+		}
+
+		rc = apr_send_pkt(q6core_lcl.core_handle_q,
+				(uint32_t *)&ah);
+		if (rc < 0) {
+			pr_err("DTS_EAGLE_CORE - %s: failed op[0x%x]rc[%d]\n",
+				__func__, ah.opcode, rc);
+			goto fail_cmd_2;
+		}
+
+		rc = wait_event_timeout(q6core_lcl.bus_bw_req_wait,
+				(q6core_lcl.bus_bw_resp_received == 1),
+				msecs_to_jiffies(TIMEOUT_MS));
+		if (!rc) {
+			pr_err("DTS_EAGLE_CORE - %s: EAGLE get params timed out\n",
+				__func__);
+			rc = -EINVAL;
+			goto fail_cmd_2;
+		}
+		if (generic_get_data->valid) {
+			rc = 0;
+			memcpy(data, generic_get_data->ints, size);
+		} else {
+			rc = -EINVAL;
+			pr_err("DTS_EAGLE_CORE - %s: EAGLE get params problem getting data - check callback error value\n",
+				__func__);
+		}
+	}
+
+fail_cmd_2:
+	kfree(generic_get_data);
+	generic_get_data = NULL;
+	return rc;
+}
+
+>>>>>>> LS-5015: Added LS-5015 Changes*/
 uint32_t core_set_dolby_manufacturer_id(int manufacturer_id)
 {
 	struct adsp_dolby_manufacturer_id payload;
diff --git a/sound/soc/soc-jack.c b/sound/soc/soc-jack.c
index 346991e39a1..cae51cbdb6e 100644
--- a/sound/soc/soc-jack.c
+++ b/sound/soc/soc-jack.c
@@ -66,6 +66,7 @@ void snd_soc_jack_report(struct snd_soc_jack *jack, int status, int mask)
 	struct snd_soc_dapm_context *dapm;
 	struct snd_soc_jack_pin *pin;
 	int enable;
+	unsigned sync = 0;
 
 	trace_snd_soc_jack_report(jack, mask, status);
 
@@ -92,12 +93,14 @@ void snd_soc_jack_report(struct snd_soc_jack *jack, int status, int mask)
 			snd_soc_dapm_enable_pin(dapm, pin->pin);
 		else
 			snd_soc_dapm_disable_pin(dapm, pin->pin);
+		sync = 1;
 	}
 
 	/* Report before the DAPM sync to help users updating micbias status */
 	blocking_notifier_call_chain(&jack->notifier, jack->status, jack);
 
-	snd_soc_dapm_sync(dapm);
+    if(sync)
+	  snd_soc_dapm_sync(dapm);
 
 	snd_jack_report(jack->jack, jack->status);
 
